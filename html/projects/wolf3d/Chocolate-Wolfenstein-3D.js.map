{"version":3,"sources":["fmopl.cpp","/Users/jfriend/code/tools/emsdk_portable/emscripten/1.38.21/system/include/libcxx/math.h","id_ca.cpp","./wl_def.h","id_in.cpp","id_pm.cpp","id_sd.cpp","./id_pm.h","id_us_1.cpp","id_vh.cpp","./id_vl.h","./id_sd.h","id_vl.cpp","wl_act1.cpp","wl_act2.cpp","wl_agent.cpp","wl_debug.cpp","wl_draw.cpp","wl_game.cpp","wl_inter.cpp","wl_main.cpp","wl_menu.cpp","wl_play.cpp","wl_state.cpp","wl_text.cpp","web.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsiEA;AAAA;;AACA;AAmBA;AAAA;;AAjBA;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAA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AA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;;;;;;;;;;;;;AArgCA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;AAkrBA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAtHA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AAWA;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAOA;;AAJA;AAAA;AAAA;AAAA;AAAA;;AAIA;;AAHA;AAAA;AAAA;AAGA;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAoBA;;AAlBA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;AAhtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAGA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;;;;;AA+kCA;AAAA;AAAA;AACA;AAAA;;;AAAA;;AAIA;AAEA;AAAA;;AAcA;;;AAZA;AAAA;AAAA;AACA;;;;;AAYA;AAAA;;;;;;;;;;;AAlhBA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AA+BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;;;;;;;;;;;;;;AA1KA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AC9MA;AAAA;AAAA;AAAA;AD8MA;AAAA;AACA;AAAA;AAAA;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AACA;AAAA;;AAEA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAnBA;AAAA;;AAkCA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AACA;AAAA;;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AApBA;AAAA;AAAA;;AAyBA;;AAAA;AAAA;;;;AAMA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAxBA;AAAA;AAAA;;AAqCA;;;;;;;;;;;;AAu1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AA0CA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;;;;AAIA;AAEA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;;AANA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAOA;AAAA;AAGA;AAAA;AAAA;AAGA;AAAA;AAAA;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAtDA;AAAA;AAAA;;AAyDA;;;;;;;;;;AAx+CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;AACA;;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAsMA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAOA;;AAJA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqDA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;AACA;;AAKA;AAAA;AAAA;;;;;AAGA;;;;AAOA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAMA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AA0BA;;AA1BA;AAAA;AAAA;AAAA;;AA0BA;;AAvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;;;;;;;;;;;AA9eA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AA0EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAEA;AAFA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;;AAWA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;AAnEA;AAAA;AAAA;;;AA+EA;;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AA5BA;AAAA;AAAA;;AA2CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AAgBA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;AAEA;AAAA;;AADA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;AAEA;AAAA;;AADA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;AE1wBA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AA5BA;AAAA;;AACA;AAAA;AAAA;AAAA;;AADA;AAAA;;;;;;;;;;;;;;;AA2CA;AAAA;AAAA;AAAA;AACA;AAAA;;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AAMA;;;AAHA;;;;;AAIA;AAAA;;;;;;;;;;;;;AAkBA;AAAA;AAAA;AACA;AAAA;;AACA;AAaA;AAAA;;AAXA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAMA;AACA;AAAA;;AAJA;AAIA;AAAA;;;;;;;;;;;;;;;;;;;;AA6EA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;;AAEA;AAAA;;;;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;;AAqBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AApBA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AASA;;;;;;;;;ACqhCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;ADn9BA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;;;;;AACA;;;;;;;;;;;;;;;;;;AAsCA;AACA;AAEA;AAAA;AACA;AAAA;;AACA;;AAEA;AAAA;AACA;AAAA;AAGA;AACA;AAEA;AAAA;AACA;AAAA;;AACA;;AAEA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAKA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAOA;AAAA;AACA;AAAA;AAEA;AACA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAWA;AACA;AAEA;AAAA;AACA;AAAA;;AACA;;AAMA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;AAJA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;AAgkBA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AA93BA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAuCA;;AAnCA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;AAFA;AAAA;;AAGA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;;;;;;;;;;;;;;;AAwSA;AACA;AAEA;AAAA;AACA;AAAA;;AACA;;AAEA;AACA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAMA;AACA;AAEA;AAAA;AACA;AAAA;;AACA;;AAaA;;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AATA;AAAA;AAAA;;AAYA;AAKA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAHA;AAAA;AAAA;;AAKA;;;;;;;;;AAqBA;AACA;AAGA;AAAA;;AACA;;AACA;AAAA;AAKA;AACA;AAEA;AAAA;AACA;AAAA;;AAEA;;AADA;AACA;;;;;AAsBA;AACA;AACA;AAEA;AACA;;;;;;;;AAmBA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAEA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;;AAEA;AAAA;AAEA;;;AAKA;;;;AAGA;;;;AAMA;;;;;;AAFA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;;AAcA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;AACA;AASA;AAAA;;AAPA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAiCA;;AA9BA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;;;;;;;;;ACmlBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;ADnkBA;;;;;;AAKA;;;;;AAGA;;;;;;;;;;AAIA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAKA;AAAA;AAEA;;;AAGA;;;;AAGA;;;;AAGA;;;;;;AAIA;AAAA;;;;AAEA;AAAA;;;;AACA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;;;AAHA;AAAA;;;;AACA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;AAmBA;AAAA;AAAA;AAAA;AAAA;;;AASA;AAAA;;AACA;;;AACA;AAAA;;AACA;;;AACA;AAAA;;AACA;;;AACA;AAAA;;AACA;;;AACA;AAAA;;AACA;;;AAEA;;;;AAOA;AAAA;AAAA;AAAA;AAAA;;;AAOA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAFA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AAmBA;AAAA;AAAA;AAAA;;AAmCA;;AA5BA;AAAA;AAAA;AACA;AAAA;;AA2BA;;AAxBA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;;AAEA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAEA;AAAA;;AAEA;;AADA;AAAA;AACA;;;;;;;;;;;;;;;AA0BA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;AAEA;AAAA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AADA;AAAA;AAAA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;AA2BA;AAAA;AAKA;AAEA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;AACA;;AAGA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AASA;AAAA;;AACA;AAAA;;AAzCA;AAAA;AAAA;;AA2CA;;;;;;;;;;;;AEv7BA;AAAA;;AAEA;AAAA;AAAA;AAAA;AA8BA;;AA1BA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AAEA;AAAA;;AAAA;;AACA;AAAA;;AAAA;;;AAEA;AAAA;;AAAA;;;AACA;AAAA;;AAAA;;;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;AAyCA;AAAA;;AAAA;AAQA;AAAA;;AANA;AAEA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;;;;;;;AA0GA;AAAA;;AAMA;;;AAHA;AAEA;AAAA;;;;;AACA;;;;;;;;;;;;;;;AA3GA;AAAA;;;AAIA;;;;;;;AAkEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;;AACA;AAAA;;AAAA;;;AACA;AAAA;;AAAA;;;AACA;AAAA;;AAAA;;;AAGA;AAAA;AAAA;;AAEA;;;AAEA;;;;;AACA;;;;;AACA;;;;;AACA;;;;;;;;;;;AAKA;AAAA;;AAOA;;AANA;AAAA;AAAA;AAMA;;;;AAAA;;;AAvFA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AAEA;AAAA;;AACA;;;AAGA;AAAA;;;AAAA;;AACA;AAAA;;AAAA;;;AACA;AAAA;;AAAA;;;AACA;AAAA;;AAAA;;;AAGA;AAAA;AAAA;;AAEA;;;AAEA;;;;;AACA;;;;;AACA;;;;;AACA;;;;;;;;;;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAGA;AAGA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;;AAiCA;;AAhCA;AAgCA;;;AArFA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAoFA;;;;;;;;AAiBA;AAAA;;;;AAEA;;AAEA;;;;;;;AAWA;AAAA;AAAA;;AA+BA;;AA5BA;AAEA;AAAA;;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;;;;AAIA;AAEA;AAAA;AAAA;AAAA;;AAEA;AACA;;AAKA;AAEA;AACA;;;;;AA2BA;AACA;AACA;AACA;;;;;AApBA;AAAA;;AAOA;;AAJA;AAAA;;AACA;AAAA;;AAEA;AACA;;;;;;;;;;;;;;;AA6BA;AAAA;AACA;AAAA;AACA;AAEA;AAEA;AAAA;AAAA;;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;;AACA;AAAA;AAAA;;AACA;AAAA;;;AACA;AAAA;AAAA;;AACA;AAAA;;;;AAEA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;;AACA;;;AAEA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;;AACA;;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;AAaA;AAIA;AACA;AAEA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;;;;;AAgGA;AAAA;;AACA;AAAA;;AAEA;;AACA;AAAA;;;;;;;AAneA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AAFA;AAAA;AAAA;AAEA;AAAA;;;;;;;AA6XA;AAIA;AAAA;;AACA;AAgCA;AAAA;;AA9BA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;;;;AAEA;AAAA;;;;;AAiBA;;AArBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAwBA;AACA;AAAA;;;AAhBA;AACA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAQA;AAAA;;;;;AAKA;AASA;;;;;;;;AAcA;;;;;AAkCA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC3lBA;AACA;AAEA;AAAA;AACA;AAAA;;AACA;;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAIA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAJA;AAAA;AAAA;;AASA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AALA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AA3BA;AAAA;AAAA;;AA+BA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;AAIA;AAAA;AACA;AAAA;AACA;;;;;ACoWA;AAAA;;AAAA;AAAA;;AAEA;AAIA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;;AAAA;AAAA;;AAYA;AAAA;;AAEA;;AAFA;AAAA;;;;;;AAzXA;AACA;AACA;;;;;;;;;AA6XA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;;AALA;AAAA;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAEA;AAAA;;AADA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;;AAEA;AAAA;;AAQA;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAIA;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAEA;AAAA;AAAA;;AADA;AAAA;;AACA;AAAA;AAAA;;AADA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AAKA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAIA;AAAA;AAAA;AADA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAIA;AAAA;AACA;AADA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;;AAAA;AA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AAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;AAYA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAaA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAYA;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;AAAA;;;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;;AACA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;AAAA;AACA;;;;;AAiDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AAcA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;;;AAyEA;AAEA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAFA;AAAA;AAAA;;AAKA;AAAA;;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;AACA;AAAA;;AAAA;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA;AAEA;AAAA;;AACA;AAAA;;AAEA;;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;;;;AAEA;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAEA;AAAA;;;AAGA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAEA;AACA;;;;;AAGA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AACA;;;;;AAIA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;AAIA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;;;AAIA;AAAA;;;AAEA;;;AAGA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;;;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;;;;AAGA;AACA;AACA;;;;AAGA;AAAA;AACA;AACA;;;;AAIA;AAAA;AACA;AACA;AACA;;;;AAGA;AAAA;;AAEA;AACA;;AAEA;;;;AAIA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;;;;AAGA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;;;;AASA;;;;;;AAIA;AAAA;;AAEA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AAKA;AAAA;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAEA;;AAGA;AAAA;;AAEA;AACA;AAAA;AAAA;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AAgCA;;;AA7BA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAyBA;;;;;AArBA;AAAA;;AAAA;;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AVxWA;AAAA;AAAA;;;;;;;;;AAZA;AAAA;;;;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AUqYA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgCA;;;AA7BA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAyBA;;;;;AArBA;AAAA;;AAAA;;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;A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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAnBA;AAAA;AAAA;;;;;AAyBA;AAAA;AAAA;;;;AAhEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAoEA;;;;;;;;;AVntBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AJizCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;Ac/kBA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AACA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;AACA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AAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAAA;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAgBA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AACA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;AA3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;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;;;AACA;AAAA;AAAA;;AACA;;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAGA;;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AACA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;;AAGA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AACA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;;;AACA;AAAA;;;AAGA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AASA;AACA;;;AAKA;AAAA;AAAA;;AACA;;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAEA;AACA;;;AAIA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;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","file":"./Chocolate-Wolfenstein-3D.js","sourcesContent":["/*\r\n**\r\n** File: fmopl.c - software implementation of FM sound generator\r\n**                                            types OPL and OPL2\r\n**\r\n** Copyright (C) 2002,2003 Jarek Burczynski (bujar at mame dot net)\r\n** Copyright (C) 1999,2000 Tatsuyuki Satoh , MultiArcadeMachineEmulator development\r\n**\r\n** Version 0.720003 ;D\r\n**\r\n\r\nRevision History:\r\n\r\n06-05-2004 Ripper:\r\n - Added mute support\r\n\r\n04-30-2004 Ripper:\r\n - Raised the main volume (may cut some quality, but at least you can hear it ;)\r\n\r\n02-20-2004 Ripper:\r\n - Changed YM3812Write to do what we want\r\n\r\n04-08-2003 Jarek Burczynski:\r\n - removed BFRDY hack. BFRDY is busy flag, and it should be 0 only when the chip\r\n   handles memory read/write or during the adpcm synthesis when the chip\r\n   requests another byte of ADPCM data.\r\n\r\n24-07-2003 Jarek Burczynski:\r\n - added a small hack for Y8950 status BFRDY flag (bit 3 should be set after\r\n   some (unknown) delay). Right now it's always set.\r\n\r\n14-06-2003 Jarek Burczynski:\r\n - implemented all of the status register flags in Y8950 emulation\r\n - renamed Y8950SetDeltaTMemory() parameters from _rom_ to _mem_ since\r\n   they can be either RAM or ROM\r\n\r\n08-10-2002 Jarek Burczynski (thanks to Dox for the YM3526 chip)\r\n - corrected YM3526Read() to always set bit 2 and bit 1\r\n   to HIGH state - identical to YM3812Read (verified on real YM3526)\r\n\r\n04-28-2002 Jarek Burczynski:\r\n - binary exact Envelope Generator (verified on real YM3812);\r\n   compared to YM2151: the EG clock is equal to internal_clock,\r\n   rates are 2 times slower and volume resolution is one bit less\r\n - modified interface functions (they no longer return pointer -\r\n   that's internal to the emulator now):\r\n    - new wrapper functions for OPLCreate: YM3526Init(), YM3812Init() and Y8950Init()\r\n - corrected 'off by one' error in feedback calculations (when feedback is off)\r\n - enabled waveform usage (credit goes to Vlad Romascanu and zazzal22)\r\n - speeded up noise generator calculations (Nicola Salmoria)\r\n\r\n03-24-2002 Jarek Burczynski (thanks to Dox for the YM3812 chip)\r\n Complete rewrite (all verified on real YM3812):\r\n - corrected sin_tab and tl_tab data\r\n - corrected operator output calculations\r\n - corrected waveform_select_enable register;\r\n   simply: ignore all writes to waveform_select register when\r\n   waveform_select_enable == 0 and do not change the waveform previously selected.\r\n - corrected KSR handling\r\n - corrected Envelope Generator: attack shape, Sustain mode and\r\n   Percussive/Non-percussive modes handling\r\n - Envelope Generator rates are two times slower now\r\n - LFO amplitude (tremolo) and phase modulation (vibrato)\r\n - rhythm sounds phase generation\r\n - white noise generator (big thanks to Olivier Galibert for mentioning Berlekamp-Massey algorithm)\r\n - corrected key on/off handling (the 'key' signal is ORed from three sources: FM, rhythm and CSM)\r\n - funky details (like ignoring output of operator 1 in BD rhythm sound when connect == 1)\r\n\r\n12-28-2001 Acho A. Tang\r\n - reflected Delta-T EOS status on Y8950 status port.\r\n - fixed subscription range of attack/decay tables\r\n\r\n\r\n    To do:\r\n        add delay before key off in CSM mode (see CSMKeyControll)\r\n        verify volume of the FM part on the Y8950\r\n*/\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n#include <string.h>\r\n\r\n//#include \"driver.h\"       /* use M.A.M.E. */\r\n\r\n//#include \"ymdeltat.h\"\r\n\r\n#if _MSC_VER == 1200            // Visual C++ 6\r\ninline void logerror(...) {}\r\n#else\r\n#define logerror(...)\r\n#endif\r\n\r\n#include \"fmopl.h\"\r\n\r\n#ifndef PI\r\n#define PI 3.14159265358979323846\r\n#endif\r\n\r\n/* output final shift */\r\n#if (OPL_SAMPLE_BITS==16)\r\n    #define FINAL_SH    (0)\r\n    #define MAXOUT      (+32767)\r\n    #define MINOUT      (-32768)\r\n#else\r\n    #define FINAL_SH    (8)\r\n    #define MAXOUT      (+127)\r\n    #define MINOUT      (-128)\r\n#endif\r\n\r\n\r\n#define FREQ_SH         16  /* 16.16 fixed point (frequency calculations) */\r\n#define EG_SH           16  /* 16.16 fixed point (EG timing)              */\r\n#define LFO_SH          24  /*  8.24 fixed point (LFO calculations)       */\r\n#define TIMER_SH        16  /* 16.16 fixed point (timers calculations)    */\r\n\r\n#define FREQ_MASK       ((1<<FREQ_SH)-1)\r\n\r\n/* envelope output entries */\r\n#define ENV_BITS        10\r\n#define ENV_LEN         (1<<ENV_BITS)\r\n#define ENV_STEP        (128.0/ENV_LEN)\r\n\r\n#define MAX_ATT_INDEX   ((1<<(ENV_BITS-1))-1) /*511*/\r\n#define MIN_ATT_INDEX   (0)\r\n\r\n/* sinwave entries */\r\n#define SIN_BITS        10\r\n#define SIN_LEN         (1<<SIN_BITS)\r\n#define SIN_MASK        (SIN_LEN-1)\r\n\r\n#define TL_RES_LEN      (256)   /* 8 bits addressing (real chip) */\r\n\r\n\r\n\r\n/* register number to channel number , slot offset */\r\n#define SLOT1 0\r\n#define SLOT2 1\r\n\r\n/* Envelope Generator phases */\r\n\r\n#define EG_ATT          4\r\n#define EG_DEC          3\r\n#define EG_SUS          2\r\n#define EG_REL          1\r\n#define EG_OFF          0\r\n\r\n\r\n/* save output as raw 16-bit sample */\r\n\r\n/*#define SAVE_SAMPLE*/\r\n\r\n#ifdef SAVE_SAMPLE\r\nINLINE signed int acc_calc(signed int value)\r\n{\r\n    if (value>=0)\r\n    {\r\n        if (value < 0x0200)\r\n            return (value & ~0);\r\n        if (value < 0x0400)\r\n            return (value & ~1);\r\n        if (value < 0x0800)\r\n            return (value & ~3);\r\n        if (value < 0x1000)\r\n            return (value & ~7);\r\n        if (value < 0x2000)\r\n            return (value & ~15);\r\n        if (value < 0x4000)\r\n            return (value & ~31);\r\n        return (value & ~63);\r\n    }\r\n    /*else value < 0*/\r\n    if (value > -0x0200)\r\n        return (~abs(value) & ~0);\r\n    if (value > -0x0400)\r\n        return (~abs(value) & ~1);\r\n    if (value > -0x0800)\r\n        return (~abs(value) & ~3);\r\n    if (value > -0x1000)\r\n        return (~abs(value) & ~7);\r\n    if (value > -0x2000)\r\n        return (~abs(value) & ~15);\r\n    if (value > -0x4000)\r\n        return (~abs(value) & ~31);\r\n    return (~abs(value) & ~63);\r\n}\r\n\r\n\r\nstatic FILE *sample[1];\r\n    #if 1   /*save to MONO file */\r\n        #define SAVE_ALL_CHANNELS \\\r\n        {   signed int pom = acc_calc(lt); \\\r\n            fputc((unsigned short)pom&0xff,sample[0]); \\\r\n            fputc(((unsigned short)pom>>8)&0xff,sample[0]); \\\r\n        }\r\n    #else   /*save to STEREO file */\r\n        #define SAVE_ALL_CHANNELS \\\r\n        {   signed int pom = lt; \\\r\n            fputc((unsigned short)pom&0xff,sample[0]); \\\r\n            fputc(((unsigned short)pom>>8)&0xff,sample[0]); \\\r\n            pom = rt; \\\r\n            fputc((unsigned short)pom&0xff,sample[0]); \\\r\n            fputc(((unsigned short)pom>>8)&0xff,sample[0]); \\\r\n        }\r\n    #endif\r\n#endif\r\n\r\n/* #define LOG_CYM_FILE */\r\n#ifdef LOG_CYM_FILE\r\n    FILE * cymfile = NULL;\r\n#endif\r\n\r\n\r\n\r\n#define OPL_TYPE_WAVESEL   0x01  /* waveform select     */\r\n#define OPL_TYPE_ADPCM     0x02  /* DELTA-T ADPCM unit  */\r\n#define OPL_TYPE_KEYBOARD  0x04  /* keyboard interface  */\r\n#define OPL_TYPE_IO        0x08  /* I/O port            */\r\n\r\n/* ---------- Generic interface section ---------- */\r\n#define OPL_TYPE_YM3526 (0)\r\n#define OPL_TYPE_YM3812 (OPL_TYPE_WAVESEL)\r\n#define OPL_TYPE_Y8950  (OPL_TYPE_ADPCM|OPL_TYPE_KEYBOARD|OPL_TYPE_IO)\r\n\r\n\r\n\r\ntypedef struct{\r\n    UINT32  ar;         /* attack rate: AR<<2           */\r\n    UINT32  dr;         /* decay rate:  DR<<2           */\r\n    UINT32  rr;         /* release rate:RR<<2           */\r\n    UINT8   KSR;        /* key scale rate               */\r\n    UINT8   ksl;        /* keyscale level               */\r\n    UINT8   ksr;        /* key scale rate: kcode>>KSR   */\r\n    UINT8   mul;        /* multiple: mul_tab[ML]        */\r\n\r\n    /* Phase Generator */\r\n    UINT32  Cnt;        /* frequency counter            */\r\n    UINT32  Incr;       /* frequency counter step       */\r\n    UINT8   FB;         /* feedback shift value         */\r\n    INT32   *connect1;  /* slot1 output pointer         */\r\n    INT32   op1_out[2]; /* slot1 output for feedback    */\r\n    UINT8   CON;        /* connection (algorithm) type  */\r\n\r\n    /* Envelope Generator */\r\n    UINT8   eg_type;    /* percussive/non-percussive mode */\r\n    UINT8   state;      /* phase type                   */\r\n    UINT32  TL;         /* total level: TL << 2         */\r\n    INT32   TLL;        /* adjusted now TL              */\r\n    INT32   volume;     /* envelope counter             */\r\n    UINT32  sl;         /* sustain level: sl_tab[SL]    */\r\n    UINT8   eg_sh_ar;   /* (attack state)               */\r\n    UINT8   eg_sel_ar;  /* (attack state)               */\r\n    UINT8   eg_sh_dr;   /* (decay state)                */\r\n    UINT8   eg_sel_dr;  /* (decay state)                */\r\n    UINT8   eg_sh_rr;   /* (release state)              */\r\n    UINT8   eg_sel_rr;  /* (release state)              */\r\n    UINT32  key;        /* 0 = KEY OFF, >0 = KEY ON     */\r\n\r\n    /* LFO */\r\n    UINT32  AMmask;     /* LFO Amplitude Modulation enable mask */\r\n    UINT8   vib;        /* LFO Phase Modulation enable flag (active high)*/\r\n\r\n    /* waveform select */\r\n    unsigned int wavetable;\r\n} OPL_SLOT;\r\n\r\ntypedef struct{\r\n    OPL_SLOT SLOT[2];\r\n    /* phase generator state */\r\n    UINT32  block_fnum; /* block+fnum                   */\r\n    UINT32  fc;         /* Freq. Increment base         */\r\n    UINT32  ksl_base;   /* KeyScaleLevel Base step      */\r\n    UINT8   kcode;      /* key code (for key scaling)   */\r\n    BOOL    muted;\r\n} OPL_CH;\r\n\r\n/* OPL state */\r\ntypedef struct fm_opl_f {\r\n    /* FM channel slots */\r\n    OPL_CH  P_CH[9];                /* OPL/OPL2 chips have 9 channels*/\r\n\r\n    UINT32  eg_cnt;                 /* global envelope generator counter    */\r\n    UINT32  eg_timer;               /* global envelope generator counter works at frequency = chipclock/72 */\r\n    UINT32  eg_timer_add;           /* step of eg_timer                     */\r\n    UINT32  eg_timer_overflow;      /* envelope generator timer overlfows every 1 sample (on real chip) */\r\n\r\n    UINT8   rhythm;                 /* Rhythm mode                  */\r\n\r\n    UINT32  fn_tab[1024];           /* fnumber->increment counter   */\r\n\r\n    /* LFO */\r\n    UINT8   lfo_am_depth;\r\n    UINT8   lfo_pm_depth_range;\r\n    UINT32  lfo_am_cnt;\r\n    UINT32  lfo_am_inc;\r\n    UINT32  lfo_pm_cnt;\r\n    UINT32  lfo_pm_inc;\r\n\r\n    UINT32  noise_rng;              /* 23 bit noise shift register  */\r\n    UINT32  noise_p;                /* current noise 'phase'        */\r\n    UINT32  noise_f;                /* current noise period         */\r\n\r\n    UINT8   wavesel;                /* waveform select enable flag  */\r\n\r\n    int     T[2];                   /* timer counters               */\r\n    UINT8   st[2];                  /* timer enable                 */\r\n\r\n#if BUILD_Y8950\r\n    /* Delta-T ADPCM unit (Y8950) */\r\n\r\n    YM_DELTAT *deltat;\r\n\r\n    /* Keyboard and I/O ports interface */\r\n    UINT8   portDirection;\r\n    UINT8   portLatch;\r\n    OPL_PORTHANDLER_R porthandler_r;\r\n    OPL_PORTHANDLER_W porthandler_w;\r\n    int     port_param;\r\n    OPL_PORTHANDLER_R keyboardhandler_r;\r\n    OPL_PORTHANDLER_W keyboardhandler_w;\r\n    int     keyboard_param;\r\n#endif\r\n\r\n    /* external event callback handlers */\r\n    OPL_TIMERHANDLER  TimerHandler; /* TIMER handler                */\r\n    int TimerParam;                 /* TIMER parameter              */\r\n    OPL_IRQHANDLER    IRQHandler;   /* IRQ handler                  */\r\n    int IRQParam;                   /* IRQ parameter                */\r\n    OPL_UPDATEHANDLER UpdateHandler;/* stream update handler        */\r\n    int UpdateParam;                /* stream update parameter      */\r\n\r\n    UINT8 type;                     /* chip type                    */\r\n    UINT8 address;                  /* address register             */\r\n    UINT8 status;                   /* status flag                  */\r\n    UINT8 statusmask;               /* status mask                  */\r\n    UINT8 mode;                     /* Reg.08 : CSM,notesel,etc.    */\r\n\r\n    int clock;                      /* master clock  (Hz)           */\r\n    int rate;                       /* sampling rate (Hz)           */\r\n    double freqbase;                /* frequency base               */\r\n    double TimerBase;               /* Timer base time (==sampling time)*/\r\n} FM_OPL;\r\n\r\n\r\n\r\n/* mapping of register number (offset) to slot number used by the emulator */\r\nstatic const int slot_array[32]=\r\n{\r\n     0, 2, 4, 1, 3, 5,-1,-1,\r\n     6, 8,10, 7, 9,11,-1,-1,\r\n    12,14,16,13,15,17,-1,-1,\r\n    -1,-1,-1,-1,-1,-1,-1,-1\r\n};\r\n\r\n/* key scale level */\r\n/* table is 3dB/octave , DV converts this into 6dB/octave */\r\n/* 0.1875 is bit 0 weight of the envelope counter (volume) expressed in the 'decibel' scale */\r\n#define DV(db) (UINT32) (db / (0.1875/2.0))\r\nstatic const UINT32 ksl_tab[8*16]=\r\n{\r\n    /* OCT 0 */\r\n    DV( 0.000),DV( 0.000),DV( 0.000),DV( 0.000),\r\n    DV( 0.000),DV( 0.000),DV( 0.000),DV( 0.000),\r\n    DV( 0.000),DV( 0.000),DV( 0.000),DV( 0.000),\r\n    DV( 0.000),DV( 0.000),DV( 0.000),DV( 0.000),\r\n    /* OCT 1 */\r\n    DV( 0.000),DV( 0.000),DV( 0.000),DV( 0.000),\r\n    DV( 0.000),DV( 0.000),DV( 0.000),DV( 0.000),\r\n    DV( 0.000),DV( 0.750),DV( 1.125),DV( 1.500),\r\n    DV( 1.875),DV( 2.250),DV( 2.625),DV( 3.000),\r\n    /* OCT 2 */\r\n    DV( 0.000),DV( 0.000),DV( 0.000),DV( 0.000),\r\n    DV( 0.000),DV( 1.125),DV( 1.875),DV( 2.625),\r\n    DV( 3.000),DV( 3.750),DV( 4.125),DV( 4.500),\r\n    DV( 4.875),DV( 5.250),DV( 5.625),DV( 6.000),\r\n    /* OCT 3 */\r\n    DV( 0.000),DV( 0.000),DV( 0.000),DV( 1.875),\r\n    DV( 3.000),DV( 4.125),DV( 4.875),DV( 5.625),\r\n    DV( 6.000),DV( 6.750),DV( 7.125),DV( 7.500),\r\n    DV( 7.875),DV( 8.250),DV( 8.625),DV( 9.000),\r\n    /* OCT 4 */\r\n    DV( 0.000),DV( 0.000),DV( 3.000),DV( 4.875),\r\n    DV( 6.000),DV( 7.125),DV( 7.875),DV( 8.625),\r\n    DV( 9.000),DV( 9.750),DV(10.125),DV(10.500),\r\n    DV(10.875),DV(11.250),DV(11.625),DV(12.000),\r\n    /* OCT 5 */\r\n    DV( 0.000),DV( 3.000),DV( 6.000),DV( 7.875),\r\n    DV( 9.000),DV(10.125),DV(10.875),DV(11.625),\r\n    DV(12.000),DV(12.750),DV(13.125),DV(13.500),\r\n    DV(13.875),DV(14.250),DV(14.625),DV(15.000),\r\n    /* OCT 6 */\r\n    DV( 0.000),DV( 6.000),DV( 9.000),DV(10.875),\r\n    DV(12.000),DV(13.125),DV(13.875),DV(14.625),\r\n    DV(15.000),DV(15.750),DV(16.125),DV(16.500),\r\n    DV(16.875),DV(17.250),DV(17.625),DV(18.000),\r\n    /* OCT 7 */\r\n    DV( 0.000),DV( 9.000),DV(12.000),DV(13.875),\r\n    DV(15.000),DV(16.125),DV(16.875),DV(17.625),\r\n    DV(18.000),DV(18.750),DV(19.125),DV(19.500),\r\n    DV(19.875),DV(20.250),DV(20.625),DV(21.000)\r\n};\r\n#undef DV\r\n\r\n/* sustain level table (3dB per step) */\r\n/* 0 - 15: 0, 3, 6, 9,12,15,18,21,24,27,30,33,36,39,42,93 (dB)*/\r\n#define SC(db) (UINT32) ( db * (2.0/ENV_STEP) )\r\nstatic const UINT32 sl_tab[16]={\r\n SC( 0),SC( 1),SC( 2),SC(3 ),SC(4 ),SC(5 ),SC(6 ),SC( 7),\r\n SC( 8),SC( 9),SC(10),SC(11),SC(12),SC(13),SC(14),SC(31)\r\n};\r\n#undef SC\r\n\r\n\r\n#define RATE_STEPS (8)\r\nstatic const unsigned char eg_inc[15*RATE_STEPS]={\r\n\r\n/*cycle:0 1  2 3  4 5  6 7*/\r\n\r\n/* 0 */ 0,1, 0,1, 0,1, 0,1, /* rates 00..12 0 (increment by 0 or 1) */\r\n/* 1 */ 0,1, 0,1, 1,1, 0,1, /* rates 00..12 1 */\r\n/* 2 */ 0,1, 1,1, 0,1, 1,1, /* rates 00..12 2 */\r\n/* 3 */ 0,1, 1,1, 1,1, 1,1, /* rates 00..12 3 */\r\n\r\n/* 4 */ 1,1, 1,1, 1,1, 1,1, /* rate 13 0 (increment by 1) */\r\n/* 5 */ 1,1, 1,2, 1,1, 1,2, /* rate 13 1 */\r\n/* 6 */ 1,2, 1,2, 1,2, 1,2, /* rate 13 2 */\r\n/* 7 */ 1,2, 2,2, 1,2, 2,2, /* rate 13 3 */\r\n\r\n/* 8 */ 2,2, 2,2, 2,2, 2,2, /* rate 14 0 (increment by 2) */\r\n/* 9 */ 2,2, 2,4, 2,2, 2,4, /* rate 14 1 */\r\n/*10 */ 2,4, 2,4, 2,4, 2,4, /* rate 14 2 */\r\n/*11 */ 2,4, 4,4, 2,4, 4,4, /* rate 14 3 */\r\n\r\n/*12 */ 4,4, 4,4, 4,4, 4,4, /* rates 15 0, 15 1, 15 2, 15 3 (increment by 4) */\r\n/*13 */ 8,8, 8,8, 8,8, 8,8, /* rates 15 2, 15 3 for attack */\r\n/*14 */ 0,0, 0,0, 0,0, 0,0, /* infinity rates for attack and decay(s) */\r\n};\r\n\r\n\r\n#define O(a) (a*RATE_STEPS)\r\n\r\n/*note that there is no O(13) in this table - it's directly in the code */\r\nstatic const unsigned char eg_rate_select[16+64+16]={   /* Envelope Generator rates (16 + 64 rates + 16 RKS) */\r\n/* 16 infinite time rates */\r\nO(14),O(14),O(14),O(14),O(14),O(14),O(14),O(14),\r\nO(14),O(14),O(14),O(14),O(14),O(14),O(14),O(14),\r\n\r\n/* rates 00-12 */\r\nO( 0),O( 1),O( 2),O( 3),\r\nO( 0),O( 1),O( 2),O( 3),\r\nO( 0),O( 1),O( 2),O( 3),\r\nO( 0),O( 1),O( 2),O( 3),\r\nO( 0),O( 1),O( 2),O( 3),\r\nO( 0),O( 1),O( 2),O( 3),\r\nO( 0),O( 1),O( 2),O( 3),\r\nO( 0),O( 1),O( 2),O( 3),\r\nO( 0),O( 1),O( 2),O( 3),\r\nO( 0),O( 1),O( 2),O( 3),\r\nO( 0),O( 1),O( 2),O( 3),\r\nO( 0),O( 1),O( 2),O( 3),\r\nO( 0),O( 1),O( 2),O( 3),\r\n\r\n/* rate 13 */\r\nO( 4),O( 5),O( 6),O( 7),\r\n\r\n/* rate 14 */\r\nO( 8),O( 9),O(10),O(11),\r\n\r\n/* rate 15 */\r\nO(12),O(12),O(12),O(12),\r\n\r\n/* 16 dummy rates (same as 15 3) */\r\nO(12),O(12),O(12),O(12),O(12),O(12),O(12),O(12),\r\nO(12),O(12),O(12),O(12),O(12),O(12),O(12),O(12),\r\n\r\n};\r\n#undef O\r\n\r\n/*rate  0,    1,    2,    3,   4,   5,   6,  7,  8,  9,  10, 11, 12, 13, 14, 15 */\r\n/*shift 12,   11,   10,   9,   8,   7,   6,  5,  4,  3,  2,  1,  0,  0,  0,  0  */\r\n/*mask  4095, 2047, 1023, 511, 255, 127, 63, 31, 15, 7,  3,  1,  0,  0,  0,  0  */\r\n\r\n#define O(a) (a*1)\r\nstatic const unsigned char eg_rate_shift[16+64+16]={    /* Envelope Generator counter shifts (16 + 64 rates + 16 RKS) */\r\n/* 16 infinite time rates */\r\nO(0),O(0),O(0),O(0),O(0),O(0),O(0),O(0),\r\nO(0),O(0),O(0),O(0),O(0),O(0),O(0),O(0),\r\n\r\n/* rates 00-12 */\r\nO(12),O(12),O(12),O(12),\r\nO(11),O(11),O(11),O(11),\r\nO(10),O(10),O(10),O(10),\r\nO( 9),O( 9),O( 9),O( 9),\r\nO( 8),O( 8),O( 8),O( 8),\r\nO( 7),O( 7),O( 7),O( 7),\r\nO( 6),O( 6),O( 6),O( 6),\r\nO( 5),O( 5),O( 5),O( 5),\r\nO( 4),O( 4),O( 4),O( 4),\r\nO( 3),O( 3),O( 3),O( 3),\r\nO( 2),O( 2),O( 2),O( 2),\r\nO( 1),O( 1),O( 1),O( 1),\r\nO( 0),O( 0),O( 0),O( 0),\r\n\r\n/* rate 13 */\r\nO( 0),O( 0),O( 0),O( 0),\r\n\r\n/* rate 14 */\r\nO( 0),O( 0),O( 0),O( 0),\r\n\r\n/* rate 15 */\r\nO( 0),O( 0),O( 0),O( 0),\r\n\r\n/* 16 dummy rates (same as 15 3) */\r\nO( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),\r\nO( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),\r\n\r\n};\r\n#undef O\r\n\r\n\r\n/* multiple table */\r\n#define ML(a) (UINT8) (a * 2)\r\nstatic const UINT8 mul_tab[16]= {\r\n/* 1/2, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,10,12,12,15,15 */\r\n  ML( 0.50),ML( 1.00),ML( 2.00),ML( 3.00),ML( 4.00),ML( 5.00),ML( 6.00),ML( 7.00),\r\n  ML( 8.00),ML( 9.00),ML(10.00),ML(10.00),ML(12.00),ML(12.00),ML(15.00),ML(15.00)\r\n};\r\n#undef ML\r\n\r\n/*  TL_TAB_LEN is calculated as:\r\n*   12 - sinus amplitude bits     (Y axis)\r\n*   2  - sinus sign bit           (Y axis)\r\n*   TL_RES_LEN - sinus resolution (X axis)\r\n*/\r\n#define TL_TAB_LEN (12*2*TL_RES_LEN)\r\nstatic signed int tl_tab[TL_TAB_LEN];\r\n\r\n#define ENV_QUIET       (TL_TAB_LEN>>4)\r\n\r\n/* sin waveform table in 'decibel' scale */\r\n/* four waveforms on OPL2 type chips */\r\nstatic unsigned int sin_tab[SIN_LEN * 4];\r\n\r\n\r\n/* LFO Amplitude Modulation table (verified on real YM3812)\r\n   27 output levels (triangle waveform); 1 level takes one of: 192, 256 or 448 samples\r\n\r\n   Length: 210 elements.\r\n\r\n    Each of the elements has to be repeated\r\n    exactly 64 times (on 64 consecutive samples).\r\n    The whole table takes: 64 * 210 = 13440 samples.\r\n\r\n    When AM = 1 data is used directly\r\n    When AM = 0 data is divided by 4 before being used (loosing precision is important)\r\n*/\r\n\r\n#define LFO_AM_TAB_ELEMENTS 210\r\n\r\nstatic const UINT8 lfo_am_table[LFO_AM_TAB_ELEMENTS] = {\r\n0,0,0,0,0,0,0,\r\n1,1,1,1,\r\n2,2,2,2,\r\n3,3,3,3,\r\n4,4,4,4,\r\n5,5,5,5,\r\n6,6,6,6,\r\n7,7,7,7,\r\n8,8,8,8,\r\n9,9,9,9,\r\n10,10,10,10,\r\n11,11,11,11,\r\n12,12,12,12,\r\n13,13,13,13,\r\n14,14,14,14,\r\n15,15,15,15,\r\n16,16,16,16,\r\n17,17,17,17,\r\n18,18,18,18,\r\n19,19,19,19,\r\n20,20,20,20,\r\n21,21,21,21,\r\n22,22,22,22,\r\n23,23,23,23,\r\n24,24,24,24,\r\n25,25,25,25,\r\n26,26,26,\r\n25,25,25,25,\r\n24,24,24,24,\r\n23,23,23,23,\r\n22,22,22,22,\r\n21,21,21,21,\r\n20,20,20,20,\r\n19,19,19,19,\r\n18,18,18,18,\r\n17,17,17,17,\r\n16,16,16,16,\r\n15,15,15,15,\r\n14,14,14,14,\r\n13,13,13,13,\r\n12,12,12,12,\r\n11,11,11,11,\r\n10,10,10,10,\r\n9,9,9,9,\r\n8,8,8,8,\r\n7,7,7,7,\r\n6,6,6,6,\r\n5,5,5,5,\r\n4,4,4,4,\r\n3,3,3,3,\r\n2,2,2,2,\r\n1,1,1,1\r\n};\r\n\r\n/* LFO Phase Modulation table (verified on real YM3812) */\r\nstatic const INT8 lfo_pm_table[8*8*2] = {\r\n\r\n/* FNUM2/FNUM = 00 0xxxxxxx (0x0000) */\r\n0, 0, 0, 0, 0, 0, 0, 0, /*LFO PM depth = 0*/\r\n0, 0, 0, 0, 0, 0, 0, 0, /*LFO PM depth = 1*/\r\n\r\n/* FNUM2/FNUM = 00 1xxxxxxx (0x0080) */\r\n0, 0, 0, 0, 0, 0, 0, 0, /*LFO PM depth = 0*/\r\n1, 0, 0, 0,-1, 0, 0, 0, /*LFO PM depth = 1*/\r\n\r\n/* FNUM2/FNUM = 01 0xxxxxxx (0x0100) */\r\n1, 0, 0, 0,-1, 0, 0, 0, /*LFO PM depth = 0*/\r\n2, 1, 0,-1,-2,-1, 0, 1, /*LFO PM depth = 1*/\r\n\r\n/* FNUM2/FNUM = 01 1xxxxxxx (0x0180) */\r\n1, 0, 0, 0,-1, 0, 0, 0, /*LFO PM depth = 0*/\r\n3, 1, 0,-1,-3,-1, 0, 1, /*LFO PM depth = 1*/\r\n\r\n/* FNUM2/FNUM = 10 0xxxxxxx (0x0200) */\r\n2, 1, 0,-1,-2,-1, 0, 1, /*LFO PM depth = 0*/\r\n4, 2, 0,-2,-4,-2, 0, 2, /*LFO PM depth = 1*/\r\n\r\n/* FNUM2/FNUM = 10 1xxxxxxx (0x0280) */\r\n2, 1, 0,-1,-2,-1, 0, 1, /*LFO PM depth = 0*/\r\n5, 2, 0,-2,-5,-2, 0, 2, /*LFO PM depth = 1*/\r\n\r\n/* FNUM2/FNUM = 11 0xxxxxxx (0x0300) */\r\n3, 1, 0,-1,-3,-1, 0, 1, /*LFO PM depth = 0*/\r\n6, 3, 0,-3,-6,-3, 0, 3, /*LFO PM depth = 1*/\r\n\r\n/* FNUM2/FNUM = 11 1xxxxxxx (0x0380) */\r\n3, 1, 0,-1,-3,-1, 0, 1, /*LFO PM depth = 0*/\r\n7, 3, 0,-3,-7,-3, 0, 3  /*LFO PM depth = 1*/\r\n};\r\n\r\n\r\n/* lock level of common table */\r\nstatic int num_lock = 0;\r\n\r\n\r\nstatic void *cur_chip = NULL;   /* current chip pointer */\r\nstatic OPL_SLOT *SLOT7_1, *SLOT7_2, *SLOT8_1, *SLOT8_2;\r\n\r\nstatic signed int phase_modulation; /* phase modulation input (SLOT 2) */\r\nstatic signed int output[1];\r\n\r\n#if BUILD_Y8950\r\nstatic INT32 output_deltat[4];      /* for Y8950 DELTA-T, chip is mono, that 4 here is just for safety */\r\n#endif\r\n\r\nstatic UINT32   LFO_AM;\r\nstatic INT32    LFO_PM;\r\n\r\n#define INLINE inline\r\n\r\nINLINE int limit( int val, int max, int min ) {\r\n    if ( val > max )\r\n        val = max;\r\n    else if ( val < min )\r\n        val = min;\r\n\r\n    return val;\r\n}\r\n\r\n\r\n/* status set and IRQ handling */\r\nINLINE void OPL_STATUS_SET(FM_OPL *OPL,int flag)\r\n{\r\n    /* set status flag */\r\n    OPL->status |= flag;\r\n    if(!(OPL->status & 0x80))\r\n    {\r\n        if(OPL->status & OPL->statusmask)\r\n        {   /* IRQ on */\r\n            OPL->status |= 0x80;\r\n            /* callback user interrupt handler (IRQ is OFF to ON) */\r\n            if(OPL->IRQHandler) (OPL->IRQHandler)(OPL->IRQParam,1);\r\n        }\r\n    }\r\n}\r\n\r\n/* status reset and IRQ handling */\r\nINLINE void OPL_STATUS_RESET(FM_OPL *OPL,int flag)\r\n{\r\n    /* reset status flag */\r\n    OPL->status &=~flag;\r\n    if((OPL->status & 0x80))\r\n    {\r\n        if (!(OPL->status & OPL->statusmask) )\r\n        {\r\n            OPL->status &= 0x7f;\r\n            /* callback user interrupt handler (IRQ is ON to OFF) */\r\n            if(OPL->IRQHandler) (OPL->IRQHandler)(OPL->IRQParam,0);\r\n        }\r\n    }\r\n}\r\n\r\n/* IRQ mask set */\r\nINLINE void OPL_STATUSMASK_SET(FM_OPL *OPL,int flag)\r\n{\r\n    OPL->statusmask = flag;\r\n    /* IRQ handling check */\r\n    OPL_STATUS_SET(OPL,0);\r\n    OPL_STATUS_RESET(OPL,0);\r\n}\r\n\r\n\r\n/* advance LFO to next sample */\r\nINLINE void advance_lfo(FM_OPL *OPL)\r\n{\r\n    UINT8 tmp;\r\n\r\n    /* LFO */\r\n    OPL->lfo_am_cnt += OPL->lfo_am_inc;\r\n    if (OPL->lfo_am_cnt >= (LFO_AM_TAB_ELEMENTS<<LFO_SH) )  /* lfo_am_table is 210 elements long */\r\n        OPL->lfo_am_cnt -= (LFO_AM_TAB_ELEMENTS<<LFO_SH);\r\n\r\n    tmp = lfo_am_table[ OPL->lfo_am_cnt >> LFO_SH ];\r\n\r\n    if (OPL->lfo_am_depth)\r\n        LFO_AM = tmp;\r\n    else\r\n        LFO_AM = tmp>>2;\r\n\r\n    OPL->lfo_pm_cnt += OPL->lfo_pm_inc;\r\n    LFO_PM = ((OPL->lfo_pm_cnt>>LFO_SH) & 7) | OPL->lfo_pm_depth_range;\r\n}\r\n\r\n/* advance to next sample */\r\nINLINE void advance(FM_OPL *OPL)\r\n{\r\n    OPL_CH *CH;\r\n    OPL_SLOT *op;\r\n    int i;\r\n\r\n    OPL->eg_timer += OPL->eg_timer_add;\r\n\r\n    while (OPL->eg_timer >= OPL->eg_timer_overflow)\r\n    {\r\n        OPL->eg_timer -= OPL->eg_timer_overflow;\r\n\r\n        OPL->eg_cnt++;\r\n\r\n        for (i=0; i<9*2; i++)\r\n        {\r\n            CH  = &OPL->P_CH[i/2];\r\n            op  = &CH->SLOT[i&1];\r\n\r\n            /* Envelope Generator */\r\n            switch(op->state)\r\n            {\r\n            case EG_ATT:        /* attack phase */\r\n                if ( !(OPL->eg_cnt & ((1<<op->eg_sh_ar)-1) ) )\r\n                {\r\n                    op->volume += (~op->volume *\r\n                                               (eg_inc[op->eg_sel_ar + ((OPL->eg_cnt>>op->eg_sh_ar)&7)])\r\n                                              ) >>3;\r\n\r\n                    if (op->volume <= MIN_ATT_INDEX)\r\n                    {\r\n                        op->volume = MIN_ATT_INDEX;\r\n                        op->state = EG_DEC;\r\n                    }\r\n\r\n                }\r\n            break;\r\n\r\n            case EG_DEC:    /* decay phase */\r\n                if ( !(OPL->eg_cnt & ((1<<op->eg_sh_dr)-1) ) )\r\n                {\r\n                    op->volume += eg_inc[op->eg_sel_dr + ((OPL->eg_cnt>>op->eg_sh_dr)&7)];\r\n\r\n                    if ( (UINT32) op->volume >= op->sl )\r\n                        op->state = EG_SUS;\r\n\r\n                }\r\n            break;\r\n\r\n            case EG_SUS:    /* sustain phase */\r\n\r\n                /* this is important behaviour:\r\n                one can change percusive/non-percussive modes on the fly and\r\n                the chip will remain in sustain phase - verified on real YM3812 */\r\n\r\n                if(op->eg_type)     /* non-percussive mode */\r\n                {\r\n                                    /* do nothing */\r\n                }\r\n                else                /* percussive mode */\r\n                {\r\n                    /* during sustain phase chip adds Release Rate (in percussive mode) */\r\n                    if ( !(OPL->eg_cnt & ((1<<op->eg_sh_rr)-1) ) )\r\n                    {\r\n                        op->volume += eg_inc[op->eg_sel_rr + ((OPL->eg_cnt>>op->eg_sh_rr)&7)];\r\n\r\n                        if ( op->volume >= MAX_ATT_INDEX )\r\n                            op->volume = MAX_ATT_INDEX;\r\n                    }\r\n                    /* else do nothing in sustain phase */\r\n                }\r\n            break;\r\n\r\n            case EG_REL:    /* release phase */\r\n                if ( !(OPL->eg_cnt & ((1<<op->eg_sh_rr)-1) ) )\r\n                {\r\n                    op->volume += eg_inc[op->eg_sel_rr + ((OPL->eg_cnt>>op->eg_sh_rr)&7)];\r\n\r\n                    if ( op->volume >= MAX_ATT_INDEX )\r\n                    {\r\n                        op->volume = MAX_ATT_INDEX;\r\n                        op->state = EG_OFF;\r\n                    }\r\n\r\n                }\r\n            break;\r\n\r\n            default:\r\n            break;\r\n            }\r\n        }\r\n    }\r\n\r\n    for (i=0; i<9*2; i++)\r\n    {\r\n        CH  = &OPL->P_CH[i/2];\r\n        op  = &CH->SLOT[i&1];\r\n\r\n        /* Phase Generator */\r\n        if(op->vib)\r\n        {\r\n            UINT8 block;\r\n            unsigned int block_fnum = CH->block_fnum;\r\n\r\n            unsigned int fnum_lfo   = (block_fnum&0x0380) >> 7;\r\n\r\n            signed int lfo_fn_table_index_offset = lfo_pm_table[LFO_PM + 16*fnum_lfo ];\r\n\r\n            if (lfo_fn_table_index_offset)  /* LFO phase modulation active */\r\n            {\r\n                block_fnum += lfo_fn_table_index_offset;\r\n                block = (block_fnum&0x1c00) >> 10;\r\n                op->Cnt += (OPL->fn_tab[block_fnum&0x03ff] >> (7-block)) * op->mul;\r\n            }\r\n            else    /* LFO phase modulation  = zero */\r\n            {\r\n                op->Cnt += op->Incr;\r\n            }\r\n        }\r\n        else    /* LFO phase modulation disabled for this operator */\r\n        {\r\n            op->Cnt += op->Incr;\r\n        }\r\n    }\r\n\r\n    /*  The Noise Generator of the YM3812 is 23-bit shift register.\r\n    *   Period is equal to 2^23-2 samples.\r\n    *   Register works at sampling frequency of the chip, so output\r\n    *   can change on every sample.\r\n    *\r\n    *   Output of the register and input to the bit 22 is:\r\n    *   bit0 XOR bit14 XOR bit15 XOR bit22\r\n    *\r\n    *   Simply use bit 22 as the noise output.\r\n    */\r\n\r\n    OPL->noise_p += OPL->noise_f;\r\n    i = OPL->noise_p >> FREQ_SH;        /* number of events (shifts of the shift register) */\r\n    OPL->noise_p &= FREQ_MASK;\r\n    while (i)\r\n    {\r\n        /*\r\n        UINT32 j;\r\n        j = ( (OPL->noise_rng) ^ (OPL->noise_rng>>14) ^ (OPL->noise_rng>>15) ^ (OPL->noise_rng>>22) ) & 1;\r\n        OPL->noise_rng = (j<<22) | (OPL->noise_rng>>1);\r\n        */\r\n\r\n        /*\r\n            Instead of doing all the logic operations above, we\r\n            use a trick here (and use bit 0 as the noise output).\r\n            The difference is only that the noise bit changes one\r\n            step ahead. This doesn't matter since we don't know\r\n            what is real state of the noise_rng after the reset.\r\n        */\r\n\r\n        if (OPL->noise_rng & 1) OPL->noise_rng ^= 0x800302;\r\n        OPL->noise_rng >>= 1;\r\n\r\n        i--;\r\n    }\r\n}\r\n\r\n\r\nINLINE signed int op_calc(UINT32 phase, unsigned int env, signed int pm, unsigned int wave_tab)\r\n{\r\n    UINT32 p;\r\n\r\n    p = (env<<4) + sin_tab[wave_tab + ((((signed int)((phase & ~FREQ_MASK) + (pm<<16))) >> FREQ_SH ) & SIN_MASK) ];\r\n\r\n    if (p >= TL_TAB_LEN)\r\n        return 0;\r\n    return tl_tab[p];\r\n}\r\n\r\nINLINE signed int op_calc1(UINT32 phase, unsigned int env, signed int pm, unsigned int wave_tab)\r\n{\r\n    UINT32 p;\r\n\r\n    p = (env<<4) + sin_tab[wave_tab + ((((signed int)((phase & ~FREQ_MASK) + pm      )) >> FREQ_SH ) & SIN_MASK) ];\r\n\r\n    if (p >= TL_TAB_LEN)\r\n        return 0;\r\n    return tl_tab[p];\r\n}\r\n\r\n\r\n#define volume_calc(OP) ((OP)->TLL + ((UINT32)(OP)->volume) + (LFO_AM & (OP)->AMmask))\r\n\r\n/* calculate output */\r\nINLINE void OPL_CALC_CH( OPL_CH *CH )\r\n{\r\n    OPL_SLOT *SLOT;\r\n    unsigned int env;\r\n    signed int out;\r\n\r\n    phase_modulation = 0;\r\n\r\n    /* SLOT 1 */\r\n    SLOT = &CH->SLOT[SLOT1];\r\n    env  = volume_calc(SLOT);\r\n    out  = SLOT->op1_out[0] + SLOT->op1_out[1];\r\n    SLOT->op1_out[0] = SLOT->op1_out[1];\r\n    if(!CH->muted || SLOT->connect1!=output)\r\n        *SLOT->connect1 += SLOT->op1_out[0];\r\n    SLOT->op1_out[1] = 0;\r\n    if( env < ENV_QUIET )\r\n    {\r\n        if (!SLOT->FB)\r\n            out = 0;\r\n        SLOT->op1_out[1] = op_calc1(SLOT->Cnt, env, (out<<SLOT->FB), SLOT->wavetable );\r\n    }\r\n\r\n    if(CH->muted) return;\r\n\r\n    /* SLOT 2 */\r\n    SLOT++;\r\n    env = volume_calc(SLOT);\r\n    if( env < ENV_QUIET )\r\n        output[0] += op_calc(SLOT->Cnt, env, phase_modulation, SLOT->wavetable);\r\n}\r\n\r\n/*\r\n    operators used in the rhythm sounds generation process:\r\n\r\n    Envelope Generator:\r\n\r\nchannel  operator  register number   Bass  High  Snare Tom  Top\r\n/ slot   number    TL ARDR SLRR Wave Drum  Hat   Drum  Tom  Cymbal\r\n 6 / 0   12        50  70   90   f0  +\r\n 6 / 1   15        53  73   93   f3  +\r\n 7 / 0   13        51  71   91   f1        +\r\n 7 / 1   16        54  74   94   f4              +\r\n 8 / 0   14        52  72   92   f2                    +\r\n 8 / 1   17        55  75   95   f5                          +\r\n\r\n    Phase Generator:\r\n\r\nchannel  operator  register number   Bass  High  Snare Tom  Top\r\n/ slot   number    MULTIPLE          Drum  Hat   Drum  Tom  Cymbal\r\n 6 / 0   12        30                +\r\n 6 / 1   15        33                +\r\n 7 / 0   13        31                      +     +           +\r\n 7 / 1   16        34                -----  n o t  u s e d -----\r\n 8 / 0   14        32                                  +\r\n 8 / 1   17        35                      +                 +\r\n\r\nchannel  operator  register number   Bass  High  Snare Tom  Top\r\nnumber   number    BLK/FNUM2 FNUM    Drum  Hat   Drum  Tom  Cymbal\r\n   6     12,15     B6        A6      +\r\n\r\n   7     13,16     B7        A7            +     +           +\r\n\r\n   8     14,17     B8        A8            +           +     +\r\n\r\n*/\r\n\r\n/* calculate rhythm */\r\n\r\nINLINE void OPL_CALC_RH( OPL_CH *CH, unsigned int noise )\r\n{\r\n    OPL_SLOT *SLOT;\r\n    signed int out;\r\n    unsigned int env;\r\n\r\n\r\n    /* Bass Drum (verified on real YM3812):\r\n      - depends on the channel 6 'connect' register:\r\n          when connect = 0 it works the same as in normal (non-rhythm) mode (op1->op2->out)\r\n          when connect = 1 _only_ operator 2 is present on output (op2->out), operator 1 is ignored\r\n      - output sample always is multiplied by 2\r\n    */\r\n\r\n    phase_modulation = 0;\r\n    /* SLOT 1 */\r\n    SLOT = &CH[6].SLOT[SLOT1];\r\n    env = volume_calc(SLOT);\r\n\r\n    out = SLOT->op1_out[0] + SLOT->op1_out[1];\r\n    SLOT->op1_out[0] = SLOT->op1_out[1];\r\n\r\n    if (!SLOT->CON)\r\n        phase_modulation = SLOT->op1_out[0];\r\n    /* else ignore output of operator 1 */\r\n\r\n    SLOT->op1_out[1] = 0;\r\n    if( env < ENV_QUIET )\r\n    {\r\n        if (!SLOT->FB)\r\n            out = 0;\r\n        SLOT->op1_out[1] = op_calc1(SLOT->Cnt, env, (out<<SLOT->FB), SLOT->wavetable );\r\n    }\r\n\r\n    /* SLOT 2 */\r\n    SLOT++;\r\n    env = volume_calc(SLOT);\r\n    if( env < ENV_QUIET && !CH->muted)\r\n        output[0] += op_calc(SLOT->Cnt, env, phase_modulation, SLOT->wavetable) * 2;\r\n\r\n\r\n    /* Phase generation is based on: */\r\n    /* HH  (13) channel 7->slot 1 combined with channel 8->slot 2 (same combination as TOP CYMBAL but different output phases) */\r\n    /* SD  (16) channel 7->slot 1 */\r\n    /* TOM (14) channel 8->slot 1 */\r\n    /* TOP (17) channel 7->slot 1 combined with channel 8->slot 2 (same combination as HIGH HAT but different output phases) */\r\n\r\n    /* Envelope generation based on: */\r\n    /* HH  channel 7->slot1 */\r\n    /* SD  channel 7->slot2 */\r\n    /* TOM channel 8->slot1 */\r\n    /* TOP channel 8->slot2 */\r\n\r\n\r\n    /* The following formulas can be well optimized.\r\n       I leave them in direct form for now (in case I've missed something).\r\n    */\r\n\r\n    /* High Hat (verified on real YM3812) */\r\n    env = volume_calc(SLOT7_1);\r\n    if( env < ENV_QUIET && !CH->muted)\r\n    {\r\n\r\n        /* high hat phase generation:\r\n            phase = d0 or 234 (based on frequency only)\r\n            phase = 34 or 2d0 (based on noise)\r\n        */\r\n\r\n        /* base frequency derived from operator 1 in channel 7 */\r\n        unsigned char bit7 = ((SLOT7_1->Cnt>>FREQ_SH)>>7)&1;\r\n        unsigned char bit3 = ((SLOT7_1->Cnt>>FREQ_SH)>>3)&1;\r\n        unsigned char bit2 = ((SLOT7_1->Cnt>>FREQ_SH)>>2)&1;\r\n\r\n        unsigned char res1 = (bit2 ^ bit7) | bit3;\r\n\r\n        /* when res1 = 0 phase = 0x000 | 0xd0; */\r\n        /* when res1 = 1 phase = 0x200 | (0xd0>>2); */\r\n        UINT32 phase = res1 ? (0x200|(0xd0>>2)) : 0xd0;\r\n\r\n        /* enable gate based on frequency of operator 2 in channel 8 */\r\n        unsigned char bit5e= ((SLOT8_2->Cnt>>FREQ_SH)>>5)&1;\r\n        unsigned char bit3e= ((SLOT8_2->Cnt>>FREQ_SH)>>3)&1;\r\n\r\n        unsigned char res2 = (bit3e ^ bit5e);\r\n\r\n        /* when res2 = 0 pass the phase from calculation above (res1); */\r\n        /* when res2 = 1 phase = 0x200 | (0xd0>>2); */\r\n        if (res2)\r\n            phase = (0x200|(0xd0>>2));\r\n\r\n\r\n        /* when phase & 0x200 is set and noise=1 then phase = 0x200|0xd0 */\r\n        /* when phase & 0x200 is set and noise=0 then phase = 0x200|(0xd0>>2), ie no change */\r\n        if (phase&0x200)\r\n        {\r\n            if (noise)\r\n                phase = 0x200|0xd0;\r\n        }\r\n        else\r\n        /* when phase & 0x200 is clear and noise=1 then phase = 0xd0>>2 */\r\n        /* when phase & 0x200 is clear and noise=0 then phase = 0xd0, ie no change */\r\n        {\r\n            if (noise)\r\n                phase = 0xd0>>2;\r\n        }\r\n\r\n        output[0] += op_calc(phase<<FREQ_SH, env, 0, SLOT7_1->wavetable) * 2;\r\n    }\r\n\r\n    /* Snare Drum (verified on real YM3812) */\r\n    env = volume_calc(SLOT7_2);\r\n    if( env < ENV_QUIET && !CH->muted)\r\n    {\r\n        /* base frequency derived from operator 1 in channel 7 */\r\n        unsigned char bit8 = ((SLOT7_1->Cnt>>FREQ_SH)>>8)&1;\r\n\r\n        /* when bit8 = 0 phase = 0x100; */\r\n        /* when bit8 = 1 phase = 0x200; */\r\n        UINT32 phase = bit8 ? 0x200 : 0x100;\r\n\r\n        /* Noise bit XOR'es phase by 0x100 */\r\n        /* when noisebit = 0 pass the phase from calculation above */\r\n        /* when noisebit = 1 phase ^= 0x100; */\r\n        /* in other words: phase ^= (noisebit<<8); */\r\n        if (noise)\r\n            phase ^= 0x100;\r\n\r\n        output[0] += op_calc(phase<<FREQ_SH, env, 0, SLOT7_2->wavetable) * 2;\r\n    }\r\n\r\n    /* Tom Tom (verified on real YM3812) */\r\n    env = volume_calc(SLOT8_1);\r\n    if( env < ENV_QUIET && !CH->muted)\r\n        output[0] += op_calc(SLOT8_1->Cnt, env, 0, SLOT8_1->wavetable) * 2;\r\n\r\n    /* Top Cymbal (verified on real YM3812) */\r\n    env = volume_calc(SLOT8_2);\r\n    if( env < ENV_QUIET && !CH->muted)\r\n    {\r\n        /* base frequency derived from operator 1 in channel 7 */\r\n        unsigned char bit7 = ((SLOT7_1->Cnt>>FREQ_SH)>>7)&1;\r\n        unsigned char bit3 = ((SLOT7_1->Cnt>>FREQ_SH)>>3)&1;\r\n        unsigned char bit2 = ((SLOT7_1->Cnt>>FREQ_SH)>>2)&1;\r\n\r\n        unsigned char res1 = (bit2 ^ bit7) | bit3;\r\n\r\n        /* when res1 = 0 phase = 0x000 | 0x100; */\r\n        /* when res1 = 1 phase = 0x200 | 0x100; */\r\n        UINT32 phase = res1 ? 0x300 : 0x100;\r\n\r\n        /* enable gate based on frequency of operator 2 in channel 8 */\r\n        unsigned char bit5e= ((SLOT8_2->Cnt>>FREQ_SH)>>5)&1;\r\n        unsigned char bit3e= ((SLOT8_2->Cnt>>FREQ_SH)>>3)&1;\r\n\r\n        unsigned char res2 = (bit3e ^ bit5e);\r\n        /* when res2 = 0 pass the phase from calculation above (res1); */\r\n        /* when res2 = 1 phase = 0x200 | 0x100; */\r\n        if (res2)\r\n            phase = 0x300;\r\n\r\n        output[0] += op_calc(phase<<FREQ_SH, env, 0, SLOT8_2->wavetable) * 2;\r\n    }\r\n\r\n}\r\n\r\n\r\n/* generic table initialize */\r\nstatic int init_tables(void)\r\n{\r\n    signed int i,x;\r\n    signed int n;\r\n    double o,m;\r\n\r\n\r\n    for (x=0; x<TL_RES_LEN; x++)\r\n    {\r\n        m = (1<<16) / pow(2, (x+1) * (ENV_STEP/4.0) / 8.0);\r\n        m = floor(m);\r\n\r\n        /* we never reach (1<<16) here due to the (x+1) */\r\n        /* result fits within 16 bits at maximum */\r\n\r\n        n = (int)m;     /* 16 bits here */\r\n        n >>= 4;        /* 12 bits here */\r\n        if (n&1)        /* round to nearest */\r\n            n = (n>>1)+1;\r\n        else\r\n            n = n>>1;\r\n                        /* 11 bits here (rounded) */\r\n        n <<= 1;        /* 12 bits here (as in real chip) */\r\n        tl_tab[ x*2 + 0 ] = n;\r\n        tl_tab[ x*2 + 1 ] = -tl_tab[ x*2 + 0 ];\r\n\r\n        for (i=1; i<12; i++)\r\n        {\r\n            tl_tab[ x*2+0 + i*2*TL_RES_LEN ] =  tl_tab[ x*2+0 ]>>i;\r\n            tl_tab[ x*2+1 + i*2*TL_RES_LEN ] = -tl_tab[ x*2+0 + i*2*TL_RES_LEN ];\r\n        }\r\n    #if 0\r\n            logerror(\"tl %04i\", x*2);\r\n            for (i=0; i<12; i++)\r\n                logerror(\", [%02i] %5i\", i*2, tl_tab[ x*2 /*+1*/ + i*2*TL_RES_LEN ] );\r\n            logerror(\"\\n\");\r\n    #endif\r\n    }\r\n    /*logerror(\"FMOPL.C: TL_TAB_LEN = %i elements (%i bytes)\\n\",TL_TAB_LEN, (int)sizeof(tl_tab));*/\r\n\r\n\r\n    for (i=0; i<SIN_LEN; i++)\r\n    {\r\n        /* non-standard sinus */\r\n        m = sin( ((i*2)+1) * PI / SIN_LEN ); /* checked against the real chip */\r\n\r\n        /* we never reach zero here due to ((i*2)+1) */\r\n\r\n        if (m>0.0)\r\n            o = 8*log(1.0/m)/log(2.0);  /* convert to 'decibels' */\r\n        else\r\n            o = 8*log(-1.0/m)/log(2.0); /* convert to 'decibels' */\r\n\r\n        o = o / (ENV_STEP/4);\r\n\r\n        n = (int)(2.0*o);\r\n        if (n&1)                        /* round to nearest */\r\n            n = (n>>1)+1;\r\n        else\r\n            n = n>>1;\r\n\r\n        sin_tab[ i ] = n*2 + (m>=0.0? 0: 1 );\r\n\r\n        /*logerror(\"FMOPL.C: sin [%4i (hex=%03x)]= %4i (tl_tab value=%5i)\\n\", i, i, sin_tab[i], tl_tab[sin_tab[i]] );*/\r\n    }\r\n\r\n    for (i=0; i<SIN_LEN; i++)\r\n    {\r\n        /* waveform 1:  __      __     */\r\n        /*             /  \\____/  \\____*/\r\n        /* output only first half of the sinus waveform (positive one) */\r\n\r\n        if (i & (1<<(SIN_BITS-1)) )\r\n            sin_tab[1*SIN_LEN+i] = TL_TAB_LEN;\r\n        else\r\n            sin_tab[1*SIN_LEN+i] = sin_tab[i];\r\n\r\n        /* waveform 2:  __  __  __  __ */\r\n        /*             /  \\/  \\/  \\/  \\*/\r\n        /* abs(sin) */\r\n\r\n        sin_tab[2*SIN_LEN+i] = sin_tab[i & (SIN_MASK>>1) ];\r\n\r\n        /* waveform 3:  _   _   _   _  */\r\n        /*             / |_/ |_/ |_/ |_*/\r\n        /* abs(output only first quarter of the sinus waveform) */\r\n\r\n        if (i & (1<<(SIN_BITS-2)) )\r\n            sin_tab[3*SIN_LEN+i] = TL_TAB_LEN;\r\n        else\r\n            sin_tab[3*SIN_LEN+i] = sin_tab[i & (SIN_MASK>>2)];\r\n\r\n        /*logerror(\"FMOPL.C: sin1[%4i]= %4i (tl_tab value=%5i)\\n\", i, sin_tab[1*SIN_LEN+i], tl_tab[sin_tab[1*SIN_LEN+i]] );\r\n        logerror(\"FMOPL.C: sin2[%4i]= %4i (tl_tab value=%5i)\\n\", i, sin_tab[2*SIN_LEN+i], tl_tab[sin_tab[2*SIN_LEN+i]] );\r\n        logerror(\"FMOPL.C: sin3[%4i]= %4i (tl_tab value=%5i)\\n\", i, sin_tab[3*SIN_LEN+i], tl_tab[sin_tab[3*SIN_LEN+i]] );*/\r\n    }\r\n    /*logerror(\"FMOPL.C: ENV_QUIET= %08x (dec*8=%i)\\n\", ENV_QUIET, ENV_QUIET*8 );*/\r\n\r\n\r\n#ifdef SAVE_SAMPLE\r\n    sample[0]=fopen(\"sampsum.pcm\",\"wb\");\r\n#endif\r\n\r\n    return 1;\r\n}\r\n\r\nstatic void OPLCloseTable( void )\r\n{\r\n#ifdef SAVE_SAMPLE\r\n    fclose(sample[0]);\r\n#endif\r\n}\r\n\r\n\r\n\r\nstatic void OPL_initalize(FM_OPL *OPL)\r\n{\r\n    int i;\r\n\r\n    /* frequency base */\r\n    OPL->freqbase  = (OPL->rate) ? ((double)OPL->clock / 72.0) / OPL->rate  : 0;\r\n#if 0\r\n    OPL->rate = (double)OPL->clock / 72.0;\r\n    OPL->freqbase  = 1.0;\r\n#endif\r\n\r\n    /*logerror(\"freqbase=%f\\n\", OPL->freqbase);*/\r\n\r\n    /* Timer base time */\r\n    OPL->TimerBase = 1.0 / ((double)OPL->clock / 72.0 );\r\n\r\n    /* make fnumber -> increment counter table */\r\n    for( i=0 ; i < 1024 ; i++ )\r\n    {\r\n        /* opn phase increment counter = 20bit */\r\n        OPL->fn_tab[i] = (UINT32)( (double)i * 64 * OPL->freqbase * (1<<(FREQ_SH-10)) ); /* -10 because chip works with 10.10 fixed point, while we use 16.16 */\r\n#if 0\r\n        logerror(\"FMOPL.C: fn_tab[%4i] = %08x (dec=%8i)\\n\",\r\n                 i, OPL->fn_tab[i]>>6, OPL->fn_tab[i]>>6 );\r\n#endif\r\n    }\r\n\r\n#if 0\r\n    for( i=0 ; i < 16 ; i++ )\r\n    {\r\n        logerror(\"FMOPL.C: sl_tab[%i] = %08x\\n\",\r\n            i, sl_tab[i] );\r\n    }\r\n    for( i=0 ; i < 8 ; i++ )\r\n    {\r\n        int j;\r\n        logerror(\"FMOPL.C: ksl_tab[oct=%2i] =\",i);\r\n        for (j=0; j<16; j++)\r\n        {\r\n            logerror(\"%08x \", ksl_tab[i*16+j] );\r\n        }\r\n        logerror(\"\\n\");\r\n    }\r\n#endif\r\n\r\n\r\n    /* Amplitude modulation: 27 output levels (triangle waveform); 1 level takes one of: 192, 256 or 448 samples */\r\n    /* One entry from LFO_AM_TABLE lasts for 64 samples */\r\n    OPL->lfo_am_inc = (UINT32) ((1.0 / 64.0 ) * (1<<LFO_SH) * OPL->freqbase);\r\n\r\n    /* Vibrato: 8 output levels (triangle waveform); 1 level takes 1024 samples */\r\n    OPL->lfo_pm_inc = (UINT32) ((1.0 / 1024.0) * (1<<LFO_SH) * OPL->freqbase);\r\n\r\n    /*logerror (\"OPL->lfo_am_inc = %8x ; OPL->lfo_pm_inc = %8x\\n\", OPL->lfo_am_inc, OPL->lfo_pm_inc);*/\r\n\r\n    /* Noise generator: a step takes 1 sample */\r\n    OPL->noise_f = (UINT32) ((1.0 / 1.0) * (1<<FREQ_SH) * OPL->freqbase);\r\n\r\n    OPL->eg_timer_add = (UINT32) ((1<<EG_SH) * OPL->freqbase);\r\n    OPL->eg_timer_overflow = ( 1 ) * (1<<EG_SH);\r\n    /*logerror(\"OPLinit eg_timer_add=%8x eg_timer_overflow=%8x\\n\", OPL->eg_timer_add, OPL->eg_timer_overflow);*/\r\n\r\n}\r\n\r\nINLINE void FM_KEYON(OPL_SLOT *SLOT, UINT32 key_set)\r\n{\r\n    if( !SLOT->key )\r\n    {\r\n        /* restart Phase Generator */\r\n        SLOT->Cnt = 0;\r\n        /* phase -> Attack */\r\n        SLOT->state = EG_ATT;\r\n    }\r\n    SLOT->key |= key_set;\r\n}\r\n\r\nINLINE void FM_KEYOFF(OPL_SLOT *SLOT, UINT32 key_clr)\r\n{\r\n    if( SLOT->key )\r\n    {\r\n        SLOT->key &= key_clr;\r\n\r\n        if( !SLOT->key )\r\n        {\r\n            /* phase -> Release */\r\n            if (SLOT->state>EG_REL)\r\n                SLOT->state = EG_REL;\r\n        }\r\n    }\r\n}\r\n\r\n/* update phase increment counter of operator (also update the EG rates if necessary) */\r\nINLINE void CALC_FCSLOT(OPL_CH *CH,OPL_SLOT *SLOT)\r\n{\r\n    int ksr;\r\n\r\n    /* (frequency) phase increment counter */\r\n    SLOT->Incr = CH->fc * SLOT->mul;\r\n    ksr = CH->kcode >> SLOT->KSR;\r\n\r\n    if( SLOT->ksr != ksr )\r\n    {\r\n        SLOT->ksr = ksr;\r\n\r\n        /* calculate envelope generator rates */\r\n        if ((SLOT->ar + SLOT->ksr) < 16+62)\r\n        {\r\n            SLOT->eg_sh_ar  = eg_rate_shift [SLOT->ar + SLOT->ksr ];\r\n            SLOT->eg_sel_ar = eg_rate_select[SLOT->ar + SLOT->ksr ];\r\n        }\r\n        else\r\n        {\r\n            SLOT->eg_sh_ar  = 0;\r\n            SLOT->eg_sel_ar = 13*RATE_STEPS;\r\n        }\r\n        SLOT->eg_sh_dr  = eg_rate_shift [SLOT->dr + SLOT->ksr ];\r\n        SLOT->eg_sel_dr = eg_rate_select[SLOT->dr + SLOT->ksr ];\r\n        SLOT->eg_sh_rr  = eg_rate_shift [SLOT->rr + SLOT->ksr ];\r\n        SLOT->eg_sel_rr = eg_rate_select[SLOT->rr + SLOT->ksr ];\r\n    }\r\n}\r\n\r\n/* set multi,am,vib,EG-TYP,KSR,mul */\r\nINLINE void set_mul(FM_OPL *OPL,int slot,int v)\r\n{\r\n    OPL_CH   *CH   = &OPL->P_CH[slot/2];\r\n    OPL_SLOT *SLOT = &CH->SLOT[slot&1];\r\n\r\n    SLOT->mul     = mul_tab[v&0x0f];\r\n    SLOT->KSR     = (v&0x10) ? 0 : 2;\r\n    SLOT->eg_type = (v&0x20);\r\n    SLOT->vib     = (v&0x40);\r\n    SLOT->AMmask  = (v&0x80) ? ~0 : 0;\r\n    CALC_FCSLOT(CH,SLOT);\r\n}\r\n\r\n/* set ksl & tl */\r\nINLINE void set_ksl_tl(FM_OPL *OPL,int slot,int v)\r\n{\r\n    OPL_CH   *CH   = &OPL->P_CH[slot/2];\r\n    OPL_SLOT *SLOT = &CH->SLOT[slot&1];\r\n    int ksl = v>>6; /* 0 / 1.5 / 3.0 / 6.0 dB/OCT */\r\n\r\n    SLOT->ksl = ksl ? 3-ksl : 31;\r\n    SLOT->TL  = (v&0x3f)<<(ENV_BITS-1-7); /* 7 bits TL (bit 6 = always 0) */\r\n\r\n    SLOT->TLL = SLOT->TL + (CH->ksl_base>>SLOT->ksl);\r\n}\r\n\r\n/* set attack rate & decay rate  */\r\nINLINE void set_ar_dr(FM_OPL *OPL,int slot,int v)\r\n{\r\n    OPL_CH   *CH   = &OPL->P_CH[slot/2];\r\n    OPL_SLOT *SLOT = &CH->SLOT[slot&1];\r\n\r\n    SLOT->ar = (v>>4)  ? 16 + ((v>>4)  <<2) : 0;\r\n\r\n    if ((SLOT->ar + SLOT->ksr) < 16+62)\r\n    {\r\n        SLOT->eg_sh_ar  = eg_rate_shift [SLOT->ar + SLOT->ksr ];\r\n        SLOT->eg_sel_ar = eg_rate_select[SLOT->ar + SLOT->ksr ];\r\n    }\r\n    else\r\n    {\r\n        SLOT->eg_sh_ar  = 0;\r\n        SLOT->eg_sel_ar = 13*RATE_STEPS;\r\n    }\r\n\r\n    SLOT->dr    = (v&0x0f)? 16 + ((v&0x0f)<<2) : 0;\r\n    SLOT->eg_sh_dr  = eg_rate_shift [SLOT->dr + SLOT->ksr ];\r\n    SLOT->eg_sel_dr = eg_rate_select[SLOT->dr + SLOT->ksr ];\r\n}\r\n\r\n/* set sustain level & release rate */\r\nINLINE void set_sl_rr(FM_OPL *OPL,int slot,int v)\r\n{\r\n    OPL_CH   *CH   = &OPL->P_CH[slot/2];\r\n    OPL_SLOT *SLOT = &CH->SLOT[slot&1];\r\n\r\n    SLOT->sl  = sl_tab[ v>>4 ];\r\n\r\n    SLOT->rr  = (v&0x0f)? 16 + ((v&0x0f)<<2) : 0;\r\n    SLOT->eg_sh_rr  = eg_rate_shift [SLOT->rr + SLOT->ksr ];\r\n    SLOT->eg_sel_rr = eg_rate_select[SLOT->rr + SLOT->ksr ];\r\n}\r\n\r\n\r\n/* write a value v to register r on OPL chip */\r\nstatic void OPLWriteReg(FM_OPL *OPL, int r, int v)\r\n{\r\n    OPL_CH *CH;\r\n    int slot;\r\n    int block_fnum;\r\n\r\n\r\n    /* adjust bus to 8 bits */\r\n    r &= 0xff;\r\n    v &= 0xff;\r\n\r\n#ifdef LOG_CYM_FILE\r\n    if ((cymfile) && (r!=0) )\r\n    {\r\n        fputc( (unsigned char)r, cymfile );\r\n        fputc( (unsigned char)v, cymfile );\r\n    }\r\n#endif\r\n\r\n\r\n    switch(r&0xe0)\r\n    {\r\n    case 0x00:  /* 00-1f:control */\r\n        switch(r&0x1f)\r\n        {\r\n        case 0x01:  /* waveform select enable */\r\n            if(OPL->type&OPL_TYPE_WAVESEL)\r\n            {\r\n                OPL->wavesel = v&0x20;\r\n                /* do not change the waveform previously selected */\r\n            }\r\n            break;\r\n        case 0x02:  /* Timer 1 */\r\n            OPL->T[0] = (256-v)*4;\r\n            break;\r\n        case 0x03:  /* Timer 2 */\r\n            OPL->T[1] = (256-v)*16;\r\n            break;\r\n        case 0x04:  /* IRQ clear / mask and Timer enable */\r\n            if(v&0x80)\r\n            {   /* IRQ flag clear */\r\n                OPL_STATUS_RESET(OPL,0x7f-0x08); /* don't reset BFRDY flag or we will have to call deltat module to set the flag */\r\n            }\r\n            else\r\n            {   /* set IRQ mask ,timer enable*/\r\n                UINT8 st1 = v&1;\r\n                UINT8 st2 = (v>>1)&1;\r\n\r\n                /* IRQRST,T1MSK,t2MSK,EOSMSK,BRMSK,x,ST2,ST1 */\r\n                OPL_STATUS_RESET(OPL, v & (0x78-0x08) );\r\n                OPL_STATUSMASK_SET(OPL, (~v) & 0x78 );\r\n\r\n                /* timer 2 */\r\n                if(OPL->st[1] != st2)\r\n                {\r\n                    double interval = st2 ? (double)OPL->T[1]*OPL->TimerBase : 0.0;\r\n                    OPL->st[1] = st2;\r\n                    if (OPL->TimerHandler) (OPL->TimerHandler)(OPL->TimerParam+1,interval);\r\n                }\r\n                /* timer 1 */\r\n                if(OPL->st[0] != st1)\r\n                {\r\n                    double interval = st1 ? (double)OPL->T[0]*OPL->TimerBase : 0.0;\r\n                    OPL->st[0] = st1;\r\n                    if (OPL->TimerHandler) (OPL->TimerHandler)(OPL->TimerParam+0,interval);\r\n                }\r\n            }\r\n            break;\r\n#if BUILD_Y8950\r\n        case 0x06:      /* Key Board OUT */\r\n            if(OPL->type&OPL_TYPE_KEYBOARD)\r\n            {\r\n                if(OPL->keyboardhandler_w)\r\n                    OPL->keyboardhandler_w(OPL->keyboard_param,v);\r\n                else\r\n                    logerror(\"Y8950: write unmapped KEYBOARD port\\n\");\r\n            }\r\n            break;\r\n        case 0x07:  /* DELTA-T control 1 : START,REC,MEMDATA,REPT,SPOFF,x,x,RST */\r\n            if(OPL->type&OPL_TYPE_ADPCM)\r\n                YM_DELTAT_ADPCM_Write(OPL->deltat,r-0x07,v);\r\n            break;\r\n#endif\r\n        case 0x08:  /* MODE,DELTA-T control 2 : CSM,NOTESEL,x,x,smpl,da/ad,64k,rom */\r\n            OPL->mode = v;\r\n#if BUILD_Y8950\r\n            if(OPL->type&OPL_TYPE_ADPCM)\r\n                YM_DELTAT_ADPCM_Write(OPL->deltat,r-0x07,v&0x0f); /* mask 4 LSBs in register 08 for DELTA-T unit */\r\n#endif\r\n            break;\r\n\r\n#if BUILD_Y8950\r\n        case 0x09:      /* START ADD */\r\n        case 0x0a:\r\n        case 0x0b:      /* STOP ADD  */\r\n        case 0x0c:\r\n        case 0x0d:      /* PRESCALE   */\r\n        case 0x0e:\r\n        case 0x0f:      /* ADPCM data write */\r\n        case 0x10:      /* DELTA-N    */\r\n        case 0x11:      /* DELTA-N    */\r\n        case 0x12:      /* ADPCM volume */\r\n            if(OPL->type&OPL_TYPE_ADPCM)\r\n                YM_DELTAT_ADPCM_Write(OPL->deltat,r-0x07,v);\r\n            break;\r\n\r\n        case 0x15:      /* DAC data high 8 bits (F7,F6...F2) */\r\n        case 0x16:      /* DAC data low 2 bits (F1, F0 in bits 7,6) */\r\n        case 0x17:      /* DAC data shift (S2,S1,S0 in bits 2,1,0) */\r\n            logerror(\"FMOPL.C: DAC data register written, but not implemented reg=%02x val=%02x\\n\",r,v);\r\n            break;\r\n\r\n        case 0x18:      /* I/O CTRL (Direction) */\r\n            if(OPL->type&OPL_TYPE_IO)\r\n                OPL->portDirection = v&0x0f;\r\n            break;\r\n        case 0x19:      /* I/O DATA */\r\n            if(OPL->type&OPL_TYPE_IO)\r\n            {\r\n                OPL->portLatch = v;\r\n                if(OPL->porthandler_w)\r\n                    OPL->porthandler_w(OPL->port_param,v&OPL->portDirection);\r\n            }\r\n            break;\r\n#endif\r\n        default:\r\n            logerror(\"FMOPL.C: write to unknown register: %02x\\n\",r);\r\n            break;\r\n        }\r\n        break;\r\n    case 0x20:  /* am ON, vib ON, ksr, eg_type, mul */\r\n        slot = slot_array[r&0x1f];\r\n        if(slot < 0) return;\r\n        set_mul(OPL,slot,v);\r\n        break;\r\n    case 0x40:\r\n        slot = slot_array[r&0x1f];\r\n        if(slot < 0) return;\r\n        set_ksl_tl(OPL,slot,v);\r\n        break;\r\n    case 0x60:\r\n        slot = slot_array[r&0x1f];\r\n        if(slot < 0) return;\r\n        set_ar_dr(OPL,slot,v);\r\n        break;\r\n    case 0x80:\r\n        slot = slot_array[r&0x1f];\r\n        if(slot < 0) return;\r\n        set_sl_rr(OPL,slot,v);\r\n        break;\r\n    case 0xa0:\r\n        if (r == 0xbd)          /* am depth, vibrato depth, r,bd,sd,tom,tc,hh */\r\n        {\r\n            OPL->lfo_am_depth = v & 0x80;\r\n            OPL->lfo_pm_depth_range = (v&0x40) ? 8 : 0;\r\n\r\n            OPL->rhythm  = v&0x3f;\r\n\r\n            if(OPL->rhythm&0x20)\r\n            {\r\n                /* BD key on/off */\r\n                if(v&0x10)\r\n                {\r\n                    FM_KEYON (&OPL->P_CH[6].SLOT[SLOT1], 2);\r\n                    FM_KEYON (&OPL->P_CH[6].SLOT[SLOT2], 2);\r\n                }\r\n                else\r\n                {\r\n                    FM_KEYOFF(&OPL->P_CH[6].SLOT[SLOT1],~2);\r\n                    FM_KEYOFF(&OPL->P_CH[6].SLOT[SLOT2],~2);\r\n                }\r\n                /* HH key on/off */\r\n                if(v&0x01) FM_KEYON (&OPL->P_CH[7].SLOT[SLOT1], 2);\r\n                else       FM_KEYOFF(&OPL->P_CH[7].SLOT[SLOT1],~2);\r\n                /* SD key on/off */\r\n                if(v&0x08) FM_KEYON (&OPL->P_CH[7].SLOT[SLOT2], 2);\r\n                else       FM_KEYOFF(&OPL->P_CH[7].SLOT[SLOT2],~2);\r\n                /* TOM key on/off */\r\n                if(v&0x04) FM_KEYON (&OPL->P_CH[8].SLOT[SLOT1], 2);\r\n                else       FM_KEYOFF(&OPL->P_CH[8].SLOT[SLOT1],~2);\r\n                /* TOP-CY key on/off */\r\n                if(v&0x02) FM_KEYON (&OPL->P_CH[8].SLOT[SLOT2], 2);\r\n                else       FM_KEYOFF(&OPL->P_CH[8].SLOT[SLOT2],~2);\r\n            }\r\n            else\r\n            {\r\n                /* BD key off */\r\n                FM_KEYOFF(&OPL->P_CH[6].SLOT[SLOT1],~2);\r\n                FM_KEYOFF(&OPL->P_CH[6].SLOT[SLOT2],~2);\r\n                /* HH key off */\r\n                FM_KEYOFF(&OPL->P_CH[7].SLOT[SLOT1],~2);\r\n                /* SD key off */\r\n                FM_KEYOFF(&OPL->P_CH[7].SLOT[SLOT2],~2);\r\n                /* TOM key off */\r\n                FM_KEYOFF(&OPL->P_CH[8].SLOT[SLOT1],~2);\r\n                /* TOP-CY off */\r\n                FM_KEYOFF(&OPL->P_CH[8].SLOT[SLOT2],~2);\r\n            }\r\n            return;\r\n        }\r\n        /* keyon,block,fnum */\r\n        if( (r&0x0f) > 8) return;\r\n        CH = &OPL->P_CH[r&0x0f];\r\n        if(!(r&0x10))\r\n        {   /* a0-a8 */\r\n            block_fnum  = (CH->block_fnum&0x1f00) | v;\r\n        }\r\n        else\r\n        {   /* b0-b8 */\r\n            block_fnum = ((v&0x1f)<<8) | (CH->block_fnum&0xff);\r\n\r\n            if(v&0x20)\r\n            {\r\n                FM_KEYON (&CH->SLOT[SLOT1], 1);\r\n                FM_KEYON (&CH->SLOT[SLOT2], 1);\r\n            }\r\n            else\r\n            {\r\n                FM_KEYOFF(&CH->SLOT[SLOT1],~1);\r\n                FM_KEYOFF(&CH->SLOT[SLOT2],~1);\r\n            }\r\n        }\r\n        /* update */\r\n        if(CH->block_fnum != (UINT32) block_fnum)\r\n        {\r\n            UINT8 block  = block_fnum >> 10;\r\n\r\n            CH->block_fnum = block_fnum;\r\n\r\n            CH->ksl_base = ksl_tab[block_fnum>>6];\r\n            CH->fc       = OPL->fn_tab[block_fnum&0x03ff] >> (7-block);\r\n\r\n            /* BLK 2,1,0 bits -> bits 3,2,1 of kcode */\r\n            CH->kcode    = (CH->block_fnum&0x1c00)>>9;\r\n\r\n             /* the info below is actually opposite to what is stated in the Manuals (verifed on real YM3812) */\r\n            /* if notesel == 0 -> lsb of kcode is bit 10 (MSB) of fnum  */\r\n            /* if notesel == 1 -> lsb of kcode is bit 9 (MSB-1) of fnum */\r\n            if (OPL->mode&0x40)\r\n                CH->kcode |= (CH->block_fnum&0x100)>>8; /* notesel == 1 */\r\n            else\r\n                CH->kcode |= (CH->block_fnum&0x200)>>9; /* notesel == 0 */\r\n\r\n            /* refresh Total Level in both SLOTs of this channel */\r\n            CH->SLOT[SLOT1].TLL = CH->SLOT[SLOT1].TL + (CH->ksl_base>>CH->SLOT[SLOT1].ksl);\r\n            CH->SLOT[SLOT2].TLL = CH->SLOT[SLOT2].TL + (CH->ksl_base>>CH->SLOT[SLOT2].ksl);\r\n\r\n            /* refresh frequency counter in both SLOTs of this channel */\r\n            CALC_FCSLOT(CH,&CH->SLOT[SLOT1]);\r\n            CALC_FCSLOT(CH,&CH->SLOT[SLOT2]);\r\n        }\r\n        break;\r\n    case 0xc0:\r\n        /* FB,C */\r\n        if( (r&0x0f) > 8) return;\r\n        CH = &OPL->P_CH[r&0x0f];\r\n        CH->SLOT[SLOT1].FB  = (v>>1)&7 ? ((v>>1)&7) + 7 : 0;\r\n        CH->SLOT[SLOT1].CON = v&1;\r\n        CH->SLOT[SLOT1].connect1 = CH->SLOT[SLOT1].CON ? &output[0] : &phase_modulation;\r\n        break;\r\n    case 0xe0: /* waveform select */\r\n        /* simply ignore write to the waveform select register if selecting not enabled in test register */\r\n        if(OPL->wavesel)\r\n        {\r\n            slot = slot_array[r&0x1f];\r\n            if(slot < 0) return;\r\n            CH = &OPL->P_CH[slot/2];\r\n\r\n            CH->SLOT[slot&1].wavetable = (v&0x03)*SIN_LEN;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nstatic void OPLMute(FM_OPL *OPL,int channel,BOOL mute)\r\n{\r\n    if(channel<0 || channel>8) return;\r\n\r\n    OPL_CH *CH = &OPL->P_CH[channel];\r\n\r\n    CH->muted=mute;\r\n\r\n/*  if(!mute)\r\n    {\r\n        if(ChannelMuted[channel]&1)\r\n        {\r\n            FM_KEYON (&CH->SLOT[SLOT1], 1);\r\n            FM_KEYON (&CH->SLOT[SLOT2], 1);\r\n        }\r\n        ChannelMuted[channel]=0;\r\n    }\r\n    else\r\n    {\r\n        if(CH->SLOT[SLOT1].volume<MIN_ATT_INDEX)\r\n        {\r\n            FM_KEYOFF(&CH->SLOT[SLOT1],~1);\r\n            FM_KEYOFF(&CH->SLOT[SLOT2],~1);\r\n            CH->SLOT[SLOT1].volume = MAX_ATT_INDEX;\r\n            CH->SLOT[SLOT1].state = EG_OFF;\r\n            CH->SLOT[SLOT2].volume = MAX_ATT_INDEX;\r\n            CH->SLOT[SLOT2].state = EG_OFF;\r\n\r\n            ChannelMuted[channel]=3;            // muted + keyon flag\r\n        }\r\n        else\r\n        {\r\n            MessageBox(NULL,\"HmMEMmSDUHSoi\",\"arghl\",MB_OK);\r\n            ChannelMuted[channel]=2;            // muted\r\n        }\r\n    }*/\r\n}\r\n\r\n#ifdef LOG_CYM_FILE\r\nstatic void cymfile_callback (int n)\r\n{\r\n    if (cymfile)\r\n    {\r\n        fputc( (unsigned char)0, cymfile );\r\n    }\r\n}\r\n#endif\r\n\r\n/* lock/unlock for common table */\r\nstatic int OPL_LockTable(void)\r\n{\r\n    num_lock++;\r\n    if(num_lock>1) return 0;\r\n\r\n    /* first time */\r\n\r\n    cur_chip = NULL;\r\n    /* allocate total level table (128kb space) */\r\n    if( !init_tables() )\r\n    {\r\n        num_lock--;\r\n        return -1;\r\n    }\r\n\r\n#ifdef LOG_CYM_FILE\r\n    cymfile = fopen(\"3812_.cym\",\"wb\");\r\n    if (cymfile)\r\n        timer_pulse ( TIME_IN_HZ(110), 0, cymfile_callback); /*110 Hz pulse timer*/\r\n    else\r\n        logerror(\"Could not create file 3812_.cym\\n\");\r\n#endif\r\n\r\n    return 0;\r\n}\r\n\r\nstatic void OPL_UnLockTable(void)\r\n{\r\n    if(num_lock) num_lock--;\r\n    if(num_lock) return;\r\n\r\n    /* last time */\r\n\r\n    cur_chip = NULL;\r\n    OPLCloseTable();\r\n\r\n#ifdef LOG_CYM_FILE\r\n    fclose (cymfile);\r\n    cymfile = NULL;\r\n#endif\r\n\r\n}\r\n\r\nstatic void OPLResetChip(FM_OPL *OPL)\r\n{\r\n    int c,s;\r\n    int i;\r\n\r\n    OPL->eg_timer = 0;\r\n    OPL->eg_cnt   = 0;\r\n\r\n    OPL->noise_rng = 1; /* noise shift register */\r\n    OPL->mode   = 0;    /* normal mode */\r\n    OPL_STATUS_RESET(OPL,0x7f);\r\n\r\n    /* reset with register write */\r\n    OPLWriteReg(OPL,0x01,0); /* wavesel disable */\r\n    OPLWriteReg(OPL,0x02,0); /* Timer1 */\r\n    OPLWriteReg(OPL,0x03,0); /* Timer2 */\r\n    OPLWriteReg(OPL,0x04,0); /* IRQ mask clear */\r\n    for(i = 0xff ; i >= 0x20 ; i-- ) OPLWriteReg(OPL,i,0);\r\n\r\n    /* reset operator parameters */\r\n    for( c = 0 ; c < 9 ; c++ )\r\n    {\r\n        OPL_CH *CH = &OPL->P_CH[c];\r\n        for(s = 0 ; s < 2 ; s++ )\r\n        {\r\n            /* wave table */\r\n            CH->SLOT[s].wavetable = 0;\r\n            CH->SLOT[s].state     = EG_OFF;\r\n            CH->SLOT[s].volume    = MAX_ATT_INDEX;\r\n        }\r\n    }\r\n#if BUILD_Y8950\r\n    if(OPL->type&OPL_TYPE_ADPCM)\r\n    {\r\n        YM_DELTAT *DELTAT = OPL->deltat;\r\n\r\n        DELTAT->freqbase = OPL->freqbase;\r\n        DELTAT->output_pointer = &output_deltat[0];\r\n        DELTAT->portshift = 5;\r\n        DELTAT->output_range = 1<<23;\r\n        YM_DELTAT_ADPCM_Reset(DELTAT,0);\r\n    }\r\n#endif\r\n}\r\n\r\n/* Create one of virtual YM3812/YM3526/Y8950 */\r\n/* 'clock' is chip clock in Hz  */\r\n/* 'rate'  is sampling rate  */\r\nstatic FM_OPL *OPLCreate(int type, int clock, int rate)\r\n{\r\n    char *ptr;\r\n    FM_OPL *OPL;\r\n    int state_size;\r\n\r\n    if (OPL_LockTable() ==-1) return NULL;\r\n\r\n    /* calculate OPL state size */\r\n    state_size  = sizeof(FM_OPL);\r\n\r\n#if BUILD_Y8950\r\n    if (type&OPL_TYPE_ADPCM) state_size+= sizeof(YM_DELTAT);\r\n#endif\r\n\r\n    /* allocate memory block */\r\n    ptr = (char *) malloc(state_size);\r\n\r\n    if (ptr==NULL)\r\n        return NULL;\r\n\r\n    /* clear */\r\n    memset(ptr,0,state_size);\r\n\r\n    OPL  = (FM_OPL *)(void *)ptr;   // ptr comes from malloc, so it is correctly aligned\r\n\r\n    ptr += sizeof(FM_OPL);\r\n\r\n#if BUILD_Y8950\r\n    if (type&OPL_TYPE_ADPCM)\r\n    {\r\n        OPL->deltat = (YM_DELTAT *)ptr;\r\n    }\r\n    ptr += sizeof(YM_DELTAT);\r\n#endif\r\n\r\n    OPL->type  = type;\r\n    OPL->clock = clock;\r\n    OPL->rate  = rate;\r\n\r\n    /* init global tables */\r\n    OPL_initalize(OPL);\r\n\r\n    return OPL;\r\n}\r\n\r\n/* Destroy one of virtual YM3812 */\r\nstatic void OPLDestroy(FM_OPL *OPL)\r\n{\r\n    OPL_UnLockTable();\r\n    free(OPL);\r\n}\r\n\r\n/* Optional handlers */\r\n\r\nstatic void OPLSetTimerHandler(FM_OPL *OPL,OPL_TIMERHANDLER TimerHandler,int channelOffset)\r\n{\r\n    OPL->TimerHandler   = TimerHandler;\r\n    OPL->TimerParam = channelOffset;\r\n}\r\nstatic void OPLSetIRQHandler(FM_OPL *OPL,OPL_IRQHANDLER IRQHandler,int param)\r\n{\r\n    OPL->IRQHandler     = IRQHandler;\r\n    OPL->IRQParam = param;\r\n}\r\nstatic void OPLSetUpdateHandler(FM_OPL *OPL,OPL_UPDATEHANDLER UpdateHandler,int param)\r\n{\r\n    OPL->UpdateHandler = UpdateHandler;\r\n    OPL->UpdateParam = param;\r\n}\r\n\r\nstatic int OPLWrite(FM_OPL *OPL,int a,int v)\r\n{\r\n    if( !(a&1) )\r\n    {   /* address port */\r\n        OPL->address = v & 0xff;\r\n    }\r\n    else\r\n    {   /* data port */\r\n        if(OPL->UpdateHandler) OPL->UpdateHandler(OPL->UpdateParam,0);\r\n        OPLWriteReg(OPL,OPL->address,v);\r\n    }\r\n    return OPL->status>>7;\r\n}\r\n\r\nstatic unsigned char OPLRead(FM_OPL *OPL,int a)\r\n{\r\n    if( !(a&1) )\r\n    {\r\n        /* status port */\r\n\r\n        #if BUILD_Y8950\r\n\r\n        if(OPL->type&OPL_TYPE_ADPCM)    /* Y8950 */\r\n        {\r\n            return (OPL->status & (OPL->statusmask|0x80)) | (OPL->deltat->PCM_BSY&1);\r\n        }\r\n\r\n        #endif\r\n\r\n        /* OPL and OPL2 */\r\n        return OPL->status & (OPL->statusmask|0x80);\r\n    }\r\n\r\n#if BUILD_Y8950\r\n    /* data port */\r\n    switch(OPL->address)\r\n    {\r\n    case 0x05: /* KeyBoard IN */\r\n        if(OPL->type&OPL_TYPE_KEYBOARD)\r\n        {\r\n            if(OPL->keyboardhandler_r)\r\n                return OPL->keyboardhandler_r(OPL->keyboard_param);\r\n            else\r\n                logerror(\"Y8950: read unmapped KEYBOARD port\\n\");\r\n        }\r\n        return 0;\r\n\r\n    case 0x0f: /* ADPCM-DATA  */\r\n        if(OPL->type&OPL_TYPE_ADPCM)\r\n        {\r\n            UINT8 val;\r\n\r\n            val = YM_DELTAT_ADPCM_Read(OPL->deltat);\r\n            /*logerror(\"Y8950: read ADPCM value read=%02x\\n\",val);*/\r\n            return val;\r\n        }\r\n        return 0;\r\n\r\n    case 0x19: /* I/O DATA    */\r\n        if(OPL->type&OPL_TYPE_IO)\r\n        {\r\n            if(OPL->porthandler_r)\r\n                return OPL->porthandler_r(OPL->port_param);\r\n            else\r\n                logerror(\"Y8950:read unmapped I/O port\\n\");\r\n        }\r\n        return 0;\r\n    case 0x1a: /* PCM-DATA    */\r\n        if(OPL->type&OPL_TYPE_ADPCM)\r\n        {\r\n            logerror(\"Y8950 A/D convertion is accessed but not implemented !\\n\");\r\n            return 0x80; /* 2's complement PCM data - result from A/D convertion */\r\n        }\r\n        return 0;\r\n    }\r\n#endif\r\n\r\n    return 0xff;\r\n}\r\n\r\n/* CSM Key Controll */\r\nINLINE void CSMKeyControll(OPL_CH *CH)\r\n{\r\n    FM_KEYON (&CH->SLOT[SLOT1], 4);\r\n    FM_KEYON (&CH->SLOT[SLOT2], 4);\r\n\r\n    /* The key off should happen exactly one sample later - not implemented correctly yet */\r\n\r\n    FM_KEYOFF(&CH->SLOT[SLOT1], ~4);\r\n    FM_KEYOFF(&CH->SLOT[SLOT2], ~4);\r\n}\r\n\r\n\r\nstatic int OPLTimerOver(FM_OPL *OPL,int c)\r\n{\r\n    if( c )\r\n    {   /* Timer B */\r\n        OPL_STATUS_SET(OPL,0x20);\r\n    }\r\n    else\r\n    {   /* Timer A */\r\n        OPL_STATUS_SET(OPL,0x40);\r\n        /* CSM mode key,TL controll */\r\n        if( OPL->mode & 0x80 )\r\n        {   /* CSM mode total level latch and auto key on */\r\n            int ch;\r\n            if(OPL->UpdateHandler) OPL->UpdateHandler(OPL->UpdateParam,0);\r\n            for(ch=0; ch<9; ch++)\r\n                CSMKeyControll( &OPL->P_CH[ch] );\r\n        }\r\n    }\r\n    /* reload timer */\r\n    if (OPL->TimerHandler) (OPL->TimerHandler)(OPL->TimerParam+c,(double)OPL->T[c]*OPL->TimerBase);\r\n    return OPL->status>>7;\r\n}\r\n\r\n\r\n#define MAX_OPL_CHIPS 2\r\n\r\n\r\n#if (BUILD_YM3812)\r\n\r\nstatic FM_OPL *OPL_YM3812[MAX_OPL_CHIPS];   /* array of pointers to the YM3812's */\r\nstatic int YM3812NumChips = 0;              /* number of chips */\r\n\r\nint YM3812Init(int num, int clock, int rate)\r\n{\r\n    int i;\r\n\r\n    if (YM3812NumChips)\r\n        return -1;  /* duplicate init. */\r\n\r\n    YM3812NumChips = num;\r\n\r\n    for (i = 0;i < YM3812NumChips; i++)\r\n    {\r\n        /* emulator create */\r\n        OPL_YM3812[i] = OPLCreate(OPL_TYPE_YM3812,clock,rate);\r\n        if(OPL_YM3812[i] == NULL)\r\n        {\r\n            /* it's really bad - we run out of memeory */\r\n            YM3812NumChips = 0;\r\n            return -1;\r\n        }\r\n        /* reset */\r\n        YM3812ResetChip(i);\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid YM3812Shutdown(void)\r\n{\r\n    int i;\r\n\r\n    for (i = 0;i < YM3812NumChips; i++)\r\n    {\r\n        /* emulator shutdown */\r\n        OPLDestroy(OPL_YM3812[i]);\r\n        OPL_YM3812[i] = NULL;\r\n    }\r\n    YM3812NumChips = 0;\r\n}\r\nvoid YM3812ResetChip(int which)\r\n{\r\n    OPLResetChip(OPL_YM3812[which]);\r\n}\r\n\r\nint YM3812Write(int which, int a, int v)\r\n{\r\n    OPLWriteReg(OPL_YM3812[which], a, v);\r\n    return (OPL_YM3812[which]->status>>7);\r\n}\r\n\r\nunsigned char YM3812Read(int which, int a)\r\n{\r\n    /* YM3812 always returns bit2 and bit1 in HIGH state */\r\n    return OPLRead(OPL_YM3812[which], a) | 0x06 ;\r\n}\r\n\r\nvoid YM3812Mute(int which, int channel, BOOL mute)\r\n{\r\n    OPLMute(OPL_YM3812[which], channel, mute);\r\n}\r\n\r\nint YM3812TimerOver(int which, int c)\r\n{\r\n    return OPLTimerOver(OPL_YM3812[which], c);\r\n}\r\n\r\nvoid YM3812SetTimerHandler(int which, OPL_TIMERHANDLER TimerHandler, int channelOffset)\r\n{\r\n    OPLSetTimerHandler(OPL_YM3812[which], TimerHandler, channelOffset);\r\n}\r\nvoid YM3812SetIRQHandler(int which,OPL_IRQHANDLER IRQHandler,int param)\r\n{\r\n    OPLSetIRQHandler(OPL_YM3812[which], IRQHandler, param);\r\n}\r\nvoid YM3812SetUpdateHandler(int which,OPL_UPDATEHANDLER UpdateHandler,int param)\r\n{\r\n    OPLSetUpdateHandler(OPL_YM3812[which], UpdateHandler, param);\r\n}\r\n\r\n\r\n/*\r\n** Generate samples for one of the YM3812's\r\n**\r\n** 'which' is the virtual YM3812 number\r\n** '*buffer' is the output buffer pointer\r\n** 'length' is the number of samples that should be generated\r\n*/\r\nvoid YM3812UpdateOne(int which, INT16 *buffer, int length)\r\n{\r\n    FM_OPL      *OPL = OPL_YM3812[which];\r\n    UINT8       rhythm = OPL->rhythm&0x20;\r\n    OPLSAMPLE   *buf = buffer;\r\n    int i;\r\n\r\n    if( (void *)OPL != cur_chip ){\r\n        cur_chip = (void *)OPL;\r\n        /* rhythm slots */\r\n        SLOT7_1 = &OPL->P_CH[7].SLOT[SLOT1];\r\n        SLOT7_2 = &OPL->P_CH[7].SLOT[SLOT2];\r\n        SLOT8_1 = &OPL->P_CH[8].SLOT[SLOT1];\r\n        SLOT8_2 = &OPL->P_CH[8].SLOT[SLOT2];\r\n    }\r\n    for( i=0; i < length ; i++ )\r\n    {\r\n        int lt;\r\n\r\n        output[0] = 0;\r\n\r\n        advance_lfo(OPL);\r\n\r\n        /* FM part */\r\n        OPL_CALC_CH(&OPL->P_CH[0]);\r\n        OPL_CALC_CH(&OPL->P_CH[1]);\r\n        OPL_CALC_CH(&OPL->P_CH[2]);\r\n        OPL_CALC_CH(&OPL->P_CH[3]);\r\n        OPL_CALC_CH(&OPL->P_CH[4]);\r\n        OPL_CALC_CH(&OPL->P_CH[5]);\r\n\r\n        if(!rhythm)\r\n        {\r\n            OPL_CALC_CH(&OPL->P_CH[6]);\r\n            OPL_CALC_CH(&OPL->P_CH[7]);\r\n            OPL_CALC_CH(&OPL->P_CH[8]);\r\n        }\r\n        else        /* Rhythm part */\r\n        {\r\n            OPL_CALC_RH(&OPL->P_CH[0], (OPL->noise_rng>>0)&1 );\r\n        }\r\n\r\n        lt = output[0];\r\n\r\n//      lt >>= FINAL_SH;\r\n        lt<<=2;\r\n\r\n        /* limit check */\r\n        lt = limit( lt , MAXOUT, MINOUT );\r\n\r\n        #ifdef SAVE_SAMPLE\r\n        if (which==0)\r\n        {\r\n            SAVE_ALL_CHANNELS\r\n        }\r\n        #endif\r\n\r\n        /* store to sound buffer */\r\n/*      #if (OPL_SAMPLE_BITS == 16)\r\n            lt += 32768;\r\n        #else\r\n            lt += 128;\r\n        #endif*/\r\n\r\n//      buf[i] = lt;\r\n\r\n        buf[i*2] = lt;          // stereo version\r\n        buf[i*2+1] = lt;\r\n\r\n        advance(OPL);\r\n    }\r\n\r\n}\r\n#endif /* BUILD_YM3812 */\r\n\r\n\r\n\r\n#if (BUILD_YM3526)\r\n\r\nstatic FM_OPL *OPL_YM3526[MAX_OPL_CHIPS];   /* array of pointers to the YM3526's */\r\nstatic int YM3526NumChips = 0;              /* number of chips */\r\n\r\nint YM3526Init(int num, int clock, int rate)\r\n{\r\n    int i;\r\n\r\n    if (YM3526NumChips)\r\n        return -1;  /* duplicate init. */\r\n\r\n    YM3526NumChips = num;\r\n\r\n    for (i = 0;i < YM3526NumChips; i++)\r\n    {\r\n        /* emulator create */\r\n        OPL_YM3526[i] = OPLCreate(OPL_TYPE_YM3526,clock,rate);\r\n        if(OPL_YM3526[i] == NULL)\r\n        {\r\n            /* it's really bad - we run out of memeory */\r\n            YM3526NumChips = 0;\r\n            return -1;\r\n        }\r\n        /* reset */\r\n        YM3526ResetChip(i);\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid YM3526Shutdown(void)\r\n{\r\n    int i;\r\n\r\n    for (i = 0;i < YM3526NumChips; i++)\r\n    {\r\n        /* emulator shutdown */\r\n        OPLDestroy(OPL_YM3526[i]);\r\n        OPL_YM3526[i] = NULL;\r\n    }\r\n    YM3526NumChips = 0;\r\n}\r\nvoid YM3526ResetChip(int which)\r\n{\r\n    OPLResetChip(OPL_YM3526[which]);\r\n}\r\n\r\nint YM3526Write(int which, int a, int v)\r\n{\r\n    return OPLWrite(OPL_YM3526[which], a, v);\r\n}\r\n\r\nunsigned char YM3526Read(int which, int a)\r\n{\r\n    /* YM3526 always returns bit2 and bit1 in HIGH state */\r\n    return OPLRead(OPL_YM3526[which], a) | 0x06 ;\r\n}\r\nint YM3526TimerOver(int which, int c)\r\n{\r\n    return OPLTimerOver(OPL_YM3526[which], c);\r\n}\r\n\r\nvoid YM3526SetTimerHandler(int which, OPL_TIMERHANDLER TimerHandler, int channelOffset)\r\n{\r\n    OPLSetTimerHandler(OPL_YM3526[which], TimerHandler, channelOffset);\r\n}\r\nvoid YM3526SetIRQHandler(int which,OPL_IRQHANDLER IRQHandler,int param)\r\n{\r\n    OPLSetIRQHandler(OPL_YM3526[which], IRQHandler, param);\r\n}\r\nvoid YM3526SetUpdateHandler(int which,OPL_UPDATEHANDLER UpdateHandler,int param)\r\n{\r\n    OPLSetUpdateHandler(OPL_YM3526[which], UpdateHandler, param);\r\n}\r\n\r\n\r\n/*\r\n** Generate samples for one of the YM3526's\r\n**\r\n** 'which' is the virtual YM3526 number\r\n** '*buffer' is the output buffer pointer\r\n** 'length' is the number of samples that should be generated\r\n*/\r\nvoid YM3526UpdateOne(int which, INT16 *buffer, int length)\r\n{\r\n    FM_OPL      *OPL = OPL_YM3526[which];\r\n    UINT8       rhythm = OPL->rhythm&0x20;\r\n    OPLSAMPLE   *buf = buffer;\r\n    int i;\r\n\r\n    if( (void *)OPL != cur_chip ){\r\n        cur_chip = (void *)OPL;\r\n        /* rhythm slots */\r\n        SLOT7_1 = &OPL->P_CH[7].SLOT[SLOT1];\r\n        SLOT7_2 = &OPL->P_CH[7].SLOT[SLOT2];\r\n        SLOT8_1 = &OPL->P_CH[8].SLOT[SLOT1];\r\n        SLOT8_2 = &OPL->P_CH[8].SLOT[SLOT2];\r\n    }\r\n    for( i=0; i < length ; i++ )\r\n    {\r\n        int lt;\r\n\r\n        output[0] = 0;\r\n\r\n        advance_lfo(OPL);\r\n\r\n        /* FM part */\r\n        OPL_CALC_CH(&OPL->P_CH[0]);\r\n        OPL_CALC_CH(&OPL->P_CH[1]);\r\n        OPL_CALC_CH(&OPL->P_CH[2]);\r\n        OPL_CALC_CH(&OPL->P_CH[3]);\r\n        OPL_CALC_CH(&OPL->P_CH[4]);\r\n        OPL_CALC_CH(&OPL->P_CH[5]);\r\n\r\n        if(!rhythm)\r\n        {\r\n            OPL_CALC_CH(&OPL->P_CH[6]);\r\n            OPL_CALC_CH(&OPL->P_CH[7]);\r\n            OPL_CALC_CH(&OPL->P_CH[8]);\r\n        }\r\n        else        /* Rhythm part */\r\n        {\r\n            OPL_CALC_RH(&OPL->P_CH[0], (OPL->noise_rng>>0)&1 );\r\n        }\r\n\r\n        lt = output[0];\r\n\r\n        lt >>= FINAL_SH;\r\n\r\n        /* limit check */\r\n        lt = limit( lt , MAXOUT, MINOUT );\r\n\r\n        #ifdef SAVE_SAMPLE\r\n        if (which==0)\r\n        {\r\n            SAVE_ALL_CHANNELS\r\n        }\r\n        #endif\r\n\r\n        /* store to sound buffer */\r\n        buf[i] = lt;\r\n\r\n        advance(OPL);\r\n    }\r\n\r\n}\r\n#endif /* BUILD_YM3526 */\r\n\r\n\r\n\r\n\r\n#if BUILD_Y8950\r\n\r\nstatic FM_OPL *OPL_Y8950[MAX_OPL_CHIPS];    /* array of pointers to the Y8950's */\r\nstatic int Y8950NumChips = 0;               /* number of chips */\r\n\r\nstatic void Y8950_deltat_status_set(UINT8 which, UINT8 changebits)\r\n{\r\n    OPL_STATUS_SET(OPL_Y8950[which], changebits);\r\n}\r\nstatic void Y8950_deltat_status_reset(UINT8 which, UINT8 changebits)\r\n{\r\n    OPL_STATUS_RESET(OPL_Y8950[which], changebits);\r\n}\r\n\r\nint Y8950Init(int num, int clock, int rate)\r\n{\r\n    int i;\r\n\r\n    if (Y8950NumChips)\r\n        return -1;  /* duplicate init. */\r\n\r\n    Y8950NumChips = num;\r\n\r\n    for (i = 0;i < Y8950NumChips; i++)\r\n    {\r\n        /* emulator create */\r\n        OPL_Y8950[i] = OPLCreate(OPL_TYPE_Y8950,clock,rate);\r\n        if(OPL_Y8950[i] == NULL)\r\n        {\r\n            /* it's really bad - we run out of memeory */\r\n            Y8950NumChips = 0;\r\n            return -1;\r\n        }\r\n        OPL_Y8950[i]->deltat->status_set_handler = Y8950_deltat_status_set;\r\n        OPL_Y8950[i]->deltat->status_reset_handler = Y8950_deltat_status_reset;\r\n        OPL_Y8950[i]->deltat->status_change_which_chip = i;\r\n        OPL_Y8950[i]->deltat->status_change_EOS_bit = 0x10;     /* status flag: set bit4 on End Of Sample */\r\n        OPL_Y8950[i]->deltat->status_change_BRDY_bit = 0x08;    /* status flag: set bit3 on BRDY (End Of: ADPCM analysis/synthesis, memory reading/writing) */\r\n\r\n        /*OPL_Y8950[i]->deltat->write_time = 10.0 / clock;*/        /* a single byte write takes 10 cycles of main clock */\r\n        /*OPL_Y8950[i]->deltat->read_time  = 8.0 / clock;*/     /* a single byte read takes 8 cycles of main clock */\r\n        /* reset */\r\n        Y8950ResetChip(i);\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid Y8950Shutdown(void)\r\n{\r\n    int i;\r\n\r\n    for (i = 0;i < Y8950NumChips; i++)\r\n    {\r\n        /* emulator shutdown */\r\n        OPLDestroy(OPL_Y8950[i]);\r\n        OPL_Y8950[i] = NULL;\r\n    }\r\n    Y8950NumChips = 0;\r\n}\r\nvoid Y8950ResetChip(int which)\r\n{\r\n    OPLResetChip(OPL_Y8950[which]);\r\n}\r\n\r\nint Y8950Write(int which, int a, int v)\r\n{\r\n    return OPLWrite(OPL_Y8950[which], a, v);\r\n}\r\n\r\nunsigned char Y8950Read(int which, int a)\r\n{\r\n    return OPLRead(OPL_Y8950[which], a);\r\n}\r\nint Y8950TimerOver(int which, int c)\r\n{\r\n    return OPLTimerOver(OPL_Y8950[which], c);\r\n}\r\n\r\nvoid Y8950SetTimerHandler(int which, OPL_TIMERHANDLER TimerHandler, int channelOffset)\r\n{\r\n    OPLSetTimerHandler(OPL_Y8950[which], TimerHandler, channelOffset);\r\n}\r\nvoid Y8950SetIRQHandler(int which,OPL_IRQHANDLER IRQHandler,int param)\r\n{\r\n    OPLSetIRQHandler(OPL_Y8950[which], IRQHandler, param);\r\n}\r\nvoid Y8950SetUpdateHandler(int which,OPL_UPDATEHANDLER UpdateHandler,int param)\r\n{\r\n    OPLSetUpdateHandler(OPL_Y8950[which], UpdateHandler, param);\r\n}\r\n\r\nvoid Y8950SetDeltaTMemory(int which, void * deltat_mem_ptr, int deltat_mem_size )\r\n{\r\n    FM_OPL      *OPL = OPL_Y8950[which];\r\n    OPL->deltat->memory = (UINT8 *)(deltat_mem_ptr);\r\n    OPL->deltat->memory_size = deltat_mem_size;\r\n}\r\n\r\n/*\r\n** Generate samples for one of the Y8950's\r\n**\r\n** 'which' is the virtual Y8950 number\r\n** '*buffer' is the output buffer pointer\r\n** 'length' is the number of samples that should be generated\r\n*/\r\nvoid Y8950UpdateOne(int which, INT16 *buffer, int length)\r\n{\r\n    int i;\r\n    FM_OPL      *OPL = OPL_Y8950[which];\r\n    UINT8       rhythm  = OPL->rhythm&0x20;\r\n    YM_DELTAT   *DELTAT = OPL->deltat;\r\n    OPLSAMPLE   *buf    = buffer;\r\n\r\n    if( (void *)OPL != cur_chip ){\r\n        cur_chip = (void *)OPL;\r\n        /* rhythm slots */\r\n        SLOT7_1 = &OPL->P_CH[7].SLOT[SLOT1];\r\n        SLOT7_2 = &OPL->P_CH[7].SLOT[SLOT2];\r\n        SLOT8_1 = &OPL->P_CH[8].SLOT[SLOT1];\r\n        SLOT8_2 = &OPL->P_CH[8].SLOT[SLOT2];\r\n\r\n    }\r\n    for( i=0; i < length ; i++ )\r\n    {\r\n        int lt;\r\n\r\n        output[0] = 0;\r\n        output_deltat[0] = 0;\r\n\r\n        advance_lfo(OPL);\r\n\r\n        /* deltaT ADPCM */\r\n        if( DELTAT->portstate&0x80 )\r\n            YM_DELTAT_ADPCM_CALC(DELTAT);\r\n\r\n        /* FM part */\r\n        OPL_CALC_CH(&OPL->P_CH[0]);\r\n        OPL_CALC_CH(&OPL->P_CH[1]);\r\n        OPL_CALC_CH(&OPL->P_CH[2]);\r\n        OPL_CALC_CH(&OPL->P_CH[3]);\r\n        OPL_CALC_CH(&OPL->P_CH[4]);\r\n        OPL_CALC_CH(&OPL->P_CH[5]);\r\n\r\n        if(!rhythm)\r\n        {\r\n            OPL_CALC_CH(&OPL->P_CH[6]);\r\n            OPL_CALC_CH(&OPL->P_CH[7]);\r\n            OPL_CALC_CH(&OPL->P_CH[8]);\r\n        }\r\n        else        /* Rhythm part */\r\n        {\r\n            OPL_CALC_RH(&OPL->P_CH[0], (OPL->noise_rng>>0)&1 );\r\n        }\r\n\r\n        lt = output[0] + (output_deltat[0]>>11);\r\n\r\n        lt >>= FINAL_SH;\r\n\r\n        /* limit check */\r\n        lt = limit( lt , MAXOUT, MINOUT );\r\n\r\n        #ifdef SAVE_SAMPLE\r\n        if (which==0)\r\n        {\r\n            SAVE_ALL_CHANNELS\r\n        }\r\n        #endif\r\n\r\n        /* store to sound buffer */\r\n        buf[i] = lt;\r\n\r\n        advance(OPL);\r\n    }\r\n\r\n}\r\n\r\nvoid Y8950SetPortHandler(int which,OPL_PORTHANDLER_W PortHandler_w,OPL_PORTHANDLER_R PortHandler_r,int param)\r\n{\r\n    FM_OPL      *OPL = OPL_Y8950[which];\r\n    OPL->porthandler_w = PortHandler_w;\r\n    OPL->porthandler_r = PortHandler_r;\r\n    OPL->port_param = param;\r\n}\r\n\r\nvoid Y8950SetKeyboardHandler(int which,OPL_PORTHANDLER_W KeyboardHandler_w,OPL_PORTHANDLER_R KeyboardHandler_r,int param)\r\n{\r\n    FM_OPL      *OPL = OPL_Y8950[which];\r\n    OPL->keyboardhandler_w = KeyboardHandler_w;\r\n    OPL->keyboardhandler_r = KeyboardHandler_r;\r\n    OPL->keyboard_param = param;\r\n}\r\n\r\n#endif\r\n","// -*- C++ -*-\n//===---------------------------- math.h ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MATH_H\n#define _LIBCPP_MATH_H\n\n/*\n    math.h synopsis\n\nMacros:\n\n    HUGE_VAL\n    HUGE_VALF               // C99\n    HUGE_VALL               // C99\n    INFINITY                // C99\n    NAN                     // C99\n    FP_INFINITE             // C99\n    FP_NAN                  // C99\n    FP_NORMAL               // C99\n    FP_SUBNORMAL            // C99\n    FP_ZERO                 // C99\n    FP_FAST_FMA             // C99\n    FP_FAST_FMAF            // C99\n    FP_FAST_FMAL            // C99\n    FP_ILOGB0               // C99\n    FP_ILOGBNAN             // C99\n    MATH_ERRNO              // C99\n    MATH_ERREXCEPT          // C99\n    math_errhandling        // C99\n\nTypes:\n\n    float_t                 // C99\n    double_t                // C99\n\n// C90\n\nfloating_point abs(floating_point x);\n\nfloating_point acos (arithmetic x);\nfloat          acosf(float x);\nlong double    acosl(long double x);\n\nfloating_point asin (arithmetic x);\nfloat          asinf(float x);\nlong double    asinl(long double x);\n\nfloating_point atan (arithmetic x);\nfloat          atanf(float x);\nlong double    atanl(long double x);\n\nfloating_point atan2 (arithmetic y, arithmetic x);\nfloat          atan2f(float y, float x);\nlong double    atan2l(long double y, long double x);\n\nfloating_point ceil (arithmetic x);\nfloat          ceilf(float x);\nlong double    ceill(long double x);\n\nfloating_point cos (arithmetic x);\nfloat          cosf(float x);\nlong double    cosl(long double x);\n\nfloating_point cosh (arithmetic x);\nfloat          coshf(float x);\nlong double    coshl(long double x);\n\nfloating_point exp (arithmetic x);\nfloat          expf(float x);\nlong double    expl(long double x);\n\nfloating_point fabs (arithmetic x);\nfloat          fabsf(float x);\nlong double    fabsl(long double x);\n\nfloating_point floor (arithmetic x);\nfloat          floorf(float x);\nlong double    floorl(long double x);\n\nfloating_point fmod (arithmetic x, arithmetic y);\nfloat          fmodf(float x, float y);\nlong double    fmodl(long double x, long double y);\n\nfloating_point frexp (arithmetic value, int* exp);\nfloat          frexpf(float value, int* exp);\nlong double    frexpl(long double value, int* exp);\n\nfloating_point ldexp (arithmetic value, int exp);\nfloat          ldexpf(float value, int exp);\nlong double    ldexpl(long double value, int exp);\n\nfloating_point log (arithmetic x);\nfloat          logf(float x);\nlong double    logl(long double x);\n\nfloating_point log10 (arithmetic x);\nfloat          log10f(float x);\nlong double    log10l(long double x);\n\nfloating_point modf (floating_point value, floating_point* iptr);\nfloat          modff(float value, float* iptr);\nlong double    modfl(long double value, long double* iptr);\n\nfloating_point pow (arithmetic x, arithmetic y);\nfloat          powf(float x, float y);\nlong double    powl(long double x, long double y);\n\nfloating_point sin (arithmetic x);\nfloat          sinf(float x);\nlong double    sinl(long double x);\n\nfloating_point sinh (arithmetic x);\nfloat          sinhf(float x);\nlong double    sinhl(long double x);\n\nfloating_point sqrt (arithmetic x);\nfloat          sqrtf(float x);\nlong double    sqrtl(long double x);\n\nfloating_point tan (arithmetic x);\nfloat          tanf(float x);\nlong double    tanl(long double x);\n\nfloating_point tanh (arithmetic x);\nfloat          tanhf(float x);\nlong double    tanhl(long double x);\n\n//  C99\n\nbool signbit(arithmetic x);\n\nint fpclassify(arithmetic x);\n\nbool isfinite(arithmetic x);\nbool isinf(arithmetic x);\nbool isnan(arithmetic x);\nbool isnormal(arithmetic x);\n\nbool isgreater(arithmetic x, arithmetic y);\nbool isgreaterequal(arithmetic x, arithmetic y);\nbool isless(arithmetic x, arithmetic y);\nbool islessequal(arithmetic x, arithmetic y);\nbool islessgreater(arithmetic x, arithmetic y);\nbool isunordered(arithmetic x, arithmetic y);\n\nfloating_point acosh (arithmetic x);\nfloat          acoshf(float x);\nlong double    acoshl(long double x);\n\nfloating_point asinh (arithmetic x);\nfloat          asinhf(float x);\nlong double    asinhl(long double x);\n\nfloating_point atanh (arithmetic x);\nfloat          atanhf(float x);\nlong double    atanhl(long double x);\n\nfloating_point cbrt (arithmetic x);\nfloat          cbrtf(float x);\nlong double    cbrtl(long double x);\n\nfloating_point copysign (arithmetic x, arithmetic y);\nfloat          copysignf(float x, float y);\nlong double    copysignl(long double x, long double y);\n\nfloating_point erf (arithmetic x);\nfloat          erff(float x);\nlong double    erfl(long double x);\n\nfloating_point erfc (arithmetic x);\nfloat          erfcf(float x);\nlong double    erfcl(long double x);\n\nfloating_point exp2 (arithmetic x);\nfloat          exp2f(float x);\nlong double    exp2l(long double x);\n\nfloating_point expm1 (arithmetic x);\nfloat          expm1f(float x);\nlong double    expm1l(long double x);\n\nfloating_point fdim (arithmetic x, arithmetic y);\nfloat          fdimf(float x, float y);\nlong double    fdiml(long double x, long double y);\n\nfloating_point fma (arithmetic x, arithmetic y, arithmetic z);\nfloat          fmaf(float x, float y, float z);\nlong double    fmal(long double x, long double y, long double z);\n\nfloating_point fmax (arithmetic x, arithmetic y);\nfloat          fmaxf(float x, float y);\nlong double    fmaxl(long double x, long double y);\n\nfloating_point fmin (arithmetic x, arithmetic y);\nfloat          fminf(float x, float y);\nlong double    fminl(long double x, long double y);\n\nfloating_point hypot (arithmetic x, arithmetic y);\nfloat          hypotf(float x, float y);\nlong double    hypotl(long double x, long double y);\n\nint ilogb (arithmetic x);\nint ilogbf(float x);\nint ilogbl(long double x);\n\nfloating_point lgamma (arithmetic x);\nfloat          lgammaf(float x);\nlong double    lgammal(long double x);\n\nlong long llrint (arithmetic x);\nlong long llrintf(float x);\nlong long llrintl(long double x);\n\nlong long llround (arithmetic x);\nlong long llroundf(float x);\nlong long llroundl(long double x);\n\nfloating_point log1p (arithmetic x);\nfloat          log1pf(float x);\nlong double    log1pl(long double x);\n\nfloating_point log2 (arithmetic x);\nfloat          log2f(float x);\nlong double    log2l(long double x);\n\nfloating_point logb (arithmetic x);\nfloat          logbf(float x);\nlong double    logbl(long double x);\n\nlong lrint (arithmetic x);\nlong lrintf(float x);\nlong lrintl(long double x);\n\nlong lround (arithmetic x);\nlong lroundf(float x);\nlong lroundl(long double x);\n\ndouble      nan (const char* str);\nfloat       nanf(const char* str);\nlong double nanl(const char* str);\n\nfloating_point nearbyint (arithmetic x);\nfloat          nearbyintf(float x);\nlong double    nearbyintl(long double x);\n\nfloating_point nextafter (arithmetic x, arithmetic y);\nfloat          nextafterf(float x, float y);\nlong double    nextafterl(long double x, long double y);\n\nfloating_point nexttoward (arithmetic x, long double y);\nfloat          nexttowardf(float x, long double y);\nlong double    nexttowardl(long double x, long double y);\n\nfloating_point remainder (arithmetic x, arithmetic y);\nfloat          remainderf(float x, float y);\nlong double    remainderl(long double x, long double y);\n\nfloating_point remquo (arithmetic x, arithmetic y, int* pquo);\nfloat          remquof(float x, float y, int* pquo);\nlong double    remquol(long double x, long double y, int* pquo);\n\nfloating_point rint (arithmetic x);\nfloat          rintf(float x);\nlong double    rintl(long double x);\n\nfloating_point round (arithmetic x);\nfloat          roundf(float x);\nlong double    roundl(long double x);\n\nfloating_point scalbln (arithmetic x, long ex);\nfloat          scalblnf(float x, long ex);\nlong double    scalblnl(long double x, long ex);\n\nfloating_point scalbn (arithmetic x, int ex);\nfloat          scalbnf(float x, int ex);\nlong double    scalbnl(long double x, int ex);\n\nfloating_point tgamma (arithmetic x);\nfloat          tgammaf(float x);\nlong double    tgammal(long double x);\n\nfloating_point trunc (arithmetic x);\nfloat          truncf(float x);\nlong double    truncl(long double x);\n\n*/\n\n#include <__config>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#include_next <math.h>\n\n#ifdef __cplusplus\n\n// We support including .h headers inside 'extern \"C\"' contexts, so switch\n// back to C++ linkage before including these C++ headers.\nextern \"C++\" {\n\n#include <type_traits>\n#include <limits>\n\n// signbit\n\n#ifdef signbit\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_signbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return signbit(__lcpp_x);\n}\n\n#undef signbit\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_floating_point<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<\n    std::is_integral<_A1>::value && std::is_signed<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{ return __lcpp_x < 0; }\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<\n    std::is_integral<_A1>::value && !std::is_signed<_A1>::value, bool>::type\nsignbit(_A1) _NOEXCEPT\n{ return false; }\n\n#elif defined(_LIBCPP_MSVCRT)\n\ntemplate <typename _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_floating_point<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{\n  return ::signbit(static_cast<typename std::__promote<_A1>::type>(__lcpp_x));\n}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<\n    std::is_integral<_A1>::value && std::is_signed<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{ return __lcpp_x < 0; }\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<\n    std::is_integral<_A1>::value && !std::is_signed<_A1>::value, bool>::type\nsignbit(_A1) _NOEXCEPT\n{ return false; }\n\n#endif  // signbit\n\n// fpclassify\n\n#ifdef fpclassify\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nint\n__libcpp_fpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return fpclassify(__lcpp_x);\n}\n\n#undef fpclassify\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_floating_point<_A1>::value, int>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, int>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{ return __lcpp_x == 0 ? FP_ZERO : FP_NORMAL; }\n\n#elif defined(_LIBCPP_MSVCRT)\n\ntemplate <typename _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_floating_point<_A1>::value, bool>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n  return ::fpclassify(static_cast<typename std::__promote<_A1>::type>(__lcpp_x));\n}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, int>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{ return __lcpp_x == 0 ? FP_ZERO : FP_NORMAL; }\n\n#endif  // fpclassify\n\n// isfinite\n\n#ifdef isfinite\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isfinite(__lcpp_x);\n}\n\n#undef isfinite\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<\n    std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity,\n    bool>::type\nisfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<\n    std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity,\n    bool>::type\nisfinite(_A1) _NOEXCEPT\n{ return true; }\n\n#endif  // isfinite\n\n// isinf\n\n#ifdef isinf\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isinf(__lcpp_x);\n}\n\n#undef isinf\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<\n    std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity,\n    bool>::type\nisinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<\n    std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity,\n    bool>::type\nisinf(_A1) _NOEXCEPT\n{ return false; }\n\n#endif  // isinf\n\n// isnan\n\n#ifdef isnan\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnan(__lcpp_x);\n}\n\n#undef isnan\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_floating_point<_A1>::value, bool>::type\nisnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, bool>::type\nisnan(_A1) _NOEXCEPT\n{ return false; }\n\n#endif  // isnan\n\n// isnormal\n\n#ifdef isnormal\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnormal(__lcpp_x);\n}\n\n#undef isnormal\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_floating_point<_A1>::value, bool>::type\nisnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, bool>::type\nisnormal(_A1 __lcpp_x) _NOEXCEPT\n{ return __lcpp_x != 0; }\n\n#endif  // isnormal\n\n// isgreater\n\n#ifdef isgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreater\n\n// isgreaterequal\n\n#ifdef isgreaterequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreaterequal(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreaterequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreaterequal\n\n// isless\n\n#ifdef isless\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isless(__lcpp_x, __lcpp_y);\n}\n\n#undef isless\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isless\n\n// islessequal\n\n#ifdef islessequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessequal(__lcpp_x, __lcpp_y);\n}\n\n#undef islessequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessequal\n\n// islessgreater\n\n#ifdef islessgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef islessgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessgreater\n\n// isunordered\n\n#ifdef isunordered\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isunordered(__lcpp_x, __lcpp_y);\n}\n\n#undef isunordered\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isunordered\n\n// abs\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY\nfloat\nabs(float __lcpp_x) _NOEXCEPT {return ::fabsf(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\ndouble\nabs(double __lcpp_x) _NOEXCEPT {return ::fabs(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong double\nabs(long double __lcpp_x) _NOEXCEPT {return ::fabsl(__lcpp_x);}\n#endif // !(defined(_AIX) || defined(__sun__))\n\n// acos\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       acos(float __lcpp_x) _NOEXCEPT       {return ::acosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acos(long double __lcpp_x) _NOEXCEPT {return ::acosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nacos(_A1 __lcpp_x) _NOEXCEPT {return ::acos((double)__lcpp_x);}\n\n// asin\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       asin(float __lcpp_x) _NOEXCEPT       {return ::asinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asin(long double __lcpp_x) _NOEXCEPT {return ::asinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nasin(_A1 __lcpp_x) _NOEXCEPT {return ::asin((double)__lcpp_x);}\n\n// atan\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       atan(float __lcpp_x) _NOEXCEPT       {return ::atanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan(long double __lcpp_x) _NOEXCEPT {return ::atanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\natan(_A1 __lcpp_x) _NOEXCEPT {return ::atan((double)__lcpp_x);}\n\n// atan2\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       atan2(float __lcpp_y, float __lcpp_x) _NOEXCEPT             {return ::atan2f(__lcpp_y, __lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan2(long double __lcpp_y, long double __lcpp_x) _NOEXCEPT {return ::atan2l(__lcpp_y, __lcpp_x);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\natan2(_A1 __lcpp_y, _A2 __lcpp_x) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);\n}\n\n// ceil\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       ceil(float __lcpp_x) _NOEXCEPT       {return ::ceilf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double ceil(long double __lcpp_x) _NOEXCEPT {return ::ceill(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nceil(_A1 __lcpp_x) _NOEXCEPT {return ::ceil((double)__lcpp_x);}\n\n// cos\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       cos(float __lcpp_x) _NOEXCEPT       {return ::cosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cos(long double __lcpp_x) _NOEXCEPT {return ::cosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncos(_A1 __lcpp_x) _NOEXCEPT {return ::cos((double)__lcpp_x);}\n\n// cosh\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       cosh(float __lcpp_x) _NOEXCEPT       {return ::coshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cosh(long double __lcpp_x) _NOEXCEPT {return ::coshl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncosh(_A1 __lcpp_x) _NOEXCEPT {return ::cosh((double)__lcpp_x);}\n\n// exp\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       exp(float __lcpp_x) _NOEXCEPT       {return ::expf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp(long double __lcpp_x) _NOEXCEPT {return ::expl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexp(_A1 __lcpp_x) _NOEXCEPT {return ::exp((double)__lcpp_x);}\n\n// fabs\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       fabs(float __lcpp_x) _NOEXCEPT       {return ::fabsf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double fabs(long double __lcpp_x) _NOEXCEPT {return ::fabsl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfabs(_A1 __lcpp_x) _NOEXCEPT {return ::fabs((double)__lcpp_x);}\n\n// floor\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       floor(float __lcpp_x) _NOEXCEPT       {return ::floorf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double floor(long double __lcpp_x) _NOEXCEPT {return ::floorl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfloor(_A1 __lcpp_x) _NOEXCEPT {return ::floor((double)__lcpp_x);}\n\n// fmod\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       fmod(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::fmodf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmod(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::fmodl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmod(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// frexp\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       frexp(float __lcpp_x, int* __lcpp_e) _NOEXCEPT       {return ::frexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double frexp(long double __lcpp_x, int* __lcpp_e) _NOEXCEPT {return ::frexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nfrexp(_A1 __lcpp_x, int* __lcpp_e) _NOEXCEPT {return ::frexp((double)__lcpp_x, __lcpp_e);}\n\n// ldexp\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       ldexp(float __lcpp_x, int __lcpp_e) _NOEXCEPT       {return ::ldexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double ldexp(long double __lcpp_x, int __lcpp_e) _NOEXCEPT {return ::ldexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nldexp(_A1 __lcpp_x, int __lcpp_e) _NOEXCEPT {return ::ldexp((double)__lcpp_x, __lcpp_e);}\n\n// log\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       log(float __lcpp_x) _NOEXCEPT       {return ::logf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log(long double __lcpp_x) _NOEXCEPT {return ::logl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog(_A1 __lcpp_x) _NOEXCEPT {return ::log((double)__lcpp_x);}\n\n// log10\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       log10(float __lcpp_x) _NOEXCEPT       {return ::log10f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log10(long double __lcpp_x) _NOEXCEPT {return ::log10l(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog10(_A1 __lcpp_x) _NOEXCEPT {return ::log10((double)__lcpp_x);}\n\n// modf\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       modf(float __lcpp_x, float* __lcpp_y) _NOEXCEPT             {return ::modff(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double modf(long double __lcpp_x, long double* __lcpp_y) _NOEXCEPT {return ::modfl(__lcpp_x, __lcpp_y);}\n#endif\n\n// pow\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       pow(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::powf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double pow(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::powl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\npow(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// sin\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sin(float __lcpp_x) _NOEXCEPT       {return ::sinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sin(long double __lcpp_x) _NOEXCEPT {return ::sinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsin(_A1 __lcpp_x) _NOEXCEPT {return ::sin((double)__lcpp_x);}\n\n// sinh\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sinh(float __lcpp_x) _NOEXCEPT       {return ::sinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sinh(long double __lcpp_x) _NOEXCEPT {return ::sinhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsinh(_A1 __lcpp_x) _NOEXCEPT {return ::sinh((double)__lcpp_x);}\n\n// sqrt\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       sqrt(float __lcpp_x) _NOEXCEPT       {return ::sqrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sqrt(long double __lcpp_x) _NOEXCEPT {return ::sqrtl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nsqrt(_A1 __lcpp_x) _NOEXCEPT {return ::sqrt((double)__lcpp_x);}\n\n// tan\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       tan(float __lcpp_x) _NOEXCEPT       {return ::tanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tan(long double __lcpp_x) _NOEXCEPT {return ::tanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntan(_A1 __lcpp_x) _NOEXCEPT {return ::tan((double)__lcpp_x);}\n\n// tanh\n\n#if !(defined(_AIX) || defined(__sun__))\ninline _LIBCPP_INLINE_VISIBILITY float       tanh(float __lcpp_x) _NOEXCEPT       {return ::tanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tanh(long double __lcpp_x) _NOEXCEPT {return ::tanhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntanh(_A1 __lcpp_x) _NOEXCEPT {return ::tanh((double)__lcpp_x);}\n\n// acosh\n\ninline _LIBCPP_INLINE_VISIBILITY float       acosh(float __lcpp_x) _NOEXCEPT       {return ::acoshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acosh(long double __lcpp_x) _NOEXCEPT {return ::acoshl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nacosh(_A1 __lcpp_x) _NOEXCEPT {return ::acosh((double)__lcpp_x);}\n\n// asinh\n\ninline _LIBCPP_INLINE_VISIBILITY float       asinh(float __lcpp_x) _NOEXCEPT       {return ::asinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asinh(long double __lcpp_x) _NOEXCEPT {return ::asinhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nasinh(_A1 __lcpp_x) _NOEXCEPT {return ::asinh((double)__lcpp_x);}\n\n// atanh\n\ninline _LIBCPP_INLINE_VISIBILITY float       atanh(float __lcpp_x) _NOEXCEPT       {return ::atanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atanh(long double __lcpp_x) _NOEXCEPT {return ::atanhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\natanh(_A1 __lcpp_x) _NOEXCEPT {return ::atanh((double)__lcpp_x);}\n\n// cbrt\n\ninline _LIBCPP_INLINE_VISIBILITY float       cbrt(float __lcpp_x) _NOEXCEPT       {return ::cbrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cbrt(long double __lcpp_x) _NOEXCEPT {return ::cbrtl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ncbrt(_A1 __lcpp_x) _NOEXCEPT {return ::cbrt((double)__lcpp_x);}\n\n// copysign\n\ninline _LIBCPP_INLINE_VISIBILITY float copysign(float __lcpp_x,\n                                                float __lcpp_y) _NOEXCEPT {\n  return ::copysignf(__lcpp_x, __lcpp_y);\n}\ninline _LIBCPP_INLINE_VISIBILITY long double\ncopysign(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {\n  return ::copysignl(__lcpp_x, __lcpp_y);\n}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\ncopysign(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// erf\n\ninline _LIBCPP_INLINE_VISIBILITY float       erf(float __lcpp_x) _NOEXCEPT       {return ::erff(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erf(long double __lcpp_x) _NOEXCEPT {return ::erfl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nerf(_A1 __lcpp_x) _NOEXCEPT {return ::erf((double)__lcpp_x);}\n\n// erfc\n\ninline _LIBCPP_INLINE_VISIBILITY float       erfc(float __lcpp_x) _NOEXCEPT       {return ::erfcf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erfc(long double __lcpp_x) _NOEXCEPT {return ::erfcl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nerfc(_A1 __lcpp_x) _NOEXCEPT {return ::erfc((double)__lcpp_x);}\n\n// exp2\n\ninline _LIBCPP_INLINE_VISIBILITY float       exp2(float __lcpp_x) _NOEXCEPT       {return ::exp2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp2(long double __lcpp_x) _NOEXCEPT {return ::exp2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexp2(_A1 __lcpp_x) _NOEXCEPT {return ::exp2((double)__lcpp_x);}\n\n// expm1\n\ninline _LIBCPP_INLINE_VISIBILITY float       expm1(float __lcpp_x) _NOEXCEPT       {return ::expm1f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double expm1(long double __lcpp_x) _NOEXCEPT {return ::expm1l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nexpm1(_A1 __lcpp_x) _NOEXCEPT {return ::expm1((double)__lcpp_x);}\n\n// fdim\n\ninline _LIBCPP_INLINE_VISIBILITY float       fdim(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::fdimf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fdim(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::fdiml(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfdim(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fma\n\ninline _LIBCPP_INLINE_VISIBILITY float       fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) _NOEXCEPT                   {return ::fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) _NOEXCEPT {return ::fmal(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2, class _A3>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value &&\n    std::is_arithmetic<_A3>::value,\n    std::__promote<_A1, _A2, _A3>\n>::type\nfma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value &&\n                     std::is_same<_A3, __result_type>::value)), \"\");\n    return ::fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);\n}\n\n// fmax\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmax(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::fmaxf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmax(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::fmaxl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmax(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fmin\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmin(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::fminf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmin(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::fminl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nfmin(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// hypot\n\ninline _LIBCPP_INLINE_VISIBILITY float       hypot(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::hypotf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double hypot(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::hypotl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nhypot(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// ilogb\n\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(float __lcpp_x) _NOEXCEPT       {return ::ilogbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(long double __lcpp_x) _NOEXCEPT {return ::ilogbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, int>::type\nilogb(_A1 __lcpp_x) _NOEXCEPT {return ::ilogb((double)__lcpp_x);}\n\n// lgamma\n\ninline _LIBCPP_INLINE_VISIBILITY float       lgamma(float __lcpp_x) _NOEXCEPT       {return ::lgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double lgamma(long double __lcpp_x) _NOEXCEPT {return ::lgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlgamma(_A1 __lcpp_x) _NOEXCEPT {return ::lgamma((double)__lcpp_x);}\n\n// llrint\n\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(float __lcpp_x) _NOEXCEPT       {return ::llrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(long double __lcpp_x) _NOEXCEPT {return ::llrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type\nllrint(_A1 __lcpp_x) _NOEXCEPT {return ::llrint((double)__lcpp_x);}\n\n// llround\n\ninline _LIBCPP_INLINE_VISIBILITY long long llround(float __lcpp_x) _NOEXCEPT       {return ::llroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llround(long double __lcpp_x) _NOEXCEPT {return ::llroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long long>::type\nllround(_A1 __lcpp_x) _NOEXCEPT {return ::llround((double)__lcpp_x);}\n\n// log1p\n\ninline _LIBCPP_INLINE_VISIBILITY float       log1p(float __lcpp_x) _NOEXCEPT       {return ::log1pf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log1p(long double __lcpp_x) _NOEXCEPT {return ::log1pl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog1p(_A1 __lcpp_x) _NOEXCEPT {return ::log1p((double)__lcpp_x);}\n\n// log2\n\ninline _LIBCPP_INLINE_VISIBILITY float       log2(float __lcpp_x) _NOEXCEPT       {return ::log2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log2(long double __lcpp_x) _NOEXCEPT {return ::log2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlog2(_A1 __lcpp_x) _NOEXCEPT {return ::log2((double)__lcpp_x);}\n\n// logb\n\ninline _LIBCPP_INLINE_VISIBILITY float       logb(float __lcpp_x) _NOEXCEPT       {return ::logbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double logb(long double __lcpp_x) _NOEXCEPT {return ::logbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nlogb(_A1 __lcpp_x) _NOEXCEPT {return ::logb((double)__lcpp_x);}\n\n// lrint\n\ninline _LIBCPP_INLINE_VISIBILITY long lrint(float __lcpp_x) _NOEXCEPT       {return ::lrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lrint(long double __lcpp_x) _NOEXCEPT {return ::lrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long>::type\nlrint(_A1 __lcpp_x) _NOEXCEPT {return ::lrint((double)__lcpp_x);}\n\n// lround\n\ninline _LIBCPP_INLINE_VISIBILITY long lround(float __lcpp_x) _NOEXCEPT       {return ::lroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lround(long double __lcpp_x) _NOEXCEPT {return ::lroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, long>::type\nlround(_A1 __lcpp_x) _NOEXCEPT {return ::lround((double)__lcpp_x);}\n\n// nan\n\n// nearbyint\n\ninline _LIBCPP_INLINE_VISIBILITY float       nearbyint(float __lcpp_x) _NOEXCEPT       {return ::nearbyintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double nearbyint(long double __lcpp_x) _NOEXCEPT {return ::nearbyintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nnearbyint(_A1 __lcpp_x) _NOEXCEPT {return ::nearbyint((double)__lcpp_x);}\n\n// nextafter\n\ninline _LIBCPP_INLINE_VISIBILITY float       nextafter(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::nextafterf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nextafter(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::nextafterl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nnextafter(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// nexttoward\n\ninline _LIBCPP_INLINE_VISIBILITY float       nexttoward(float __lcpp_x, long double __lcpp_y) _NOEXCEPT       {return ::nexttowardf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nexttoward(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::nexttowardl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nnexttoward(_A1 __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::nexttoward((double)__lcpp_x, __lcpp_y);}\n\n// remainder\n\ninline _LIBCPP_INLINE_VISIBILITY float       remainder(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return ::remainderf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double remainder(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return ::remainderl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nremainder(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// remquo\n\ninline _LIBCPP_INLINE_VISIBILITY float       remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) _NOEXCEPT             {return ::remquof(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) _NOEXCEPT {return ::remquol(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::__lazy_enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    std::__promote<_A1, _A2>\n>::type\nremquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type __result_type;\n    static_assert((!(std::is_same<_A1, __result_type>::value &&\n                     std::is_same<_A2, __result_type>::value)), \"\");\n    return ::remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);\n}\n\n// rint\n\ninline _LIBCPP_INLINE_VISIBILITY float       rint(float __lcpp_x) _NOEXCEPT       {return ::rintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double rint(long double __lcpp_x) _NOEXCEPT {return ::rintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nrint(_A1 __lcpp_x) _NOEXCEPT {return ::rint((double)__lcpp_x);}\n\n// round\n\ninline _LIBCPP_INLINE_VISIBILITY float       round(float __lcpp_x) _NOEXCEPT       {return ::roundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double round(long double __lcpp_x) _NOEXCEPT {return ::roundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nround(_A1 __lcpp_x) _NOEXCEPT {return ::round((double)__lcpp_x);}\n\n// scalbln\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbln(float __lcpp_x, long __lcpp_y) _NOEXCEPT       {return ::scalblnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbln(long double __lcpp_x, long __lcpp_y) _NOEXCEPT {return ::scalblnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nscalbln(_A1 __lcpp_x, long __lcpp_y) _NOEXCEPT {return ::scalbln((double)__lcpp_x, __lcpp_y);}\n\n// scalbn\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbn(float __lcpp_x, int __lcpp_y) _NOEXCEPT       {return ::scalbnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbn(long double __lcpp_x, int __lcpp_y) _NOEXCEPT {return ::scalbnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\nscalbn(_A1 __lcpp_x, int __lcpp_y) _NOEXCEPT {return ::scalbn((double)__lcpp_x, __lcpp_y);}\n\n// tgamma\n\ninline _LIBCPP_INLINE_VISIBILITY float       tgamma(float __lcpp_x) _NOEXCEPT       {return ::tgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tgamma(long double __lcpp_x) _NOEXCEPT {return ::tgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntgamma(_A1 __lcpp_x) _NOEXCEPT {return ::tgamma((double)__lcpp_x);}\n\n// trunc\n\ninline _LIBCPP_INLINE_VISIBILITY float       trunc(float __lcpp_x) _NOEXCEPT       {return ::truncf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double trunc(long double __lcpp_x) _NOEXCEPT {return ::truncl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_integral<_A1>::value, double>::type\ntrunc(_A1 __lcpp_x) _NOEXCEPT {return ::trunc((double)__lcpp_x);}\n\n} // extern \"C++\"\n\n#endif // __cplusplus\n\n#endif  // _LIBCPP_MATH_H\n","// ID_CA.C\r\n\r\n// this has been customized for WOLF\r\n\r\n/*\r\n=============================================================================\r\n\r\nId Software Caching Manager\r\n---------------------------\r\n\r\nMust be started BEFORE the memory manager, because it needs to get the headers\r\nloaded into the data segment\r\n\r\n=============================================================================\r\n*/\r\n\r\n#include <sys/types.h>\r\n#if defined _WIN32\r\n    #include <io.h>\r\n#else\r\n    #include <sys/uio.h>\r\n    #include <unistd.h>\r\n#endif\r\n\r\n#include \"wl_def.h\"\r\n#pragma hdrstop\r\n\r\n#define THREEBYTEGRSTARTS\r\n\r\n/*\r\n=============================================================================\r\n\r\n                             LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\ntypedef struct\r\n{\r\n    word bit0,bit1;       // 0-255 is a character, > is a pointer to a node\r\n} huffnode;\r\n\r\n\r\ntypedef struct\r\n{\r\n    word RLEWtag;\r\n    int32_t headeroffsets[100];\r\n} mapfiletype;\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                             GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define BUFFERSIZE 0x1000\r\nstatic int32_t bufferseg[BUFFERSIZE/4];\r\n\r\nint     mapon;\r\n\r\nword    *mapsegs[MAPPLANES];\r\nstatic maptype* mapheaderseg[NUMMAPS];\r\nbyte    *audiosegs[NUMSNDCHUNKS];\r\nbyte    *grsegs[NUMCHUNKS];\r\n\r\nword    RLEWtag;\r\n\r\nint     numEpisodesMissing = 0;\r\n\r\n/*\r\n=============================================================================\r\n\r\n                             LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nchar extension[5]; // Need a string, not constant to change cache files\r\nchar graphext[5];\r\nchar audioext[5];\r\nstatic const char gheadname[] = \"vgahead.\";\r\nstatic const char gfilename[] = \"vgagraph.\";\r\nstatic const char gdictname[] = \"vgadict.\";\r\nstatic const char mheadname[] = \"maphead.\";\r\n\r\nstatic const char aheadname[] = \"audiohed.\";\r\nstatic const char afilename[] = \"audiot.\";\r\n\r\nvoid CA_CannotOpen(const char *string);\r\n\r\nstatic int32_t  grstarts[NUMCHUNKS + 1];\r\nstatic int32_t* audiostarts; // array of offsets in audio / audiot\r\n\r\n#ifdef GRHEADERLINKED\r\nhuffnode *grhuffman;\r\n#else\r\nhuffnode grhuffman[255];\r\n#endif\r\n\r\nint    grhandle = -1;               // handle to EGAGRAPH\r\nint    maphandle = -1;              // handle to MAPTEMP / GAMEMAPS\r\nint    audiohandle = -1;            // handle to AUDIOT / AUDIO\r\n\r\nint32_t   chunkcomplen,chunkexplen;\r\n\r\nSDMode oldsoundmode;\r\n\r\n\r\nstatic int32_t GRFILEPOS(const size_t idx)\r\n{\r\n    assert(idx < lengthof(grstarts));\r\n    return grstarts[idx];\r\n}\r\n\r\n/*\r\n=============================================================================\r\n\r\n                            LOW LEVEL ROUTINES\r\n\r\n=============================================================================\r\n*/\r\n\r\n/*\r\n============================\r\n=\r\n= CAL_GetGrChunkLength\r\n=\r\n= Gets the length of an explicit length chunk (not tiles)\r\n= The file pointer is positioned so the compressed data can be read in next.\r\n=\r\n============================\r\n*/\r\n\r\nvoid CAL_GetGrChunkLength (int chunk)\r\n{\r\n    lseek(grhandle,GRFILEPOS(chunk),SEEK_SET);\r\n    read(grhandle,&chunkexplen,sizeof(chunkexplen));\r\n    chunkcomplen = GRFILEPOS(chunk+1)-GRFILEPOS(chunk)-4;\r\n}\r\n\r\n\r\n/*\r\n==========================\r\n=\r\n= CA_WriteFile\r\n=\r\n= Writes a file from a memory buffer\r\n=\r\n==========================\r\n*/\r\n\r\nboolean CA_WriteFile (const char *filename, void *ptr, int32_t length)\r\n{\r\n    const int handle = open(filename, O_CREAT | O_WRONLY | O_BINARY, 0644);\r\n    if (handle == -1)\r\n        return false;\r\n\r\n    if (!write (handle,ptr,length))\r\n    {\r\n        close (handle);\r\n        return false;\r\n    }\r\n    close (handle);\r\n    return true;\r\n}\r\n\r\n\r\n\r\n/*\r\n==========================\r\n=\r\n= CA_LoadFile\r\n=\r\n= Allocate space for and load a file\r\n=\r\n==========================\r\n*/\r\n\r\nboolean CA_LoadFile (const char *filename, memptr *ptr)\r\n{\r\n    int32_t size;\r\n\r\n    const int handle = open(filename, O_RDONLY | O_BINARY);\r\n    if (handle == -1)\r\n        return false;\r\n\r\n    size = lseek(handle, 0, SEEK_END);\r\n    lseek(handle, 0, SEEK_SET);\r\n    *ptr=malloc(size);\r\n    CHECKMALLOCRESULT(*ptr);\r\n    if (!read (handle,*ptr,size))\r\n    {\r\n        close (handle);\r\n        return false;\r\n    }\r\n    close (handle);\r\n    return true;\r\n}\r\n\r\n/*\r\n============================================================================\r\n\r\n                COMPRESSION routines, see JHUFF.C for more\r\n\r\n============================================================================\r\n*/\r\n\r\nstatic void CAL_HuffExpand(byte *source, byte *dest, int32_t length, huffnode *hufftable)\r\n{\r\n    byte *end;\r\n    huffnode *headptr, *huffptr;\r\n\r\n    if(!length || !dest)\r\n    {\r\n        Quit(\"length or dest is null!\");\r\n        return;\r\n    }\r\n\r\n    headptr = hufftable+254;        // head node is always node 254\r\n\r\n    int written = 0;\r\n\r\n    end=dest+length;\r\n\r\n    byte val = *source++;\r\n    byte mask = 1;\r\n    word nodeval;\r\n    huffptr = headptr;\r\n    while(1)\r\n    {\r\n        if(!(val & mask))\r\n            nodeval = huffptr->bit0;\r\n        else\r\n            nodeval = huffptr->bit1;\r\n        if(mask==0x80)\r\n        {\r\n            val = *source++;\r\n            mask = 1;\r\n        }\r\n        else mask <<= 1;\r\n\r\n        if(nodeval<256)\r\n        {\r\n            *dest++ = (byte) nodeval;\r\n            written++;\r\n            huffptr = headptr;\r\n            if(dest>=end) break;\r\n        }\r\n        else\r\n        {\r\n            huffptr = hufftable + (nodeval - 256);\r\n        }\r\n    }\r\n}\r\n\r\n/*\r\n======================\r\n=\r\n= CAL_CarmackExpand\r\n=\r\n= Length is the length of the EXPANDED data\r\n=\r\n======================\r\n*/\r\n\r\n#define NEARTAG 0xa7\r\n#define FARTAG  0xa8\r\n\r\nvoid CAL_CarmackExpand (byte *source, word *dest, int length)\r\n{\r\n    word ch,chhigh,count,offset;\r\n    byte *inptr;\r\n    word *copyptr, *outptr;\r\n\r\n    length/=2;\r\n\r\n    inptr = (byte *) source;\r\n    outptr = dest;\r\n\r\n    while (length>0)\r\n    {\r\n        ch = READWORD(inptr);\r\n        chhigh = ch>>8;\r\n        if (chhigh == NEARTAG)\r\n        {\r\n            count = ch&0xff;\r\n            if (!count)\r\n            {                               // have to insert a word containing the tag byte\r\n                ch |= *inptr++;\r\n                *outptr++ = ch;\r\n                length--;\r\n            }\r\n            else\r\n            {\r\n                offset = *inptr++;\r\n                copyptr = outptr - offset;\r\n                length -= count;\r\n                if(length<0) return;\r\n                while (count--)\r\n                    *outptr++ = *copyptr++;\r\n            }\r\n        }\r\n        else if (chhigh == FARTAG)\r\n        {\r\n            count = ch&0xff;\r\n            if (!count)\r\n            {                               // have to insert a word containing the tag byte\r\n                ch |= *inptr++;\r\n                *outptr++ = ch;\r\n                length --;\r\n            }\r\n            else\r\n            {\r\n                offset = READWORD(inptr);\r\n                copyptr = dest + offset;\r\n                length -= count;\r\n                if(length<0) return;\r\n                while (count--)\r\n                    *outptr++ = *copyptr++;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            *outptr++ = ch;\r\n            length --;\r\n        }\r\n    }\r\n}\r\n\r\n/*\r\n======================\r\n=\r\n= CA_RLEWcompress\r\n=\r\n======================\r\n*/\r\n\r\nint32_t CA_RLEWCompress (word *source, int32_t length, word *dest, word rlewtag)\r\n{\r\n    word value,count;\r\n    unsigned i;\r\n    word *start,*end;\r\n\r\n    start = dest;\r\n\r\n    end = source + (length+1)/2;\r\n\r\n    //\r\n    // compress it\r\n    //\r\n    do\r\n    {\r\n        count = 1;\r\n        value = *source++;\r\n        while (*source == value && source<end)\r\n        {\r\n            count++;\r\n            source++;\r\n        }\r\n        if (count>3 || value == rlewtag)\r\n        {\r\n            //\r\n            // send a tag / count / value string\r\n            //\r\n            *dest++ = rlewtag;\r\n            *dest++ = count;\r\n            *dest++ = value;\r\n        }\r\n        else\r\n        {\r\n            //\r\n            // send word without compressing\r\n            //\r\n            for (i=1;i<=count;i++)\r\n                *dest++ = value;\r\n        }\r\n\r\n    } while (source<end);\r\n\r\n    return (int32_t)(2*(dest-start));\r\n}\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CA_RLEWexpand\r\n= length is EXPANDED length\r\n=\r\n======================\r\n*/\r\n\r\nvoid CA_RLEWexpand (word *source, word *dest, int32_t length, word rlewtag)\r\n{\r\n    word value,count,i;\r\n    word *end=dest+length/2;\r\n\r\n//\r\n// expand it\r\n//\r\n    do\r\n    {\r\n        value = *source++;\r\n        if (value != rlewtag)\r\n            //\r\n            // uncompressed\r\n            //\r\n            *dest++=value;\r\n        else\r\n        {\r\n            //\r\n            // compressed string\r\n            //\r\n            count = *source++;\r\n            value = *source++;\r\n            for (i=1;i<=count;i++)\r\n                *dest++ = value;\r\n        }\r\n    } while (dest<end);\r\n}\r\n\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                         CACHE MANAGER ROUTINES\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CAL_SetupGrFile\r\n=\r\n======================\r\n*/\r\n\r\nvoid CAL_SetupGrFile (void)\r\n{\r\n    char fname[13];\r\n    int handle;\r\n    byte *compseg;\r\n\r\n#ifdef GRHEADERLINKED\r\n\r\n    grhuffman = (huffnode *)&EGAdict;\r\n    grstarts = (int32_t _seg *)FP_SEG(&EGAhead);\r\n\r\n#else\r\n\r\n//\r\n// load ???dict.ext (huffman dictionary for graphics files)\r\n//\r\n\r\n    strcpy(fname,gdictname);\r\n    strcat(fname,graphext);\r\n\r\n    handle = open(fname, O_RDONLY | O_BINARY);\r\n    if (handle == -1)\r\n        CA_CannotOpen(fname);\r\n\r\n    read(handle, grhuffman, sizeof(grhuffman));\r\n    close(handle);\r\n\r\n    // load the data offsets from ???head.ext\r\n    strcpy(fname,gheadname);\r\n    strcat(fname,graphext);\r\n\r\n    handle = open(fname, O_RDONLY | O_BINARY);\r\n    if (handle == -1)\r\n        CA_CannotOpen(fname);\r\n\r\n    long headersize = lseek(handle, 0, SEEK_END);\r\n    lseek(handle, 0, SEEK_SET);\r\n\r\n#ifndef APOGEE_1_0\r\n    int expectedsize = lengthof(grstarts) - numEpisodesMissing;\r\n#else\r\n    int expectedsize = lengthof(grstarts);\r\n#endif\r\n\r\n    if(!param_ignorenumchunks && headersize / 3 != (long) expectedsize)\r\n        Quit(\"Chocolate Wolfenstein 3D was not compiled for these data files:\\n\"\r\n            \"%s contains a wrong number of offsets (%i instead of %i)!\\n\\n\"\r\n            \"Please check whether you are using the right executable!\\n\"\r\n            \"(For mod developers: perhaps you forgot to update NUMCHUNKS?)\",\r\n            fname, headersize / 3, expectedsize);\r\n\r\n    byte data[lengthof(grstarts) * 3];\r\n    read(handle, data, sizeof(data));\r\n    close(handle);\r\n\r\n    const byte* d = data;\r\n    for (int32_t* i = grstarts; i != endof(grstarts); ++i)\r\n    {\r\n        const int32_t val = d[0] | d[1] << 8 | d[2] << 16;\r\n        *i = (val == 0x00FFFFFF ? -1 : val);\r\n        d += 3;\r\n    }\r\n#endif\r\n\r\n//\r\n// Open the graphics file, leaving it open until the game is finished\r\n//\r\n    strcpy(fname,gfilename);\r\n    strcat(fname,graphext);\r\n\r\n    grhandle = open(fname, O_RDONLY | O_BINARY);\r\n    if (grhandle == -1)\r\n        CA_CannotOpen(fname);\r\n\r\n\r\n//\r\n// load the pic and sprite headers into the arrays in the data segment\r\n//\r\n    pictable=(pictabletype *) malloc(NUMPICS*sizeof(pictabletype));\r\n    CHECKMALLOCRESULT(pictable);\r\n    CAL_GetGrChunkLength(STRUCTPIC);                // position file pointer\r\n    compseg=(byte *) malloc(chunkcomplen);\r\n    CHECKMALLOCRESULT(compseg);\r\n    read (grhandle,compseg,chunkcomplen);\r\n    CAL_HuffExpand(compseg, (byte*)pictable, NUMPICS * sizeof(pictabletype), grhuffman);\r\n    free(compseg);\r\n}\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CAL_SetupMapFile\r\n=\r\n======================\r\n*/\r\n\r\nvoid CAL_SetupMapFile (void)\r\n{\r\n    int     i;\r\n    int handle;\r\n    int32_t length,pos;\r\n    char fname[13];\r\n\r\n//\r\n// load maphead.ext (offsets and tileinfo for map file)\r\n//\r\n    strcpy(fname,mheadname);\r\n    strcat(fname,extension);\r\n\r\n    handle = open(fname, O_RDONLY | O_BINARY);\r\n    if (handle == -1)\r\n        CA_CannotOpen(fname);\r\n\r\n    length = NUMMAPS*4+2; // used to be \"filelength(handle);\"\r\n    mapfiletype *tinf=(mapfiletype *) malloc(sizeof(mapfiletype));\r\n    CHECKMALLOCRESULT(tinf);\r\n    read(handle, tinf, length);\r\n    close(handle);\r\n\r\n    RLEWtag=tinf->RLEWtag;\r\n\r\n//\r\n// open the data file\r\n//\r\n#ifdef CARMACIZED\r\n    strcpy(fname, \"gamemaps.\");\r\n    strcat(fname, extension);\r\n\r\n    maphandle = open(fname, O_RDONLY | O_BINARY);\r\n    if (maphandle == -1)\r\n        CA_CannotOpen(fname);\r\n#else\r\n    strcpy(fname,mfilename);\r\n    strcat(fname,extension);\r\n\r\n    maphandle = open(fname, O_RDONLY | O_BINARY);\r\n    if (maphandle == -1)\r\n        CA_CannotOpen(fname);\r\n#endif\r\n\r\n//\r\n// load all map header\r\n//\r\n    for (i=0;i<NUMMAPS;i++)\r\n    {\r\n        pos = tinf->headeroffsets[i];\r\n        if (pos<0)                          // $FFFFFFFF start is a sparse map\r\n            continue;\r\n\r\n        mapheaderseg[i]=(maptype *) malloc(sizeof(maptype));\r\n        CHECKMALLOCRESULT(mapheaderseg[i]);\r\n        lseek(maphandle,pos,SEEK_SET);\r\n        read (maphandle,(memptr)mapheaderseg[i],sizeof(maptype));\r\n    }\r\n\r\n    free(tinf);\r\n\r\n//\r\n// allocate space for 3 64*64 planes\r\n//\r\n    for (i=0;i<MAPPLANES;i++)\r\n    {\r\n        mapsegs[i]=(word *) malloc(maparea*2);\r\n        CHECKMALLOCRESULT(mapsegs[i]);\r\n    }\r\n}\r\n\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CAL_SetupAudioFile\r\n=\r\n======================\r\n*/\r\n\r\nvoid CAL_SetupAudioFile (void)\r\n{\r\n    char fname[13];\r\n\r\n//\r\n// load audiohed.ext (offsets for audio file)\r\n//\r\n    strcpy(fname,aheadname);\r\n    strcat(fname,audioext);\r\n\r\n    void* ptr;\r\n    if (!CA_LoadFile(fname, &ptr))\r\n        CA_CannotOpen(fname);\r\n    audiostarts = (int32_t*)ptr;\r\n\r\n//\r\n// open the data file\r\n//\r\n    strcpy(fname,afilename);\r\n    strcat(fname,audioext);\r\n\r\n    audiohandle = open(fname, O_RDONLY | O_BINARY);\r\n    if (audiohandle == -1)\r\n        CA_CannotOpen(fname);\r\n}\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CA_Startup\r\n=\r\n= Open all files and load in headers\r\n=\r\n======================\r\n*/\r\n\r\nvoid CA_Startup (void)\r\n{\r\n#ifdef PROFILE\r\n    unlink (\"PROFILE.TXT\");\r\n    profilehandle = open(\"PROFILE.TXT\", O_CREAT | O_WRONLY | O_TEXT);\r\n#endif\r\n\r\n    CAL_SetupMapFile ();\r\n    CAL_SetupGrFile ();\r\n    CAL_SetupAudioFile ();\r\n\r\n    mapon = -1;\r\n}\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CA_Shutdown\r\n=\r\n= Closes all files\r\n=\r\n======================\r\n*/\r\n\r\nvoid CA_Shutdown (void)\r\n{\r\n    int i,start;\r\n\r\n    if(maphandle != -1)\r\n        close(maphandle);\r\n    if(grhandle != -1)\r\n        close(grhandle);\r\n    if(audiohandle != -1)\r\n        close(audiohandle);\r\n\r\n    for(i=0; i<NUMCHUNKS; i++)\r\n        UNCACHEGRCHUNK(i);\r\n    free(pictable);\r\n\r\n    switch(oldsoundmode)\r\n    {\r\n        case sdm_Off:\r\n            return;\r\n        case sdm_PC:\r\n            start = STARTPCSOUNDS;\r\n            break;\r\n        case sdm_AdLib:\r\n            start = STARTADLIBSOUNDS;\r\n            break;\r\n    }\r\n\r\n    for(i=0; i<NUMSOUNDS; i++,start++)\r\n        UNCACHEAUDIOCHUNK(start);\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n======================\r\n=\r\n= CA_CacheAudioChunk\r\n=\r\n======================\r\n*/\r\n\r\nint32_t CA_CacheAudioChunk (int chunk)\r\n{\r\n    int32_t pos = audiostarts[chunk];\r\n    int32_t size = audiostarts[chunk+1]-pos;\r\n\r\n    if (audiosegs[chunk])\r\n        return size;                        // already in memory\r\n\r\n    audiosegs[chunk]=(byte *) malloc(size);\r\n    CHECKMALLOCRESULT(audiosegs[chunk]);\r\n\r\n    lseek(audiohandle,pos,SEEK_SET);\r\n    read(audiohandle,audiosegs[chunk],size);\r\n\r\n    return size;\r\n}\r\n\r\nvoid CA_CacheAdlibSoundChunk (int chunk)\r\n{\r\n    int32_t pos = audiostarts[chunk];\r\n    int32_t size = audiostarts[chunk+1]-pos;\r\n\r\n    if (audiosegs[chunk])\r\n        return;                        // already in memory\r\n\r\n    lseek(audiohandle, pos, SEEK_SET);\r\n    read(audiohandle, bufferseg, ORIG_ADLIBSOUND_SIZE - 1);   // without data[1]\r\n\r\n    AdLibSound *sound = (AdLibSound *) malloc(size + sizeof(AdLibSound) - ORIG_ADLIBSOUND_SIZE);\r\n    CHECKMALLOCRESULT(sound);\r\n\r\n    byte *ptr = (byte *) bufferseg;\r\n    sound->common.length = READLONGWORD(ptr);\r\n    sound->common.priority = READWORD(ptr);\r\n    sound->inst.mChar = *ptr++;\r\n    sound->inst.cChar = *ptr++;\r\n    sound->inst.mScale = *ptr++;\r\n    sound->inst.cScale = *ptr++;\r\n    sound->inst.mAttack = *ptr++;\r\n    sound->inst.cAttack = *ptr++;\r\n    sound->inst.mSus = *ptr++;\r\n    sound->inst.cSus = *ptr++;\r\n    sound->inst.mWave = *ptr++;\r\n    sound->inst.cWave = *ptr++;\r\n    sound->inst.nConn = *ptr++;\r\n    sound->inst.voice = *ptr++;\r\n    sound->inst.mode = *ptr++;\r\n    sound->inst.unused[0] = *ptr++;\r\n    sound->inst.unused[1] = *ptr++;\r\n    sound->inst.unused[2] = *ptr++;\r\n    sound->block = *ptr++;\r\n\r\n    read(audiohandle, sound->data, size - ORIG_ADLIBSOUND_SIZE + 1);  // + 1 because of byte data[1]\r\n\r\n    audiosegs[chunk]=(byte *) sound;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n======================\r\n=\r\n= CA_LoadAllSounds\r\n=\r\n= Purges all sounds, then loads all new ones (mode switch)\r\n=\r\n======================\r\n*/\r\n\r\nvoid CA_LoadAllSounds (void)\r\n{\r\n    unsigned start,i;\r\n\r\n    switch (oldsoundmode)\r\n    {\r\n        case sdm_Off:\r\n            goto cachein;\r\n        case sdm_PC:\r\n            start = STARTPCSOUNDS;\r\n            break;\r\n        case sdm_AdLib:\r\n            start = STARTADLIBSOUNDS;\r\n            break;\r\n    }\r\n\r\n    for (i=0;i<NUMSOUNDS;i++,start++)\r\n        UNCACHEAUDIOCHUNK(start);\r\n\r\ncachein:\r\n\r\n    oldsoundmode = SoundMode;\r\n\r\n    switch (SoundMode)\r\n    {\r\n        case sdm_Off:\r\n            start = STARTADLIBSOUNDS;   // needed for priorities...\r\n            break;\r\n        case sdm_PC:\r\n            start = STARTPCSOUNDS;\r\n            break;\r\n        case sdm_AdLib:\r\n            start = STARTADLIBSOUNDS;\r\n            break;\r\n    }\r\n\r\n    if(start == STARTADLIBSOUNDS)\r\n    {\r\n        for (i=0;i<NUMSOUNDS;i++,start++)\r\n            CA_CacheAdlibSoundChunk(start);\r\n    }\r\n    else\r\n    {\r\n        for (i=0;i<NUMSOUNDS;i++,start++)\r\n            CA_CacheAudioChunk(start);\r\n    }\r\n}\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CAL_ExpandGrChunk\r\n=\r\n= Does whatever is needed with a pointer to a compressed chunk\r\n=\r\n======================\r\n*/\r\n\r\nvoid CAL_ExpandGrChunk (int chunk, int32_t *source)\r\n{\r\n    int32_t    expanded;\r\n\r\n    if (chunk >= STARTTILE8 && chunk < STARTEXTERNS)\r\n    {\r\n        //\r\n        // expanded sizes of tile8/16/32 are implicit\r\n        //\r\n\r\n#define BLOCK           64\r\n#define MASKBLOCK       128\r\n\r\n        if (chunk<STARTTILE8M)          // tile 8s are all in one chunk!\r\n            expanded = BLOCK*NUMTILE8;\r\n        else if (chunk<STARTTILE16)\r\n            expanded = MASKBLOCK*NUMTILE8M;\r\n        else if (chunk<STARTTILE16M)    // all other tiles are one/chunk\r\n            expanded = BLOCK*4;\r\n        else if (chunk<STARTTILE32)\r\n            expanded = MASKBLOCK*4;\r\n        else if (chunk<STARTTILE32M)\r\n            expanded = BLOCK*16;\r\n        else\r\n            expanded = MASKBLOCK*16;\r\n    }\r\n    else\r\n    {\r\n        //\r\n        // everything else has an explicit size longword\r\n        //\r\n        expanded = *source++;\r\n    }\r\n\r\n    //\r\n    // allocate final space, decompress it, and free bigbuffer\r\n    // Sprites need to have shifts made and various other junk\r\n    //\r\n    grsegs[chunk]=(byte *) malloc(expanded);\r\n    CHECKMALLOCRESULT(grsegs[chunk]);\r\n    CAL_HuffExpand((byte *) source, grsegs[chunk], expanded, grhuffman);\r\n}\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CA_CacheGrChunk\r\n=\r\n= Makes sure a given chunk is in memory, loadiing it if needed\r\n=\r\n======================\r\n*/\r\n\r\nvoid CA_CacheGrChunk (int chunk)\r\n{\r\n    int32_t pos,compressed;\r\n    int32_t *source;\r\n    int  next;\r\n\r\n    if (grsegs[chunk])\r\n        return;                             // already in memory\r\n\r\n//\r\n// load the chunk into a buffer, either the miscbuffer if it fits, or allocate\r\n// a larger buffer\r\n//\r\n    pos = GRFILEPOS(chunk);\r\n    if (pos<0)                              // $FFFFFFFF start is a sparse tile\r\n        return;\r\n\r\n    next = chunk +1;\r\n    while (GRFILEPOS(next) == -1)           // skip past any sparse tiles\r\n        next++;\r\n\r\n    compressed = GRFILEPOS(next)-pos;\r\n\r\n    lseek(grhandle,pos,SEEK_SET);\r\n\r\n    if (compressed<=BUFFERSIZE)\r\n    {\r\n        read(grhandle,bufferseg,compressed);\r\n        source = bufferseg;\r\n    }\r\n    else\r\n    {\r\n        source = (int32_t *) malloc(compressed);\r\n        CHECKMALLOCRESULT(source);\r\n        read(grhandle,source,compressed);\r\n    }\r\n\r\n    CAL_ExpandGrChunk (chunk,source);\r\n\r\n    if (compressed>BUFFERSIZE)\r\n        free(source);\r\n}\r\n\r\n\r\n\r\n//==========================================================================\r\n\r\n/*\r\n======================\r\n=\r\n= CA_CacheScreen\r\n=\r\n= Decompresses a chunk from disk straight onto the screen\r\n=\r\n======================\r\n*/\r\n\r\nvoid CA_CacheScreen (int chunk)\r\n{\r\n    int32_t    pos,compressed,expanded;\r\n    memptr  bigbufferseg;\r\n    int32_t    *source;\r\n    int             next;\r\n\r\n//\r\n// load the chunk into a buffer\r\n//\r\n    pos = GRFILEPOS(chunk);\r\n    next = chunk +1;\r\n    while (GRFILEPOS(next) == -1)           // skip past any sparse tiles\r\n        next++;\r\n    compressed = GRFILEPOS(next)-pos;\r\n\r\n    lseek(grhandle,pos,SEEK_SET);\r\n\r\n    bigbufferseg=malloc(compressed);\r\n    CHECKMALLOCRESULT(bigbufferseg);\r\n    read(grhandle,bigbufferseg,compressed);\r\n    source = (int32_t *) bigbufferseg;\r\n\r\n    expanded = *source++;\r\n\r\n//\r\n// allocate final space, decompress it, and free bigbuffer\r\n// Sprites need to have shifts made and various other junk\r\n//\r\n    byte *pic = (byte *) malloc(64000);\r\n    CHECKMALLOCRESULT(pic);\r\n    CAL_HuffExpand((byte *) source, pic, expanded, grhuffman);\r\n\r\n    byte *vbuf = LOCK();\r\n    for(int y = 0, scy = 0; y < 200; y++, scy += scaleFactor)\r\n    {\r\n        for(int x = 0, scx = 0; x < 320; x++, scx += scaleFactor)\r\n        {\r\n            byte col = pic[(y * 80 + (x >> 2)) + (x & 3) * 80 * 200];\r\n            for(unsigned i = 0; i < scaleFactor; i++)\r\n                for(unsigned j = 0; j < scaleFactor; j++)\r\n                    vbuf[(scy + i) * curPitch + scx + j] = col;\r\n        }\r\n    }\r\n    UNLOCK();\r\n    free(pic);\r\n    free(bigbufferseg);\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n======================\r\n=\r\n= CA_CacheMap\r\n=\r\n= WOLF: This is specialized for a 64*64 map size\r\n=\r\n======================\r\n*/\r\n\r\nvoid CA_CacheMap (int mapnum)\r\n{\r\n    int32_t   pos,compressed;\r\n    int       plane;\r\n    word     *dest;\r\n    memptr    bigbufferseg;\r\n    unsigned  size;\r\n    word     *source;\r\n#ifdef CARMACIZED\r\n    word     *buffer2seg;\r\n    int32_t   expanded;\r\n#endif\r\n\r\n    mapon = mapnum;\r\n\r\n//\r\n// load the planes into the allready allocated buffers\r\n//\r\n    size = maparea*2;\r\n\r\n    for (plane = 0; plane<MAPPLANES; plane++)\r\n    {\r\n        pos = mapheaderseg[mapnum]->planestart[plane];\r\n        compressed = mapheaderseg[mapnum]->planelength[plane];\r\n\r\n        dest = mapsegs[plane];\r\n\r\n        lseek(maphandle,pos,SEEK_SET);\r\n        if (compressed<=BUFFERSIZE)\r\n            source = (word *) bufferseg;\r\n        else\r\n        {\r\n            bigbufferseg=malloc(compressed);\r\n            CHECKMALLOCRESULT(bigbufferseg);\r\n            source = (word *) bigbufferseg;\r\n        }\r\n\r\n        read(maphandle,source,compressed);\r\n#ifdef CARMACIZED\r\n        //\r\n        // unhuffman, then unRLEW\r\n        // The huffman'd chunk has a two byte expanded length first\r\n        // The resulting RLEW chunk also does, even though it's not really\r\n        // needed\r\n        //\r\n        expanded = *source;\r\n        source++;\r\n        buffer2seg = (word *) malloc(expanded);\r\n        CHECKMALLOCRESULT(buffer2seg);\r\n        CAL_CarmackExpand((byte *) source, buffer2seg,expanded);\r\n        CA_RLEWexpand(buffer2seg+1,dest,size,RLEWtag);\r\n        free(buffer2seg);\r\n\r\n#else\r\n        //\r\n        // unRLEW, skipping expanded length\r\n        //\r\n        CA_RLEWexpand (source+1,dest,size,RLEWtag);\r\n#endif\r\n\r\n        if (compressed>BUFFERSIZE)\r\n            free(bigbufferseg);\r\n    }\r\n}\r\n\r\n//===========================================================================\r\n\r\nvoid CA_CannotOpen(const char *string)\r\n{\r\n    char str[30];\r\n\r\n    strcpy(str,\"Can't open \");\r\n    strcat(str,string);\r\n    strcat(str,\"!\\n\");\r\n    Quit (str);\r\n}\r\n","#ifndef WL_DEF_H\r\n#define WL_DEF_H\r\n\r\n// Defines which version shall be built and configures supported extra features\r\n#include \"version.h\"\r\n\r\n#include <assert.h>\r\n#include <fcntl.h>\r\n#include <math.h>\r\n#include <ctype.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n// Win32\r\n#ifdef _WIN32\r\n#include <wtypes.h>\r\n#include \"SDL.h\"\r\n#include \"SDL_syswm.h\"\r\n#endif\r\n#if !defined(_WIN32)\r\n#   include <stdint.h>\r\n#   include <string.h>\r\n#   include <stdarg.h>\r\n#include <SDL/SDL.h>\r\n\r\n#endif\r\n\r\n\r\n#if !defined O_BINARY\r\n#   define O_BINARY 0\r\n#endif\r\n\r\n#pragma pack(1)\r\n\r\n\r\n#define YESBUTTONNAME \"Y\"\r\n#define NOBUTTONNAME  \"N\"\r\n\r\n#include \"foreign.h\"\r\n\r\n#ifndef SPEAR\r\n    #include \"audiowl6.h\"\r\n    #ifdef UPLOAD\r\n        #include \"gfxv_apo.h\"\r\n    #else\r\n        #ifdef GOODTIMES\r\n            #include \"gfxv_wl6.h\"\r\n        #else\r\n            #include \"gfxv_apo.h\"\r\n        #endif\r\n    #endif\r\n#else\r\n    #include \"audiosod.h\"\r\n    #include \"gfxv_sod.h\"\r\n    #include \"f_spear.h\"\r\n#endif\r\n\r\ntypedef uint8_t byte;\r\ntypedef uint16_t word;\r\ntypedef int32_t fixed;\r\ntypedef uint32_t longword;\r\n// Win32\r\n#ifndef _WIN32\r\ntypedef int8_t boolean;\r\n#endif\r\ntypedef void * memptr;\r\n\r\ntypedef struct\r\n{\r\n    int x,y;\r\n} Point;\r\ntypedef struct\r\n{\r\n    Point ul,lr;\r\n} Rect;\r\n\r\nvoid Quit(const char *errorStr, ...);\r\n\r\n#include \"id_pm.h\"\r\n#include \"id_sd.h\"\r\n#include \"id_in.h\"\r\n#include \"id_vl.h\"\r\n#include \"id_vh.h\"\r\n#include \"id_us.h\"\r\n#include \"id_ca.h\"\r\n\r\n#include \"wl_menu.h\"\r\n\r\n#define MAPSPOT(x,y,plane) (mapsegs[plane][((y)<<mapshift)+(x)])\r\n\r\n#define SIGN(x)         ((x)>0?1:-1)\r\n#define ABS(x)          ((int)(x)>0?(x):-(x))\r\n#define LABS(x)         ((int32_t)(x)>0?(x):-(x))\r\n\r\n#define abs(x) ABS(x)\r\n\r\n/*\r\n=============================================================================\r\n\r\n                            GLOBAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define MAXTICS 10\r\n#define DEMOTICS        4\r\n\r\n#define MAXACTORS       150         // max number of nazis, etc / map\r\n#define MAXSTATS        400         // max number of lamps, bonus, etc\r\n#define MAXDOORS        64          // max number of sliding doors\r\n#define MAXWALLTILES    64          // max number of wall tiles\r\n\r\n//\r\n// tile constants\r\n//\r\n\r\n#define ICONARROWS      90\r\n#define PUSHABLETILE    98\r\n#define EXITTILE        99          // at end of castle\r\n#define AREATILE        107         // first of NUMAREAS floor tiles\r\n#define NUMAREAS        37\r\n#define ELEVATORTILE    21\r\n#define AMBUSHTILE      106\r\n#define ALTELEVATORTILE 107\r\n\r\n#define NUMBERCHARS     9\r\n\r\n\r\n//----------------\r\n\r\n#define EXTRAPOINTS     40000\r\n\r\n#define PLAYERSPEED     3000\r\n#define RUNSPEED        6000\r\n\r\n#define SCREENSEG       0xa000\r\n\r\n#define SCREENBWIDE     80\r\n\r\n#define HEIGHTRATIO     0.50            // also defined in id_mm.c\r\n\r\n#define BORDERCOLOR     3\r\n#define FLASHCOLOR      5\r\n#define FLASHTICS       4\r\n\r\n#ifndef SPEAR\r\n    #define LRpack      8       // # of levels to store in endgame\r\n#else\r\n    #define LRpack      20\r\n#endif\r\n\r\n#define PLAYERSIZE      MINDIST         // player radius\r\n#define MINACTORDIST    0x10000l        // minimum dist from player center\r\n                                        // to any actor center\r\n\r\n#define NUMLATCHPICS    100\r\n\r\n#undef M_PI\r\n#define PI              3.141592657\r\n#define M_PI PI\r\n\r\n#define GLOBAL1         (1l<<16)\r\n#define TILEGLOBAL      GLOBAL1\r\n#define PIXGLOBAL       (GLOBAL1/64)\r\n#define TILESHIFT       16l\r\n#define UNSIGNEDSHIFT   8\r\n\r\n#define ANGLES          360             // must be divisable by 4\r\n#define ANGLEQUAD       (ANGLES/4)\r\n#define FINEANGLES      3600\r\n#define ANG90           (FINEANGLES/4)\r\n#define ANG180          (ANG90*2)\r\n#define ANG270          (ANG90*3)\r\n#define ANG360          (ANG90*4)\r\n#define VANG90          (ANGLES/4)\r\n#define VANG180         (VANG90*2)\r\n#define VANG270         (VANG90*3)\r\n#define VANG360         (VANG90*4)\r\n\r\n#define MINDIST         (0x5800l)\r\n\r\n#define mapshift        6\r\n#define MAPSIZE         (1<<mapshift)\r\n#define maparea         MAPSIZE*MAPSIZE\r\n\r\n#define mapheight       MAPSIZE\r\n#define mapwidth        MAPSIZE\r\n\r\n\r\n\r\n#define TEXTURESHIFT    6\r\n#define TEXTURESIZE     (1<<TEXTURESHIFT)\r\n#define TEXTUREFROMFIXEDSHIFT 4\r\n#define TEXTUREMASK     (TEXTURESIZE*(TEXTURESIZE-1))\r\n\r\n#define SPRITESCALEFACTOR 2\r\n\r\n\r\n\r\n#define NORTH   0\r\n#define EAST    1\r\n#define SOUTH   2\r\n#define WEST    3\r\n\r\n\r\n#define STATUSLINES     40\r\n\r\n#define SCREENSIZE      (SCREENBWIDE*208)\r\n#define PAGE1START      0\r\n#define PAGE2START      (SCREENSIZE)\r\n#define PAGE3START      (SCREENSIZE*2u)\r\n#define FREESTART       (SCREENSIZE*3u)\r\n\r\n\r\n#define PIXRADIUS       512\r\n\r\n#define STARTAMMO       8\r\n\r\n\r\n// object flag values\r\n\r\ntypedef enum\r\n{\r\n    FL_SHOOTABLE        = 0x00000001,\r\n    FL_BONUS            = 0x00000002,\r\n    FL_NEVERMARK        = 0x00000004,\r\n    FL_VISABLE          = 0x00000008,\r\n    FL_ATTACKMODE       = 0x00000010,\r\n    FL_FIRSTATTACK      = 0x00000020,\r\n    FL_AMBUSH           = 0x00000040,\r\n    FL_NONMARK          = 0x00000080,\r\n    FL_FULLBRIGHT       = 0x00000100,\r\n\r\n    // next free bit is   0x00001000\r\n} objflag_t;\r\n\r\n\r\n//\r\n// sprite constants\r\n//\r\n\r\nenum\r\n{\r\n    SPR_DEMO,\r\n#ifndef APOGEE_1_0\r\n    SPR_DEATHCAM,\r\n#endif\r\n//\r\n// static sprites\r\n//\r\n    SPR_STAT_0,SPR_STAT_1,SPR_STAT_2,SPR_STAT_3,\r\n    SPR_STAT_4,SPR_STAT_5,SPR_STAT_6,SPR_STAT_7,\r\n\r\n    SPR_STAT_8,SPR_STAT_9,SPR_STAT_10,SPR_STAT_11,\r\n    SPR_STAT_12,SPR_STAT_13,SPR_STAT_14,SPR_STAT_15,\r\n\r\n    SPR_STAT_16,SPR_STAT_17,SPR_STAT_18,SPR_STAT_19,\r\n    SPR_STAT_20,SPR_STAT_21,SPR_STAT_22,SPR_STAT_23,\r\n\r\n    SPR_STAT_24,SPR_STAT_25,SPR_STAT_26,SPR_STAT_27,\r\n    SPR_STAT_28,SPR_STAT_29,SPR_STAT_30,SPR_STAT_31,\r\n\r\n    SPR_STAT_32,SPR_STAT_33,SPR_STAT_34,SPR_STAT_35,\r\n    SPR_STAT_36,SPR_STAT_37,SPR_STAT_38,SPR_STAT_39,\r\n\r\n    SPR_STAT_40,SPR_STAT_41,SPR_STAT_42,SPR_STAT_43,\r\n    SPR_STAT_44,SPR_STAT_45,SPR_STAT_46,SPR_STAT_47,\r\n\r\n#ifdef SPEAR\r\n    SPR_STAT_48,SPR_STAT_49,SPR_STAT_50,SPR_STAT_51,\r\n#endif\r\n\r\n//\r\n// guard\r\n//\r\n    SPR_GRD_S_1,SPR_GRD_S_2,SPR_GRD_S_3,SPR_GRD_S_4,\r\n    SPR_GRD_S_5,SPR_GRD_S_6,SPR_GRD_S_7,SPR_GRD_S_8,\r\n\r\n    SPR_GRD_W1_1,SPR_GRD_W1_2,SPR_GRD_W1_3,SPR_GRD_W1_4,\r\n    SPR_GRD_W1_5,SPR_GRD_W1_6,SPR_GRD_W1_7,SPR_GRD_W1_8,\r\n\r\n    SPR_GRD_W2_1,SPR_GRD_W2_2,SPR_GRD_W2_3,SPR_GRD_W2_4,\r\n    SPR_GRD_W2_5,SPR_GRD_W2_6,SPR_GRD_W2_7,SPR_GRD_W2_8,\r\n\r\n    SPR_GRD_W3_1,SPR_GRD_W3_2,SPR_GRD_W3_3,SPR_GRD_W3_4,\r\n    SPR_GRD_W3_5,SPR_GRD_W3_6,SPR_GRD_W3_7,SPR_GRD_W3_8,\r\n\r\n    SPR_GRD_W4_1,SPR_GRD_W4_2,SPR_GRD_W4_3,SPR_GRD_W4_4,\r\n    SPR_GRD_W4_5,SPR_GRD_W4_6,SPR_GRD_W4_7,SPR_GRD_W4_8,\r\n\r\n    SPR_GRD_PAIN_1,SPR_GRD_DIE_1,SPR_GRD_DIE_2,SPR_GRD_DIE_3,\r\n    SPR_GRD_PAIN_2,SPR_GRD_DEAD,\r\n\r\n    SPR_GRD_SHOOT1,SPR_GRD_SHOOT2,SPR_GRD_SHOOT3,\r\n\r\n//\r\n// dogs\r\n//\r\n    SPR_DOG_W1_1,SPR_DOG_W1_2,SPR_DOG_W1_3,SPR_DOG_W1_4,\r\n    SPR_DOG_W1_5,SPR_DOG_W1_6,SPR_DOG_W1_7,SPR_DOG_W1_8,\r\n\r\n    SPR_DOG_W2_1,SPR_DOG_W2_2,SPR_DOG_W2_3,SPR_DOG_W2_4,\r\n    SPR_DOG_W2_5,SPR_DOG_W2_6,SPR_DOG_W2_7,SPR_DOG_W2_8,\r\n\r\n    SPR_DOG_W3_1,SPR_DOG_W3_2,SPR_DOG_W3_3,SPR_DOG_W3_4,\r\n    SPR_DOG_W3_5,SPR_DOG_W3_6,SPR_DOG_W3_7,SPR_DOG_W3_8,\r\n\r\n    SPR_DOG_W4_1,SPR_DOG_W4_2,SPR_DOG_W4_3,SPR_DOG_W4_4,\r\n    SPR_DOG_W4_5,SPR_DOG_W4_6,SPR_DOG_W4_7,SPR_DOG_W4_8,\r\n\r\n    SPR_DOG_DIE_1,SPR_DOG_DIE_2,SPR_DOG_DIE_3,SPR_DOG_DEAD,\r\n    SPR_DOG_JUMP1,SPR_DOG_JUMP2,SPR_DOG_JUMP3,\r\n\r\n\r\n\r\n//\r\n// ss\r\n//\r\n    SPR_SS_S_1,SPR_SS_S_2,SPR_SS_S_3,SPR_SS_S_4,\r\n    SPR_SS_S_5,SPR_SS_S_6,SPR_SS_S_7,SPR_SS_S_8,\r\n\r\n    SPR_SS_W1_1,SPR_SS_W1_2,SPR_SS_W1_3,SPR_SS_W1_4,\r\n    SPR_SS_W1_5,SPR_SS_W1_6,SPR_SS_W1_7,SPR_SS_W1_8,\r\n\r\n    SPR_SS_W2_1,SPR_SS_W2_2,SPR_SS_W2_3,SPR_SS_W2_4,\r\n    SPR_SS_W2_5,SPR_SS_W2_6,SPR_SS_W2_7,SPR_SS_W2_8,\r\n\r\n    SPR_SS_W3_1,SPR_SS_W3_2,SPR_SS_W3_3,SPR_SS_W3_4,\r\n    SPR_SS_W3_5,SPR_SS_W3_6,SPR_SS_W3_7,SPR_SS_W3_8,\r\n\r\n    SPR_SS_W4_1,SPR_SS_W4_2,SPR_SS_W4_3,SPR_SS_W4_4,\r\n    SPR_SS_W4_5,SPR_SS_W4_6,SPR_SS_W4_7,SPR_SS_W4_8,\r\n\r\n    SPR_SS_PAIN_1,SPR_SS_DIE_1,SPR_SS_DIE_2,SPR_SS_DIE_3,\r\n    SPR_SS_PAIN_2,SPR_SS_DEAD,\r\n\r\n    SPR_SS_SHOOT1,SPR_SS_SHOOT2,SPR_SS_SHOOT3,\r\n\r\n//\r\n// mutant\r\n//\r\n    SPR_MUT_S_1,SPR_MUT_S_2,SPR_MUT_S_3,SPR_MUT_S_4,\r\n    SPR_MUT_S_5,SPR_MUT_S_6,SPR_MUT_S_7,SPR_MUT_S_8,\r\n\r\n    SPR_MUT_W1_1,SPR_MUT_W1_2,SPR_MUT_W1_3,SPR_MUT_W1_4,\r\n    SPR_MUT_W1_5,SPR_MUT_W1_6,SPR_MUT_W1_7,SPR_MUT_W1_8,\r\n\r\n    SPR_MUT_W2_1,SPR_MUT_W2_2,SPR_MUT_W2_3,SPR_MUT_W2_4,\r\n    SPR_MUT_W2_5,SPR_MUT_W2_6,SPR_MUT_W2_7,SPR_MUT_W2_8,\r\n\r\n    SPR_MUT_W3_1,SPR_MUT_W3_2,SPR_MUT_W3_3,SPR_MUT_W3_4,\r\n    SPR_MUT_W3_5,SPR_MUT_W3_6,SPR_MUT_W3_7,SPR_MUT_W3_8,\r\n\r\n    SPR_MUT_W4_1,SPR_MUT_W4_2,SPR_MUT_W4_3,SPR_MUT_W4_4,\r\n    SPR_MUT_W4_5,SPR_MUT_W4_6,SPR_MUT_W4_7,SPR_MUT_W4_8,\r\n\r\n    SPR_MUT_PAIN_1,SPR_MUT_DIE_1,SPR_MUT_DIE_2,SPR_MUT_DIE_3,\r\n    SPR_MUT_PAIN_2,SPR_MUT_DIE_4,SPR_MUT_DEAD,\r\n\r\n    SPR_MUT_SHOOT1,SPR_MUT_SHOOT2,SPR_MUT_SHOOT3,SPR_MUT_SHOOT4,\r\n\r\n//\r\n// officer\r\n//\r\n    SPR_OFC_S_1,SPR_OFC_S_2,SPR_OFC_S_3,SPR_OFC_S_4,\r\n    SPR_OFC_S_5,SPR_OFC_S_6,SPR_OFC_S_7,SPR_OFC_S_8,\r\n\r\n    SPR_OFC_W1_1,SPR_OFC_W1_2,SPR_OFC_W1_3,SPR_OFC_W1_4,\r\n    SPR_OFC_W1_5,SPR_OFC_W1_6,SPR_OFC_W1_7,SPR_OFC_W1_8,\r\n\r\n    SPR_OFC_W2_1,SPR_OFC_W2_2,SPR_OFC_W2_3,SPR_OFC_W2_4,\r\n    SPR_OFC_W2_5,SPR_OFC_W2_6,SPR_OFC_W2_7,SPR_OFC_W2_8,\r\n\r\n    SPR_OFC_W3_1,SPR_OFC_W3_2,SPR_OFC_W3_3,SPR_OFC_W3_4,\r\n    SPR_OFC_W3_5,SPR_OFC_W3_6,SPR_OFC_W3_7,SPR_OFC_W3_8,\r\n\r\n    SPR_OFC_W4_1,SPR_OFC_W4_2,SPR_OFC_W4_3,SPR_OFC_W4_4,\r\n    SPR_OFC_W4_5,SPR_OFC_W4_6,SPR_OFC_W4_7,SPR_OFC_W4_8,\r\n\r\n    SPR_OFC_PAIN_1,SPR_OFC_DIE_1,SPR_OFC_DIE_2,SPR_OFC_DIE_3,\r\n    SPR_OFC_PAIN_2,SPR_OFC_DIE_4,SPR_OFC_DEAD,\r\n\r\n    SPR_OFC_SHOOT1,SPR_OFC_SHOOT2,SPR_OFC_SHOOT3,\r\n\r\n#ifndef SPEAR\r\n//\r\n// ghosts\r\n//\r\n    SPR_BLINKY_W1,SPR_BLINKY_W2,SPR_PINKY_W1,SPR_PINKY_W2,\r\n    SPR_CLYDE_W1,SPR_CLYDE_W2,SPR_INKY_W1,SPR_INKY_W2,\r\n\r\n//\r\n// hans\r\n//\r\n    SPR_BOSS_W1,SPR_BOSS_W2,SPR_BOSS_W3,SPR_BOSS_W4,\r\n    SPR_BOSS_SHOOT1,SPR_BOSS_SHOOT2,SPR_BOSS_SHOOT3,SPR_BOSS_DEAD,\r\n\r\n    SPR_BOSS_DIE1,SPR_BOSS_DIE2,SPR_BOSS_DIE3,\r\n\r\n//\r\n// schabbs\r\n//\r\n    SPR_SCHABB_W1,SPR_SCHABB_W2,SPR_SCHABB_W3,SPR_SCHABB_W4,\r\n    SPR_SCHABB_SHOOT1,SPR_SCHABB_SHOOT2,\r\n\r\n    SPR_SCHABB_DIE1,SPR_SCHABB_DIE2,SPR_SCHABB_DIE3,SPR_SCHABB_DEAD,\r\n    SPR_HYPO1,SPR_HYPO2,SPR_HYPO3,SPR_HYPO4,\r\n\r\n//\r\n// fake\r\n//\r\n    SPR_FAKE_W1,SPR_FAKE_W2,SPR_FAKE_W3,SPR_FAKE_W4,\r\n    SPR_FAKE_SHOOT,SPR_FIRE1,SPR_FIRE2,\r\n\r\n    SPR_FAKE_DIE1,SPR_FAKE_DIE2,SPR_FAKE_DIE3,SPR_FAKE_DIE4,\r\n    SPR_FAKE_DIE5,SPR_FAKE_DEAD,\r\n\r\n//\r\n// hitler\r\n//\r\n    SPR_MECHA_W1,SPR_MECHA_W2,SPR_MECHA_W3,SPR_MECHA_W4,\r\n    SPR_MECHA_SHOOT1,SPR_MECHA_SHOOT2,SPR_MECHA_SHOOT3,SPR_MECHA_DEAD,\r\n\r\n    SPR_MECHA_DIE1,SPR_MECHA_DIE2,SPR_MECHA_DIE3,\r\n\r\n    SPR_HITLER_W1,SPR_HITLER_W2,SPR_HITLER_W3,SPR_HITLER_W4,\r\n    SPR_HITLER_SHOOT1,SPR_HITLER_SHOOT2,SPR_HITLER_SHOOT3,SPR_HITLER_DEAD,\r\n\r\n    SPR_HITLER_DIE1,SPR_HITLER_DIE2,SPR_HITLER_DIE3,SPR_HITLER_DIE4,\r\n    SPR_HITLER_DIE5,SPR_HITLER_DIE6,SPR_HITLER_DIE7,\r\n\r\n//\r\n// giftmacher\r\n//\r\n    SPR_GIFT_W1,SPR_GIFT_W2,SPR_GIFT_W3,SPR_GIFT_W4,\r\n    SPR_GIFT_SHOOT1,SPR_GIFT_SHOOT2,\r\n\r\n    SPR_GIFT_DIE1,SPR_GIFT_DIE2,SPR_GIFT_DIE3,SPR_GIFT_DEAD,\r\n#endif\r\n//\r\n// Rocket, smoke and small explosion\r\n//\r\n    SPR_ROCKET_1,SPR_ROCKET_2,SPR_ROCKET_3,SPR_ROCKET_4,\r\n    SPR_ROCKET_5,SPR_ROCKET_6,SPR_ROCKET_7,SPR_ROCKET_8,\r\n\r\n    SPR_SMOKE_1,SPR_SMOKE_2,SPR_SMOKE_3,SPR_SMOKE_4,\r\n    SPR_BOOM_1,SPR_BOOM_2,SPR_BOOM_3,\r\n\r\n//\r\n// Angel of Death's DeathSparks(tm)\r\n//\r\n#ifdef SPEAR\r\n    SPR_HROCKET_1,SPR_HROCKET_2,SPR_HROCKET_3,SPR_HROCKET_4,\r\n    SPR_HROCKET_5,SPR_HROCKET_6,SPR_HROCKET_7,SPR_HROCKET_8,\r\n\r\n    SPR_HSMOKE_1,SPR_HSMOKE_2,SPR_HSMOKE_3,SPR_HSMOKE_4,\r\n    SPR_HBOOM_1,SPR_HBOOM_2,SPR_HBOOM_3,\r\n\r\n    SPR_SPARK1,SPR_SPARK2,SPR_SPARK3,SPR_SPARK4,\r\n#endif\r\n\r\n#ifndef SPEAR\r\n//\r\n// gretel\r\n//\r\n    SPR_GRETEL_W1,SPR_GRETEL_W2,SPR_GRETEL_W3,SPR_GRETEL_W4,\r\n    SPR_GRETEL_SHOOT1,SPR_GRETEL_SHOOT2,SPR_GRETEL_SHOOT3,SPR_GRETEL_DEAD,\r\n\r\n    SPR_GRETEL_DIE1,SPR_GRETEL_DIE2,SPR_GRETEL_DIE3,\r\n\r\n//\r\n// fat face\r\n//\r\n    SPR_FAT_W1,SPR_FAT_W2,SPR_FAT_W3,SPR_FAT_W4,\r\n    SPR_FAT_SHOOT1,SPR_FAT_SHOOT2,SPR_FAT_SHOOT3,SPR_FAT_SHOOT4,\r\n\r\n    SPR_FAT_DIE1,SPR_FAT_DIE2,SPR_FAT_DIE3,SPR_FAT_DEAD,\r\n\r\n//\r\n// bj\r\n//\r\n#ifdef APOGEE_1_0\r\n    SPR_BJ_W1=360,\r\n#elif defined(APOGEE_1_1) && defined(UPLOAD)\r\n    SPR_BJ_W1=406,\r\n#else\r\n    SPR_BJ_W1,\r\n#endif\r\n    SPR_BJ_W2,SPR_BJ_W3,SPR_BJ_W4,\r\n    SPR_BJ_JUMP1,SPR_BJ_JUMP2,SPR_BJ_JUMP3,SPR_BJ_JUMP4,\r\n#else\r\n//\r\n// THESE ARE FOR 'SPEAR OF DESTINY'\r\n//\r\n\r\n//\r\n// Trans Grosse\r\n//\r\n    SPR_TRANS_W1,SPR_TRANS_W2,SPR_TRANS_W3,SPR_TRANS_W4,\r\n    SPR_TRANS_SHOOT1,SPR_TRANS_SHOOT2,SPR_TRANS_SHOOT3,SPR_TRANS_DEAD,\r\n\r\n    SPR_TRANS_DIE1,SPR_TRANS_DIE2,SPR_TRANS_DIE3,\r\n\r\n//\r\n// Wilhelm\r\n//\r\n    SPR_WILL_W1,SPR_WILL_W2,SPR_WILL_W3,SPR_WILL_W4,\r\n    SPR_WILL_SHOOT1,SPR_WILL_SHOOT2,SPR_WILL_SHOOT3,SPR_WILL_SHOOT4,\r\n\r\n    SPR_WILL_DIE1,SPR_WILL_DIE2,SPR_WILL_DIE3,SPR_WILL_DEAD,\r\n\r\n//\r\n// UberMutant\r\n//\r\n    SPR_UBER_W1,SPR_UBER_W2,SPR_UBER_W3,SPR_UBER_W4,\r\n    SPR_UBER_SHOOT1,SPR_UBER_SHOOT2,SPR_UBER_SHOOT3,SPR_UBER_SHOOT4,\r\n\r\n    SPR_UBER_DIE1,SPR_UBER_DIE2,SPR_UBER_DIE3,SPR_UBER_DIE4,\r\n    SPR_UBER_DEAD,\r\n\r\n//\r\n// Death Knight\r\n//\r\n    SPR_DEATH_W1,SPR_DEATH_W2,SPR_DEATH_W3,SPR_DEATH_W4,\r\n    SPR_DEATH_SHOOT1,SPR_DEATH_SHOOT2,SPR_DEATH_SHOOT3,SPR_DEATH_SHOOT4,\r\n\r\n    SPR_DEATH_DIE1,SPR_DEATH_DIE2,SPR_DEATH_DIE3,SPR_DEATH_DIE4,\r\n    SPR_DEATH_DIE5,SPR_DEATH_DIE6,SPR_DEATH_DEAD,\r\n\r\n//\r\n// Ghost\r\n//\r\n    SPR_SPECTRE_W1,SPR_SPECTRE_W2,SPR_SPECTRE_W3,SPR_SPECTRE_W4,\r\n    SPR_SPECTRE_F1,SPR_SPECTRE_F2,SPR_SPECTRE_F3,SPR_SPECTRE_F4,\r\n\r\n//\r\n// Angel of Death\r\n//\r\n    SPR_ANGEL_W1,SPR_ANGEL_W2,SPR_ANGEL_W3,SPR_ANGEL_W4,\r\n    SPR_ANGEL_SHOOT1,SPR_ANGEL_SHOOT2,SPR_ANGEL_TIRED1,SPR_ANGEL_TIRED2,\r\n\r\n    SPR_ANGEL_DIE1,SPR_ANGEL_DIE2,SPR_ANGEL_DIE3,SPR_ANGEL_DIE4,\r\n    SPR_ANGEL_DIE5,SPR_ANGEL_DIE6,SPR_ANGEL_DIE7,SPR_ANGEL_DEAD,\r\n\r\n#endif\r\n\r\n//\r\n// player attack frames\r\n//\r\n    SPR_KNIFEREADY,SPR_KNIFEATK1,SPR_KNIFEATK2,SPR_KNIFEATK3,\r\n    SPR_KNIFEATK4,\r\n\r\n    SPR_PISTOLREADY,SPR_PISTOLATK1,SPR_PISTOLATK2,SPR_PISTOLATK3,\r\n    SPR_PISTOLATK4,\r\n\r\n    SPR_MACHINEGUNREADY,SPR_MACHINEGUNATK1,SPR_MACHINEGUNATK2,MACHINEGUNATK3,\r\n    SPR_MACHINEGUNATK4,\r\n\r\n    SPR_CHAINREADY,SPR_CHAINATK1,SPR_CHAINATK2,SPR_CHAINATK3,\r\n    SPR_CHAINATK4,\r\n\r\n};\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                               GLOBAL TYPES\r\n\r\n=============================================================================\r\n*/\r\n\r\ntypedef enum {\r\n    di_north,\r\n    di_east,\r\n    di_south,\r\n    di_west\r\n} controldir_t;\r\n\r\ntypedef enum {\r\n    dr_normal,\r\n    dr_lock1,\r\n    dr_lock2,\r\n    dr_lock3,\r\n    dr_lock4,\r\n    dr_elevator\r\n} door_t;\r\n\r\ntypedef enum {\r\n    ac_badobject = -1,\r\n    ac_no,\r\n    ac_yes,\r\n    ac_allways\r\n} activetype;\r\n\r\ntypedef enum {\r\n    nothing,\r\n    playerobj,\r\n    inertobj,\r\n    guardobj,\r\n    officerobj,\r\n    ssobj,\r\n    dogobj,\r\n    bossobj,\r\n    schabbobj,\r\n    fakeobj,\r\n    mechahitlerobj,\r\n    mutantobj,\r\n    needleobj,\r\n    fireobj,\r\n    bjobj,\r\n    ghostobj,\r\n    realhitlerobj,\r\n    gretelobj,\r\n    giftobj,\r\n    fatobj,\r\n    rocketobj,\r\n\r\n    spectreobj,\r\n    angelobj,\r\n    transobj,\r\n    uberobj,\r\n    willobj,\r\n    deathobj,\r\n    hrocketobj,\r\n    sparkobj\r\n} classtype;\r\n\r\ntypedef enum {\r\n    none,\r\n    block,\r\n    bo_gibs,\r\n    bo_alpo,\r\n    bo_firstaid,\r\n    bo_key1,\r\n    bo_key2,\r\n    bo_key3,\r\n    bo_key4,\r\n    bo_cross,\r\n    bo_chalice,\r\n    bo_bible,\r\n    bo_crown,\r\n    bo_clip,\r\n    bo_clip2,\r\n    bo_machinegun,\r\n    bo_chaingun,\r\n    bo_food,\r\n    bo_fullheal,\r\n    bo_25clip,\r\n    bo_spear\r\n} wl_stat_t;\r\n\r\ntypedef enum {\r\n    east,\r\n    northeast,\r\n    north,\r\n    northwest,\r\n    west,\r\n    southwest,\r\n    south,\r\n    southeast,\r\n    nodir\r\n} dirtype;\r\n\r\n\r\n#define NUMENEMIES  22\r\ntypedef enum {\r\n    en_guard,\r\n    en_officer,\r\n    en_ss,\r\n    en_dog,\r\n    en_boss,\r\n    en_schabbs,\r\n    en_fake,\r\n    en_hitler,\r\n    en_mutant,\r\n    en_blinky,\r\n    en_clyde,\r\n    en_pinky,\r\n    en_inky,\r\n    en_gretel,\r\n    en_gift,\r\n    en_fat,\r\n    en_spectre,\r\n    en_angel,\r\n    en_trans,\r\n    en_uber,\r\n    en_will,\r\n    en_death\r\n} enemy_t;\r\n\r\ntypedef void (* statefunc) (void *);\r\n\r\ntypedef struct statestruct\r\n{\r\n    boolean rotate;\r\n    short   shapenum;           // a shapenum of -1 means get from ob->temp1\r\n    short   tictime;\r\n    void    (*think) (void *),(*action) (void *);\r\n    struct  statestruct *next;\r\n} statetype;\r\n\r\n\r\n//---------------------\r\n//\r\n// trivial actor structure\r\n//\r\n//---------------------\r\n\r\ntypedef struct statstruct\r\n{\r\n    byte      tilex,tiley;\r\n    short     shapenum;           // if shapenum == -1 the obj has been removed\r\n    byte      *visspot;\r\n    uint32_t  flags;\r\n    byte      itemnumber;\r\n} statobj_t;\r\n\r\n\r\n//---------------------\r\n//\r\n// door actor structure\r\n//\r\n//---------------------\r\n\r\ntypedef enum\r\n{\r\n    dr_open,dr_closed,dr_opening,dr_closing\r\n} doortype;\r\n\r\ntypedef struct doorstruct\r\n{\r\n    byte     tilex,tiley;\r\n    boolean  vertical;\r\n    byte     lock;\r\n    doortype action;\r\n    short    ticcount;\r\n} doorobj_t;\r\n\r\n\r\n//--------------------\r\n//\r\n// thinking actor structure\r\n//\r\n//--------------------\r\n\r\ntypedef struct objstruct\r\n{\r\n    activetype  active;\r\n    short       ticcount;\r\n    classtype   obclass;\r\n    statetype   *state;\r\n\r\n    uint32_t    flags;              // FL_SHOOTABLE, etc\r\n\r\n    int32_t     distance;           // if negative, wait for that door to open\r\n    dirtype     dir;\r\n\r\n    fixed       x,y;\r\n    word        tilex,tiley;\r\n    byte        areanumber;\r\n\r\n    short       viewx;\r\n    word        viewheight;\r\n    fixed       transx,transy;      // in global coord\r\n\r\n    short       angle;\r\n    short       hitpoints;\r\n    int32_t     speed;\r\n\r\n    short       temp1,temp2,hidden;\r\n    struct objstruct *next,*prev;\r\n} objtype;\r\n\r\nenum\r\n{\r\n    bt_nobutton=-1,\r\n    bt_attack=0,\r\n    bt_strafe,\r\n    bt_run,\r\n    bt_use,\r\n    bt_readyknife,\r\n    bt_readypistol,\r\n    bt_readymachinegun,\r\n    bt_readychaingun,\r\n    bt_nextweapon,\r\n    bt_prevweapon,\r\n    bt_esc,\r\n    bt_pause,\r\n    bt_strafeleft,\r\n    bt_straferight,\r\n    bt_moveforward,\r\n    bt_movebackward,\r\n    bt_turnleft,\r\n    bt_turnright,\r\n    NUMBUTTONS\r\n};\r\n\r\n\r\n#define NUMWEAPONS      4\r\ntypedef enum\r\n{\r\n    wp_knife,\r\n    wp_pistol,\r\n    wp_machinegun,\r\n    wp_chaingun\r\n} weapontype;\r\n\r\n\r\nenum\r\n{\r\n    gd_baby,\r\n    gd_easy,\r\n    gd_medium,\r\n    gd_hard\r\n};\r\n\r\n//---------------\r\n//\r\n// gamestate structure\r\n//\r\n//---------------\r\n\r\ntypedef struct\r\n{\r\n    short       difficulty;\r\n    short       mapon;\r\n    int32_t     oldscore,score,nextextra;\r\n    short       lives;\r\n    short       health;\r\n    short       ammo;\r\n    short       keys;\r\n    weapontype  bestweapon,weapon,chosenweapon;\r\n\r\n    short       faceframe;\r\n    short       attackframe,attackcount,weaponframe;\r\n\r\n    short       episode,secretcount,treasurecount,killcount,\r\n                secrettotal,treasuretotal,killtotal;\r\n    int32_t     TimeCount;\r\n    int32_t     killx,killy;\r\n    boolean     victoryflag;            // set during victory animations\r\n} gametype;\r\n\r\n\r\ntypedef enum\r\n{\r\n    ex_stillplaying,\r\n    ex_completed,\r\n    ex_died,\r\n    ex_warped,\r\n    ex_resetgame,\r\n    ex_loadedgame,\r\n    ex_victorious,\r\n    ex_abort,\r\n    ex_demodone,\r\n    ex_secretlevel\r\n} exit_t;\r\n\r\n\r\nextern word *mapsegs[MAPPLANES];\r\nextern int mapon;\r\n\r\n/*\r\n=============================================================================\r\n\r\n                             WL_MAIN DEFINITIONS\r\n\r\n=============================================================================\r\n*/\r\n\r\nextern  boolean  loadedgame;\r\nextern  fixed    focallength;\r\nextern  int      viewscreenx, viewscreeny;\r\nextern  int      viewwidth;\r\nextern  int      viewheight;\r\nextern  short    centerx;\r\nextern  int32_t  heightnumerator;\r\nextern  fixed    scale;\r\n\r\nextern  int      dirangle[9];\r\n\r\nextern  int      mouseadjustment;\r\nextern  int      shootdelta;\r\nextern  unsigned screenofs;\r\n\r\nextern  boolean  startgame;\r\nextern  char     str[80];\r\nextern  char     configdir[256];\r\nextern  char     configname[13];\r\n\r\n//\r\n// Command line parameter variables\r\n//\r\nextern  boolean  param_debugmode;\r\nextern  boolean  param_nowait;\r\nextern  int      param_difficulty;\r\nextern  int      param_tedlevel;\r\nextern  int      param_joystickindex;\r\nextern  int      param_joystickhat;\r\nextern  int      param_samplerate;\r\nextern  int      param_audiobuffer;\r\nextern  int      param_mission;\r\nextern  boolean  param_goodtimes;\r\nextern  boolean  param_ignorenumchunks;\r\n\r\n\r\nvoid            NewGame (int difficulty,int episode);\r\nvoid            CalcProjection (int32_t focal);\r\nvoid            NewViewSize (int width);\r\nboolean         SetViewSize (unsigned width, unsigned height);\r\nboolean         LoadTheGame(FILE *file,int x,int y);\r\nboolean         SaveTheGame(FILE *file,int x,int y);\r\nvoid            ShowViewSize (int width);\r\nvoid            ShutdownId (void);\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                         WL_GAME DEFINITIONS\r\n\r\n=============================================================================\r\n*/\r\n\r\nextern  gametype        gamestate;\r\nextern  byte            bordercol;\r\nextern  SDL_Surface     *latchpics[NUMLATCHPICS];\r\nextern  char            demoname[13];\r\n\r\nvoid    SetupGameLevel (void);\r\nvoid    GameLoop (int);\r\nvoid    DrawPlayBorder (void);\r\nvoid    DrawStatusBorder (byte color);\r\nvoid    DrawPlayScreen (void);\r\nvoid    DrawPlayBorderSides (void);\r\nvoid    ShowActStatus();\r\n\r\nvoid    PlayDemo (int demonumber);\r\nvoid    RecordDemo (void);\r\n\r\n\r\n#ifdef SPEAR\r\nextern  int32_t            spearx,speary;\r\nextern  unsigned        spearangle;\r\nextern  boolean         spearflag;\r\n#endif\r\n\r\n\r\n#define ClearMemory SD_StopDigitized\r\n\r\n\r\n// JAB\r\n#define PlaySoundLocTile(s,tx,ty)       PlaySoundLocGlobal(s,(((int32_t)(tx) << TILESHIFT) + (1L << (TILESHIFT - 1))),(((int32_t)ty << TILESHIFT) + (1L << (TILESHIFT - 1))))\r\n#define PlaySoundLocActor(s,ob)         PlaySoundLocGlobal(s,(ob)->x,(ob)->y)\r\nvoid    PlaySoundLocGlobal(word s,fixed gx,fixed gy);\r\nvoid UpdateSoundLoc(void);\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                            WL_PLAY DEFINITIONS\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define BASEMOVE                35\r\n#define RUNMOVE                 70\r\n#define BASETURN                35\r\n#define RUNTURN                 70\r\n\r\n#define JOYSCALE                2\r\n\r\nextern  byte            tilemap[MAPSIZE][MAPSIZE];      // wall values only\r\nextern  byte            spotvis[MAPSIZE][MAPSIZE];\r\nextern  objtype         *actorat[MAPSIZE][MAPSIZE];\r\n\r\nextern  objtype         *player;\r\n\r\nextern  unsigned        tics;\r\nextern  int             viewsize;\r\n\r\nextern  int             lastgamemusicoffset;\r\n\r\n//\r\n// current user input\r\n//\r\nextern  int         controlx,controly;              // range from -100 to 100\r\nextern  boolean     buttonstate[NUMBUTTONS];\r\nextern  objtype     objlist[MAXACTORS];\r\nextern  boolean     buttonheld[NUMBUTTONS];\r\nextern  exit_t      playstate;\r\nextern  boolean     madenoise;\r\nextern  statobj_t   statobjlist[MAXSTATS];\r\nextern  statobj_t   *laststatobj;\r\nextern  objtype     *newobj,*killerobj;\r\nextern  doorobj_t   doorobjlist[MAXDOORS];\r\nextern  doorobj_t   *lastdoorobj;\r\nextern  int         godmode;\r\n\r\nextern  boolean     demorecord,demoplayback;\r\nextern  int8_t      *demoptr, *lastdemoptr;\r\nextern  memptr      demobuffer;\r\n\r\n//\r\n// control info\r\n//\r\nextern  boolean     mouseenabled,joystickenabled;\r\nextern  int         dirscan[4];\r\nextern  int         buttonscan[NUMBUTTONS];\r\nextern  int         buttonmouse[4];\r\nextern  int         buttonjoy[32];\r\n\r\nvoid    InitActorList (void);\r\nvoid    GetNewActor (void);\r\nvoid    PlayLoop (int);\r\n\r\nvoid    CenterWindow(word w,word h);\r\n\r\nvoid    InitRedShifts (void);\r\nvoid    FinishPaletteShifts (void);\r\n\r\nvoid    RemoveObj (objtype *gone);\r\nvoid    PollControls (void);\r\nint     StopMusic(void);\r\nvoid    StartMusic(void);\r\nvoid    ContinueMusic(int offs);\r\nvoid    StartDamageFlash (int damage);\r\nvoid    StartBonusFlash (void);\r\n\r\n#ifdef SPEAR\r\nextern  int32_t     funnyticount;           // FOR FUNNY BJ FACE\r\n#endif\r\n\r\nextern  objtype     *objfreelist;     // *obj,*player,*lastobj,\r\n\r\nextern  boolean     noclip,ammocheat;\r\nextern  int         singlestep, extravbls;\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                WL_INTER\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid IntroScreen (void);\r\nvoid PG13(void);\r\nvoid DrawHighScores(void);\r\nvoid CheckHighScore (int32_t score,word other);\r\nvoid Victory (void);\r\nvoid LevelCompleted (void);\r\nvoid ClearSplitVWB (void);\r\n\r\nvoid PreloadGraphics(void);\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                WL_DEBUG\r\n\r\n=============================================================================\r\n*/\r\n\r\nint DebugKeys (void);\r\n\r\n/*\r\n=============================================================================\r\n\r\n                            WL_DRAW DEFINITIONS\r\n\r\n=============================================================================\r\n*/\r\n\r\n//\r\n// math tables\r\n//\r\nextern  short *pixelangle;\r\nextern  int32_t finetangent[FINEANGLES/4];\r\nextern  fixed sintable[];\r\nextern  fixed *costable;\r\nextern  int *wallheight;\r\nextern  word horizwall[],vertwall[];\r\nextern  int32_t    lasttimecount;\r\nextern  int32_t    frameon;\r\n\r\nextern  unsigned screenloc[3];\r\n\r\nextern  boolean fizzlein, fpscounter;\r\n\r\nextern  fixed   viewx,viewy;                    // the focal point\r\nextern  fixed   viewsin,viewcos;\r\n\r\nvoid    ThreeDRefresh (void);\r\nvoid    CalcTics (void);\r\n\r\ntypedef struct\r\n{\r\n    word leftpix,rightpix;\r\n    word dataofs[64];\r\n// table data after dataofs[rightpix-leftpix+1]\r\n} t_compshape;\r\n\r\n/*\r\n=============================================================================\r\n\r\n                             WL_STATE DEFINITIONS\r\n\r\n=============================================================================\r\n*/\r\n#define TURNTICS        10\r\n#define SPDPATROL       512\r\n#define SPDDOG          1500\r\n\r\n\r\nvoid    InitHitRect (objtype *ob, unsigned radius);\r\nvoid    SpawnNewObj (unsigned tilex, unsigned tiley, statetype *state);\r\nvoid    NewState (objtype *ob, statetype *state);\r\n\r\nboolean TryWalk (objtype *ob);\r\nvoid    SelectChaseDir (objtype *ob);\r\nvoid    SelectDodgeDir (objtype *ob);\r\nvoid    SelectRunDir (objtype *ob);\r\nvoid    MoveObj (objtype *ob, int32_t move);\r\nboolean SightPlayer (objtype *ob);\r\n\r\nvoid    KillActor (objtype *ob);\r\nvoid    DamageActor (objtype *ob, unsigned damage);\r\n\r\nboolean CheckLine (objtype *ob);\r\nboolean CheckSight (objtype *ob);\r\n\r\n/*\r\n=============================================================================\r\n\r\n                             WL_AGENT DEFINITIONS\r\n\r\n=============================================================================\r\n*/\r\n\r\nextern  short    anglefrac;\r\nextern  int      facecount, facetimes;\r\nextern  word     plux,pluy;         // player coordinates scaled to unsigned\r\nextern  int32_t  thrustspeed;\r\nextern  objtype  *LastAttacker;\r\n\r\nvoid    Thrust (int angle, int32_t speed);\r\nvoid    SpawnPlayer (int tilex, int tiley, int dir);\r\nvoid    TakeDamage (int points,objtype *attacker);\r\nvoid    GivePoints (int32_t points);\r\nvoid    GetBonus (statobj_t *check);\r\nvoid    GiveWeapon (int weapon);\r\nvoid    GiveAmmo (int ammo);\r\nvoid    GiveKey (int key);\r\n\r\n//\r\n// player state info\r\n//\r\n\r\nvoid    StatusDrawFace(unsigned picnum);\r\nvoid    DrawFace (void);\r\nvoid    DrawHealth (void);\r\nvoid    HealSelf (int points);\r\nvoid    DrawLevel (void);\r\nvoid    DrawLives (void);\r\nvoid    GiveExtraMan (void);\r\nvoid    DrawScore (void);\r\nvoid    DrawWeapon (void);\r\nvoid    DrawKeys (void);\r\nvoid    DrawAmmo (void);\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                             WL_ACT1 DEFINITIONS\r\n\r\n=============================================================================\r\n*/\r\n\r\nextern  doorobj_t doorobjlist[MAXDOORS];\r\nextern  doorobj_t *lastdoorobj;\r\nextern  short     doornum;\r\n\r\nextern  word      doorposition[MAXDOORS];\r\n\r\nextern  byte      areaconnect[NUMAREAS][NUMAREAS];\r\n\r\nextern  boolean   areabyplayer[NUMAREAS];\r\n\r\nextern word     pwallstate;\r\nextern word     pwallpos;        // amount a pushable wall has been moved (0-63)\r\nextern word     pwallx,pwally;\r\nextern byte     pwalldir,pwalltile;\r\n\r\n\r\nvoid InitDoorList (void);\r\nvoid InitStaticList (void);\r\nvoid SpawnStatic (int tilex, int tiley, int type);\r\nvoid SpawnDoor (int tilex, int tiley, boolean vertical, int lock);\r\nvoid MoveDoors (void);\r\nvoid MovePWalls (void);\r\nvoid OpenDoor (int door);\r\nvoid PlaceItemType (int itemtype, int tilex, int tiley);\r\nvoid PushWall (int checkx, int checky, int dir);\r\nvoid OperateDoor (int door);\r\nvoid InitAreas (void);\r\n\r\n/*\r\n=============================================================================\r\n\r\n                             WL_ACT2 DEFINITIONS\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define s_nakedbody s_static10\r\n\r\nextern  statetype s_grddie1;\r\nextern  statetype s_dogdie1;\r\nextern  statetype s_ofcdie1;\r\nextern  statetype s_mutdie1;\r\nextern  statetype s_ssdie1;\r\nextern  statetype s_bossdie1;\r\nextern  statetype s_schabbdie1;\r\nextern  statetype s_fakedie1;\r\nextern  statetype s_mechadie1;\r\nextern  statetype s_hitlerdie1;\r\nextern  statetype s_greteldie1;\r\nextern  statetype s_giftdie1;\r\nextern  statetype s_fatdie1;\r\n\r\nextern  statetype s_spectredie1;\r\nextern  statetype s_angeldie1;\r\nextern  statetype s_transdie0;\r\nextern  statetype s_uberdie0;\r\nextern  statetype s_willdie1;\r\nextern  statetype s_deathdie1;\r\n\r\n\r\nextern  statetype s_grdchase1;\r\nextern  statetype s_dogchase1;\r\nextern  statetype s_ofcchase1;\r\nextern  statetype s_sschase1;\r\nextern  statetype s_mutchase1;\r\nextern  statetype s_bosschase1;\r\nextern  statetype s_schabbchase1;\r\nextern  statetype s_fakechase1;\r\nextern  statetype s_mechachase1;\r\nextern  statetype s_gretelchase1;\r\nextern  statetype s_giftchase1;\r\nextern  statetype s_fatchase1;\r\n\r\nextern  statetype s_spectrechase1;\r\nextern  statetype s_angelchase1;\r\nextern  statetype s_transchase1;\r\nextern  statetype s_uberchase1;\r\nextern  statetype s_willchase1;\r\nextern  statetype s_deathchase1;\r\n\r\nextern  statetype s_blinkychase1;\r\nextern  statetype s_hitlerchase1;\r\n\r\nextern  statetype s_grdpain;\r\nextern  statetype s_grdpain1;\r\nextern  statetype s_ofcpain;\r\nextern  statetype s_ofcpain1;\r\nextern  statetype s_sspain;\r\nextern  statetype s_sspain1;\r\nextern  statetype s_mutpain;\r\nextern  statetype s_mutpain1;\r\n\r\nextern  statetype s_deathcam;\r\n\r\nextern  statetype s_schabbdeathcam2;\r\nextern  statetype s_hitlerdeathcam2;\r\nextern  statetype s_giftdeathcam2;\r\nextern  statetype s_fatdeathcam2;\r\n\r\nvoid SpawnStand (enemy_t which, int tilex, int tiley, int dir);\r\nvoid SpawnPatrol (enemy_t which, int tilex, int tiley, int dir);\r\nvoid KillActor (objtype *ob);\r\n\r\nvoid SpawnDeadGuard (int tilex, int tiley);\r\nvoid SpawnBoss (int tilex, int tiley);\r\nvoid SpawnGretel (int tilex, int tiley);\r\nvoid SpawnTrans (int tilex, int tiley);\r\nvoid SpawnUber (int tilex, int tiley);\r\nvoid SpawnWill (int tilex, int tiley);\r\nvoid SpawnDeath (int tilex, int tiley);\r\nvoid SpawnAngel (int tilex, int tiley);\r\nvoid SpawnSpectre (int tilex, int tiley);\r\nvoid SpawnGhosts (int which, int tilex, int tiley);\r\nvoid SpawnSchabbs (int tilex, int tiley);\r\nvoid SpawnGift (int tilex, int tiley);\r\nvoid SpawnFat (int tilex, int tiley);\r\nvoid SpawnFakeHitler (int tilex, int tiley);\r\nvoid SpawnHitler (int tilex, int tiley);\r\n\r\nvoid A_DeathScream (objtype *ob);\r\nvoid SpawnBJVictory (void);\r\n\r\n/*\r\n=============================================================================\r\n\r\n                             WL_TEXT DEFINITIONS\r\n\r\n=============================================================================\r\n*/\r\n\r\nextern  char    helpfilename[],endfilename[];\r\n\r\nextern  void    HelpScreens(void);\r\nextern  void    EndText(void);\r\n\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                             MISC DEFINITIONS\r\n\r\n=============================================================================\r\n*/\r\n\r\nstatic inline fixed FixedMul(fixed a, fixed b)\r\n{\r\n    return (fixed)(((int64_t)a * b + 0x8000) >> 16);\r\n}\r\n\r\n#ifdef PLAYDEMOLIKEORIGINAL\r\n    #define DEMOCHOOSE_ORIG_SDL(orig, sdl) ((demorecord || demoplayback) ? (orig) : (sdl))\r\n    #define DEMOCOND_ORIG                  (demorecord || demoplayback)\r\n    #define DEMOIF_SDL                     if(DEMOCOND_SDL)\r\n#else\r\n    #define DEMOCHOOSE_ORIG_SDL(orig, sdl) (sdl)\r\n    #define DEMOCOND_ORIG                  false\r\n    #define DEMOIF_SDL\r\n#endif\r\n#define DEMOCOND_SDL                   (!DEMOCOND_ORIG)\r\n\r\n#define GetTicks() ((SDL_GetTicks()*7)/100)\r\n\r\n#define ISPOINTER(x) ((((uintptr_t)(x)) & ~0xffff) != 0)\r\n\r\n#define CHECKMALLOCRESULT(x) if(!(x)) Quit(\"Out of memory at %s:%i\", __FILE__, __LINE__)\r\n\r\n// Mingw32 includes these definitions in string.h\r\n#ifndef __MINGW32__\r\n#ifdef _WIN32\r\n    #define strcasecmp stricmp\r\n    #define strncasecmp strnicmp\r\n    #define snprintf _snprintf\r\n#else\r\n    static inline char* itoa(int value, char* string, int radix)\r\n    {\r\n        sprintf(string, \"%d\", value);\r\n        return string;\r\n    }\r\n\r\n    static inline char* ltoa(long value, char* string, int radix)\r\n    {\r\n        sprintf(string, \"%ld\", value);\r\n        return string;\r\n    }\r\n#endif\r\n#endif\r\n\r\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\r\n#define endof(x)    ((x) + lengthof(x))\r\n\r\nstatic inline word READWORD(byte *&ptr)\r\n{\r\n    word val = ptr[0] | ptr[1] << 8;\r\n    ptr += 2;\r\n    return val;\r\n}\r\n\r\nstatic inline longword READLONGWORD(byte *&ptr)\r\n{\r\n    longword val = ptr[0] | ptr[1] << 8 | ptr[2] << 16 | ptr[3] << 24;\r\n    ptr += 4;\r\n    return val;\r\n}\r\n\r\n#endif\r\n\r\n","//\r\n//  ID Engine\r\n//  ID_IN.c - Input Manager\r\n//  v1.0d1\r\n//  By Jason Blochowiak\r\n//\r\n\r\n//\r\n//  This module handles dealing with the various input devices\r\n//\r\n//  Depends on: Memory Mgr (for demo recording), Sound Mgr (for timing stuff),\r\n//              User Mgr (for command line parms)\r\n//\r\n//  Globals:\r\n//      LastScan - The keyboard scan code of the last key pressed\r\n//      LastASCII - The ASCII value of the last key pressed\r\n//  DEBUG - there are more globals\r\n//\r\n\r\n#include \"wl_def.h\"\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                    GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n//\r\n// configuration variables\r\n//\r\nboolean MousePresent;\r\nboolean forcegrabmouse;\r\n\r\n\r\n//  Global variables\r\nvolatile boolean    Keyboard[SDLK_LAST];\r\nvolatile boolean    Paused;\r\nvolatile char       LastASCII;\r\nvolatile ScanCode   LastScan;\r\n\r\n//KeyboardDef   KbdDefs = {0x1d,0x38,0x47,0x48,0x49,0x4b,0x4d,0x4f,0x50,0x51};\r\nstatic KeyboardDef KbdDefs = {\r\n    sc_Control,             // button0\r\n    sc_Alt,                 // button1\r\n    sc_Home,                // upleft\r\n    sc_UpArrow,             // up\r\n    sc_PgUp,                // upright\r\n    sc_LeftArrow,           // left\r\n    sc_RightArrow,          // right\r\n    sc_End,                 // downleft\r\n    sc_DownArrow,           // down\r\n    sc_PgDn                 // downright\r\n};\r\n\r\nstatic SDL_Joystick *Joystick;\r\nint JoyNumButtons;\r\nstatic int JoyNumHats;\r\n\r\nstatic bool GrabInput = false;\r\n\r\n/*\r\n=============================================================================\r\n\r\n                    LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\nbyte        ASCIINames[] =      // Unshifted ASCII for scan codes       // TODO: keypad\r\n{\r\n//   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\r\n    0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,8  ,9  ,0  ,0  ,0  ,13 ,0  ,0  ,    // 0\r\n    0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,27 ,0  ,0  ,0  ,    // 1\r\n    ' ',0  ,0  ,0  ,0  ,0  ,0  ,39 ,0  ,0  ,'*','+',',','-','.','/',    // 2\r\n    '0','1','2','3','4','5','6','7','8','9',0  ,';',0  ,'=',0  ,0  ,    // 3\r\n    '`','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o',    // 4\r\n    'p','q','r','s','t','u','v','w','x','y','z','[',92 ,']',0  ,0  ,    // 5\r\n    0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,    // 6\r\n    0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0       // 7\r\n};\r\nbyte ShiftNames[] =     // Shifted ASCII for scan codes\r\n{\r\n//   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\r\n    0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,8  ,9  ,0  ,0  ,0  ,13 ,0  ,0  ,    // 0\r\n    0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,27 ,0  ,0  ,0  ,    // 1\r\n    ' ',0  ,0  ,0  ,0  ,0  ,0  ,34 ,0  ,0  ,'*','+','<','_','>','?',    // 2\r\n    ')','!','@','#','$','%','^','&','*','(',0  ,':',0  ,'+',0  ,0  ,    // 3\r\n    '~','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O',    // 4\r\n    'P','Q','R','S','T','U','V','W','X','Y','Z','{','|','}',0  ,0  ,    // 5\r\n    0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,    // 6\r\n    0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0       // 7\r\n};\r\nbyte SpecialNames[] =   // ASCII for 0xe0 prefixed codes\r\n{\r\n//   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\r\n    0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,    // 0\r\n    0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,13 ,0  ,0  ,0  ,    // 1\r\n    0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,    // 2\r\n    0  ,0  ,0  ,0  ,0  ,'/',0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,    // 3\r\n    0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,    // 4\r\n    0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,    // 5\r\n    0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,    // 6\r\n    0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0       // 7\r\n};\r\n\r\n\r\nstatic  boolean     IN_Started;\r\n\r\nstatic  Direction   DirTable[] =        // Quick lookup for total direction\r\n{\r\n    dir_NorthWest,  dir_North,  dir_NorthEast,\r\n    dir_West,       dir_None,   dir_East,\r\n    dir_SouthWest,  dir_South,  dir_SouthEast\r\n};\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  INL_GetMouseButtons() - Gets the status of the mouse buttons from the\r\n//      mouse driver\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic int\r\nINL_GetMouseButtons(void)\r\n{\r\n    int buttons = SDL_GetMouseState(NULL, NULL);\r\n    int middlePressed = buttons & SDL_BUTTON(SDL_BUTTON_MIDDLE);\r\n    int rightPressed = buttons & SDL_BUTTON(SDL_BUTTON_RIGHT);\r\n    buttons &= ~(SDL_BUTTON(SDL_BUTTON_MIDDLE) | SDL_BUTTON(SDL_BUTTON_RIGHT));\r\n    if(middlePressed) buttons |= 1 << 2;\r\n    if(rightPressed) buttons |= 1 << 1;\r\n\r\n    return buttons;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  IN_GetJoyDelta() - Returns the relative movement of the specified\r\n//      joystick (from +/-127)\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid IN_GetJoyDelta(int *dx,int *dy)\r\n{\r\n    if(!Joystick)\r\n    {\r\n        *dx = *dy = 0;\r\n        return;\r\n    }\r\n\r\n    SDL_JoystickUpdate();\r\n\r\n    int x = SDL_JoystickGetAxis(Joystick, 0) >> 8;\r\n    int y = SDL_JoystickGetAxis(Joystick, 1) >> 8;\r\n\r\n    if(param_joystickhat != -1)\r\n    {\r\n        uint8_t hatState = SDL_JoystickGetHat(Joystick, param_joystickhat);\r\n        if(hatState & SDL_HAT_RIGHT)\r\n            x += 127;\r\n        else if(hatState & SDL_HAT_LEFT)\r\n            x -= 127;\r\n        if(hatState & SDL_HAT_DOWN)\r\n            y += 127;\r\n        else if(hatState & SDL_HAT_UP)\r\n            y -= 127;\r\n\r\n        if(x < -128) x = -128;\r\n        else if(x > 127) x = 127;\r\n\r\n        if(y < -128) y = -128;\r\n        else if(y > 127) y = 127;\r\n    }\r\n\r\n    *dx = x;\r\n    *dy = y;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  IN_GetJoyFineDelta() - Returns the relative movement of the specified\r\n//      joystick without dividing the results by 256 (from +/-127)\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid IN_GetJoyFineDelta(int *dx, int *dy)\r\n{\r\n    if(!Joystick)\r\n    {\r\n        *dx = 0;\r\n        *dy = 0;\r\n        return;\r\n    }\r\n\r\n    SDL_JoystickUpdate();\r\n    int x = SDL_JoystickGetAxis(Joystick, 0);\r\n    int y = SDL_JoystickGetAxis(Joystick, 1);\r\n\r\n    if(x < -128) x = -128;\r\n    else if(x > 127) x = 127;\r\n\r\n    if(y < -128) y = -128;\r\n    else if(y > 127) y = 127;\r\n\r\n    *dx = x;\r\n    *dy = y;\r\n}\r\n\r\n/*\r\n===================\r\n=\r\n= IN_JoyButtons\r\n=\r\n===================\r\n*/\r\n\r\nint IN_JoyButtons()\r\n{\r\n    if(!Joystick) return 0;\r\n\r\n    SDL_JoystickUpdate();\r\n\r\n    int res = 0;\r\n    for(int i = 0; i < JoyNumButtons && i < 32; i++)\r\n        res |= SDL_JoystickGetButton(Joystick, i) << i;\r\n    return res;\r\n}\r\n\r\nboolean IN_JoyPresent()\r\n{\r\n    return Joystick != NULL;\r\n}\r\n\r\nstatic void processEvent(SDL_Event *event)\r\n{\r\n    switch (event->type)\r\n    {\r\n        // exit if the window is closed\r\n        case SDL_QUIT:\r\n            Quit(NULL);\r\n\r\n        // check for keypresses\r\n        case SDL_KEYDOWN:\r\n        {\r\n            if(event->key.keysym.sym==SDLK_SCROLLOCK || event->key.keysym.sym==SDLK_F12)\r\n            {\r\n                GrabInput = !GrabInput;\r\n                SDL_WM_GrabInput(GrabInput ? SDL_GRAB_ON : SDL_GRAB_OFF);\r\n                return;\r\n            }\r\n\r\n            LastScan = event->key.keysym.sym;\r\n            SDLMod mod = SDL_GetModState();\r\n            if(Keyboard[sc_Alt])\r\n            {\r\n                if(LastScan==SDLK_F4)\r\n                    Quit(NULL);\r\n            }\r\n\r\n            if(LastScan == SDLK_KP_ENTER) LastScan = SDLK_RETURN;\r\n            else if(LastScan == SDLK_RSHIFT) LastScan = SDLK_LSHIFT;\r\n            else if(LastScan == SDLK_RALT) LastScan = SDLK_LALT;\r\n            else if(LastScan == SDLK_RCTRL) LastScan = SDLK_LCTRL;\r\n            else\r\n            {\r\n                if((mod & KMOD_NUM) == 0)\r\n                {\r\n                    switch(LastScan)\r\n                    {\r\n                        case SDLK_KP2: LastScan = SDLK_DOWN; break;\r\n                        case SDLK_KP4: LastScan = SDLK_LEFT; break;\r\n                        case SDLK_KP6: LastScan = SDLK_RIGHT; break;\r\n                        case SDLK_KP8: LastScan = SDLK_UP; break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            int sym = LastScan;\r\n            if(sym >= 'a' && sym <= 'z')\r\n                sym -= 32;  // convert to uppercase\r\n\r\n            if(mod & (KMOD_SHIFT | KMOD_CAPS))\r\n            {\r\n                if(sym < lengthof(ShiftNames) && ShiftNames[sym])\r\n                    LastASCII = ShiftNames[sym];\r\n            }\r\n            else\r\n            {\r\n                if(sym < lengthof(ASCIINames) && ASCIINames[sym])\r\n                    LastASCII = ASCIINames[sym];\r\n            }\r\n\r\n\t\t\tif (LastScan<SDLK_i){\r\n\t\t\t}\r\n\r\n\t\t\tif(LastScan<SDLK_LAST){\r\n                Keyboard[LastScan] = 1;\r\n\t\t\t}\r\n            if(LastScan == SDLK_PAUSE)\r\n                Paused = true;\r\n            break;\r\n        }\r\n\r\n        case SDL_KEYUP:\r\n        {\r\n            int key = event->key.keysym.sym;\r\n            if(key == SDLK_KP_ENTER) key = SDLK_RETURN;\r\n            else if(key == SDLK_RSHIFT) key = SDLK_LSHIFT;\r\n            else if(key == SDLK_RALT) key = SDLK_LALT;\r\n            else if(key == SDLK_RCTRL) key = SDLK_LCTRL;\r\n            else\r\n            {\r\n                if((SDL_GetModState() & KMOD_NUM) == 0)\r\n                {\r\n                    switch(key)\r\n                    {\r\n                        case SDLK_KP2: key = SDLK_DOWN; break;\r\n                        case SDLK_KP4: key = SDLK_LEFT; break;\r\n                        case SDLK_KP6: key = SDLK_RIGHT; break;\r\n                        case SDLK_KP8: key = SDLK_UP; break;\r\n                    }\r\n                }\r\n            }\r\n\r\n\t\t\tif(key<SDLK_LAST){\r\n                Keyboard[key] = 0;\r\n\t\t\t}\r\n            break;\r\n        }\r\n\r\n    }\r\n}\r\n\r\nvoid IN_WaitAndProcessEvents()\r\n{\r\n    SDL_Event event;\r\n    if(!SDL_WaitEvent(&event)) return;\r\n    do\r\n    {\r\n        processEvent(&event);\r\n    }\r\n    while(SDL_PollEvent(&event));\r\n}\r\n\r\nvoid IN_ProcessEvents()\r\n{\r\n    SDL_Event event;\r\n\r\n    while (SDL_PollEvent(&event))\r\n    {\r\n        processEvent(&event);\r\n    }\r\n}\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  IN_Startup() - Starts up the Input Mgr\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_Startup(void)\r\n{\r\n    if (IN_Started)\r\n        return;\r\n\r\n    IN_ClearKeysDown();\r\n\r\n    if(param_joystickindex >= 0 && param_joystickindex < SDL_NumJoysticks())\r\n    {\r\n        Joystick = SDL_JoystickOpen(param_joystickindex);\r\n        if(Joystick)\r\n        {\r\n            JoyNumButtons = SDL_JoystickNumButtons(Joystick);\r\n            if(JoyNumButtons > 32) JoyNumButtons = 32;      // only up to 32 buttons are supported\r\n            JoyNumHats = SDL_JoystickNumHats(Joystick);\r\n            if(param_joystickhat < -1 || param_joystickhat >= JoyNumHats)\r\n                Quit(\"The joystickhat param must be between 0 and %i!\", JoyNumHats - 1);\r\n        }\r\n    }\r\n\r\n    SDL_EventState(SDL_MOUSEMOTION, SDL_IGNORE);\r\n\r\n    if(fullscreen || forcegrabmouse)\r\n    {\r\n        GrabInput = true;\r\n        SDL_WM_GrabInput(SDL_GRAB_ON);\r\n    }\r\n\r\n    // I didn't find a way to ask libSDL whether a mouse is present, yet...\r\n\r\n    MousePresent = true;\r\n    \r\n    IN_Started = true;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  IN_Shutdown() - Shuts down the Input Mgr\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_Shutdown(void)\r\n{\r\n    if (!IN_Started)\r\n        return;\r\n\r\n    if(Joystick)\r\n        SDL_JoystickClose(Joystick);\r\n\r\n    IN_Started = false;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  IN_ClearKeysDown() - Clears the keyboard array\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_ClearKeysDown(void)\r\n{\r\n    LastScan = sc_None;\r\n    LastASCII = key_None;\r\n    memset ((void *) Keyboard,0,sizeof(Keyboard));\r\n}\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  IN_ReadControl() - Reads the device associated with the specified\r\n//      player and fills in the control info struct\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_ReadControl(int player,ControlInfo *info)\r\n{\r\n    word        buttons;\r\n    int         dx,dy;\r\n    Motion      mx,my;\r\n\r\n    dx = dy = 0;\r\n    mx = my = motion_None;\r\n    buttons = 0;\r\n\r\n    IN_ProcessEvents();\r\n\r\n    if (Keyboard[KbdDefs.upleft])\r\n        mx = motion_Left,my = motion_Up;\r\n    else if (Keyboard[KbdDefs.upright])\r\n        mx = motion_Right,my = motion_Up;\r\n    else if (Keyboard[KbdDefs.downleft])\r\n        mx = motion_Left,my = motion_Down;\r\n    else if (Keyboard[KbdDefs.downright])\r\n        mx = motion_Right,my = motion_Down;\r\n\r\n    if (Keyboard[KbdDefs.up])\r\n        my = motion_Up;\r\n    else if (Keyboard[KbdDefs.down])\r\n        my = motion_Down;\r\n\r\n    if (Keyboard[KbdDefs.left])\r\n        mx = motion_Left;\r\n    else if (Keyboard[KbdDefs.right])\r\n        mx = motion_Right;\r\n\r\n    if (Keyboard[KbdDefs.button0])\r\n        buttons += 1 << 0;\r\n    if (Keyboard[KbdDefs.button1])\r\n        buttons += 1 << 1;\r\n\r\n    dx = mx * 127;\r\n    dy = my * 127;\r\n\r\n    info->x = dx;\r\n    info->xaxis = mx;\r\n    info->y = dy;\r\n    info->yaxis = my;\r\n    info->button0 = (buttons & (1 << 0)) != 0;\r\n    info->button1 = (buttons & (1 << 1)) != 0;\r\n    info->button2 = (buttons & (1 << 2)) != 0;\r\n    info->button3 = (buttons & (1 << 3)) != 0;\r\n    info->dir = DirTable[((my + 1) * 3) + (mx + 1)];\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  IN_Ack() - waits for a button or key press.  If a button is down, upon\r\n// calling, it must be released for it to be recognized\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\n\r\nboolean btnstate[NUMBUTTONS];\r\n\r\nvoid IN_StartAck(void)\r\n{\r\n    IN_ProcessEvents();\r\n//\r\n// get initial state of everything\r\n//\r\n    IN_ClearKeysDown();\r\n    memset(btnstate, 0, sizeof(btnstate));\r\n\r\n    int buttons = IN_JoyButtons() << 4;\r\n\r\n    if(MousePresent)\r\n        buttons |= IN_MouseButtons();\r\n\r\n    for(int i = 0; i < NUMBUTTONS; i++, buttons >>= 1)\r\n        if(buttons & 1)\r\n            btnstate[i] = true;\r\n}\r\n\r\n\r\nboolean IN_CheckAck (void)\r\n{\r\n    IN_ProcessEvents();\r\n//\r\n// see if something has been pressed\r\n//\r\n    if(LastScan)\r\n        return true;\r\n\r\n    int buttons = IN_JoyButtons() << 4;\r\n\r\n    if(MousePresent)\r\n        buttons |= IN_MouseButtons();\r\n\r\n    for(int i = 0; i < NUMBUTTONS; i++, buttons >>= 1)\r\n    {\r\n        if(buttons & 1)\r\n        {\r\n            if(!btnstate[i])\r\n            {\r\n                // Wait until button has been released\r\n                do\r\n                {\r\n                    IN_WaitAndProcessEvents();\r\n                    buttons = IN_JoyButtons() << 4;\r\n\r\n                    if(MousePresent)\r\n                        buttons |= IN_MouseButtons();\r\n                }\r\n                while(buttons & (1 << i));\r\n\r\n                return true;\r\n            }\r\n        }\r\n        else\r\n            btnstate[i] = false;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n\r\nvoid IN_Ack (void)\r\n{\r\n    IN_StartAck ();\r\n\r\n    // TODO(jsdf): some kind of UI event loop here\r\n\r\n    // do\r\n    // {\r\n    //     IN_WaitAndProcessEvents();\r\n    // }\r\n    // while(!IN_CheckAck ());\r\n}\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  IN_UserInput() - Waits for the specified delay time (in ticks) or the\r\n//      user pressing a key or a mouse button. If the clear flag is set, it\r\n//      then either clears the key or waits for the user to let the mouse\r\n//      button up.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nboolean IN_UserInput(longword delay)\r\n{\r\n    longword    lasttime;\r\n    return(false);\r\n\r\n\r\n    lasttime = GetTimeCount();\r\n    IN_StartAck ();\r\n    do\r\n    {\r\n        IN_ProcessEvents();\r\n        if (IN_CheckAck())\r\n            return true;\r\n        SDL_Delay(5);\r\n    } while (GetTimeCount() - lasttime < delay);\r\n    return(false);\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n===================\r\n=\r\n= IN_MouseButtons\r\n=\r\n===================\r\n*/\r\nint IN_MouseButtons (void)\r\n{\r\n    if (MousePresent)\r\n        return INL_GetMouseButtons();\r\n    else\r\n        return 0;\r\n}\r\n\r\nbool IN_IsInputGrabbed()\r\n{\r\n    return GrabInput;\r\n}\r\n\r\nvoid IN_CenterMouse()\r\n{\r\n    SDL_WarpMouse(screenWidth / 2, screenHeight / 2);\r\n}\r\n","#include \"wl_def.h\"\r\n\r\nint ChunksInFile;\r\nint PMSpriteStart;\r\nint PMSoundStart;\r\n\r\nbool PMSoundInfoPagePadded = false;\r\n\r\n// holds the whole VSWAP\r\nuint32_t *PMPageData;\r\nsize_t PMPageDataSize;\r\n\r\n// ChunksInFile+1 pointers to page starts.\r\n// The last pointer points one byte after the last page.\r\nuint8_t **PMPages;\r\n\r\nvoid PM_Startup()\r\n{\r\n    char fname[13] = \"vswap.\";\r\n    strcat(fname,extension);\r\n\r\n    FILE *file = fopen(fname,\"rb\");\r\n    if(!file)\r\n        CA_CannotOpen(fname);\r\n\r\n    ChunksInFile = 0;\r\n    fread(&ChunksInFile, sizeof(word), 1, file);\r\n    PMSpriteStart = 0;\r\n    fread(&PMSpriteStart, sizeof(word), 1, file);\r\n    PMSoundStart = 0;\r\n    fread(&PMSoundStart, sizeof(word), 1, file);\r\n\r\n    uint32_t* pageOffsets = (uint32_t *) malloc((ChunksInFile + 1) * sizeof(int32_t));\r\n    CHECKMALLOCRESULT(pageOffsets);\r\n    fread(pageOffsets, sizeof(uint32_t), ChunksInFile, file);\r\n\r\n    word *pageLengths = (word *) malloc(ChunksInFile * sizeof(word));\r\n    CHECKMALLOCRESULT(pageLengths);\r\n    fread(pageLengths, sizeof(word), ChunksInFile, file);\r\n\r\n    fseek(file, 0, SEEK_END);\r\n    long fileSize = ftell(file);\r\n    long pageDataSize = fileSize - pageOffsets[0];\r\n    if(pageDataSize > (size_t) -1)\r\n        Quit(\"The page file \\\"%s\\\" is too large!\", fname);\r\n\r\n    pageOffsets[ChunksInFile] = fileSize;\r\n\r\n    uint32_t dataStart = pageOffsets[0];\r\n    int i;\r\n\r\n    // Check that all pageOffsets are valid\r\n    for(i = 0; i < ChunksInFile; i++)\r\n    {\r\n        if(!pageOffsets[i]) continue;   // sparse page\r\n        if(pageOffsets[i] < dataStart || pageOffsets[i] >= (size_t) fileSize)\r\n            Quit(\"Illegal page offset for page %i: %u (filesize: %u)\",\r\n                    i, pageOffsets[i], fileSize);\r\n    }\r\n\r\n    // Calculate total amount of padding needed for sprites and sound info page\r\n    int alignPadding = 0;\r\n    for(i = PMSpriteStart; i < PMSoundStart; i++)\r\n    {\r\n        if(!pageOffsets[i]) continue;   // sparse page\r\n        uint32_t offs = pageOffsets[i] - dataStart + alignPadding;\r\n        if(offs & 1)\r\n            alignPadding++;\r\n    }\r\n\r\n    if((pageOffsets[ChunksInFile - 1] - dataStart + alignPadding) & 1)\r\n        alignPadding++;\r\n\r\n    PMPageDataSize = (size_t) pageDataSize + alignPadding;\r\n    PMPageData = (uint32_t *) malloc(PMPageDataSize);\r\n    CHECKMALLOCRESULT(PMPageData);\r\n\r\n    PMPages = (uint8_t **) malloc((ChunksInFile + 1) * sizeof(uint8_t *));\r\n    CHECKMALLOCRESULT(PMPages);\r\n\r\n    // Load pages and initialize PMPages pointers\r\n    uint8_t *ptr = (uint8_t *) PMPageData;\r\n    for(i = 0; i < ChunksInFile; i++)\r\n    {\r\n        if(i >= PMSpriteStart && i < PMSoundStart || i == ChunksInFile - 1)\r\n        {\r\n            size_t offs = ptr - (uint8_t *) PMPageData;\r\n\r\n            // pad with zeros to make it 2-byte aligned\r\n            if(offs & 1)\r\n            {\r\n                *ptr++ = 0;\r\n                if(i == ChunksInFile - 1) PMSoundInfoPagePadded = true;\r\n            }\r\n        }\r\n\r\n        PMPages[i] = ptr;\r\n\r\n        if(!pageOffsets[i])\r\n            continue;               // sparse page\r\n\r\n        // Use specified page length, when next page is sparse page.\r\n        // Otherwise, calculate size from the offset difference between this and the next page.\r\n        uint32_t size;\r\n        if(!pageOffsets[i + 1]) size = pageLengths[i];\r\n        else size = pageOffsets[i + 1] - pageOffsets[i];\r\n\r\n        fseek(file, pageOffsets[i], SEEK_SET);\r\n        fread(ptr, 1, size, file);\r\n        ptr += size;\r\n    }\r\n\r\n    // last page points after page buffer\r\n    PMPages[ChunksInFile] = ptr;\r\n\r\n    free(pageLengths);\r\n    free(pageOffsets);\r\n    fclose(file);\r\n}\r\n\r\nvoid PM_Shutdown()\r\n{\r\n    free(PMPages);\r\n    free(PMPageData);\r\n}\r\n","//\r\n//      ID Engine\r\n//      ID_SD.c - Sound Manager for Wolfenstein 3D\r\n//      v1.2\r\n//      By Jason Blochowiak\r\n//\r\n\r\n//\r\n//      This module handles dealing with generating sound on the appropriate\r\n//              hardware\r\n//\r\n//      Depends on: User Mgr (for parm checking)\r\n//\r\n//      Globals:\r\n//              For User Mgr:\r\n//                      SoundBlasterPresent - SoundBlaster card present?\r\n//                      AdLibPresent - AdLib card present?\r\n//                      SoundMode - What device is used for sound effects\r\n//                              (Use SM_SetSoundMode() to set)\r\n//                      MusicMode - What device is used for music\r\n//                              (Use SM_SetMusicMode() to set)\r\n//                      DigiMode - What device is used for digitized sound effects\r\n//                              (Use SM_SetDigiDevice() to set)\r\n//\r\n//              For Cache Mgr:\r\n//                      NeedsDigitized - load digitized sounds?\r\n//                      NeedsMusic - load music?\r\n//\r\n\r\n#include \"wl_def.h\"\r\n#ifdef _WIN32\r\n#include \"SDL_mixer.h\"\r\n#elif __linux__\r\n#include <SDL/SDL_mixer.h>\r\n#else\r\n#include <SDL/SDL_mixer.h>\r\n#endif\r\n#include \"fmopl.h\"\r\n\r\n#pragma hdrstop\r\n\r\n#define ORIGSAMPLERATE 7042\r\n\r\ntypedef struct\r\n{\r\n    char RIFF[4];\r\n    longword filelenminus8;\r\n    char WAVE[4];\r\n    char fmt_[4];\r\n    longword formatlen;\r\n    word val0x0001;\r\n    word channels;\r\n    longword samplerate;\r\n    longword bytespersec;\r\n    word bytespersample;\r\n    word bitspersample;\r\n} headchunk;\r\n\r\ntypedef struct\r\n{\r\n    char chunkid[4];\r\n    longword chunklength;\r\n} wavechunk;\r\n\r\ntypedef struct\r\n{\r\n    uint32_t startpage;\r\n    uint32_t length;\r\n} digiinfo;\r\n\r\nstatic Mix_Chunk *SoundChunks[ STARTMUSIC - STARTDIGISOUNDS];\r\nstatic byte      *SoundBuffers[STARTMUSIC - STARTDIGISOUNDS];\r\n\r\nglobalsoundpos channelSoundPos[MIX_CHANNELS];\r\n\r\n//      Global variables\r\n        boolean         AdLibPresent,\r\n                        SoundBlasterPresent,SBProPresent,\r\n                        SoundPositioned;\r\n        SDMode          SoundMode;\r\n        SMMode          MusicMode;\r\n        SDSMode         DigiMode;\r\nstatic  byte          **SoundTable;\r\n        int             DigiMap[LASTSOUND];\r\n        int             DigiChannel[STARTMUSIC - STARTDIGISOUNDS];\r\n\r\n//      Internal variables\r\nstatic  boolean                 SD_Started;\r\nstatic  boolean                 nextsoundpos;\r\nstatic  soundnames              SoundNumber;\r\nstatic  soundnames              DigiNumber;\r\nstatic  word                    SoundPriority;\r\nstatic  word                    DigiPriority;\r\nstatic  int                     LeftPosition;\r\nstatic  int                     RightPosition;\r\n\r\n        word                    NumDigi;\r\nstatic  digiinfo               *DigiList;\r\nstatic  boolean                 DigiPlaying;\r\n\r\n//      PC Sound variables\r\n\r\nstatic  byte * volatile         pcSound;\r\n\r\n\r\n//      AdLib variables\r\nstatic  byte * volatile         alSound;\r\nstatic  byte                    alBlock;\r\nstatic  longword                alLengthLeft;\r\nstatic  longword                alTimeCount;\r\nstatic  Instrument              alZeroInst;\r\n\r\n//      Sequencer variables\r\nstatic  volatile boolean        sqActive;\r\nstatic  word                   *sqHack;\r\nstatic  word                   *sqHackPtr;\r\nstatic  int                     sqHackLen;\r\nstatic  int                     sqHackSeqLen;\r\nstatic  longword                sqHackTime;\r\n\r\n\r\nstatic void SDL_SoundFinished(void)\r\n{\r\n    SoundNumber   = (soundnames)0;\r\n    SoundPriority = 0;\r\n}\r\n\r\n\r\n#ifdef NOTYET\r\n\r\nvoid SDL_turnOnPCSpeaker(word timerval);\r\n#pragma aux SDL_turnOnPCSpeaker = \\\r\n        \"mov    al,0b6h\" \\\r\n        \"out    43h,al\" \\\r\n        \"mov    al,bl\" \\\r\n        \"out    42h,al\" \\\r\n        \"mov    al,bh\" \\\r\n        \"out    42h,al\" \\\r\n        \"in     al,61h\" \\\r\n        \"or     al,3\"   \\\r\n        \"out    61h,al\" \\\r\n        parm [bx] \\\r\n        modify exact [al]\r\n\r\nvoid SDL_turnOffPCSpeaker();\r\n#pragma aux SDL_turnOffPCSpeaker = \\\r\n        \"in     al,61h\" \\\r\n        \"and    al,0fch\" \\\r\n        \"out    61h,al\" \\\r\n        modify exact [al]\r\n\r\nvoid SDL_setPCSpeaker(byte val);\r\n#pragma aux SDL_setPCSpeaker = \\\r\n        \"in     al,61h\" \\\r\n        \"and    al,0fch\" \\\r\n        \"or     al,ah\" \\\r\n        \"out    61h,al\" \\\r\n        parm [ah] \\\r\n        modify exact [al]\r\n\r\nvoid inline SDL_DoFX()\r\n{\r\n        if(pcSound)\r\n        {\r\n                if(*pcSound!=pcLastSample)\r\n                {\r\n                        pcLastSample=*pcSound;\r\n\r\n                        if(pcLastSample)\r\n                                SDL_turnOnPCSpeaker(pcLastSample*60);\r\n                        else\r\n                                SDL_turnOffPCSpeaker();\r\n                }\r\n                pcSound++;\r\n                pcLengthLeft--;\r\n                if(!pcLengthLeft)\r\n                {\r\n                        pcSound=0;\r\n                        SoundNumber=(soundnames)0;\r\n                        SoundPriority=0;\r\n                        SDL_turnOffPCSpeaker();\r\n                }\r\n        }\r\n\r\n        // [adlib sound stuff removed...]\r\n}\r\n\r\nstatic void SDL_DigitizedDoneInIRQ(void);\r\n\r\nvoid inline SDL_DoFast()\r\n{\r\n        count_fx++;\r\n        if(count_fx>=5)\r\n        {\r\n                count_fx=0;\r\n\r\n                SDL_DoFX();\r\n\r\n                count_time++;\r\n                if(count_time>=2)\r\n                {\r\n                        TimeCount++;\r\n                        count_time=0;\r\n                }\r\n        }\r\n\r\n        // [adlib music and soundsource stuff removed...]\r\n\r\n        TimerCount+=TimerDivisor;\r\n        if(*((word *)&TimerCount+1))\r\n        {\r\n                *((word *)&TimerCount+1)=0;\r\n                t0OldService();\r\n        }\r\n        else\r\n        {\r\n                outp(0x20,0x20);\r\n        }\r\n}\r\n\r\n// Timer 0 ISR for 7000Hz interrupts\r\nvoid __interrupt SDL_t0ExtremeAsmService(void)\r\n{\r\n        if(pcindicate)\r\n        {\r\n                if(pcSound)\r\n                {\r\n                        SDL_setPCSpeaker(((*pcSound++)&0x80)>>6);\r\n                        pcLengthLeft--;\r\n                        if(!pcLengthLeft)\r\n                        {\r\n                                pcSound=0;\r\n                                SDL_turnOffPCSpeaker();\r\n                                SDL_DigitizedDoneInIRQ();\r\n                        }\r\n                }\r\n        }\r\n        extreme++;\r\n        if(extreme>=10)\r\n        {\r\n                extreme=0;\r\n                SDL_DoFast();\r\n        }\r\n        else\r\n                outp(0x20,0x20);\r\n}\r\n\r\n// Timer 0 ISR for 700Hz interrupts\r\nvoid __interrupt SDL_t0FastAsmService(void)\r\n{\r\n        SDL_DoFast();\r\n}\r\n\r\n// Timer 0 ISR for 140Hz interrupts\r\nvoid __interrupt SDL_t0SlowAsmService(void)\r\n{\r\n        count_time++;\r\n        if(count_time>=2)\r\n        {\r\n                TimeCount++;\r\n                count_time=0;\r\n        }\r\n\r\n        SDL_DoFX();\r\n\r\n        TimerCount+=TimerDivisor;\r\n        if(*((word *)&TimerCount+1))\r\n        {\r\n                *((word *)&TimerCount+1)=0;\r\n                t0OldService();\r\n        }\r\n        else\r\n                outp(0x20,0x20);\r\n}\r\n\r\nvoid SDL_IndicatePC(boolean ind)\r\n{\r\n        pcindicate=ind;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SDL_SetTimer0() - Sets system timer 0 to the specified speed\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_SetTimer0(word speed)\r\n{\r\n#ifndef TPROF   // If using Borland's profiling, don't screw with the timer\r\n//      _asm pushfd\r\n        _asm cli\r\n\r\n        outp(0x43,0x36);                                // Change timer 0\r\n        outp(0x40,(byte)speed);\r\n        outp(0x40,speed >> 8);\r\n        // Kludge to handle special case for digitized PC sounds\r\n        if (TimerDivisor == (1192030 / (TickBase * 100)))\r\n                TimerDivisor = (1192030 / (TickBase * 10));\r\n        else\r\n                TimerDivisor = speed;\r\n\r\n//      _asm popfd\r\n        _asm    sti\r\n#else\r\n        TimerDivisor = 0x10000;\r\n#endif\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SDL_SetIntsPerSec() - Uses SDL_SetTimer0() to set the number of\r\n//              interrupts generated by system timer 0 per second\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_SetIntsPerSec(word ints)\r\n{\r\n        TimerRate = ints;\r\n        SDL_SetTimer0(1192030 / ints);\r\n}\r\n\r\nstatic void\r\nSDL_SetTimerSpeed(void)\r\n{\r\n        word    rate;\r\n        void (_interrupt *isr)(void);\r\n\r\n        if ((DigiMode == sds_PC) && DigiPlaying)\r\n        {\r\n                rate = TickBase * 100;\r\n                isr = SDL_t0ExtremeAsmService;\r\n        }\r\n        else if ((MusicMode == smm_AdLib) || ((DigiMode == sds_SoundSource) && DigiPlaying)     )\r\n        {\r\n                rate = TickBase * 10;\r\n                isr = SDL_t0FastAsmService;\r\n        }\r\n        else\r\n        {\r\n                rate = TickBase * 2;\r\n                isr = SDL_t0SlowAsmService;\r\n        }\r\n\r\n        if (rate != TimerRate)\r\n        {\r\n                _dos_setvect(8,isr);\r\n                SDL_SetIntsPerSec(rate);\r\n                TimerRate = rate;\r\n        }\r\n}\r\n\r\n//\r\n//      PC Sound code\r\n//\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SDL_PCPlaySample() - Plays the specified sample on the PC speaker\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\n#ifdef  _MUSE_\r\nvoid\r\n#else\r\nstatic void\r\n#endif\r\nSDL_PCPlaySample(byte *data,longword len,boolean inIRQ)\r\n{\r\n        if(!inIRQ)\r\n        {\r\n//              _asm    pushfd\r\n                _asm    cli\r\n        }\r\n\r\n        SDL_IndicatePC(true);\r\n\r\n        pcLengthLeft = len;\r\n        pcSound = (volatile byte *)data;\r\n\r\n        if(!inIRQ)\r\n        {\r\n//              _asm    popfd\r\n                _asm    sti\r\n        }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SDL_PCStopSample() - Stops a sample playing on the PC speaker\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\n#ifdef  _MUSE_\r\nvoid\r\n#else\r\nstatic void\r\n#endif\r\nSDL_PCStopSampleInIRQ(void)\r\n{\r\n        pcSound = 0;\r\n\r\n        SDL_IndicatePC(false);\r\n\r\n        _asm    in      al,0x61                 // Turn the speaker off\r\n        _asm    and     al,0xfd                 // ~2\r\n        _asm    out     0x61,al\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SDL_PCPlaySound() - Plays the specified sound on the PC speaker\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\n#ifdef  _MUSE_\r\nvoid\r\n#else\r\nstatic void\r\n#endif\r\nSDL_PCPlaySound(PCSound *sound)\r\n{\r\n//      _asm    pushfd\r\n        _asm    cli\r\n\r\n        pcLastSample = -1;\r\n        pcLengthLeft = sound->common.length;\r\n        pcSound = sound->data;\r\n\r\n//      _asm    popfd\r\n        _asm    sti\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SDL_PCStopSound() - Stops the current sound playing on the PC Speaker\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\n#ifdef  _MUSE_\r\nvoid\r\n#else\r\nstatic void\r\n#endif\r\nSDL_PCStopSound(void)\r\n{\r\n//      _asm    pushfd\r\n        _asm    cli\r\n\r\n        pcSound = 0;\r\n\r\n        _asm    in      al,0x61                 // Turn the speaker off\r\n        _asm    and     al,0xfd                 // ~2\r\n        _asm    out     0x61,al\r\n\r\n//      _asm    popfd\r\n        _asm    sti\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SDL_ShutPC() - Turns off the pc speaker\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_ShutPC(void)\r\n{\r\n//      _asm    pushfd\r\n        _asm    cli\r\n\r\n        pcSound = 0;\r\n\r\n        _asm    in      al,0x61                 // Turn the speaker & gate off\r\n        _asm    and     al,0xfc                 // ~3\r\n        _asm    out     0x61,al\r\n\r\n//      _asm    popfd\r\n        _asm    sti\r\n}\r\n\r\n#endif\r\n\r\nvoid\r\nSD_StopDigitized(void)\r\n{\r\n                assert(DigiMap[18] == 3);\r\n\r\n    DigiPlaying = false;\r\n    DigiNumber = (soundnames) 0;\r\n    DigiPriority = 0;\r\n    SoundPositioned = false;\r\n    if ((DigiMode == sds_PC) && (SoundMode == sdm_PC))\r\n        SDL_SoundFinished();\r\n            assert(DigiMap[18] == 3);\r\n\r\n    switch (DigiMode)\r\n    {\r\n        case sds_PC:\r\n//            SDL_PCStopSampleInIRQ();\r\n            break;\r\n        case sds_SoundBlaster:\r\n//            SDL_SBStopSampleInIRQ();\r\n            // Mix_HaltChannel(-1);\r\n            break;\r\n    }\r\n                assert(DigiMap[18] == 3);\r\n\r\n}\r\n\r\nint SD_GetChannelForDigi(int which)\r\n{\r\n    if(DigiChannel[which] != -1) return DigiChannel[which];\r\n\r\n    int channel = Mix_GroupAvailable(1);\r\n    if(channel == -1) channel = Mix_GroupOldest(1);\r\n    if(channel == -1)           // All sounds stopped in the meantime?\r\n        return Mix_GroupAvailable(1);\r\n    return channel;\r\n}\r\n\r\nvoid SD_SetPosition(int channel, int leftpos, int rightpos)\r\n{\r\n    if((leftpos < 0) || (leftpos > 15) || (rightpos < 0) || (rightpos > 15)\r\n            || ((leftpos == 15) && (rightpos == 15)))\r\n        Quit(\"SD_SetPosition: Illegal position\");\r\n\r\n    switch (DigiMode)\r\n    {\r\n        case sds_SoundBlaster:\r\n//            SDL_PositionSBP(leftpos,rightpos);\r\n            Mix_SetPanning(channel, ((15 - leftpos) << 4) + 15,\r\n                ((15 - rightpos) << 4) + 15);\r\n            break;\r\n    }\r\n}\r\n\r\nSint16 GetSample(float csample, byte *samples, int size)\r\n{\r\n    float s0=0, s1=0, s2=0;\r\n    int cursample = (int) csample;\r\n    float sf = csample - (float) cursample;\r\n\r\n    if(cursample-1 >= 0) s0 = (float) (samples[cursample-1] - 128);\r\n    s1 = (float) (samples[cursample] - 128);\r\n    if(cursample+1 < size) s2 = (float) (samples[cursample+1] - 128);\r\n\r\n    float val = s0*sf*(sf-1)/2 - s1*(sf*sf-1) + s2*(sf+1)*sf/2;\r\n    int32_t intval = (int32_t) (val * 256);\r\n    if(intval < -32768) intval = -32768;\r\n    else if(intval > 32767) intval = 32767;\r\n    return (Sint16) intval;\r\n}\r\n\r\nvoid SD_PrepareSound(int which)\r\n{\r\n    if(DigiList == NULL)\r\n        Quit(\"SD_PrepareSound(%i): DigiList not initialized!\\n\", which);\r\n\r\n    int page = DigiList[which].startpage;\r\n    int size = DigiList[which].length;\r\n\r\n    byte *origsamples = PM_GetSound(page);\r\n    if(origsamples + size >= PM_GetEnd())\r\n        Quit(\"SD_PrepareSound(%i): Sound reaches out of page file!\\n\", which);\r\n\r\n    int destsamples = (int) ((float) size * (float) param_samplerate\r\n        / (float) ORIGSAMPLERATE);\r\n\r\n    byte *wavebuffer = (byte *) malloc(sizeof(headchunk) + sizeof(wavechunk)\r\n        + destsamples * 2);     // dest are 16-bit samples\r\n    if(wavebuffer == NULL)\r\n        Quit(\"Unable to allocate wave buffer for sound %i!\\n\", which);\r\n\r\n    headchunk head = {{'R','I','F','F'}, 0, {'W','A','V','E'},\r\n        {'f','m','t',' '}, 0x10, 0x0001, 1, param_samplerate, param_samplerate*2, 2, 16};\r\n    wavechunk dhead = {{'d', 'a', 't', 'a'}, destsamples*2};\r\n    head.filelenminus8 = sizeof(head) + destsamples*2;  // (sizeof(dhead)-8 = 0)\r\n    memcpy(wavebuffer, &head, sizeof(head));\r\n    memcpy(wavebuffer+sizeof(head), &dhead, sizeof(dhead));\r\n\r\n    // alignment is correct, as wavebuffer comes from malloc\r\n    // and sizeof(headchunk) % 4 == 0 and sizeof(wavechunk) % 4 == 0\r\n    Sint16 *newsamples = (Sint16 *)(void *) (wavebuffer + sizeof(headchunk)\r\n        + sizeof(wavechunk));\r\n    float cursample = 0.F;\r\n    float samplestep = (float) ORIGSAMPLERATE / (float) param_samplerate;\r\n    for(int i=0; i<destsamples; i++, cursample+=samplestep)\r\n    {\r\n        newsamples[i] = GetSample((float)size * (float)i / (float)destsamples,\r\n            origsamples, size);\r\n    }\r\n    SoundBuffers[which] = wavebuffer;\r\n\r\n    SoundChunks[which] = Mix_LoadWAV_RW(SDL_RWFromMem(wavebuffer,\r\n        sizeof(headchunk) + sizeof(wavechunk) + destsamples * 2), 1);\r\n}\r\n\r\nint SD_PlayDigitized(word which,int leftpos,int rightpos)\r\n{\r\n    if (!DigiMode)\r\n        return 0;\r\n\r\n    if (which >= NumDigi)\r\n        Quit(\"SD_PlayDigitized: bad sound number %i\", which);\r\n\r\n    int channel = SD_GetChannelForDigi(which);\r\n    SD_SetPosition(channel, leftpos,rightpos);\r\n\r\n    DigiPlaying = true;\r\n\r\n    Mix_Chunk *sample = SoundChunks[which];\r\n    if(sample == NULL)\r\n    {\r\n        printf(\"SoundChunks[%i] is NULL!\\n\", which);\r\n        return 0;\r\n    }\r\n\r\n    if(Mix_PlayChannel(channel, sample, 0) == -1)\r\n    {\r\n        printf(\"Unable to play sound: %s\\n\", Mix_GetError());\r\n        return 0;\r\n    }\r\n\r\n    return channel;\r\n}\r\n\r\nvoid SD_ChannelFinished(int channel)\r\n{\r\n    channelSoundPos[channel].valid = 0;\r\n}\r\n\r\nvoid\r\nSD_SetDigiDevice(SDSMode mode)\r\n{\r\n    boolean devicenotpresent;\r\n\r\n    if (mode == DigiMode)\r\n        return;\r\n\r\n    SD_StopDigitized();\r\n\r\n    devicenotpresent = false;\r\n    switch (mode)\r\n    {\r\n        case sds_SoundBlaster:\r\n            if (!SoundBlasterPresent)\r\n                devicenotpresent = true;\r\n            break;\r\n    }\r\n\r\n    if (!devicenotpresent)\r\n    {\r\n        DigiMode = mode;\r\n\r\n#ifdef NOTYET\r\n        SDL_SetTimerSpeed();\r\n#endif\r\n    }\r\n}\r\n\r\nvoid\r\nSDL_SetupDigi(void)\r\n{\r\n    // Correct padding enforced by PM_Startup()\r\n    word *soundInfoPage = (word *) (void *) PM_GetPage(ChunksInFile-1);\r\n    NumDigi = (word) PM_GetPageSize(ChunksInFile - 1) / 4;\r\n\r\n    DigiList = (digiinfo *) malloc(NumDigi * sizeof(digiinfo));\r\n    int i;\r\n    for(i = 0; i < NumDigi; i++)\r\n    {\r\n        // Calculate the size of the digi from the sizes of the pages between\r\n        // the start page and the start page of the next sound\r\n\r\n        DigiList[i].startpage = soundInfoPage[i * 2];\r\n        if((int) DigiList[i].startpage >= ChunksInFile - 1)\r\n        {\r\n            NumDigi = i;\r\n            break;\r\n        }\r\n\r\n        int lastPage;\r\n        if(i < NumDigi - 1)\r\n        {\r\n            lastPage = soundInfoPage[i * 2 + 2];\r\n            if(lastPage == 0 || lastPage + PMSoundStart > ChunksInFile - 1) lastPage = ChunksInFile - 1;\r\n            else lastPage += PMSoundStart;\r\n        }\r\n        else lastPage = ChunksInFile - 1;\r\n\r\n        int size = 0;\r\n        for(int page = PMSoundStart + DigiList[i].startpage; page < lastPage; page++)\r\n            size += PM_GetPageSize(page);\r\n\r\n        // Don't include padding of sound info page, if padding was added\r\n        if(lastPage == ChunksInFile - 1 && PMSoundInfoPagePadded) size--;\r\n\r\n        // Patch lower 16-bit of size with size from sound info page.\r\n        // The original VSWAP contains padding which is included in the page size,\r\n        // but not included in the 16-bit size. So we use the more precise value.\r\n        if((size & 0xffff0000) != 0 && (size & 0xffff) < soundInfoPage[i * 2 + 1])\r\n            size -= 0x10000;\r\n        size = (size & 0xffff0000) | soundInfoPage[i * 2 + 1];\r\n\r\n        DigiList[i].length = size;\r\n    }\r\n\r\n    for(i = 0; i < LASTSOUND; i++)\r\n    {\r\n        DigiMap[i] = -1;\r\n        DigiChannel[i] = -1;\r\n    }\r\n}\r\n\r\n//      AdLib Code\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SDL_ALStopSound() - Turns off any sound effects playing through the\r\n//              AdLib card\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_ALStopSound(void)\r\n{\r\n    alSound = 0;\r\n    alOut(alFreqH + 0, 0);\r\n}\r\n\r\nstatic void\r\nSDL_AlSetFXInst(Instrument *inst)\r\n{\r\n    byte c,m;\r\n\r\n    m = 0;      // modulator cell for channel 0\r\n    c = 3;      // carrier cell for channel 0\r\n    alOut(m + alChar,inst->mChar);\r\n    alOut(m + alScale,inst->mScale);\r\n    alOut(m + alAttack,inst->mAttack);\r\n    alOut(m + alSus,inst->mSus);\r\n    alOut(m + alWave,inst->mWave);\r\n    alOut(c + alChar,inst->cChar);\r\n    alOut(c + alScale,inst->cScale);\r\n    alOut(c + alAttack,inst->cAttack);\r\n    alOut(c + alSus,inst->cSus);\r\n    alOut(c + alWave,inst->cWave);\r\n\r\n    // Note: Switch commenting on these lines for old MUSE compatibility\r\n//    alOutInIRQ(alFeedCon,inst->nConn);\r\n    alOut(alFeedCon,0);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SDL_ALPlaySound() - Plays the specified sound on the AdLib card\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_ALPlaySound(AdLibSound *sound)\r\n{\r\n    Instrument      *inst;\r\n    byte            *data;\r\n\r\n    SDL_ALStopSound();\r\n\r\n    alLengthLeft = sound->common.length;\r\n    data = sound->data;\r\n    alBlock = ((sound->block & 7) << 2) | 0x20;\r\n    inst = &sound->inst;\r\n\r\n    if (!(inst->mSus | inst->cSus))\r\n    {\r\n        Quit(\"SDL_ALPlaySound() - Bad instrument\");\r\n    }\r\n\r\n    SDL_AlSetFXInst(inst);\r\n    alSound = (byte *)data;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SDL_ShutAL() - Shuts down the AdLib card for sound effects\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_ShutAL(void)\r\n{\r\n    alSound = 0;\r\n    alOut(alEffects,0);\r\n    alOut(alFreqH + 0,0);\r\n    SDL_AlSetFXInst(&alZeroInst);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SDL_CleanAL() - Totally shuts down the AdLib card\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_CleanAL(void)\r\n{\r\n    int     i;\r\n\r\n    alOut(alEffects,0);\r\n    for (i = 1; i < 0xf5; i++)\r\n        alOut(i, 0);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SDL_StartAL() - Starts up the AdLib card for sound effects\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_StartAL(void)\r\n{\r\n    alOut(alEffects, 0);\r\n    SDL_AlSetFXInst(&alZeroInst);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SDL_DetectAdLib() - Determines if there's an AdLib (or SoundBlaster\r\n//              emulating an AdLib) present\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nSDL_DetectAdLib(void)\r\n{\r\n    for (int i = 1; i <= 0xf5; i++)       // Zero all the registers\r\n        alOut(i, 0);\r\n\r\n    alOut(1, 0x20);             // Set WSE=1\r\n//    alOut(8, 0);                // Set CSM=0 & SEL=0\r\n\r\n    return true;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SDL_ShutDevice() - turns off whatever device was being used for sound fx\r\n//\r\n////////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_ShutDevice(void)\r\n{\r\n    switch (SoundMode)\r\n    {\r\n        case sdm_PC:\r\n//            SDL_ShutPC();\r\n            break;\r\n        case sdm_AdLib:\r\n            SDL_ShutAL();\r\n            break;\r\n    }\r\n    SoundMode = sdm_Off;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SDL_CleanDevice() - totally shuts down all sound devices\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_CleanDevice(void)\r\n{\r\n    if ((SoundMode == sdm_AdLib) || (MusicMode == smm_AdLib))\r\n        SDL_CleanAL();\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SDL_StartDevice() - turns on whatever device is to be used for sound fx\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_StartDevice(void)\r\n{\r\n    switch (SoundMode)\r\n    {\r\n        case sdm_AdLib:\r\n            SDL_StartAL();\r\n            break;\r\n    }\r\n    SoundNumber = (soundnames) 0;\r\n    SoundPriority = 0;\r\n}\r\n\r\n//      Public routines\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SD_SetSoundMode() - Sets which sound hardware to use for sound effects\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nboolean\r\nSD_SetSoundMode(SDMode mode)\r\n{\r\n    boolean result = false;\r\n    word    tableoffset;\r\n\r\n    SD_StopSound();\r\n\r\n    if ((mode == sdm_AdLib) && !AdLibPresent)\r\n        mode = sdm_PC;\r\n\r\n    switch (mode)\r\n    {\r\n        case sdm_Off:\r\n            tableoffset = STARTADLIBSOUNDS;\r\n            result = true;\r\n            break;\r\n        case sdm_PC:\r\n            tableoffset = STARTPCSOUNDS;\r\n            result = true;\r\n            break;\r\n        case sdm_AdLib:\r\n            tableoffset = STARTADLIBSOUNDS;\r\n            if (AdLibPresent)\r\n                result = true;\r\n            break;\r\n        default:\r\n            Quit(\"SD_SetSoundMode: Invalid sound mode %i\", mode);\r\n            return false;\r\n    }\r\n    SoundTable = &audiosegs[tableoffset];\r\n\r\n    if (result && (mode != SoundMode))\r\n    {\r\n        SDL_ShutDevice();\r\n        SoundMode = mode;\r\n        SDL_StartDevice();\r\n    }\r\n\r\n    return(result);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SD_SetMusicMode() - sets the device to use for background music\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nboolean\r\nSD_SetMusicMode(SMMode mode)\r\n{\r\n    boolean result = false;\r\n\r\n    SD_FadeOutMusic();\r\n    while (SD_MusicPlaying())\r\n        SDL_Delay(5);\r\n\r\n    switch (mode)\r\n    {\r\n        case smm_Off:\r\n            result = true;\r\n            break;\r\n        case smm_AdLib:\r\n            if (AdLibPresent)\r\n                result = true;\r\n            break;\r\n    }\r\n\r\n    if (result)\r\n        MusicMode = mode;\r\n\r\n//    SDL_SetTimerSpeed();\r\n\r\n    return(result);\r\n}\r\n\r\nint numreadysamples = 0;\r\nbyte *curAlSound = 0;\r\nbyte *curAlSoundPtr = 0;\r\nlongword curAlLengthLeft = 0;\r\nint soundTimeCounter = 5;\r\nint samplesPerMusicTick;\r\n\r\nvoid SDL_IMFMusicPlayer(void *udata, Uint8 *stream, int len)\r\n{\r\n    int stereolen = len>>1;\r\n    int sampleslen = stereolen>>1;\r\n    INT16 *stream16 = (INT16 *) (void *) stream;    // expect correct alignment\r\n\r\n    while(1)\r\n    {\r\n        if(numreadysamples)\r\n        {\r\n            if(numreadysamples<sampleslen)\r\n            {\r\n                YM3812UpdateOne(0, stream16, numreadysamples);\r\n                stream16 += numreadysamples*2;\r\n                sampleslen -= numreadysamples;\r\n            }\r\n            else\r\n            {\r\n                YM3812UpdateOne(0, stream16, sampleslen);\r\n                numreadysamples -= sampleslen;\r\n                return;\r\n            }\r\n        }\r\n        soundTimeCounter--;\r\n        if(!soundTimeCounter)\r\n        {\r\n            soundTimeCounter = 5;\r\n            if(curAlSound != alSound)\r\n            {\r\n                curAlSound = curAlSoundPtr = alSound;\r\n                curAlLengthLeft = alLengthLeft;\r\n            }\r\n            if(curAlSound)\r\n            {\r\n                if(*curAlSoundPtr)\r\n                {\r\n                    alOut(alFreqL, *curAlSoundPtr);\r\n                    alOut(alFreqH, alBlock);\r\n                }\r\n                else alOut(alFreqH, 0);\r\n                curAlSoundPtr++;\r\n                curAlLengthLeft--;\r\n                if(!curAlLengthLeft)\r\n                {\r\n                    curAlSound = alSound = 0;\r\n                    SoundNumber = (soundnames) 0;\r\n                    SoundPriority = 0;\r\n                    alOut(alFreqH, 0);\r\n                }\r\n            }\r\n        }\r\n        if(sqActive)\r\n        {\r\n            do\r\n            {\r\n                if(sqHackTime > alTimeCount) break;\r\n                sqHackTime = alTimeCount + *(sqHackPtr+1);\r\n                alOut(*(byte *) sqHackPtr, *(((byte *) sqHackPtr)+1));\r\n                sqHackPtr += 2;\r\n                sqHackLen -= 4;\r\n            }\r\n            while(sqHackLen>0);\r\n            alTimeCount++;\r\n            if(!sqHackLen)\r\n            {\r\n                sqHackPtr = sqHack;\r\n                sqHackLen = sqHackSeqLen;\r\n                sqHackTime = 0;\r\n                alTimeCount = 0;\r\n            }\r\n        }\r\n        numreadysamples = samplesPerMusicTick;\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SD_Startup() - starts up the Sound Mgr\r\n//              Detects all additional sound hardware and installs my ISR\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nSD_Startup(void)\r\n{\r\n    int     i;\r\n\r\n    if (SD_Started)\r\n        return;\r\n\r\n    if(Mix_OpenAudio(param_samplerate, AUDIO_S16, 2, param_audiobuffer))\r\n    {\r\n        printf(\"Unable to open audio: %s\\n\", Mix_GetError());\r\n        return;\r\n    }\r\n\r\n    Mix_ReserveChannels(2);  // reserve player and boss weapon channels\r\n    Mix_GroupChannels(2, MIX_CHANNELS-1, 1); // group remaining channels\r\n\r\n    // Init music\r\n\r\n    samplesPerMusicTick = param_samplerate / 700;    // SDL_t0FastAsmService played at 700Hz\r\n\r\n    if(YM3812Init(1,3579545,param_samplerate))\r\n    {\r\n        printf(\"Unable to create virtual OPL!!\\n\");\r\n    }\r\n\r\n    for(i=1;i<0xf6;i++)\r\n        YM3812Write(0,i,0);\r\n\r\n    YM3812Write(0,1,0x20); // Set WSE=1\r\n//    YM3812Write(0,8,0); // Set CSM=0 & SEL=0       // already set in for statement\r\n\r\n    Mix_HookMusic(SDL_IMFMusicPlayer, 0);\r\n    Mix_ChannelFinished(SD_ChannelFinished);\r\n    AdLibPresent = true;\r\n    SoundBlasterPresent = true;\r\n\r\n    alTimeCount = 0;\r\n\r\n    SD_SetSoundMode(sdm_Off);\r\n    SD_SetMusicMode(smm_Off);\r\n\r\n    SDL_SetupDigi();\r\n\r\n    SD_Started = true;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SD_Shutdown() - shuts down the Sound Mgr\r\n//              Removes sound ISR and turns off whatever sound hardware was active\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nSD_Shutdown(void)\r\n{\r\n    if (!SD_Started)\r\n        return;\r\n\r\n    SD_MusicOff();\r\n    SD_StopSound();\r\n\r\n    for(int i = 0; i < STARTMUSIC - STARTDIGISOUNDS; i++)\r\n    {\r\n        if(SoundChunks[i]) Mix_FreeChunk(SoundChunks[i]);\r\n        if(SoundBuffers[i]) free(SoundBuffers[i]);\r\n    }\r\n\r\n    free(DigiList);\r\n\r\n    SD_Started = false;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SD_PositionSound() - Sets up a stereo imaging location for the next\r\n//              sound to be played. Each channel ranges from 0 to 15.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nSD_PositionSound(int leftvol,int rightvol)\r\n{\r\n    LeftPosition = leftvol;\r\n    RightPosition = rightvol;\r\n    nextsoundpos = true;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SD_PlaySound() - plays the specified sound on the appropriate hardware\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nboolean\r\nSD_PlaySound(soundnames sound)\r\n{\r\n    boolean         ispos;\r\n    SoundCommon     *s;\r\n    int             lp,rp;\r\n\r\n    lp = LeftPosition;\r\n    rp = RightPosition;\r\n    LeftPosition = 0;\r\n    RightPosition = 0;\r\n\r\n    ispos = nextsoundpos;\r\n    nextsoundpos = false;\r\n    printf(\"%s:%d\\n\", __func__, __LINE__);\r\n\r\n    if (sound == -1 || (DigiMode == sds_Off && SoundMode == sdm_Off))\r\n        return 0;\r\n\r\n    s = (SoundCommon *) SoundTable[sound];\r\n\r\n    if ((SoundMode != sdm_Off) && !s)\r\n            Quit(\"SD_PlaySound() - Uncached sound\");\r\n\r\n    if ((DigiMode != sds_Off) && (DigiMap[sound] != -1))\r\n    {\r\n        if ((DigiMode == sds_PC) && (SoundMode == sdm_PC))\r\n        {\r\n#ifdef NOTYET\r\n            if (s->priority < SoundPriority)\r\n                return 0;\r\n\r\n            SDL_PCStopSound();\r\n\r\n            SD_PlayDigitized(DigiMap[sound],lp,rp);\r\n            SoundPositioned = ispos;\r\n            SoundNumber = sound;\r\n            SoundPriority = s->priority;\r\n#else\r\n            return 0;\r\n#endif\r\n        }\r\n        else\r\n        {\r\n#ifdef NOTYET\r\n            if (s->priority < DigiPriority)\r\n                return(false);\r\n#endif\r\n\r\n            int digimapindex = 0;\r\n            // while(digimapindex < LASTSOUND) {\r\n            //     printf(\"DigiMap[%d]=%d\\n\", digimapindex, DigiMap[digimapindex]);\r\n            //     digimapindex++;\r\n            // }\r\n\r\n            // printf(\"SD_PlaySound sound=%d digi=%d\\n\", sound, DigiMap[sound]);\r\n            int channel = SD_PlayDigitized(DigiMap[sound], lp, rp);\r\n            SoundPositioned = ispos;\r\n            DigiNumber = sound;\r\n            DigiPriority = s->priority;\r\n            return channel + 1;\r\n        }\r\n\r\n        return(true);\r\n    }\r\n\r\n    if (SoundMode == sdm_Off)\r\n        return 0;\r\n\r\n    if (!s->length)\r\n        Quit(\"SD_PlaySound() - Zero length sound\");\r\n    if (s->priority < SoundPriority)\r\n        return 0;\r\n\r\n    switch (SoundMode)\r\n    {\r\n        case sdm_PC:\r\n//            SDL_PCPlaySound((PCSound *)s);\r\n            break;\r\n        case sdm_AdLib:\r\n            SDL_ALPlaySound((AdLibSound *)s);\r\n            break;\r\n    }\r\n\r\n    SoundNumber = sound;\r\n    SoundPriority = s->priority;\r\n\r\n    return 0;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SD_SoundPlaying() - returns the sound number that's playing, or 0 if\r\n//              no sound is playing\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nword\r\nSD_SoundPlaying(void)\r\n{\r\n    boolean result = false;\r\n\r\n    switch (SoundMode)\r\n    {\r\n        case sdm_PC:\r\n            result = pcSound? true : false;\r\n            break;\r\n        case sdm_AdLib:\r\n            result = alSound? true : false;\r\n            break;\r\n    }\r\n\r\n    if (result)\r\n        return(SoundNumber);\r\n    else\r\n        return(false);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SD_StopSound() - if a sound is playing, stops it\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nSD_StopSound(void)\r\n{\r\n    if (DigiPlaying)\r\n        SD_StopDigitized();\r\n\r\n    switch (SoundMode)\r\n    {\r\n        case sdm_PC:\r\n//            SDL_PCStopSound();\r\n            break;\r\n        case sdm_AdLib:\r\n            SDL_ALStopSound();\r\n            break;\r\n    }\r\n\r\n    SoundPositioned = false;\r\n\r\n    SDL_SoundFinished();\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SD_WaitSoundDone() - waits until the current sound is done playing\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nSD_WaitSoundDone(void)\r\n{\r\n    while (SD_SoundPlaying())\r\n        SDL_Delay(5);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SD_MusicOn() - turns on the sequencer\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nSD_MusicOn(void)\r\n{\r\n    sqActive = true;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SD_MusicOff() - turns off the sequencer and any playing notes\r\n//      returns the last music offset for music continue\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nint\r\nSD_MusicOff(void)\r\n{\r\n    word    i;\r\n\r\n    sqActive = false;\r\n    switch (MusicMode)\r\n    {\r\n        case smm_AdLib:\r\n            alOut(alEffects, 0);\r\n            for (i = 0;i < sqMaxTracks;i++)\r\n                alOut(alFreqH + i + 1, 0);\r\n            break;\r\n    }\r\n\r\n    return (int) (sqHackPtr-sqHack);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SD_StartMusic() - starts playing the music pointed to\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nSD_StartMusic(int chunk)\r\n{\r\n    SD_MusicOff();\r\n\r\n    if (MusicMode == smm_AdLib)\r\n    {\r\n        int32_t chunkLen = CA_CacheAudioChunk(chunk);\r\n        sqHack = (word *)(void *) audiosegs[chunk];     // alignment is correct\r\n        if(*sqHack == 0) sqHackLen = sqHackSeqLen = chunkLen;\r\n        else sqHackLen = sqHackSeqLen = *sqHack++;\r\n        sqHackPtr = sqHack;\r\n        sqHackTime = 0;\r\n        alTimeCount = 0;\r\n        SD_MusicOn();\r\n    }\r\n}\r\n\r\nvoid\r\nSD_ContinueMusic(int chunk, int startoffs)\r\n{\r\n    SD_MusicOff();\r\n\r\n    if (MusicMode == smm_AdLib)\r\n    {\r\n        int32_t chunkLen = CA_CacheAudioChunk(chunk);\r\n        sqHack = (word *)(void *) audiosegs[chunk];     // alignment is correct\r\n        if(*sqHack == 0) sqHackLen = sqHackSeqLen = chunkLen;\r\n        else sqHackLen = sqHackSeqLen = *sqHack++;\r\n        sqHackPtr = sqHack;\r\n\r\n        if(startoffs >= sqHackLen)\r\n        {\r\n            Quit(\"SD_StartMusic: Illegal startoffs provided!\");\r\n        }\r\n\r\n        // fast forward to correct position\r\n        // (needed to reconstruct the instruments)\r\n\r\n        for(int i = 0; i < startoffs; i += 2)\r\n        {\r\n            byte reg = *(byte *)sqHackPtr;\r\n            byte val = *(((byte *)sqHackPtr) + 1);\r\n            if(reg >= 0xb1 && reg <= 0xb8) val &= 0xdf;           // disable play note flag\r\n            else if(reg == 0xbd) val &= 0xe0;                     // disable drum flags\r\n\r\n            alOut(reg,val);\r\n            sqHackPtr += 2;\r\n            sqHackLen -= 4;\r\n        }\r\n        sqHackTime = 0;\r\n        alTimeCount = 0;\r\n\r\n        SD_MusicOn();\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SD_FadeOutMusic() - starts fading out the music. Call SD_MusicPlaying()\r\n//              to see if the fadeout is complete\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nSD_FadeOutMusic(void)\r\n{\r\n    switch (MusicMode)\r\n    {\r\n        case smm_AdLib:\r\n            // DEBUG - quick hack to turn the music off\r\n            SD_MusicOff();\r\n            break;\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      SD_MusicPlaying() - returns true if music is currently playing, false if\r\n//              not\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nboolean\r\nSD_MusicPlaying(void)\r\n{\r\n    boolean result;\r\n\r\n    switch (MusicMode)\r\n    {\r\n        case smm_AdLib:\r\n            result = sqActive;\r\n            break;\r\n        default:\r\n            result = false;\r\n            break;\r\n    }\r\n\r\n    return(result);\r\n}\r\n","#ifndef __ID_PM__\r\n#define __ID_PM__\r\n\r\n\r\n#define PMPageSize 4096\r\n\r\nextern int ChunksInFile;\r\nextern int PMSpriteStart;\r\nextern int PMSoundStart;\r\n\r\nextern bool PMSoundInfoPagePadded;\r\n\r\n// ChunksInFile+1 pointers to page starts.\r\n// The last pointer points one byte after the last page.\r\nextern uint8_t **PMPages;\r\n\r\nvoid PM_Startup();\r\nvoid PM_Shutdown();\r\n\r\nstatic inline uint32_t PM_GetPageSize(int page)\r\n{\r\n    if(page < 0 || page >= ChunksInFile)\r\n        Quit(\"PM_GetPageSize: Tried to access illegal page: %i\", page);\r\n    return (uint32_t) (PMPages[page + 1] - PMPages[page]);\r\n}\r\n\r\nstatic inline uint8_t *PM_GetPage(int page)\r\n{\r\n    if(page < 0 || page >= ChunksInFile)\r\n        Quit(\"PM_GetPage: Tried to access illegal page: %i\", page);\r\n    return PMPages[page];\r\n}\r\n\r\nstatic inline uint8_t *PM_GetEnd()\r\n{\r\n    return PMPages[ChunksInFile];\r\n}\r\n\r\nstatic inline byte *PM_GetTexture(int wallpic)\r\n{\r\n    return PM_GetPage(wallpic);\r\n}\r\n\r\nstatic inline uint16_t *PM_GetSprite(int shapenum)\r\n{\r\n    // correct alignment is enforced by PM_Startup()\r\n    return (uint16_t *) (void *) PM_GetPage(PMSpriteStart + shapenum);\r\n}\r\n\r\nstatic inline byte *PM_GetSound(int soundpagenum)\r\n{\r\n    return PM_GetPage(PMSoundStart + soundpagenum);\r\n}\r\n\r\n#endif\r\n","//\r\n//  ID Engine\r\n//  ID_US_1.c - User Manager - General routines\r\n//  v1.1d1\r\n//  By Jason Blochowiak\r\n//  Hacked up for Catacomb 3D\r\n//\r\n\r\n//\r\n//  This module handles dealing with user input & feedback\r\n//\r\n//  Depends on: Input Mgr, View Mgr, some variables from the Sound, Caching,\r\n//      and Refresh Mgrs, Memory Mgr for background save/restore\r\n//\r\n//  Globals:\r\n//      ingame - Flag set by game indicating if a game is in progress\r\n//      loadedgame - Flag set if a game was loaded\r\n//      PrintX, PrintY - Where the User Mgr will print (global coords)\r\n//      WindowX,WindowY,WindowW,WindowH - The dimensions of the current\r\n//          window\r\n//\r\n\r\n#include \"wl_def.h\"\r\n\r\n#pragma hdrstop\r\n\r\n#if _MSC_VER == 1200            // Visual C++ 6\r\n    #define vsnprintf _vsnprintf\r\n#endif\r\n\r\n//  Global variables\r\n        word        PrintX,PrintY;\r\n        word        WindowX,WindowY,WindowW,WindowH;\r\n\r\n//  Internal variables\r\n#define ConfigVersion   1\r\n\r\nstatic  boolean     US_Started;\r\n\r\n        void        (*USL_MeasureString)(const char *,word *,word *) = VW_MeasurePropString;\r\n        void        (*USL_DrawString)(const char *) = VWB_DrawPropString;\r\n\r\n        SaveGame    Games[MaxSaveGames];\r\n        HighScore   Scores[MaxScores] =\r\n                    {\r\n                        {\"id software-'92\",10000,1},\r\n                        {\"Adrian Carmack\",10000,1},\r\n                        {\"John Carmack\",10000,1},\r\n                        {\"Kevin Cloud\",10000,1},\r\n                        {\"Tom Hall\",10000,1},\r\n                        {\"John Romero\",10000,1},\r\n                        {\"Jay Wilbur\",10000,1},\r\n                    };\r\n\r\nint rndindex = 0;\r\n\r\nstatic byte rndtable[] = {\r\n      0,   8, 109, 220, 222, 241, 149, 107,  75, 248, 254, 140,  16,  66,\r\n     74,  21, 211,  47,  80, 242, 154,  27, 205, 128, 161,  89,  77,  36,\r\n     95, 110,  85,  48, 212, 140, 211, 249,  22,  79, 200,  50,  28, 188,\r\n     52, 140, 202, 120,  68, 145,  62,  70, 184, 190,  91, 197, 152, 224,\r\n    149, 104,  25, 178, 252, 182, 202, 182, 141, 197,   4,  81, 181, 242,\r\n    145,  42,  39, 227, 156, 198, 225, 193, 219,  93, 122, 175, 249,   0,\r\n    175, 143,  70, 239,  46, 246, 163,  53, 163, 109, 168, 135,   2, 235,\r\n     25,  92,  20, 145, 138,  77,  69, 166,  78, 176, 173, 212, 166, 113,\r\n     94, 161,  41,  50, 239,  49, 111, 164,  70,  60,   2,  37, 171,  75,\r\n    136, 156,  11,  56,  42, 146, 138, 229,  73, 146,  77,  61,  98, 196,\r\n    135, 106,  63, 197, 195,  86,  96, 203, 113, 101, 170, 247, 181, 113,\r\n     80, 250, 108,   7, 255, 237, 129, 226,  79, 107, 112, 166, 103, 241,\r\n     24, 223, 239, 120, 198,  58,  60,  82, 128,   3, 184,  66, 143, 224,\r\n    145, 224,  81, 206, 163,  45,  63,  90, 168, 114,  59,  33, 159,  95,\r\n     28, 139, 123,  98, 125, 196,  15,  70, 194, 253,  54,  14, 109, 226,\r\n     71,  17, 161,  93, 186,  87, 244, 138,  20,  52, 123, 251,  26,  36,\r\n     17,  46,  52, 231, 232,  76,  31, 221,  84,  37, 216, 165, 212, 106,\r\n    197, 242,  98,  43,  39, 175, 254, 145, 190,  84, 118, 222, 187, 136,\r\n    120, 163, 236, 249 };\r\n\r\n//  Internal routines\r\n\r\n//  Public routines\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  US_Startup() - Starts the User Mgr\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid US_Startup()\r\n{\r\n    if (US_Started)\r\n        return;\r\n\r\n    US_InitRndT(true);      // Initialize the random number generator\r\n\r\n    US_Started = true;\r\n}\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  US_Shutdown() - Shuts down the User Mgr\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_Shutdown(void)\r\n{\r\n    if (!US_Started)\r\n        return;\r\n\r\n    US_Started = false;\r\n}\r\n\r\n//  Window/Printing routines\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  US_SetPrintRoutines() - Sets the routines used to measure and print\r\n//      from within the User Mgr. Primarily provided to allow switching\r\n//      between masked and non-masked fonts\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_SetPrintRoutines(void (*measure)(const char *,word *,word *),\r\n    void (*print)(const char *))\r\n{\r\n    USL_MeasureString = measure;\r\n    USL_DrawString = print;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  US_Print() - Prints a string in the current window. Newlines are\r\n//      supported.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_Print(const char *sorg)\r\n{\r\n    char c;\r\n    char *sstart = strdup(sorg);\r\n    char *s = sstart;\r\n    char *se;\r\n    word w,h;\r\n\r\n    while (*s)\r\n    {\r\n        se = s;\r\n        while ((c = *se)!=0 && (c != '\\n'))\r\n            se++;\r\n        *se = '\\0';\r\n\r\n        USL_MeasureString(s,&w,&h);\r\n        px = PrintX;\r\n        py = PrintY;\r\n        USL_DrawString(s);\r\n\r\n        s = se;\r\n        if (c)\r\n        {\r\n            *se = c;\r\n            s++;\r\n\r\n            PrintX = WindowX;\r\n            PrintY += h;\r\n        }\r\n        else\r\n            PrintX += w;\r\n    }\r\n    free(sstart);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  US_PrintUnsigned() - Prints an unsigned long\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_PrintUnsigned(longword n)\r\n{\r\n    char    buffer[32];\r\n    sprintf(buffer, \"%lu\", n);\r\n\r\n    US_Print(buffer);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  US_PrintSigned() - Prints a signed long\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_PrintSigned(int32_t n)\r\n{\r\n    char    buffer[32];\r\n\r\n    US_Print(ltoa(n,buffer,10));\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  USL_PrintInCenter() - Prints a string in the center of the given rect\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUSL_PrintInCenter(const char *s,Rect r)\r\n{\r\n    word    w,h,\r\n            rw,rh;\r\n\r\n    USL_MeasureString(s,&w,&h);\r\n    rw = r.lr.x - r.ul.x;\r\n    rh = r.lr.y - r.ul.y;\r\n\r\n    px = r.ul.x + ((rw - w) / 2);\r\n    py = r.ul.y + ((rh - h) / 2);\r\n    USL_DrawString(s);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  US_PrintCentered() - Prints a string centered in the current window.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_PrintCentered(const char *s)\r\n{\r\n    Rect    r;\r\n\r\n    r.ul.x = WindowX;\r\n    r.ul.y = WindowY;\r\n    r.lr.x = r.ul.x + WindowW;\r\n    r.lr.y = r.ul.y + WindowH;\r\n\r\n    USL_PrintInCenter(s,r);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  US_CPrintLine() - Prints a string centered on the current line and\r\n//      advances to the next line. Newlines are not supported.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_CPrintLine(const char *s)\r\n{\r\n    word    w,h;\r\n\r\n    USL_MeasureString(s,&w,&h);\r\n\r\n    if (w > WindowW)\r\n        Quit(\"US_CPrintLine() - String exceeds width\");\r\n    px = WindowX + ((WindowW - w) / 2);\r\n    py = PrintY;\r\n    USL_DrawString(s);\r\n    PrintY += h;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  US_CPrint() - Prints a string centered in the current window.\r\n//      Newlines are supported.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_CPrint(const char *sorg)\r\n{\r\n    char    c;\r\n    char *sstart = strdup(sorg);\r\n    char *s = sstart;\r\n    char *se;\r\n\r\n    while (*s)\r\n    {\r\n        se = s;\r\n        while ((c = *se)!=0 && (c != '\\n'))\r\n            se++;\r\n        *se = '\\0';\r\n\r\n        US_CPrintLine(s);\r\n\r\n        s = se;\r\n        if (c)\r\n        {\r\n            *se = c;\r\n            s++;\r\n        }\r\n    }\r\n    free(sstart);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  US_Printf() - Prints a formatted string in the current window.\r\n//      Newlines are supported.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\n\r\nvoid US_Printf(const char *formatStr, ...)\r\n{\r\n    char strbuf[256];\r\n    va_list vlist;\r\n    va_start(vlist, formatStr);\r\n    int len = vsnprintf(strbuf, sizeof(strbuf), formatStr, vlist);\r\n    va_end(vlist);\r\n    if(len <= -1 || len >= sizeof(strbuf))\r\n        strbuf[sizeof(strbuf) - 1] = 0;\r\n    US_Print(strbuf);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  US_CPrintf() - Prints a formatted string centered in the current window.\r\n//      Newlines are supported.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\n\r\nvoid US_CPrintf(const char *formatStr, ...)\r\n{\r\n    char strbuf[256];\r\n    va_list vlist;\r\n    va_start(vlist, formatStr);\r\n    int len = vsnprintf(strbuf, sizeof(strbuf), formatStr, vlist);\r\n    va_end(vlist);\r\n    if(len <= -1 || len >= sizeof(strbuf))\r\n        strbuf[sizeof(strbuf) - 1] = 0;\r\n    US_CPrint(strbuf);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  US_ClearWindow() - Clears the current window to white and homes the\r\n//      cursor\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_ClearWindow(void)\r\n{\r\n    VWB_Bar(WindowX,WindowY,WindowW,WindowH,WHITE);\r\n    PrintX = WindowX;\r\n    PrintY = WindowY;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  US_DrawWindow() - Draws a frame and sets the current window parms\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_DrawWindow(word x,word y,word w,word h)\r\n{\r\n   \r\n    word    i,\r\n            sx,sy,sw,sh;\r\n\r\n    WindowX = x * 8;\r\n    WindowY = y * 8;\r\n    WindowW = w * 8;\r\n    WindowH = h * 8;\r\n\r\n    PrintX = WindowX;\r\n    PrintY = WindowY;\r\n\r\n    sx = (x - 1) * 8;\r\n    sy = (y - 1) * 8;\r\n    sw = (w + 1) * 8;\r\n    sh = (h + 1) * 8;\r\n\r\n    US_ClearWindow();\r\n\r\n    VWB_DrawTile8(sx,sy,0),VWB_DrawTile8(sx,sy + sh,5);\r\n    for (i = sx + 8;i <= sx + sw - 8;i += 8)\r\n        VWB_DrawTile8(i,sy,1),VWB_DrawTile8(i,sy + sh,6);\r\n    VWB_DrawTile8(i,sy,2),VWB_DrawTile8(i,sy + sh,7);\r\n\r\n    for (i = sy + 8;i <= sy + sh - 8;i += 8)\r\n        VWB_DrawTile8(sx,i,3),VWB_DrawTile8(sx + sw,i,4);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  US_SaveWindow() - Saves the current window parms into a record for\r\n//      later restoration\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_SaveWindow(WindowRec *win)\r\n{\r\n    win->x = WindowX;\r\n    win->y = WindowY;\r\n    win->w = WindowW;\r\n    win->h = WindowH;\r\n\r\n    win->px = PrintX;\r\n    win->py = PrintY;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  US_RestoreWindow() - Sets the current window parms to those held in the\r\n//      record\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_RestoreWindow(WindowRec *win)\r\n{\r\n    WindowX = win->x;\r\n    WindowY = win->y;\r\n    WindowW = win->w;\r\n    WindowH = win->h;\r\n\r\n    PrintX = win->px;\r\n    PrintY = win->py;\r\n}\r\n\r\n//  Input routines\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  USL_XORICursor() - XORs the I-bar text cursor. Used by US_LineInput()\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_XORICursor(int x,int y,const char *s,word cursor)\r\n{\r\n    static  boolean status;     // VGA doesn't XOR...\r\n    char    buf[MaxString];\r\n    int     temp;\r\n    word    w,h;\r\n\r\n    strcpy(buf,s);\r\n    buf[cursor] = '\\0';\r\n    USL_MeasureString(buf,&w,&h);\r\n\r\n    px = x + w - 1;\r\n    py = y;\r\n    if (status^=1)\r\n        USL_DrawString(\"\\x80\");\r\n    else\r\n    {\r\n        temp = fontcolor;\r\n        fontcolor = backcolor;\r\n        USL_DrawString(\"\\x80\");\r\n        fontcolor = temp;\r\n    }\r\n}\r\n\r\nchar USL_RotateChar(char ch, int dir)\r\n{\r\n    static const char charSet[] = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ.,-!?0123456789\";\r\n    const int numChars = sizeof(charSet) / sizeof(char) - 1;\r\n    int i;\r\n    for(i = 0; i < numChars; i++)\r\n    {\r\n        if(ch == charSet[i]) break;\r\n    }\r\n\r\n    if(i == numChars) i = 0;\r\n\r\n    i += dir;\r\n    if(i < 0) i = numChars - 1;\r\n    else if(i >= numChars) i = 0;\r\n    return charSet[i];\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//  US_LineInput() - Gets a line of user input at (x,y), the string defaults\r\n//      to whatever is pointed at by def. Input is restricted to maxchars\r\n//      chars or maxwidth pixels wide. If the user hits escape (and escok is\r\n//      true), nothing is copied into buf, and false is returned. If the\r\n//      user hits return, the current string is copied into buf, and true is\r\n//      returned\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nboolean\r\nUS_LineInput(int x,int y,char *buf,const char *def,boolean escok,\r\n                int maxchars,int maxwidth)\r\n{\r\n    boolean     redraw,\r\n                cursorvis,cursormoved,\r\n                done,result, checkkey;\r\n    ScanCode    sc;\r\n    char        c;\r\n    char        s[MaxString],olds[MaxString];\r\n    int         cursor,len;\r\n    word        i,\r\n                w,h,\r\n                temp;\r\n    longword    curtime, lasttime, lastdirtime, lastbuttontime, lastdirmovetime;\r\n    ControlInfo ci;\r\n    Direction   lastdir = dir_None;\r\n\r\n    if (def)\r\n        strcpy(s,def);\r\n    else\r\n        *s = '\\0';\r\n    *olds = '\\0';\r\n    cursor = (int) strlen(s);\r\n    cursormoved = redraw = true;\r\n\r\n    cursorvis = done = false;\r\n    lasttime = lastdirtime = lastdirmovetime = GetTimeCount();\r\n    lastbuttontime = lasttime + TickBase / 4;   // 250 ms => first button press accepted after 500 ms\r\n    LastASCII = key_None;\r\n    LastScan = sc_None;\r\n\r\n    while (!done)\r\n    {\r\n        ReadAnyControl(&ci);\r\n\r\n        if (cursorvis)\r\n            USL_XORICursor(x,y,s,cursor);\r\n\r\n        sc = LastScan;\r\n        LastScan = sc_None;\r\n        c = LastASCII;\r\n        LastASCII = key_None;\r\n\r\n        checkkey = true;\r\n        curtime = GetTimeCount();\r\n\r\n        // After each direction change accept the next change after 250 ms and then everz 125 ms\r\n        if(ci.dir != lastdir || curtime - lastdirtime > TickBase / 4 && curtime - lastdirmovetime > TickBase / 8)\r\n        {\r\n            if(ci.dir != lastdir)\r\n            {\r\n                lastdir = ci.dir;\r\n                lastdirtime = curtime;\r\n            }\r\n            lastdirmovetime = curtime;\r\n\r\n            switch(ci.dir)\r\n            {\r\n                case dir_West:\r\n                    if(cursor)\r\n                    {\r\n                        // Remove trailing whitespace if cursor is at end of string\r\n                        if(s[cursor] == ' ' && s[cursor + 1] == 0)\r\n                            s[cursor] = 0;\r\n                        cursor--;\r\n                    }\r\n                    cursormoved = true;\r\n                    checkkey = false;\r\n                    break;\r\n                case dir_East:\r\n                    if(cursor >= MaxString - 1) break;\r\n\r\n                    if(!s[cursor])\r\n                    {\r\n                        USL_MeasureString(s,&w,&h);\r\n                        if(len >= maxchars || maxwidth && w >= maxwidth) break;\r\n\r\n                        s[cursor] = ' ';\r\n                        s[cursor + 1] = 0;\r\n                    }\r\n                    cursor++;\r\n                    cursormoved = true;\r\n                    checkkey = false;\r\n                    break;\r\n\r\n                case dir_North:\r\n                    if(!s[cursor])\r\n                    {\r\n                        USL_MeasureString(s,&w,&h);\r\n                        if(len >= maxchars || maxwidth && w >= maxwidth) break;\r\n                        s[cursor + 1] = 0;\r\n                    }\r\n                    s[cursor] = USL_RotateChar(s[cursor], 1);\r\n                    redraw = true;\r\n                    checkkey = false;\r\n                    break;\r\n\r\n                case dir_South:\r\n                    if(!s[cursor])\r\n                    {\r\n                        USL_MeasureString(s,&w,&h);\r\n                        if(len >= maxchars || maxwidth && w >= maxwidth) break;\r\n                        s[cursor + 1] = 0;\r\n                    }\r\n                    s[cursor] = USL_RotateChar(s[cursor], -1);\r\n                    redraw = true;\r\n                    checkkey = false;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if((int)(curtime - lastbuttontime) > TickBase / 4)   // 250 ms\r\n        {\r\n            if(ci.button0)             // acts as return\r\n            {\r\n                strcpy(buf,s);\r\n                done = true;\r\n                result = true;\r\n                checkkey = false;\r\n            }\r\n            if(ci.button1 && escok)    // acts as escape\r\n            {\r\n                done = true;\r\n                result = false;\r\n                checkkey = false;\r\n            }\r\n            if(ci.button2)             // acts as backspace\r\n            {\r\n                lastbuttontime = curtime;\r\n                if(cursor)\r\n                {\r\n                    strcpy(s + cursor - 1,s + cursor);\r\n                    cursor--;\r\n                    redraw = true;\r\n                }\r\n                cursormoved = true;\r\n                checkkey = false;\r\n            }\r\n        }\r\n\r\n        if(checkkey)\r\n        {\r\n            switch (sc)\r\n            {\r\n                case sc_LeftArrow:\r\n                    if (cursor)\r\n                        cursor--;\r\n                    c = key_None;\r\n                    cursormoved = true;\r\n                    break;\r\n                case sc_RightArrow:\r\n                    if (s[cursor])\r\n                        cursor++;\r\n                    c = key_None;\r\n                    cursormoved = true;\r\n                    break;\r\n                case sc_Home:\r\n                    cursor = 0;\r\n                    c = key_None;\r\n                    cursormoved = true;\r\n                    break;\r\n                case sc_End:\r\n                    cursor = (int) strlen(s);\r\n                    c = key_None;\r\n                    cursormoved = true;\r\n                    break;\r\n\r\n                case sc_Return:\r\n                    strcpy(buf,s);\r\n                    done = true;\r\n                    result = true;\r\n                    c = key_None;\r\n                    break;\r\n                case sc_Escape:\r\n                    if (escok)\r\n                    {\r\n                        done = true;\r\n                        result = false;\r\n                    }\r\n                    c = key_None;\r\n                    break;\r\n\r\n                case sc_BackSpace:\r\n                    if (cursor)\r\n                    {\r\n                        strcpy(s + cursor - 1,s + cursor);\r\n                        cursor--;\r\n                        redraw = true;\r\n                    }\r\n                    c = key_None;\r\n                    cursormoved = true;\r\n                    break;\r\n                case sc_Delete:\r\n                    if (s[cursor])\r\n                    {\r\n                        strcpy(s + cursor,s + cursor + 1);\r\n                        redraw = true;\r\n                    }\r\n                    c = key_None;\r\n                    cursormoved = true;\r\n                    break;\r\n\r\n                case SDLK_KP5: //0x4c:  // Keypad 5 // TODO: hmmm...\r\n                case sc_UpArrow:\r\n                case sc_DownArrow:\r\n                case sc_PgUp:\r\n                case sc_PgDn:\r\n                case sc_Insert:\r\n                    c = key_None;\r\n                    break;\r\n            }\r\n\r\n            if (c)\r\n            {\r\n                len = (int) strlen(s);\r\n                USL_MeasureString(s,&w,&h);\r\n\r\n                if(isprint(c) && (len < MaxString - 1) && ((!maxchars) || (len < maxchars))\r\n                    && ((!maxwidth) || (w < maxwidth)))\r\n                {\r\n                    for (i = len + 1;i > cursor;i--)\r\n                        s[i] = s[i - 1];\r\n                    s[cursor++] = c;\r\n                    redraw = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (redraw)\r\n        {\r\n            px = x;\r\n            py = y;\r\n            temp = fontcolor;\r\n            fontcolor = backcolor;\r\n            USL_DrawString(olds);\r\n            fontcolor = (byte) temp;\r\n            strcpy(olds,s);\r\n\r\n            px = x;\r\n            py = y;\r\n            USL_DrawString(s);\r\n\r\n            redraw = false;\r\n        }\r\n\r\n        if (cursormoved)\r\n        {\r\n            cursorvis = false;\r\n            lasttime = curtime - TickBase;\r\n\r\n            cursormoved = false;\r\n        }\r\n        if (curtime - lasttime > TickBase / 2)    // 500 ms\r\n        {\r\n            lasttime = curtime;\r\n\r\n            cursorvis ^= true;\r\n        }\r\n        else SDL_Delay(5);\r\n        if (cursorvis)\r\n            USL_XORICursor(x,y,s,cursor);\r\n\r\n        VW_UpdateScreen();\r\n    }\r\n\r\n    if (cursorvis)\r\n        USL_XORICursor(x,y,s,cursor);\r\n    if (!result)\r\n    {\r\n        px = x;\r\n        py = y;\r\n        USL_DrawString(olds);\r\n    }\r\n    VW_UpdateScreen();\r\n\r\n    IN_ClearKeysDown();\r\n    return(result);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n// US_InitRndT - Initializes the pseudo random number generator.\r\n//      If randomize is true, the seed will be initialized depending on the\r\n//      current time\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid US_InitRndT(int randomize)\r\n{\r\n    if(randomize)\r\n        rndindex = (SDL_GetTicks() >> 4) & 0xff;\r\n    else\r\n        rndindex = 0;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n// US_RndT - Returns the next 8-bit pseudo random number\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nint US_RndT()\r\n{\r\n    rndindex = (rndindex+1)&0xff;\r\n    return rndtable[rndindex];\r\n}\r\n","#include \"wl_def.h\"\r\n#include \"id_vl.h\"\r\n\r\n\r\npictabletype    *pictable;\r\nSDL_Surface     *latchpics[NUMLATCHPICS];\r\n\r\nint     px,py;\r\nbyte    fontcolor,backcolor;\r\nint     fontnumber;\r\n\r\n//==========================================================================\r\n\r\nvoid VWB_DrawPropString(const char* string)\r\n{\r\n    fontstruct  *font;\r\n    int         width, step, height;\r\n    byte        *source, *dest;\r\n    byte        ch;\r\n\r\n    byte *vbuf = LOCK();\r\n\r\n    font = (fontstruct *) grsegs[STARTFONT+fontnumber];\r\n    height = font->height;\r\n    dest = vbuf + scaleFactor * (py * curPitch + px);\r\n\r\n    while ((ch = (byte)*string++)!=0)\r\n    {\r\n        width = step = font->width[ch];\r\n        source = ((byte *)font)+font->location[ch];\r\n        while (width--)\r\n        {\r\n            for(int i=0;i<height;i++)\r\n            {\r\n                if(source[i*step])\r\n                {\r\n                    for(unsigned sy=0; sy<scaleFactor; sy++)\r\n                        for(unsigned sx=0; sx<scaleFactor; sx++)\r\n                            dest[(scaleFactor*i+sy)*curPitch+sx]=fontcolor;\r\n                }\r\n            }\r\n\r\n            source++;\r\n            px++;\r\n            dest+=scaleFactor;\r\n        }\r\n    }\r\n\r\n    UNLOCK();\r\n}\r\n\r\n/*\r\n=================\r\n=\r\n= VL_MungePic\r\n=\r\n=================\r\n*/\r\n\r\nvoid VL_MungePic (byte *source, unsigned width, unsigned height)\r\n{\r\n    unsigned x,y,plane,size,pwidth;\r\n    byte *temp, *dest, *srcline;\r\n\r\n    size = width*height;\r\n\r\n    if (width&3)\r\n        Quit (\"VL_MungePic: Not divisable by 4!\");\r\n\r\n//\r\n// copy the pic to a temp buffer\r\n//\r\n    temp=(byte *) malloc(size);\r\n    CHECKMALLOCRESULT(temp);\r\n    memcpy (temp,source,size);\r\n\r\n//\r\n// munge it back into the original buffer\r\n//\r\n    dest = source;\r\n    pwidth = width/4;\r\n\r\n    for (plane=0;plane<4;plane++)\r\n    {\r\n        srcline = temp;\r\n        for (y=0;y<height;y++)\r\n        {\r\n            for (x=0;x<pwidth;x++)\r\n                *dest++ = *(srcline+x*4+plane);\r\n            srcline+=width;\r\n        }\r\n    }\r\n\r\n    free(temp);\r\n}\r\n\r\nvoid VWL_MeasureString (const char *string, word *width, word *height, fontstruct *font)\r\n{\r\n    *height = font->height;\r\n    for (*width = 0;*string;string++)\r\n        *width += font->width[*((byte *)string)];   // proportional width\r\n}\r\n\r\nvoid VW_MeasurePropString (const char *string, word *width, word *height)\r\n{\r\n    VWL_MeasureString(string,width,height,(fontstruct *)grsegs[STARTFONT+fontnumber]);\r\n}\r\n\r\n/*\r\n=============================================================================\r\n\r\n                Double buffer management routines\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid VH_UpdateScreen()\r\n{\r\n#ifdef __EMSCRIPTEN__\r\n    Em_BlitToScreen();\r\n#else\r\n    SDL_BlitSurface(screenBuffer, NULL, screen, NULL);\r\n#endif\r\n\r\n    SDL_Flip(screen);\r\n}\r\n\r\n\r\nvoid VWB_DrawTile8 (int x, int y, int tile)\r\n{\r\n    LatchDrawChar(x,y,tile);\r\n}\r\n\r\nvoid VWB_DrawTile8M (int x, int y, int tile)\r\n{\r\n    VL_MemToScreen (((byte *)grsegs[STARTTILE8M])+tile*64,8,8,x,y);\r\n}\r\n\r\nvoid VWB_DrawPic (int x, int y, int chunknum)\r\n{\r\n    int picnum = chunknum - STARTPICS;\r\n    unsigned width,height;\r\n\r\n    x &= ~7;\r\n\r\n    width = pictable[picnum].width;\r\n    height = pictable[picnum].height;\r\n\r\n    VL_MemToScreen (grsegs[chunknum],width,height,x,y);\r\n}\r\n\r\nvoid VWB_DrawPicScaledCoord (int scx, int scy, int chunknum)\r\n{\r\n    int picnum = chunknum - STARTPICS;\r\n    unsigned width,height;\r\n\r\n    width = pictable[picnum].width;\r\n    height = pictable[picnum].height;\r\n\r\n    VL_MemToScreenScaledCoord (grsegs[chunknum],width,height,scx,scy);\r\n}\r\n\r\n\r\nvoid VWB_Bar (int x, int y, int width, int height, int color)\r\n{\r\n    VW_Bar (x,y,width,height,color);\r\n}\r\n\r\nvoid VWB_Plot (int x, int y, int color)\r\n{\r\n    if(scaleFactor == 1)\r\n        VW_Plot(x,y,color);\r\n    else\r\n        VW_Bar(x, y, 1, 1, color);\r\n}\r\n\r\nvoid VWB_Hlin (int x1, int x2, int y, int color)\r\n{\r\n    if(scaleFactor == 1)\r\n        VW_Hlin(x1,x2,y,color);\r\n    else\r\n        VW_Bar(x1, y, x2-x1+1, 1, color);\r\n}\r\n\r\nvoid VWB_Vlin (int y1, int y2, int x, int color)\r\n{\r\n    if(scaleFactor == 1)\r\n        VW_Vlin(y1,y2,x,color);\r\n    else\r\n        VW_Bar(x, y1, 1, y2-y1+1, color);\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                        WOLFENSTEIN STUFF\r\n\r\n=============================================================================\r\n*/\r\n\r\n/*\r\n=====================\r\n=\r\n= LatchDrawPic\r\n=\r\n=====================\r\n*/\r\n\r\nvoid LatchDrawPic (unsigned x, unsigned y, unsigned picnum)\r\n{\r\n    VL_LatchToScreen (latchpics[2+picnum-LATCHPICS_LUMP_START], x*8, y);\r\n}\r\n\r\nvoid LatchDrawPicScaledCoord (unsigned scx, unsigned scy, unsigned picnum)\r\n{\r\n    VL_LatchToScreenScaledCoord (latchpics[2+picnum-LATCHPICS_LUMP_START], scx*8, scy);\r\n}\r\n\r\n\r\n//==========================================================================\r\n\r\n/*\r\n===================\r\n=\r\n= LoadLatchMem\r\n=\r\n===================\r\n*/\r\n\r\nvoid LoadLatchMem (void)\r\n{\r\n    int i,width,height,start,end;\r\n    byte *src;\r\n    SDL_Surface *surf;\r\n\r\n//\r\n// tile 8s\r\n//\r\n    \r\n    surf = SDL_CreateRGBSurface(SDL_SWSURFACE, 8*8,\r\n        ((NUMTILE8 + 7) / 8) * 8, 8, 0, 0, 0, 0);\r\n    if(surf == NULL)\r\n    {\r\n        Quit(\"Unable to create surface for tiles!\");\r\n    }\r\n    SDL_SetColors(surf, gamepal, 0, 256);\r\n\r\n    latchpics[0] = surf;\r\n    CA_CacheGrChunk (STARTTILE8);\r\n    src = grsegs[STARTTILE8];\r\n\r\n    for (i=0;i<NUMTILE8;i++)\r\n    {\r\n        VL_MemToLatch (src, 8, 8, surf, (i & 7) * 8, (i >> 3) * 8);\r\n        src += 64;\r\n    }\r\n    UNCACHEGRCHUNK (STARTTILE8);\r\n\r\n//\r\n// pics\r\n//\r\n    start = LATCHPICS_LUMP_START;\r\n    end = LATCHPICS_LUMP_END;\r\n\r\n    for (i=start;i<=end;i++)\r\n    {\r\n        width = pictable[i-STARTPICS].width;\r\n        height = pictable[i-STARTPICS].height;\r\n        surf = SDL_CreateRGBSurface(SDL_SWSURFACE, width, height, 8, 0, 0, 0, 0);\r\n        if(surf == NULL)\r\n        {\r\n            Quit(\"Unable to create surface for picture!\");\r\n        }\r\n        SDL_SetColors(surf, gamepal, 0, 256);\r\n\r\n        latchpics[2+i-start] = surf;\r\n        CA_CacheGrChunk (i);\r\n        VL_MemToLatch (grsegs[i], width, height, surf, 0, 0);\r\n        UNCACHEGRCHUNK(i);\r\n    }\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n===================\r\n=\r\n= FizzleFade\r\n=\r\n= returns true if aborted\r\n=\r\n= It uses maximum-length Linear Feedback Shift Registers (LFSR) counters.\r\n= You can find a list of them with lengths from 3 to 168 at:\r\n= http://www.xilinx.com/support/documentation/application_notes/xapp052.pdf\r\n= Many thanks to Xilinx for this list!!!\r\n=\r\n===================\r\n*/\r\n\r\n// XOR masks for the pseudo-random number sequence starting with n=17 bits\r\nstatic const uint32_t rndmasks[] = {\r\n                    // n    XNOR from (starting at 1, not 0 as usual)\r\n    0x00012000,     // 17   17,14\r\n    0x00020400,     // 18   18,11\r\n    0x00040023,     // 19   19,6,2,1\r\n    0x00090000,     // 20   20,17\r\n    0x00140000,     // 21   21,19\r\n    0x00300000,     // 22   22,21\r\n    0x00420000,     // 23   23,18\r\n    0x00e10000,     // 24   24,23,22,17\r\n    0x01200000,     // 25   25,22      (this is enough for 8191x4095)\r\n};\r\n\r\nstatic unsigned int rndbits_y;\r\nstatic unsigned int rndmask;\r\n\r\nextern SDL_Color curpal[256];\r\n\r\n// Returns the number of bits needed to represent the given value\r\nstatic int log2_ceil(uint32_t x)\r\n{\r\n    int n = 0;\r\n    uint32_t v = 1;\r\n    while(v < x)\r\n    {\r\n        n++;\r\n        v <<= 1;\r\n    }\r\n    return n;\r\n}\r\n\r\nvoid VH_Startup()\r\n{\r\n    int rndbits_x = log2_ceil(screenWidth);\r\n    rndbits_y = log2_ceil(screenHeight);\r\n\r\n    int rndbits = rndbits_x + rndbits_y;\r\n    if(rndbits < 17)\r\n        rndbits = 17;       // no problem, just a bit slower\r\n    else if(rndbits > 25)\r\n        rndbits = 25;       // fizzle fade will not fill whole screen\r\n\r\n    rndmask = rndmasks[rndbits - 17];\r\n}\r\n\r\nboolean FizzleFade (SDL_Surface *source, int x1, int y1,\r\n    unsigned width, unsigned height, unsigned frames, boolean abortable)\r\n{\r\n\r\n    unsigned x, y, frame, pixperframe;\r\n    int32_t  rndval, lastrndval;\r\n    int      first = 1;\r\n\r\n    lastrndval = 0;\r\n    pixperframe = width * height / frames;\r\n\r\n    IN_StartAck ();\r\n\r\n    frame = GetTimeCount();\r\n\r\n    //can't rely on screen as dest b/c crt.cpp writes over it with screenBuffer\r\n    //can't rely on screenBuffer as source for same reason: every flip it has to be updated\r\n    SDL_Surface *source_copy = SDL_ConvertSurface(source, source->format, source->flags);\r\n    SDL_Surface *screen_copy = SDL_ConvertSurface(screen, screen->format, screen->flags);\r\n\r\n    byte *srcptr = VL_LockSurface(source_copy);\r\n    do\r\n    {\r\n        if(abortable && IN_CheckAck ())\r\n        {\r\n            VL_UnlockSurface(source_copy);\r\n            SDL_BlitSurface(screen_copy, NULL, screenBuffer, NULL);\r\n#ifdef __EMSCRIPTEN__\r\n            Em_BlitToScreen();\r\n#else\r\n            SDL_BlitSurface(screenBuffer, NULL, screen, NULL);\r\n#endif\r\n\r\n            SDL_Flip(screen);\r\n            SDL_FreeSurface(source_copy);\r\n            SDL_FreeSurface(screen_copy);\r\n            return true;\r\n        }\r\n\r\n        byte *destptr = VL_LockSurface(screen_copy);\r\n\r\n        rndval = lastrndval;\r\n\r\n        // When using double buffering, we have to copy the pixels of the last AND the current frame.\r\n        // Only for the first frame, there is no \"last frame\"\r\n        for(int i = first; i < 2; i++)\r\n        {\r\n            for(unsigned p = 0; p < pixperframe; p++)\r\n            {\r\n                //\r\n                // seperate random value into x/y pair\r\n                //\r\n\r\n                x = rndval >> rndbits_y;\r\n                y = rndval & ((1 << rndbits_y) - 1);\r\n\r\n                //\r\n                // advance to next random element\r\n                //\r\n\r\n                rndval = (rndval >> 1) ^ (rndval & 1 ? 0 : rndmask);\r\n\r\n                if(x >= width || y >= height)\r\n                {\r\n                    if(rndval == 0)     // entire sequence has been completed\r\n                        goto finished;\r\n                    p--;\r\n                    continue;\r\n                }\r\n\r\n                //\r\n                // copy one pixel\r\n                //\r\n\r\n                if(screenBits == 8)\r\n                {\r\n                    *(destptr + (y1 + y) * screen->pitch + x1 + x)\r\n                        = *(srcptr + (y1 + y) * source->pitch + x1 + x);\r\n                }\r\n                else\r\n                {\r\n                    byte col = *(srcptr + (y1 + y) * source->pitch + x1 + x);\r\n                    uint32_t fullcol = SDL_MapRGB(screen->format, curpal[col].r, curpal[col].g, curpal[col].b);\r\n                    memcpy(destptr + (y1 + y) * screen->pitch + (x1 + x) * screen->format->BytesPerPixel,\r\n                        &fullcol, screen->format->BytesPerPixel);\r\n                }\r\n\r\n                if(rndval == 0)     // entire sequence has been completed\r\n                    goto finished;\r\n            }\r\n\r\n            if(!i || first) lastrndval = rndval;\r\n        }\r\n\r\n        // If there is no double buffering, we always use the \"first frame\" case\r\n        if(usedoublebuffering) first = 0;\r\n\r\n        VL_UnlockSurface(screen_copy);\r\n        SDL_BlitSurface(screen_copy, NULL, screenBuffer, NULL);\r\n#ifdef __EMSCRIPTEN__\r\n        Em_BlitToScreen();\r\n#else\r\n        SDL_BlitSurface(screenBuffer, NULL, screen, NULL);\r\n#endif\r\n\r\n        SDL_Flip(screen);\r\n\r\n        frame++;\r\n        Delay(frame - GetTimeCount());        // don't go too fast\r\n    } while (1);\r\n\r\nfinished:\r\n    VL_UnlockSurface(source_copy);\r\n    VL_UnlockSurface(screen_copy);\r\n    SDL_BlitSurface(screen_copy, NULL, screenBuffer, NULL);\r\n#ifdef __EMSCRIPTEN__\r\n    Em_BlitToScreen();\r\n#else\r\n    SDL_BlitSurface(screenBuffer, NULL, screen, NULL);\r\n#endif\r\n\r\n    SDL_Flip(screen);\r\n    SDL_FreeSurface(source_copy);\r\n    SDL_FreeSurface(screen_copy);\r\n    return false;\r\n}\r\n","// ID_VL.H\r\n\r\n// wolf compatability\r\n\r\n// Win32\r\n//#ifndef ID_VL.H \r\n//#define ID_VL.H\r\n#ifndef ID_VL_H \r\n#define ID_VL_H\r\n\r\n#include \"wl_def.h\"\r\n\r\nvoid Quit (const char *error,...);\r\n\r\n//===========================================================================\r\n\r\n#define CHARWIDTH       2\r\n#define TILEWIDTH       4\r\n\r\n//===========================================================================\r\n\r\nextern SDL_Surface *screen, *screenBuffer, *curSurface;\r\n\r\nextern  boolean  fullscreen, usedoublebuffering;\r\nextern  unsigned screenWidth, screenHeight, screenBits, screenPitch, bufferPitch, curPitch;\r\nextern  unsigned scaleFactor;\r\n\r\nextern  boolean  screenfaded;\r\nextern  unsigned bordercolor;\r\n\r\nextern SDL_Color gamepal[256];\r\n\r\n//===========================================================================\r\n\r\n//\r\n// VGA hardware routines\r\n//\r\n\r\n#define VL_WaitVBL(a) SDL_Delay((a)*8)\r\n\r\nvoid VL_SetVGAPlaneMode (void);\r\nvoid VL_SetTextMode (void);\r\nvoid VL_Shutdown (void);\r\n\r\nvoid VL_ConvertPalette(byte *srcpal, SDL_Color *destpal, int numColors);\r\nvoid VL_FillPalette (int red, int green, int blue);\r\nvoid VL_SetColor    (int color, int red, int green, int blue);\r\nvoid VL_GetColor    (int color, int *red, int *green, int *blue);\r\nvoid VL_SetPalette  (SDL_Color *palette, bool forceupdate);\r\nvoid VL_GetPalette  (SDL_Color *palette);\r\nvoid VL_FadeOut     (int start, int end, int red, int green, int blue, int steps);\r\nvoid VL_FadeIn      (int start, int end, SDL_Color *palette, int steps);\r\n\r\nbyte *VL_LockSurface(SDL_Surface *surface);\r\nvoid VL_UnlockSurface(SDL_Surface *surface);\r\n\r\n#define LOCK() VL_LockSurface(curSurface)\r\n#define UNLOCK() VL_UnlockSurface(curSurface)\r\n\r\nbyte VL_GetPixel        (int x, int y);\r\nvoid VL_Plot            (int x, int y, int color);\r\nvoid VL_Hlin            (unsigned x, unsigned y, unsigned width, int color);\r\nvoid VL_Vlin            (int x, int y, int height, int color);\r\nvoid VL_BarScaledCoord  (int scx, int scy, int scwidth, int scheight, int color);\r\nvoid inline VL_Bar      (int x, int y, int width, int height, int color)\r\n{\r\n    VL_BarScaledCoord(scaleFactor*x, scaleFactor*y,\r\n        scaleFactor*width, scaleFactor*height, color);\r\n}\r\nvoid inline VL_ClearScreen(int color)\r\n{\r\n    SDL_FillRect(curSurface, NULL, color);\r\n}\r\n\r\nvoid VL_MungePic                (byte *source, unsigned width, unsigned height);\r\nvoid VL_DrawPicBare             (int x, int y, byte *pic, int width, int height);\r\nvoid VL_MemToLatch              (byte *source, int width, int height,\r\n                                    SDL_Surface *destSurface, int x, int y);\r\nvoid VL_ScreenToScreen          (SDL_Surface *source, SDL_Surface *dest);\r\nvoid VL_MemToScreenScaledCoord  (byte *source, int width, int height, int scx, int scy);\r\nvoid VL_MemToScreenScaledCoord  (byte *source, int origwidth, int origheight, int srcx, int srcy,\r\n                                    int destx, int desty, int width, int height);\r\n\r\nvoid inline VL_MemToScreen (byte *source, int width, int height, int x, int y)\r\n{\r\n    VL_MemToScreenScaledCoord(source, width, height, scaleFactor*x, scaleFactor*y);\r\n}\r\n\r\nvoid VL_MaskedToScreen (byte *source, int width, int height, int x, int y);\r\n\r\nvoid VL_LatchToScreenScaledCoord (SDL_Surface *source, int xsrc, int ysrc,\r\n    int width, int height, int scxdest, int scydest);\r\n\r\nvoid inline VL_LatchToScreen (SDL_Surface *source, int xsrc, int ysrc,\r\n    int width, int height, int xdest, int ydest)\r\n{\r\n    VL_LatchToScreenScaledCoord(source,xsrc,ysrc,width,height,\r\n        scaleFactor*xdest,scaleFactor*ydest);\r\n}\r\nvoid inline VL_LatchToScreenScaledCoord (SDL_Surface *source, int scx, int scy)\r\n{\r\n    VL_LatchToScreenScaledCoord(source,0,0,source->w,source->h,scx,scy);\r\n}\r\nvoid inline VL_LatchToScreen (SDL_Surface *source, int x, int y)\r\n{\r\n    VL_LatchToScreenScaledCoord(source,0,0,source->w,source->h,\r\n        scaleFactor*x,scaleFactor*y);\r\n}\r\n\r\nvoid Em_BlitToScreen();\r\n\r\n#endif\r\n","//\r\n//      ID Engine\r\n//      ID_SD.h - Sound Manager Header\r\n//      Version for Wolfenstein\r\n//      By Jason Blochowiak\r\n//\r\n\r\n#ifndef __ID_SD__\r\n#define __ID_SD__\r\n\r\n#define alOut(n,b) YM3812Write(0, n, b)\r\n\r\n#define TickBase        70      // 70Hz per tick - used as a base for timer 0\r\n\r\ntypedef enum\r\n{\r\n    sdm_Off,\r\n    sdm_PC,sdm_AdLib,\r\n} SDMode;\r\n\r\ntypedef enum\r\n{\r\n    smm_Off,smm_AdLib\r\n} SMMode;\r\n\r\ntypedef enum\r\n{\r\n    sds_Off,sds_PC,sds_SoundBlaster\r\n} SDSMode;\r\n\r\ntypedef struct\r\n{\r\n    longword        length;\r\n    word            priority;\r\n} SoundCommon;\r\n\r\n#define ORIG_SOUNDCOMMON_SIZE 6\r\n\r\n//      PC Sound stuff\r\n#define pcTimer         0x42\r\n#define pcTAccess       0x43\r\n#define pcSpeaker       0x61\r\n\r\n#define pcSpkBits       3\r\n\r\ntypedef struct\r\n{\r\n    SoundCommon     common;\r\n    byte            data[1];\r\n} PCSound;\r\n\r\n//      Register addresses\r\n// Operator stuff\r\n#define alChar          0x20\r\n#define alScale         0x40\r\n#define alAttack        0x60\r\n#define alSus           0x80\r\n#define alWave          0xe0\r\n// Channel stuff\r\n#define alFreqL         0xa0\r\n#define alFreqH         0xb0\r\n#define alFeedCon       0xc0\r\n// Global stuff\r\n#define alEffects       0xbd\r\n\r\ntypedef struct\r\n{\r\n    byte    mChar,cChar,\r\n            mScale,cScale,\r\n            mAttack,cAttack,\r\n            mSus,cSus,\r\n            mWave,cWave,\r\n            nConn,\r\n\r\n            // These are only for Muse - these bytes are really unused\r\n            voice,\r\n            mode;\r\n    byte    unused[3];\r\n} Instrument;\r\n\r\n#define ORIG_INSTRUMENT_SIZE 16\r\n\r\ntypedef struct\r\n{\r\n    SoundCommon     common;\r\n    Instrument      inst;\r\n    byte            block;\r\n    byte            data[1];\r\n} AdLibSound;\r\n\r\n#define ORIG_ADLIBSOUND_SIZE (ORIG_SOUNDCOMMON_SIZE + ORIG_INSTRUMENT_SIZE + 2)\r\n\r\n//\r\n//      Sequencing stuff\r\n//\r\n#define sqMaxTracks     10\r\n\r\ntypedef struct\r\n{\r\n    word    length;\r\n    word    values[1];\r\n} MusicGroup;\r\n\r\ntypedef struct\r\n{\r\n    int valid;\r\n    fixed globalsoundx, globalsoundy;\r\n} globalsoundpos;\r\n\r\nextern globalsoundpos channelSoundPos[];\r\n\r\n// Global variables\r\nextern  boolean         AdLibPresent,\r\n                        SoundBlasterPresent,\r\n                        SoundPositioned;\r\nextern  SDMode          SoundMode;\r\nextern  SDSMode         DigiMode;\r\nextern  SMMode          MusicMode;\r\nextern  int             DigiMap[];\r\nextern  int             DigiChannel[];\r\n\r\n#define GetTimeCount()  ((SDL_GetTicks()*7)/100)\r\n\r\ninline void Delay(int wolfticks)\r\n{\r\n    if(wolfticks>0) SDL_Delay(wolfticks * 100 / 7);\r\n}\r\n\r\n// Function prototypes\r\nextern  void    SD_Startup(void),\r\n                SD_Shutdown(void);\r\n\r\nextern  int     SD_GetChannelForDigi(int which);\r\nextern  void    SD_PositionSound(int leftvol,int rightvol);\r\nextern  boolean SD_PlaySound(soundnames sound);\r\nextern  void    SD_SetPosition(int channel, int leftvol,int rightvol);\r\nextern  void    SD_StopSound(void),\r\n                SD_WaitSoundDone(void);\r\n\r\nextern  void    SD_StartMusic(int chunk);\r\nextern  void    SD_ContinueMusic(int chunk, int startoffs);\r\nextern  void    SD_MusicOn(void),\r\n                SD_FadeOutMusic(void);\r\nextern  int     SD_MusicOff(void);\r\n\r\nextern  boolean SD_MusicPlaying(void);\r\nextern  boolean SD_SetSoundMode(SDMode mode);\r\nextern  boolean SD_SetMusicMode(SMMode mode);\r\nextern  word    SD_SoundPlaying(void);\r\n\r\nextern  void    SD_SetDigiDevice(SDSMode);\r\nextern  void    SD_PrepareSound(int which);\r\nextern  int     SD_PlayDigitized(word which,int leftpos,int rightpos);\r\nextern  void    SD_StopDigitized(void);\r\n\r\n#endif\r\n","// ID_VL.C\r\n\r\n#include <string.h>\r\n#include \"wl_def.h\"\r\n#pragma hdrstop\r\n\r\n#ifdef __EMSCRIPTEN__\r\n#include <emscripten.h>\r\n#endif\r\n\r\n\r\n// Uncomment the following line, if you get destination out of bounds\r\n// assertion errors and want to ignore them during debugging\r\n//#define IGNORE_BAD_DEST\r\n\r\n#ifdef IGNORE_BAD_DEST\r\n#undef assert\r\n#define assert(x) if(!(x)) return\r\n#define assert_ret(x) if(!(x)) return 0\r\n#else\r\n#define assert_ret(x) assert(x)\r\n#endif\r\n\r\nboolean fullscreen = false;\r\n\r\n\r\nboolean usedoublebuffering = true;\r\nunsigned screenWidth = 640;\r\nunsigned screenHeight = 480;\r\nunsigned screenBits = -1;      // use \"best\" color depth according to libSDL\r\n\r\n\r\nSDL_Surface *screen = NULL;\r\nunsigned screenPitch;\r\n\r\nSDL_Surface *screenBuffer = NULL;\r\nunsigned bufferPitch;\r\n\r\nSDL_Surface *curSurface = NULL;\r\nunsigned curPitch;\r\n\r\nunsigned scaleFactor;\r\n\r\nboolean  screenfaded;\r\nunsigned bordercolor;\r\n\r\nSDL_Color palette1[256], palette2[256];\r\nSDL_Color curpal[256];\r\n\r\n\r\n#define CASSERT(x) extern int ASSERT_COMPILE[((x) != 0) * 2 - 1];\r\n#define RGB(r, g, b) {(r)*255/63, (g)*255/63, (b)*255/63, 0}\r\n\r\nSDL_Color gamepal[]={\r\n#ifdef SPEAR\r\n    #include \"sodpal.inc\"\r\n#else\r\n    #include \"wolfpal.inc\"\r\n#endif\r\n};\r\n\r\nCASSERT(lengthof(gamepal) == 256)\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n=======================\r\n=\r\n= VL_Shutdown\r\n=\r\n=======================\r\n*/\r\n\r\nvoid    VL_Shutdown (void)\r\n{\r\n    //VL_SetTextMode ();\r\n}\r\n\r\n\r\n/*\r\n=======================\r\n=\r\n= VL_SetVGAPlaneMode\r\n=\r\n=======================\r\n*/\r\n\r\nvoid    VL_SetVGAPlaneMode (void)\r\n{\r\n#ifdef SPEAR\r\n    SDL_WM_SetCaption(\"Spear of Destiny\", NULL);\r\n#else\r\n    SDL_WM_SetCaption(\"Wolfenstein 3D\", NULL);\r\n#endif\r\n    // authentic resolution\r\n    screenWidth=320;\r\n    screenHeight=200;\r\n    #ifdef __EMSCRIPTEN__\r\n    screenBits=-1; // browser canvas is always 32bpp\r\n    #endif\r\n\r\n    if(screenBits == -1)\r\n    {\r\n        const SDL_VideoInfo *vidInfo = SDL_GetVideoInfo();\r\n        screenBits = vidInfo->vfmt->BitsPerPixel;\r\n    }\r\n\r\n\r\n    //Fab's CRT Hack\r\n    //Adjust height so the screen is 4:3 aspect ratio\r\n    // screenHeight=screenWidth * 3.0/4.0;\r\n    \r\n    // screen = SDL_SetVideoMode(screenWidth, screenHeight, screenBits,\r\n    //       (usedoublebuffering ? SDL_HWSURFACE | SDL_DOUBLEBUF : 0)\r\n    //     | (screenBits == 8 ? SDL_HWPALETTE : 0)\r\n    //     | (fullscreen ? SDL_FULLSCREEN : 0) | SDL_OPENGL | SDL_OPENGLBLIT);\r\n    \r\n    screen = SDL_SetVideoMode(screenWidth, screenHeight, screenBits,\r\n          (usedoublebuffering ? SDL_HWSURFACE | SDL_DOUBLEBUF : 0)\r\n        | (screenBits == 8 ? SDL_HWPALETTE : 0)\r\n        | (fullscreen ? SDL_FULLSCREEN : 0));\r\n    printf(\"set %ix%ix%i video mode\\n\", screenWidth, screenHeight, screenBits);\r\n\r\n    if(!screen)\r\n    {\r\n        printf(\"Unable to set %ix%ix%i video mode: %s\\n\", screenWidth, screenHeight, screenBits, SDL_GetError());\r\n        exit(1);\r\n    }\r\n    if((screen->flags & SDL_DOUBLEBUF) != SDL_DOUBLEBUF)\r\n        usedoublebuffering = false;\r\n    SDL_ShowCursor(SDL_DISABLE);\r\n\r\n    // SDL_SetColors(screen, gamepal, 0, 256);\r\n    memcpy(curpal, gamepal, sizeof(SDL_Color) * 256);\r\n\r\n    //Fab's CRT Hack\r\n    // CRT_Init(screenWidth);\r\n    \r\n    //Fab's CRT Hack\r\n    // screenWidth=320;\r\n    // screenHeight=200;\r\n    \r\n    printf(\"screenWidth=%d,screenHeight=%d\\n\", screenWidth,screenHeight);\r\n    \r\n    screenBuffer = SDL_CreateRGBSurface(SDL_SWSURFACE, screenWidth,\r\n        screenHeight, 8, 0, 0, 0, 0);\r\n    if(!screenBuffer)\r\n    {\r\n        printf(\"Unable to create screen buffer surface: %s\\n\", SDL_GetError());\r\n        exit(1);\r\n    }\r\n    SDL_SetColors(screenBuffer, gamepal, 0, 256);\r\n\r\n    screenPitch = screen->pitch;\r\n    bufferPitch = screenBuffer->pitch;\r\n\r\n    curSurface = screenBuffer;\r\n    curPitch = bufferPitch;\r\n\r\n    scaleFactor = screenWidth/320;\r\n    if(screenHeight/200 < scaleFactor) scaleFactor = screenHeight/200;\r\n    \r\n    \r\n    pixelangle = (short *) malloc(screenWidth * sizeof(short));\r\n    CHECKMALLOCRESULT(pixelangle);\r\n    wallheight = (int *) malloc(screenWidth * sizeof(int));\r\n    CHECKMALLOCRESULT(wallheight);\r\n}\r\n\r\nint frames_to_dump = 0;\r\n\r\nvoid Em_BlitToScreen() {\r\n    VL_LockSurface(screen);\r\n    VL_LockSurface(screenBuffer);\r\n\r\n    assert(screen->pixels != 0);\r\n    assert(screen->format->BitsPerPixel == 32);\r\n    assert(screen->w == 320);\r\n    assert(screen->h == 200);\r\n    assert(screenBuffer->pixels != 0);\r\n    // assert(screenBuffer->format->BitsPerPixel == 8);\r\n    // assert(screenBuffer->w == 320);\r\n    // assert(screenBuffer->h == 200);\r\n\r\n    int colorstats[256]; \r\n    for (int i = 0; i < 256; i++ ) {\r\n        colorstats[i] = 0;\r\n    }\r\n    //Convert palette based framebuffer to RGB\r\n    uint32_t* pixelPointer = (uint32_t*)screen->pixels;\r\n    for (int y=0; y < screenBuffer->h; y++) {\r\n        for (int x=0; x < screenBuffer->w; x++) {\r\n            int i = y * screenBuffer->pitch + x;\r\n\r\n            unsigned char paletteIndex = ((byte*)screenBuffer->pixels)[i];\r\n            colorstats[paletteIndex]++;\r\n            *pixelPointer++ = SDL_MapRGBA(\r\n                screen->format,\r\n                curpal[paletteIndex].r,\r\n                curpal[paletteIndex].g,\r\n                curpal[paletteIndex].b,\r\n                255\r\n            );\r\n        }\r\n    }\r\n    frames_to_dump++;\r\n    if (frames_to_dump % 60 == 0) {\r\n        // printf(\"frame %d blit\\n\", frames_to_dump);\r\n        // for (int i = 0; i < 256; i++ ) {\r\n        //     if(colorstats[i]) {\r\n        //         printf(\"pixelstats[%d]=%d\\n\", i, colorstats[i]);\r\n        //     }\r\n        // }\r\n        // printf(\"palette \");\r\n        // for (int i = 0; i < 256; i++ ) {\r\n        //     printf(\"%d: [%d,%d,%d], \", i, curpal[i].r,curpal[i].g,curpal[i].b);\r\n        // }\r\n        // printf(\"\\n\");\r\n    }\r\n\r\n\r\n    VL_UnlockSurface(screen);\r\n    VL_UnlockSurface(screenBuffer);\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                        PALETTE OPS\r\n\r\n        To avoid snow, do a WaitVBL BEFORE calling these\r\n\r\n=============================================================================\r\n*/\r\n\r\n/*\r\n=================\r\n=\r\n= VL_ConvertPalette\r\n=\r\n=================\r\n*/\r\n\r\nvoid VL_ConvertPalette(byte *srcpal, SDL_Color *destpal, int numColors)\r\n{\r\n    for(int i=0; i<numColors; i++)\r\n    {\r\n        destpal[i].r = *srcpal++ * 255 / 63;\r\n        destpal[i].g = *srcpal++ * 255 / 63;\r\n        destpal[i].b = *srcpal++ * 255 / 63;\r\n    }\r\n}\r\n\r\n/*\r\n=================\r\n=\r\n= VL_FillPalette\r\n=\r\n=================\r\n*/\r\n\r\nvoid VL_FillPalette (int red, int green, int blue)\r\n{\r\n    int i;\r\n    SDL_Color pal[256];\r\n\r\n    for(i=0; i<256; i++)\r\n    {\r\n        pal[i].r = red;\r\n        pal[i].g = green;\r\n        pal[i].b = blue;\r\n    }\r\n\r\n    VL_SetPalette(pal, true);\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=================\r\n=\r\n= VL_SetColor\r\n=\r\n=================\r\n*/\r\n\r\nvoid VL_SetColor    (int color, int red, int green, int blue)\r\n{\r\n    SDL_Color col = { red, green, blue };\r\n    curpal[color] = col;\r\n\r\n    if(screenBits == 8)\r\n        SDL_SetPalette(screen, SDL_PHYSPAL, &col, color, 1);\r\n    else\r\n    {\r\n        SDL_SetPalette(curSurface, SDL_LOGPAL, &col, color, 1);\r\n#ifdef __EMSCRIPTEN__\r\n        Em_BlitToScreen();\r\n#else\r\n        SDL_BlitSurface(screenBuffer, NULL, screen, NULL);\r\n#endif\r\n        SDL_Flip(screen);\r\n    }\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=================\r\n=\r\n= VL_GetColor\r\n=\r\n=================\r\n*/\r\n\r\nvoid VL_GetColor    (int color, int *red, int *green, int *blue)\r\n{\r\n    SDL_Color *col = &curpal[color];\r\n    *red = col->r;\r\n    *green = col->g;\r\n    *blue = col->b;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=================\r\n=\r\n= VL_SetPalette\r\n=\r\n=================\r\n*/\r\n\r\nvoid VL_SetPalette (SDL_Color *palette, bool forceupdate)\r\n{\r\n    memcpy(curpal, palette, sizeof(SDL_Color) * 256);\r\n\r\n    if(screenBits == 8)\r\n        SDL_SetPalette(screen, SDL_PHYSPAL, palette, 0, 256);\r\n    else\r\n    {\r\n        SDL_SetPalette(curSurface, SDL_LOGPAL, palette, 0, 256);\r\n        if(forceupdate)\r\n        {\r\n#ifdef __EMSCRIPTEN__\r\n            Em_BlitToScreen();\r\n#else\r\n            SDL_BlitSurface(screenBuffer, NULL, screen, NULL);\r\n#endif\r\n            SDL_Flip(screen);\r\n        }\r\n    }\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=================\r\n=\r\n= VL_GetPalette\r\n=\r\n=================\r\n*/\r\n\r\nvoid VL_GetPalette (SDL_Color *palette)\r\n{\r\n    memcpy(palette, curpal, sizeof(SDL_Color) * 256);\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=================\r\n=\r\n= VL_FadeOut\r\n=\r\n= Fades the current palette to the given color in the given number of steps\r\n=\r\n=================\r\n*/\r\n\r\nvoid VL_FadeOut (int start, int end, int red, int green, int blue, int steps)\r\n{\r\n    int         i,j,orig,delta;\r\n    SDL_Color   *origptr, *newptr;\r\n\r\n    red = red * 255 / 63;\r\n    green = green * 255 / 63;\r\n    blue = blue * 255 / 63;\r\n\r\n    VL_WaitVBL(1);\r\n    VL_GetPalette(palette1);\r\n    memcpy(palette2, palette1, sizeof(SDL_Color) * 256);\r\n\r\n//\r\n// fade through intermediate frames\r\n//\r\n    for (i=0;i<steps;i++)\r\n    {\r\n        origptr = &palette1[start];\r\n        newptr = &palette2[start];\r\n        for (j=start;j<=end;j++)\r\n        {\r\n            orig = origptr->r;\r\n            delta = red-orig;\r\n            newptr->r = orig + delta * i / steps;\r\n            orig = origptr->g;\r\n            delta = green-orig;\r\n            newptr->g = orig + delta * i / steps;\r\n            orig = origptr->b;\r\n            delta = blue-orig;\r\n            newptr->b = orig + delta * i / steps;\r\n            origptr++;\r\n            newptr++;\r\n        }\r\n\r\n        if(!usedoublebuffering || screenBits == 8) VL_WaitVBL(1);\r\n        VL_SetPalette (palette2, true);\r\n    }\r\n\r\n//\r\n// final color\r\n//\r\n    VL_FillPalette (red,green,blue);\r\n\r\n    screenfaded = true;\r\n}\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= VL_FadeIn\r\n=\r\n=================\r\n*/\r\n\r\nvoid VL_FadeIn (int start, int end, SDL_Color *palette, int steps)\r\n{\r\n    int i,j,delta;\r\n\r\n    VL_WaitVBL(1);\r\n    VL_GetPalette(palette1);\r\n    memcpy(palette2, palette1, sizeof(SDL_Color) * 256);\r\n\r\n//\r\n// fade through intermediate frames\r\n//\r\n    for (i=0;i<steps;i++)\r\n    {\r\n        for (j=start;j<=end;j++)\r\n        {\r\n            delta = palette[j].r-palette1[j].r;\r\n            palette2[j].r = palette1[j].r + delta * i / steps;\r\n            delta = palette[j].g-palette1[j].g;\r\n            palette2[j].g = palette1[j].g + delta * i / steps;\r\n            delta = palette[j].b-palette1[j].b;\r\n            palette2[j].b = palette1[j].b + delta * i / steps;\r\n        }\r\n\r\n        if(!usedoublebuffering || screenBits == 8) VL_WaitVBL(1);\r\n        VL_SetPalette(palette2, true);\r\n    }\r\n\r\n//\r\n// final color\r\n//\r\n    VL_SetPalette (palette, true);\r\n    screenfaded = false;\r\n}\r\n\r\n/*\r\n=============================================================================\r\n\r\n                            PIXEL OPS\r\n\r\n=============================================================================\r\n*/\r\n\r\nbyte *VL_LockSurface(SDL_Surface *surface)\r\n{\r\n    if(/*surface == screen &&*/ SDL_MUSTLOCK(surface))\r\n    {\r\n        if(SDL_LockSurface(surface) < 0)\r\n            return NULL;\r\n    }\r\n    return (byte *) surface->pixels;\r\n}\r\n\r\nvoid VL_UnlockSurface(SDL_Surface *surface)\r\n{\r\n    if(/*surface == screen &&*/ SDL_MUSTLOCK(surface))\r\n    {\r\n        SDL_UnlockSurface(surface);\r\n    }\r\n}\r\n\r\n/*\r\n=================\r\n=\r\n= VL_Plot\r\n=\r\n=================\r\n*/\r\n\r\nvoid VL_Plot (int x, int y, int color)\r\n{\r\n    assert(x >= 0 && (unsigned) x < screenWidth\r\n            && y >= 0 && (unsigned) y < screenHeight\r\n            && \"VL_Plot: Pixel out of bounds!\");\r\n\r\n    VL_LockSurface(curSurface);\r\n    ((byte *) curSurface->pixels)[y * curPitch + x] = color;\r\n    VL_UnlockSurface(curSurface);\r\n}\r\n\r\n/*\r\n=================\r\n=\r\n= VL_GetPixel\r\n=\r\n=================\r\n*/\r\n\r\nbyte VL_GetPixel (int x, int y)\r\n{\r\n    assert_ret(x >= 0 && (unsigned) x < screenWidth\r\n            && y >= 0 && (unsigned) y < screenHeight\r\n            && \"VL_GetPixel: Pixel out of bounds!\");\r\n\r\n    VL_LockSurface(curSurface);\r\n    byte col = ((byte *) curSurface->pixels)[y * curPitch + x];\r\n    VL_UnlockSurface(curSurface);\r\n    return col;\r\n}\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= VL_Hlin\r\n=\r\n=================\r\n*/\r\n\r\nvoid VL_Hlin (unsigned x, unsigned y, unsigned width, int color)\r\n{\r\n    assert(x >= 0 && x + width <= screenWidth\r\n            && y >= 0 && y < screenHeight\r\n            && \"VL_Hlin: Destination rectangle out of bounds!\");\r\n\r\n    VL_LockSurface(curSurface);\r\n    Uint8 *dest = ((byte *) curSurface->pixels) + y * curPitch + x;\r\n    memset(dest, color, width);\r\n    VL_UnlockSurface(curSurface);\r\n}\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= VL_Vlin\r\n=\r\n=================\r\n*/\r\n\r\nvoid VL_Vlin (int x, int y, int height, int color)\r\n{\r\n    assert(x >= 0 && (unsigned) x < screenWidth\r\n            && y >= 0 && (unsigned) y + height <= screenHeight\r\n            && \"VL_Vlin: Destination rectangle out of bounds!\");\r\n\r\n    VL_LockSurface(curSurface);\r\n    Uint8 *dest = ((byte *) curSurface->pixels) + y * curPitch + x;\r\n\r\n    while (height--)\r\n    {\r\n        *dest = color;\r\n        dest += curPitch;\r\n    }\r\n    VL_UnlockSurface(curSurface);\r\n}\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= VL_Bar\r\n=\r\n=================\r\n*/\r\n\r\nvoid VL_BarScaledCoord (int scx, int scy, int scwidth, int scheight, int color)\r\n{\r\n    assert(scx >= 0 && (unsigned) scx + scwidth <= screenWidth\r\n            && scy >= 0 && (unsigned) scy + scheight <= screenHeight\r\n            && \"VL_BarScaledCoord: Destination rectangle out of bounds!\");\r\n\r\n    VL_LockSurface(curSurface);\r\n    Uint8 *dest = ((byte *) curSurface->pixels) + scy * curPitch + scx;\r\n\r\n    while (scheight--)\r\n    {\r\n        memset(dest, color, scwidth);\r\n        dest += curPitch;\r\n    }\r\n    VL_UnlockSurface(curSurface);\r\n}\r\n\r\n/*\r\n============================================================================\r\n\r\n                            MEMORY OPS\r\n\r\n============================================================================\r\n*/\r\n\r\n/*\r\n=================\r\n=\r\n= VL_MemToLatch\r\n=\r\n=================\r\n*/\r\n\r\nvoid VL_MemToLatch(byte *source, int width, int height,\r\n    SDL_Surface *destSurface, int x, int y)\r\n{\r\n    assert(x >= 0 && (unsigned) x + width <= screenWidth\r\n            && y >= 0 && (unsigned) y + height <= screenHeight\r\n            && \"VL_MemToLatch: Destination rectangle out of bounds!\");\r\n\r\n    VL_LockSurface(destSurface);\r\n    int pitch = destSurface->pitch;\r\n    byte *dest = (byte *) destSurface->pixels + y * pitch + x;\r\n    for(int ysrc = 0; ysrc < height; ysrc++)\r\n    {\r\n        for(int xsrc = 0; xsrc < width; xsrc++)\r\n        {\r\n            dest[ysrc * pitch + xsrc] = source[(ysrc * (width >> 2) + (xsrc >> 2))\r\n                + (xsrc & 3) * (width >> 2) * height];\r\n        }\r\n    }\r\n    VL_UnlockSurface(destSurface);\r\n}\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= VL_MemToScreenScaledCoord\r\n=\r\n= Draws a block of data to the screen with scaling according to scaleFactor.\r\n=\r\n=================\r\n*/\r\n\r\nvoid VL_MemToScreenScaledCoord (byte *source, int width, int height, int destx, int desty)\r\n{\r\n    assert(destx >= 0 && destx + width * scaleFactor <= screenWidth\r\n            && desty >= 0 && desty + height * scaleFactor <= screenHeight\r\n            && \"VL_MemToScreenScaledCoord: Destination rectangle out of bounds!\");\r\n\r\n    VL_LockSurface(curSurface);\r\n    byte *vbuf = (byte *) curSurface->pixels;\r\n    for(int j=0,scj=0; j<height; j++, scj+=scaleFactor)\r\n    {\r\n        for(int i=0,sci=0; i<width; i++, sci+=scaleFactor)\r\n        {\r\n            byte col = source[(j*(width>>2)+(i>>2))+(i&3)*(width>>2)*height];\r\n            for(unsigned m=0; m<scaleFactor; m++)\r\n            {\r\n                for(unsigned n=0; n<scaleFactor; n++)\r\n                {\r\n                    vbuf[(scj+m+desty)*curPitch+sci+n+destx] = col;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    VL_UnlockSurface(curSurface);\r\n}\r\n\r\n/*\r\n=================\r\n=\r\n= VL_MemToScreenScaledCoord\r\n=\r\n= Draws a part of a block of data to the screen.\r\n= The block has the size origwidth*origheight.\r\n= The part at (srcx, srcy) has the size width*height\r\n= and will be painted to (destx, desty) with scaling according to scaleFactor.\r\n=\r\n=================\r\n*/\r\n\r\nvoid VL_MemToScreenScaledCoord (byte *source, int origwidth, int origheight, int srcx, int srcy,\r\n                                int destx, int desty, int width, int height)\r\n{\r\n    assert(destx >= 0 && destx + width * scaleFactor <= screenWidth\r\n            && desty >= 0 && desty + height * scaleFactor <= screenHeight\r\n            && \"VL_MemToScreenScaledCoord: Destination rectangle out of bounds!\");\r\n\r\n    VL_LockSurface(curSurface);\r\n    byte *vbuf = (byte *) curSurface->pixels;\r\n    for(int j=0,scj=0; j<height; j++, scj+=scaleFactor)\r\n    {\r\n        for(int i=0,sci=0; i<width; i++, sci+=scaleFactor)\r\n        {\r\n            byte col = source[((j+srcy)*(origwidth>>2)+((i+srcx)>>2))+((i+srcx)&3)*(origwidth>>2)*origheight];\r\n            for(unsigned m=0; m<scaleFactor; m++)\r\n            {\r\n                for(unsigned n=0; n<scaleFactor; n++)\r\n                {\r\n                    vbuf[(scj+m+desty)*curPitch+sci+n+destx] = col;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    VL_UnlockSurface(curSurface);\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n=================\r\n=\r\n= VL_LatchToScreen\r\n=\r\n=================\r\n*/\r\n\r\nvoid VL_LatchToScreenScaledCoord(SDL_Surface *source, int xsrc, int ysrc,\r\n    int width, int height, int scxdest, int scydest)\r\n{\r\n    assert(scxdest >= 0 && scxdest + width * scaleFactor <= screenWidth\r\n            && scydest >= 0 && scydest + height * scaleFactor <= screenHeight\r\n            && \"VL_LatchToScreenScaledCoord: Destination rectangle out of bounds!\");\r\n\r\n    if(scaleFactor == 1)\r\n    {\r\n        // HACK: If screenBits is not 8 and the screen is faded out, the\r\n        //       result will be black when using SDL_BlitSurface. The reason\r\n        //       is that the logical palette needed for the transformation\r\n        //       to the screen color depth is not equal to the logical\r\n        //       palette of the latch (the latch is not faded). Therefore,\r\n        //       SDL tries to map the colors...\r\n        //       The result: All colors are mapped to black.\r\n        //       So, we do the blit on our own...\r\n        if(screenBits != 8)\r\n        {\r\n            VL_LockSurface(source);\r\n            byte *src = (byte *) source->pixels;\r\n            unsigned srcPitch = source->pitch;\r\n\r\n            VL_LockSurface(curSurface);\r\n            byte *vbuf = (byte *) curSurface->pixels;\r\n            for(int j=0,scj=0; j<height; j++, scj++)\r\n            {\r\n                for(int i=0,sci=0; i<width; i++, sci++)\r\n                {\r\n                    byte col = src[(ysrc + j)*srcPitch + xsrc + i];\r\n                    vbuf[(scydest+scj)*curPitch+scxdest+sci] = col;\r\n                }\r\n            }\r\n            VL_UnlockSurface(curSurface);\r\n            VL_UnlockSurface(source);\r\n        }\r\n        else\r\n        {\r\n            SDL_Rect srcrect = { xsrc, ysrc, width, height };\r\n            SDL_Rect destrect = { scxdest, scydest, 0, 0 }; // width and height are ignored\r\n            SDL_BlitSurface(source, &srcrect, curSurface, &destrect);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        VL_LockSurface(source);\r\n        byte *src = (byte *) source->pixels;\r\n        unsigned srcPitch = source->pitch;\r\n\r\n        VL_LockSurface(curSurface);\r\n        byte *vbuf = (byte *) curSurface->pixels;\r\n        for(int j=0,scj=0; j<height; j++, scj+=scaleFactor)\r\n        {\r\n            for(int i=0,sci=0; i<width; i++, sci+=scaleFactor)\r\n            {\r\n                byte col = src[(ysrc + j)*srcPitch + xsrc + i];\r\n                for(unsigned m=0; m<scaleFactor; m++)\r\n                {\r\n                    for(unsigned n=0; n<scaleFactor; n++)\r\n                    {\r\n                        vbuf[(scydest+scj+m)*curPitch+scxdest+sci+n] = col;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        VL_UnlockSurface(curSurface);\r\n        VL_UnlockSurface(source);\r\n    }\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=================\r\n=\r\n= VL_ScreenToScreen\r\n=\r\n=================\r\n*/\r\n\r\nvoid VL_ScreenToScreen (SDL_Surface *source, SDL_Surface *dest)\r\n{\r\n    SDL_BlitSurface(source, NULL, dest, NULL);\r\n}\r\n","// WL_ACT1.C\r\n\r\n#include \"wl_def.h\"\r\n#pragma hdrstop\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                                        STATICS\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\nstatobj_t       statobjlist[MAXSTATS];\r\nstatobj_t       *laststatobj;\r\n\r\n\r\nstruct\r\n{\r\n    short      picnum;\r\n    wl_stat_t  type;\r\n    uint32_t   specialFlags;    // they are ORed to the statobj_t flags\r\n} statinfo[] =\r\n{\r\n    {SPR_STAT_0},                           // puddle          spr1v\r\n    {SPR_STAT_1,block},                     // Green Barrel    \"\r\n    {SPR_STAT_2,block},                     // Table/chairs    \"\r\n    {SPR_STAT_3,block,FL_FULLBRIGHT},       // Floor lamp      \"\r\n    {SPR_STAT_4,none,FL_FULLBRIGHT},        // Chandelier      \"\r\n    {SPR_STAT_5,block},                     // Hanged man      \"\r\n    {SPR_STAT_6,bo_alpo},                   // Bad food        \"\r\n    {SPR_STAT_7,block},                     // Red pillar      \"\r\n    //\r\n    // NEW PAGE\r\n    //\r\n    {SPR_STAT_8,block},                     // Tree            spr2v\r\n    {SPR_STAT_9},                           // Skeleton flat   \"\r\n    {SPR_STAT_10,block},                    // Sink            \" (SOD:gibs)\r\n    {SPR_STAT_11,block},                    // Potted plant    \"\r\n    {SPR_STAT_12,block},                    // Urn             \"\r\n    {SPR_STAT_13,block},                    // Bare table      \"\r\n    {SPR_STAT_14,none,FL_FULLBRIGHT},       // Ceiling light   \"\r\n    #ifndef SPEAR\r\n    {SPR_STAT_15},                          // Kitchen stuff   \"\r\n    #else\r\n    {SPR_STAT_15,block},                    // Gibs!\r\n    #endif\r\n    //\r\n    // NEW PAGE\r\n    //\r\n    {SPR_STAT_16,block},                    // suit of armor   spr3v\r\n    {SPR_STAT_17,block},                    // Hanging cage    \"\r\n    {SPR_STAT_18,block},                    // SkeletoninCage  \"\r\n    {SPR_STAT_19},                          // Skeleton relax  \"\r\n    {SPR_STAT_20,bo_key1},                  // Key 1           \"\r\n    {SPR_STAT_21,bo_key2},                  // Key 2           \"\r\n    {SPR_STAT_22,block},                    // stuff             (SOD:gibs)\r\n    {SPR_STAT_23},                          // stuff\r\n    //\r\n    // NEW PAGE\r\n    //\r\n    {SPR_STAT_24,bo_food},                  // Good food       spr4v\r\n    {SPR_STAT_25,bo_firstaid},              // First aid       \"\r\n    {SPR_STAT_26,bo_clip},                  // Clip            \"\r\n    {SPR_STAT_27,bo_machinegun},            // Machine gun     \"\r\n    {SPR_STAT_28,bo_chaingun},              // Gatling gun     \"\r\n    {SPR_STAT_29,bo_cross},                 // Cross           \"\r\n    {SPR_STAT_30,bo_chalice},               // Chalice         \"\r\n    {SPR_STAT_31,bo_bible},                 // Bible           \"\r\n    //\r\n    // NEW PAGE\r\n    //\r\n    {SPR_STAT_32,bo_crown},                 // crown           spr5v\r\n    {SPR_STAT_33,bo_fullheal,FL_FULLBRIGHT},// one up          \"\r\n    {SPR_STAT_34,bo_gibs},                  // gibs            \"\r\n    {SPR_STAT_35,block},                    // barrel          \"\r\n    {SPR_STAT_36,block},                    // well            \"\r\n    {SPR_STAT_37,block},                    // Empty well      \"\r\n    {SPR_STAT_38,bo_gibs},                  // Gibs 2          \"\r\n    {SPR_STAT_39,block},                    // flag            \"\r\n    //\r\n    // NEW PAGE\r\n    //\r\n    #ifndef SPEAR\r\n    {SPR_STAT_40,block},                    // Call Apogee          spr7v\r\n    #else\r\n    {SPR_STAT_40},                          // Red light\r\n    #endif\r\n    //\r\n    // NEW PAGE\r\n    //\r\n    {SPR_STAT_41},                          // junk            \"\r\n    {SPR_STAT_42},                          // junk            \"\r\n    {SPR_STAT_43},                          // junk            \"\r\n    #ifndef SPEAR\r\n    {SPR_STAT_44},                          // pots            \"\r\n    #else\r\n    {SPR_STAT_44,block},                    // Gibs!\r\n    #endif\r\n    {SPR_STAT_45,block},                    // stove           \" (SOD:gibs)\r\n    {SPR_STAT_46,block},                    // spears          \" (SOD:gibs)\r\n    {SPR_STAT_47},                          // vines           \"\r\n    //\r\n    // NEW PAGE\r\n    //\r\n    #ifdef SPEAR\r\n    {SPR_STAT_48,block},                    // marble pillar\r\n    {SPR_STAT_49,bo_25clip},                // bonus 25 clip\r\n    {SPR_STAT_50,block},                    // truck\r\n    {SPR_STAT_51,bo_spear},                 // SPEAR OF DESTINY!\r\n    #endif\r\n\r\n    {SPR_STAT_26,bo_clip2},                 // Clip            \"\r\n\r\n    {-1}                                    // terminator\r\n};\r\n\r\n/*\r\n===============\r\n=\r\n= InitStaticList\r\n=\r\n===============\r\n*/\r\n\r\nvoid InitStaticList (void)\r\n{\r\n    laststatobj = &statobjlist[0];\r\n}\r\n\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnStatic\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnStatic (int tilex, int tiley, int type)\r\n{\r\n    laststatobj->shapenum = statinfo[type].picnum;\r\n    laststatobj->tilex = tilex;\r\n    laststatobj->tiley = tiley;\r\n    laststatobj->visspot = &spotvis[tilex][tiley];\r\n\r\n    switch (statinfo[type].type)\r\n    {\r\n        case block:\r\n            actorat[tilex][tiley] = (objtype *) 64;          // consider it a blocking tile\r\n        case none:\r\n            laststatobj->flags = 0;\r\n            break;\r\n\r\n        case    bo_cross:\r\n        case    bo_chalice:\r\n        case    bo_bible:\r\n        case    bo_crown:\r\n        case    bo_fullheal:\r\n            if (!loadedgame)\r\n                gamestate.treasuretotal++;\r\n\r\n        case    bo_firstaid:\r\n        case    bo_key1:\r\n        case    bo_key2:\r\n        case    bo_key3:\r\n        case    bo_key4:\r\n        case    bo_clip:\r\n        case    bo_25clip:\r\n        case    bo_machinegun:\r\n        case    bo_chaingun:\r\n        case    bo_food:\r\n        case    bo_alpo:\r\n        case    bo_gibs:\r\n        case    bo_spear:\r\n            laststatobj->flags = FL_BONUS;\r\n            laststatobj->itemnumber = statinfo[type].type;\r\n            break;\r\n    }\r\n\r\n    laststatobj->flags |= statinfo[type].specialFlags;\r\n\r\n    laststatobj++;\r\n\r\n    if (laststatobj == &statobjlist[MAXSTATS])\r\n        Quit (\"Too many static objects!\\n\");\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= PlaceItemType\r\n=\r\n= Called during game play to drop actors' items.  It finds the proper\r\n= item number based on the item type (bo_???).  If there are no free item\r\n= spots, nothing is done.\r\n=\r\n===============\r\n*/\r\n\r\nvoid PlaceItemType (int itemtype, int tilex, int tiley)\r\n{\r\n    int type;\r\n    statobj_t *spot;\r\n\r\n    //\r\n    // find the item number\r\n    //\r\n    for (type=0; ; type++)\r\n    {\r\n        if (statinfo[type].picnum == -1)                    // end of list\r\n            Quit (\"PlaceItemType: couldn't find type!\");\r\n        if (statinfo[type].type == itemtype)\r\n            break;\r\n    }\r\n\r\n    //\r\n    // find a spot in statobjlist to put it in\r\n    //\r\n    for (spot=&statobjlist[0]; ; spot++)\r\n    {\r\n        if (spot==laststatobj)\r\n        {\r\n            if (spot == &statobjlist[MAXSTATS])\r\n                return;                                     // no free spots\r\n            laststatobj++;                                  // space at end\r\n            break;\r\n        }\r\n\r\n        if (spot->shapenum == -1)                           // -1 is a free spot\r\n            break;\r\n    }\r\n    //\r\n    // place it\r\n    //\r\n    spot->shapenum = statinfo[type].picnum;\r\n    spot->tilex = tilex;\r\n    spot->tiley = tiley;\r\n    spot->visspot = &spotvis[tilex][tiley];\r\n    spot->flags = FL_BONUS | statinfo[type].specialFlags;\r\n    spot->itemnumber = statinfo[type].type;\r\n}\r\n\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                  DOORS\r\n\r\ndoorobjlist[] holds most of the information for the doors\r\n\r\ndoorposition[] holds the amount the door is open, ranging from 0 to 0xffff\r\n        this is directly accessed by AsmRefresh during rendering\r\n\r\nThe number of doors is limited to 64 because a spot in tilemap holds the\r\n        door number in the low 6 bits, with the high bit meaning a door center\r\n        and bit 6 meaning a door side tile\r\n\r\nOpen doors conect two areas, so sounds will travel between them and sight\r\n        will be checked when the player is in a connected area.\r\n\r\nAreaconnect is incremented/decremented by each door. If >0 they connect\r\n\r\nEvery time a door opens or closes the areabyplayer matrix gets recalculated.\r\n        An area is true if it connects with the player's current spor.\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define DOORWIDTH       0x7800\r\n#define OPENTICS        300\r\n\r\ndoorobj_t       doorobjlist[MAXDOORS],*lastdoorobj;\r\nshort           doornum;\r\n\r\nword            doorposition[MAXDOORS];             // leading edge of door 0=closed\r\n                                                    // 0xffff = fully open\r\n\r\nbyte            areaconnect[NUMAREAS][NUMAREAS];\r\n\r\nboolean         areabyplayer[NUMAREAS];\r\n\r\n\r\n/*\r\n==============\r\n=\r\n= ConnectAreas\r\n=\r\n= Scans outward from playerarea, marking all connected areas\r\n=\r\n==============\r\n*/\r\n\r\nvoid RecursiveConnect (int areanumber)\r\n{\r\n    int i;\r\n\r\n    for (i=0;i<NUMAREAS;i++)\r\n    {\r\n        if (areaconnect[areanumber][i] && !areabyplayer[i])\r\n        {\r\n            areabyplayer[i] = true;\r\n            RecursiveConnect (i);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nvoid ConnectAreas (void)\r\n{\r\n    memset (areabyplayer,0,sizeof(areabyplayer));\r\n    areabyplayer[player->areanumber] = true;\r\n    RecursiveConnect (player->areanumber);\r\n}\r\n\r\n\r\nvoid InitAreas (void)\r\n{\r\n    memset (areabyplayer,0,sizeof(areabyplayer));\r\n    if (player->areanumber < NUMAREAS)\r\n        areabyplayer[player->areanumber] = true;\r\n}\r\n\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= InitDoorList\r\n=\r\n===============\r\n*/\r\n\r\nvoid InitDoorList (void)\r\n{\r\n    memset (areabyplayer,0,sizeof(areabyplayer));\r\n    memset (areaconnect,0,sizeof(areaconnect));\r\n\r\n    lastdoorobj = &doorobjlist[0];\r\n    doornum = 0;\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnDoor\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnDoor (int tilex, int tiley, boolean vertical, int lock)\r\n{\r\n    word *map;\r\n\r\n    if (doornum==MAXDOORS)\r\n        Quit (\"64+ doors on level!\");\r\n\r\n    doorposition[doornum] = 0;              // doors start out fully closed\r\n    lastdoorobj->tilex = tilex;\r\n    lastdoorobj->tiley = tiley;\r\n    lastdoorobj->vertical = vertical;\r\n    lastdoorobj->lock = lock;\r\n    lastdoorobj->action = dr_closed;\r\n\r\n    actorat[tilex][tiley] = (objtype *)(uintptr_t)(doornum | 0x80);   // consider it a solid wall\r\n\r\n    //\r\n    // make the door tile a special tile, and mark the adjacent tiles\r\n    // for door sides\r\n    //\r\n    tilemap[tilex][tiley] = doornum | 0x80;\r\n    map = mapsegs[0] + (tiley<<mapshift) +tilex;\r\n    if (vertical)\r\n    {\r\n        *map = *(map-1);                        // set area number\r\n        tilemap[tilex][tiley-1] |= 0x40;\r\n        tilemap[tilex][tiley+1] |= 0x40;\r\n    }\r\n    else\r\n    {\r\n        *map = *(map-mapwidth);                                 // set area number\r\n        tilemap[tilex-1][tiley] |= 0x40;\r\n        tilemap[tilex+1][tiley] |= 0x40;\r\n    }\r\n\r\n    doornum++;\r\n    lastdoorobj++;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= OpenDoor\r\n=\r\n=====================\r\n*/\r\n\r\nvoid OpenDoor (int door)\r\n{\r\n    if (doorobjlist[door].action == dr_open)\r\n        doorobjlist[door].ticcount = 0;         // reset open time\r\n    else\r\n        doorobjlist[door].action = dr_opening;  // start it opening\r\n}\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= CloseDoor\r\n=\r\n=====================\r\n*/\r\n\r\nvoid CloseDoor (int door)\r\n{\r\n    int     tilex,tiley,area;\r\n    objtype *check;\r\n\r\n    //\r\n    // don't close on anything solid\r\n    //\r\n    tilex = doorobjlist[door].tilex;\r\n    tiley = doorobjlist[door].tiley;\r\n\r\n    if (actorat[tilex][tiley])\r\n        return;\r\n\r\n    if (player->tilex == tilex && player->tiley == tiley)\r\n        return;\r\n\r\n    if (doorobjlist[door].vertical)\r\n    {\r\n        if ( player->tiley == tiley )\r\n        {\r\n            if ( ((player->x+MINDIST) >>TILESHIFT) == tilex )\r\n                return;\r\n            if ( ((player->x-MINDIST) >>TILESHIFT) == tilex )\r\n                return;\r\n        }\r\n        check = actorat[tilex-1][tiley];\r\n        if (ISPOINTER(check) && ((check->x+MINDIST) >> TILESHIFT) == tilex )\r\n            return;\r\n        check = actorat[tilex+1][tiley];\r\n        if (ISPOINTER(check) && ((check->x-MINDIST) >> TILESHIFT) == tilex )\r\n            return;\r\n    }\r\n    else if (!doorobjlist[door].vertical)\r\n    {\r\n        if (player->tilex == tilex)\r\n        {\r\n            if ( ((player->y+MINDIST) >>TILESHIFT) == tiley )\r\n                return;\r\n            if ( ((player->y-MINDIST) >>TILESHIFT) == tiley )\r\n                return;\r\n        }\r\n        check = actorat[tilex][tiley-1];\r\n        if (ISPOINTER(check) && ((check->y+MINDIST) >> TILESHIFT) == tiley )\r\n            return;\r\n        check = actorat[tilex][tiley+1];\r\n        if (ISPOINTER(check) && ((check->y-MINDIST) >> TILESHIFT) == tiley )\r\n            return;\r\n    }\r\n\r\n\r\n    //\r\n    // play door sound if in a connected area\r\n    //\r\n    area = *(mapsegs[0] + (doorobjlist[door].tiley<<mapshift)\r\n        +doorobjlist[door].tilex)-AREATILE;\r\n    if (areabyplayer[area])\r\n    {\r\n        PlaySoundLocTile(CLOSEDOORSND,doorobjlist[door].tilex,doorobjlist[door].tiley); // JAB\r\n    }\r\n\r\n    doorobjlist[door].action = dr_closing;\r\n    //\r\n    // make the door space solid\r\n    //\r\n    actorat[tilex][tiley] = (objtype *)(uintptr_t)(door | 0x80);\r\n}\r\n\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= OperateDoor\r\n=\r\n= The player wants to change the door's direction\r\n=\r\n=====================\r\n*/\r\n\r\nvoid OperateDoor (int door)\r\n{\r\n    int lock;\r\n\r\n    lock = doorobjlist[door].lock;\r\n    if (lock >= dr_lock1 && lock <= dr_lock4)\r\n    {\r\n        if ( ! (gamestate.keys & (1 << (lock-dr_lock1) ) ) )\r\n        {\r\n            SD_PlaySound (NOWAYSND);                // locked\r\n            return;\r\n        }\r\n    }\r\n\r\n    switch (doorobjlist[door].action)\r\n    {\r\n        case dr_closed:\r\n        case dr_closing:\r\n            OpenDoor (door);\r\n            break;\r\n        case dr_open:\r\n        case dr_opening:\r\n            CloseDoor (door);\r\n            break;\r\n    }\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n===============\r\n=\r\n= DoorOpen\r\n=\r\n= Close the door after three seconds\r\n=\r\n===============\r\n*/\r\n\r\nvoid DoorOpen (int door)\r\n{\r\n    if ( (doorobjlist[door].ticcount += (short) tics) >= OPENTICS)\r\n        CloseDoor (door);\r\n}\r\n\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= DoorOpening\r\n=\r\n===============\r\n*/\r\n\r\nvoid DoorOpening (int door)\r\n{\r\n    unsigned area1,area2;\r\n    word *map;\r\n    int32_t position;\r\n\r\n    position = doorposition[door];\r\n    if (!position)\r\n    {\r\n        //\r\n        // door is just starting to open, so connect the areas\r\n        //\r\n        map = mapsegs[0] + (doorobjlist[door].tiley<<mapshift)\r\n            +doorobjlist[door].tilex;\r\n\r\n        if (doorobjlist[door].vertical)\r\n        {\r\n            area1 = *(map+1);\r\n            area2 = *(map-1);\r\n        }\r\n        else\r\n        {\r\n            area1 = *(map-mapwidth);\r\n            area2 = *(map+mapwidth);\r\n        }\r\n        area1 -= AREATILE;\r\n        area2 -= AREATILE;\r\n\r\n        if (area1 < NUMAREAS && area2 < NUMAREAS)\r\n        {\r\n            areaconnect[area1][area2]++;\r\n            areaconnect[area2][area1]++;\r\n\r\n            if (player->areanumber < NUMAREAS)\r\n                ConnectAreas ();\r\n\r\n            if (areabyplayer[area1])\r\n                PlaySoundLocTile(OPENDOORSND,doorobjlist[door].tilex,doorobjlist[door].tiley);  // JAB\r\n        }\r\n    }\r\n\r\n    //\r\n    // slide the door by an adaptive amount\r\n    //\r\n    position += tics<<10;\r\n    if (position >= 0xffff)\r\n    {\r\n        //\r\n        // door is all the way open\r\n        //\r\n        position = 0xffff;\r\n        doorobjlist[door].ticcount = 0;\r\n        doorobjlist[door].action = dr_open;\r\n        actorat[doorobjlist[door].tilex][doorobjlist[door].tiley] = 0;\r\n    }\r\n\r\n    doorposition[door] = (word) position;\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= DoorClosing\r\n=\r\n===============\r\n*/\r\n\r\nvoid DoorClosing (int door)\r\n{\r\n    unsigned area1,area2;\r\n    word *map;\r\n    int32_t position;\r\n    int tilex,tiley;\r\n\r\n    tilex = doorobjlist[door].tilex;\r\n    tiley = doorobjlist[door].tiley;\r\n\r\n    if ( ((int)(uintptr_t)actorat[tilex][tiley] != (door | 0x80))\r\n        || (player->tilex == tilex && player->tiley == tiley) )\r\n    {                       // something got inside the door\r\n        OpenDoor (door);\r\n        return;\r\n    };\r\n\r\n    position = doorposition[door];\r\n\r\n    //\r\n    // slide the door by an adaptive amount\r\n    //\r\n    position -= tics<<10;\r\n    if (position <= 0)\r\n    {\r\n        //\r\n        // door is closed all the way, so disconnect the areas\r\n        //\r\n        position = 0;\r\n\r\n        doorobjlist[door].action = dr_closed;\r\n\r\n        map = mapsegs[0] + (doorobjlist[door].tiley<<mapshift) + doorobjlist[door].tilex;\r\n\r\n        if (doorobjlist[door].vertical)\r\n        {\r\n            area1 = *(map+1);\r\n            area2 = *(map-1);\r\n        }\r\n        else\r\n        {\r\n            area1 = *(map-mapwidth);\r\n            area2 = *(map+mapwidth);\r\n        }\r\n        area1 -= AREATILE;\r\n        area2 -= AREATILE;\r\n\r\n        if (area1 < NUMAREAS && area2 < NUMAREAS)\r\n        {\r\n            areaconnect[area1][area2]--;\r\n            areaconnect[area2][area1]--;\r\n\r\n            if (player->areanumber < NUMAREAS)\r\n                ConnectAreas ();\r\n        }\r\n    }\r\n\r\n    doorposition[door] = (word) position;\r\n}\r\n\r\n\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= MoveDoors\r\n=\r\n= Called from PlayLoop\r\n=\r\n=====================\r\n*/\r\n\r\nvoid MoveDoors (void)\r\n{\r\n    int door;\r\n\r\n    if (gamestate.victoryflag)              // don't move door during victory sequence\r\n        return;\r\n\r\n    for (door = 0; door < doornum; door++)\r\n    {\r\n        switch (doorobjlist[door].action)\r\n        {\r\n            case dr_open:\r\n                DoorOpen (door);\r\n                break;\r\n\r\n            case dr_opening:\r\n                DoorOpening(door);\r\n                break;\r\n\r\n            case dr_closing:\r\n                DoorClosing(door);\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                PUSHABLE WALLS\r\n\r\n=============================================================================\r\n*/\r\n\r\nword pwallstate;\r\nword pwallpos;                  // amount a pushable wall has been moved (0-63)\r\nword pwallx,pwally;\r\nbyte pwalldir,pwalltile;\r\nint dirs[4][2]={{0,-1},{1,0},{0,1},{-1,0}};\r\n\r\n/*\r\n===============\r\n=\r\n= PushWall\r\n=\r\n===============\r\n*/\r\n\r\nvoid PushWall (int checkx, int checky, int dir)\r\n{\r\n    int oldtile, dx, dy;\r\n\r\n    if (pwallstate)\r\n        return;\r\n\r\n    oldtile = tilemap[checkx][checky];\r\n    if (!oldtile)\r\n        return;\r\n\r\n    dx = dirs[dir][0];\r\n    dy = dirs[dir][1];\r\n\r\n    if (actorat[checkx+dx][checky+dy])\r\n    {\r\n        SD_PlaySound (NOWAYSND);\r\n        return;\r\n    }\r\n    actorat[checkx+dx][checky+dy] = (objtype *)(uintptr_t) (tilemap[checkx+dx][checky+dy] = oldtile);\r\n\r\n    gamestate.secretcount++;\r\n    pwallx = checkx;\r\n    pwally = checky;\r\n    pwalldir = dir;\r\n    pwallstate = 1;\r\n    pwallpos = 0;\r\n    pwalltile = tilemap[pwallx][pwally];\r\n    tilemap[pwallx][pwally] = 64;\r\n    tilemap[pwallx+dx][pwally+dy] = 64;\r\n    *(mapsegs[1]+(pwally<<mapshift)+pwallx) = 0;   // remove P tile info\r\n    *(mapsegs[0]+(pwally<<mapshift)+pwallx) = *(mapsegs[0]+(player->tiley<<mapshift)+player->tilex); // set correct floorcode (BrotherTank's fix)\r\n\r\n    SD_PlaySound (PUSHWALLSND);\r\n}\r\n\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= MovePWalls\r\n=\r\n=================\r\n*/\r\n\r\nvoid MovePWalls (void)\r\n{\r\n    int oldblock,oldtile;\r\n\r\n    if (!pwallstate)\r\n        return;\r\n\r\n    oldblock = pwallstate/128;\r\n\r\n    pwallstate += (word)tics;\r\n\r\n    if (pwallstate/128 != oldblock)\r\n    {\r\n        // block crossed into a new block\r\n        oldtile = pwalltile;\r\n\r\n        //\r\n        // the tile can now be walked into\r\n        //\r\n        tilemap[pwallx][pwally] = 0;\r\n        actorat[pwallx][pwally] = 0;\r\n        *(mapsegs[0]+(pwally<<mapshift)+pwallx) = player->areanumber+AREATILE;\r\n\r\n        int dx=dirs[pwalldir][0], dy=dirs[pwalldir][1];\r\n        //\r\n        // see if it should be pushed farther\r\n        //\r\n        if (pwallstate>=256)            // only move two tiles fix\r\n        {\r\n            //\r\n            // the block has been pushed two tiles\r\n            //\r\n            pwallstate = 0;\r\n            tilemap[pwallx+dx][pwally+dy] = oldtile;\r\n            return;\r\n        }\r\n        else\r\n        {\r\n            int xl,yl,xh,yh;\r\n            xl = (player->x-PLAYERSIZE) >> TILESHIFT;\r\n            yl = (player->y-PLAYERSIZE) >> TILESHIFT;\r\n            xh = (player->x+PLAYERSIZE) >> TILESHIFT;\r\n            yh = (player->y+PLAYERSIZE) >> TILESHIFT;\r\n\r\n            pwallx += dx;\r\n            pwally += dy;\r\n\r\n            if (actorat[pwallx+dx][pwally+dy]\r\n                || xl<=pwallx+dx && pwallx+dx<=xh && yl<=pwally+dy && pwally+dy<=yh)\r\n            {\r\n                pwallstate = 0;\r\n                tilemap[pwallx][pwally] = oldtile;\r\n                return;\r\n            }\r\n            actorat[pwallx+dx][pwally+dy] = (objtype *)(uintptr_t) (tilemap[pwallx+dx][pwally+dy] = oldtile);\r\n            tilemap[pwallx+dx][pwally+dy] = 64;\r\n        }\r\n    }\r\n\r\n    pwallpos = (pwallstate/2)&63;\r\n}\r\n","// WL_ACT2.C\r\n\r\n#include <stdio.h>\r\n#include <math.h>\r\n#include \"wl_def.h\"\r\n#pragma hdrstop\r\n\r\n/*\r\n=============================================================================\r\n\r\n                               LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define PROJECTILESIZE  0xc000l\r\n\r\n#define BJRUNSPEED      2048\r\n#define BJJUMPSPEED     680\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                              GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                              LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\ndirtype dirtable[9] = {northwest,north,northeast,west,nodir,east,\r\n    southwest,south,southeast};\r\n\r\nshort starthitpoints[4][NUMENEMIES] =\r\n//\r\n// BABY MODE\r\n//\r\n{\r\n    {\r\n        25,   // guards\r\n        50,   // officer\r\n        100,  // SS\r\n        1,    // dogs\r\n        850,  // Hans\r\n        850,  // Schabbs\r\n        200,  // fake hitler\r\n        800,  // mecha hitler\r\n        45,   // mutants\r\n        25,   // ghosts\r\n        25,   // ghosts\r\n        25,   // ghosts\r\n        25,   // ghosts\r\n\r\n        850,  // Gretel\r\n        850,  // Gift\r\n        850,  // Fat\r\n        5,    // en_spectre,\r\n        1450, // en_angel,\r\n        850,  // en_trans,\r\n        1050, // en_uber,\r\n        950,  // en_will,\r\n        1250  // en_death\r\n    },\r\n    //\r\n    // DON'T HURT ME MODE\r\n    //\r\n    {\r\n        25,   // guards\r\n        50,   // officer\r\n        100,  // SS\r\n        1,    // dogs\r\n        950,  // Hans\r\n        950,  // Schabbs\r\n        300,  // fake hitler\r\n        950,  // mecha hitler\r\n        55,   // mutants\r\n        25,   // ghosts\r\n        25,   // ghosts\r\n        25,   // ghosts\r\n        25,   // ghosts\r\n\r\n        950,  // Gretel\r\n        950,  // Gift\r\n        950,  // Fat\r\n        10,   // en_spectre,\r\n        1550, // en_angel,\r\n        950,  // en_trans,\r\n        1150, // en_uber,\r\n        1050, // en_will,\r\n        1350  // en_death\r\n    },\r\n    //\r\n    // BRING 'EM ON MODE\r\n    //\r\n    {\r\n        25,   // guards\r\n        50,   // officer\r\n        100,  // SS\r\n        1,    // dogs\r\n\r\n        1050, // Hans\r\n        1550, // Schabbs\r\n        400,  // fake hitler\r\n        1050, // mecha hitler\r\n\r\n        55,   // mutants\r\n        25,   // ghosts\r\n        25,   // ghosts\r\n        25,   // ghosts\r\n        25,   // ghosts\r\n\r\n        1050, // Gretel\r\n        1050, // Gift\r\n        1050, // Fat\r\n        15,   // en_spectre,\r\n        1650, // en_angel,\r\n        1050, // en_trans,\r\n        1250, // en_uber,\r\n        1150, // en_will,\r\n        1450  // en_death\r\n    },\r\n    //\r\n    // DEATH INCARNATE MODE\r\n    //\r\n    {\r\n        25,   // guards\r\n        50,   // officer\r\n        100,  // SS\r\n        1,    // dogs\r\n\r\n        1200, // Hans\r\n        2400, // Schabbs\r\n        500,  // fake hitler\r\n        1200, // mecha hitler\r\n\r\n        65,   // mutants\r\n        25,   // ghosts\r\n        25,   // ghosts\r\n        25,   // ghosts\r\n        25,   // ghosts\r\n\r\n        1200, // Gretel\r\n        1200, // Gift\r\n        1200, // Fat\r\n        25,   // en_spectre,\r\n        2000, // en_angel,\r\n        1200, // en_trans,\r\n        1400, // en_uber,\r\n        1300, // en_will,\r\n        1600  // en_death\r\n    }\r\n};\r\n\r\nvoid    A_StartDeathCam (objtype *ob);\r\n\r\n\r\nvoid    T_Path (objtype *ob);\r\nvoid    T_Shoot (objtype *ob);\r\nvoid    T_Bite (objtype *ob);\r\nvoid    T_DogChase (objtype *ob);\r\nvoid    T_Chase (objtype *ob);\r\nvoid    T_Projectile (objtype *ob);\r\nvoid    T_Stand (objtype *ob);\r\n\r\nvoid A_DeathScream (objtype *ob);\r\n\r\nextern  statetype s_rocket;\r\nextern  statetype s_smoke1;\r\nextern  statetype s_smoke2;\r\nextern  statetype s_smoke3;\r\nextern  statetype s_smoke4;\r\nextern  statetype s_boom2;\r\nextern  statetype s_boom3;\r\n\r\nvoid A_Smoke (objtype *ob);\r\n\r\nstatetype s_rocket              = {true,SPR_ROCKET_1,3,(statefunc)T_Projectile,(statefunc)A_Smoke,&s_rocket};\r\nstatetype s_smoke1              = {false,SPR_SMOKE_1,3,NULL,NULL,&s_smoke2};\r\nstatetype s_smoke2              = {false,SPR_SMOKE_2,3,NULL,NULL,&s_smoke3};\r\nstatetype s_smoke3              = {false,SPR_SMOKE_3,3,NULL,NULL,&s_smoke4};\r\nstatetype s_smoke4              = {false,SPR_SMOKE_4,3,NULL,NULL,NULL};\r\n\r\nstatetype s_boom1               = {false,SPR_BOOM_1,6,NULL,NULL,&s_boom2};\r\nstatetype s_boom2               = {false,SPR_BOOM_2,6,NULL,NULL,&s_boom3};\r\nstatetype s_boom3               = {false,SPR_BOOM_3,6,NULL,NULL,NULL};\r\n\r\n#ifdef SPEAR\r\n\r\nextern  statetype s_hrocket;\r\nextern  statetype s_hsmoke1;\r\nextern  statetype s_hsmoke2;\r\nextern  statetype s_hsmoke3;\r\nextern  statetype s_hsmoke4;\r\nextern  statetype s_hboom2;\r\nextern  statetype s_hboom3;\r\n\r\nvoid A_Smoke (objtype *ob);\r\n\r\nstatetype s_hrocket             = {true,SPR_HROCKET_1,3,(statefunc)T_Projectile,(statefunc)A_Smoke,&s_hrocket};\r\nstatetype s_hsmoke1             = {false,SPR_HSMOKE_1,3,NULL,NULL,&s_hsmoke2};\r\nstatetype s_hsmoke2             = {false,SPR_HSMOKE_2,3,NULL,NULL,&s_hsmoke3};\r\nstatetype s_hsmoke3             = {false,SPR_HSMOKE_3,3,NULL,NULL,&s_hsmoke4};\r\nstatetype s_hsmoke4             = {false,SPR_HSMOKE_4,3,NULL,NULL,NULL};\r\n\r\nstatetype s_hboom1              = {false,SPR_HBOOM_1,6,NULL,NULL,&s_hboom2};\r\nstatetype s_hboom2              = {false,SPR_HBOOM_2,6,NULL,NULL,&s_hboom3};\r\nstatetype s_hboom3              = {false,SPR_HBOOM_3,6,NULL,NULL,NULL};\r\n\r\n#endif\r\n\r\nvoid    T_Schabb (objtype *ob);\r\nvoid    T_SchabbThrow (objtype *ob);\r\nvoid    T_Fake (objtype *ob);\r\nvoid    T_FakeFire (objtype *ob);\r\nvoid    T_Ghosts (objtype *ob);\r\n\r\nvoid A_Slurpie (objtype *ob);\r\nvoid A_HitlerMorph (objtype *ob);\r\nvoid A_MechaSound (objtype *ob);\r\n\r\n/*\r\n=================\r\n=\r\n= A_Smoke\r\n=\r\n=================\r\n*/\r\n\r\nvoid A_Smoke (objtype *ob)\r\n{\r\n    GetNewActor ();\r\n#ifdef SPEAR\r\n    if (ob->obclass == hrocketobj)\r\n        newobj->state = &s_hsmoke1;\r\n    else\r\n#endif\r\n        newobj->state = &s_smoke1;\r\n    newobj->ticcount = 6;\r\n\r\n    newobj->tilex = ob->tilex;\r\n    newobj->tiley = ob->tiley;\r\n    newobj->x = ob->x;\r\n    newobj->y = ob->y;\r\n    newobj->obclass = inertobj;\r\n    newobj->active = ac_yes;\r\n\r\n    newobj->flags = FL_NEVERMARK;\r\n}\r\n\r\n\r\n/*\r\n===================\r\n=\r\n= ProjectileTryMove\r\n=\r\n= returns true if move ok\r\n===================\r\n*/\r\n\r\n#define PROJSIZE        0x2000\r\n\r\nboolean ProjectileTryMove (objtype *ob)\r\n{\r\n    int      xl,yl,xh,yh,x,y;\r\n    objtype *check;\r\n\r\n    xl = (ob->x-PROJSIZE) >> TILESHIFT;\r\n    yl = (ob->y-PROJSIZE) >> TILESHIFT;\r\n\r\n    xh = (ob->x+PROJSIZE) >> TILESHIFT;\r\n    yh = (ob->y+PROJSIZE) >> TILESHIFT;\r\n\r\n    //\r\n    // check for solid walls\r\n    //\r\n    for (y=yl;y<=yh;y++)\r\n        for (x=xl;x<=xh;x++)\r\n        {\r\n            check = actorat[x][y];\r\n            if (check && !ISPOINTER(check))\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n}\r\n\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= T_Projectile\r\n=\r\n=================\r\n*/\r\n\r\nvoid T_Projectile (objtype *ob)\r\n{\r\n    int32_t deltax,deltay;\r\n    int     damage;\r\n    int32_t speed;\r\n\r\n    speed = (int32_t)ob->speed*tics;\r\n\r\n    deltax = FixedMul(speed,costable[ob->angle]);\r\n    deltay = -FixedMul(speed,sintable[ob->angle]);\r\n\r\n    if (deltax>0x10000l)\r\n        deltax = 0x10000l;\r\n    if (deltay>0x10000l)\r\n        deltay = 0x10000l;\r\n\r\n    ob->x += deltax;\r\n    ob->y += deltay;\r\n\r\n    deltax = LABS(ob->x - player->x);\r\n    deltay = LABS(ob->y - player->y);\r\n\r\n    if (!ProjectileTryMove (ob))\r\n    {\r\n#ifndef APOGEE_1_0          // actually the whole method is never reached in shareware 1.0\r\n        if (ob->obclass == rocketobj)\r\n        {\r\n            PlaySoundLocActor(MISSILEHITSND,ob);\r\n            ob->state = &s_boom1;\r\n        }\r\n#ifdef SPEAR\r\n        else if (ob->obclass == hrocketobj)\r\n        {\r\n            PlaySoundLocActor(MISSILEHITSND,ob);\r\n            ob->state = &s_hboom1;\r\n        }\r\n#endif\r\n        else\r\n#endif\r\n            ob->state = NULL;               // mark for removal\r\n\r\n        return;\r\n    }\r\n\r\n    if (deltax < PROJECTILESIZE && deltay < PROJECTILESIZE)\r\n    {       // hit the player\r\n        switch (ob->obclass)\r\n        {\r\n        case needleobj:\r\n            damage = (US_RndT() >>3) + 20;\r\n            break;\r\n        case rocketobj:\r\n        case hrocketobj:\r\n        case sparkobj:\r\n            damage = (US_RndT() >>3) + 30;\r\n            break;\r\n        case fireobj:\r\n            damage = (US_RndT() >>3);\r\n            break;\r\n        }\r\n\r\n        TakeDamage (damage,ob);\r\n        ob->state = NULL;               // mark for removal\r\n        return;\r\n    }\r\n\r\n    ob->tilex = (short)(ob->x >> TILESHIFT);\r\n    ob->tiley = (short)(ob->y >> TILESHIFT);\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\nGUARD\r\n\r\n=============================================================================\r\n*/\r\n\r\n//\r\n// guards\r\n//\r\n\r\nextern  statetype s_grdstand;\r\n\r\nextern  statetype s_grdpath1;\r\nextern  statetype s_grdpath1s;\r\nextern  statetype s_grdpath2;\r\nextern  statetype s_grdpath3;\r\nextern  statetype s_grdpath3s;\r\nextern  statetype s_grdpath4;\r\n\r\nextern  statetype s_grdpain;\r\nextern  statetype s_grdpain1;\r\n\r\nextern  statetype s_grdgiveup;\r\n\r\nextern  statetype s_grdshoot1;\r\nextern  statetype s_grdshoot2;\r\nextern  statetype s_grdshoot3;\r\nextern  statetype s_grdshoot4;\r\n\r\nextern  statetype s_grdchase1;\r\nextern  statetype s_grdchase1s;\r\nextern  statetype s_grdchase2;\r\nextern  statetype s_grdchase3;\r\nextern  statetype s_grdchase3s;\r\nextern  statetype s_grdchase4;\r\n\r\nextern  statetype s_grddie1;\r\nextern  statetype s_grddie1d;\r\nextern  statetype s_grddie2;\r\nextern  statetype s_grddie3;\r\nextern  statetype s_grddie4;\r\n\r\nstatetype s_grdstand            = {true,SPR_GRD_S_1,0,(statefunc)T_Stand,NULL,&s_grdstand};\r\n\r\nstatetype s_grdpath1            = {true,SPR_GRD_W1_1,20,(statefunc)T_Path,NULL,&s_grdpath1s};\r\nstatetype s_grdpath1s           = {true,SPR_GRD_W1_1,5,NULL,NULL,&s_grdpath2};\r\nstatetype s_grdpath2            = {true,SPR_GRD_W2_1,15,(statefunc)T_Path,NULL,&s_grdpath3};\r\nstatetype s_grdpath3            = {true,SPR_GRD_W3_1,20,(statefunc)T_Path,NULL,&s_grdpath3s};\r\nstatetype s_grdpath3s           = {true,SPR_GRD_W3_1,5,NULL,NULL,&s_grdpath4};\r\nstatetype s_grdpath4            = {true,SPR_GRD_W4_1,15,(statefunc)T_Path,NULL,&s_grdpath1};\r\n\r\nstatetype s_grdpain             = {2,SPR_GRD_PAIN_1,10,NULL,NULL,&s_grdchase1};\r\nstatetype s_grdpain1            = {2,SPR_GRD_PAIN_2,10,NULL,NULL,&s_grdchase1};\r\n\r\nstatetype s_grdshoot1           = {false,SPR_GRD_SHOOT1,20,NULL,NULL,&s_grdshoot2};\r\nstatetype s_grdshoot2           = {false,SPR_GRD_SHOOT2,20,NULL,(statefunc)T_Shoot,&s_grdshoot3};\r\nstatetype s_grdshoot3           = {false,SPR_GRD_SHOOT3,20,NULL,NULL,&s_grdchase1};\r\n\r\nstatetype s_grdchase1           = {true,SPR_GRD_W1_1,10,(statefunc)T_Chase,NULL,&s_grdchase1s};\r\nstatetype s_grdchase1s          = {true,SPR_GRD_W1_1,3,NULL,NULL,&s_grdchase2};\r\nstatetype s_grdchase2           = {true,SPR_GRD_W2_1,8,(statefunc)T_Chase,NULL,&s_grdchase3};\r\nstatetype s_grdchase3           = {true,SPR_GRD_W3_1,10,(statefunc)T_Chase,NULL,&s_grdchase3s};\r\nstatetype s_grdchase3s          = {true,SPR_GRD_W3_1,3,NULL,NULL,&s_grdchase4};\r\nstatetype s_grdchase4           = {true,SPR_GRD_W4_1,8,(statefunc)T_Chase,NULL,&s_grdchase1};\r\n\r\nstatetype s_grddie1             = {false,SPR_GRD_DIE_1,15,NULL,(statefunc)A_DeathScream,&s_grddie2};\r\nstatetype s_grddie2             = {false,SPR_GRD_DIE_2,15,NULL,NULL,&s_grddie3};\r\nstatetype s_grddie3             = {false,SPR_GRD_DIE_3,15,NULL,NULL,&s_grddie4};\r\nstatetype s_grddie4             = {false,SPR_GRD_DEAD,0,NULL,NULL,&s_grddie4};\r\n\r\n\r\n#ifndef SPEAR\r\n//\r\n// ghosts\r\n//\r\nextern  statetype s_blinkychase1;\r\nextern  statetype s_blinkychase2;\r\nextern  statetype s_inkychase1;\r\nextern  statetype s_inkychase2;\r\nextern  statetype s_pinkychase1;\r\nextern  statetype s_pinkychase2;\r\nextern  statetype s_clydechase1;\r\nextern  statetype s_clydechase2;\r\n\r\nstatetype s_blinkychase1        = {false,SPR_BLINKY_W1,10,(statefunc)T_Ghosts,NULL,&s_blinkychase2};\r\nstatetype s_blinkychase2        = {false,SPR_BLINKY_W2,10,(statefunc)T_Ghosts,NULL,&s_blinkychase1};\r\n\r\nstatetype s_inkychase1          = {false,SPR_INKY_W1,10,(statefunc)T_Ghosts,NULL,&s_inkychase2};\r\nstatetype s_inkychase2          = {false,SPR_INKY_W2,10,(statefunc)T_Ghosts,NULL,&s_inkychase1};\r\n\r\nstatetype s_pinkychase1         = {false,SPR_PINKY_W1,10,(statefunc)T_Ghosts,NULL,&s_pinkychase2};\r\nstatetype s_pinkychase2         = {false,SPR_PINKY_W2,10,(statefunc)T_Ghosts,NULL,&s_pinkychase1};\r\n\r\nstatetype s_clydechase1         = {false,SPR_CLYDE_W1,10,(statefunc)T_Ghosts,NULL,&s_clydechase2};\r\nstatetype s_clydechase2         = {false,SPR_CLYDE_W2,10,(statefunc)T_Ghosts,NULL,&s_clydechase1};\r\n#endif\r\n\r\n//\r\n// dogs\r\n//\r\n\r\nextern  statetype s_dogpath1;\r\nextern  statetype s_dogpath1s;\r\nextern  statetype s_dogpath2;\r\nextern  statetype s_dogpath3;\r\nextern  statetype s_dogpath3s;\r\nextern  statetype s_dogpath4;\r\n\r\nextern  statetype s_dogjump1;\r\nextern  statetype s_dogjump2;\r\nextern  statetype s_dogjump3;\r\nextern  statetype s_dogjump4;\r\nextern  statetype s_dogjump5;\r\n\r\nextern  statetype s_dogchase1;\r\nextern  statetype s_dogchase1s;\r\nextern  statetype s_dogchase2;\r\nextern  statetype s_dogchase3;\r\nextern  statetype s_dogchase3s;\r\nextern  statetype s_dogchase4;\r\n\r\nextern  statetype s_dogdie1;\r\nextern  statetype s_dogdie1d;\r\nextern  statetype s_dogdie2;\r\nextern  statetype s_dogdie3;\r\nextern  statetype s_dogdead;\r\n\r\nstatetype s_dogpath1            = {true,SPR_DOG_W1_1,20,(statefunc)T_Path,NULL,&s_dogpath1s};\r\nstatetype s_dogpath1s           = {true,SPR_DOG_W1_1,5,NULL,NULL,&s_dogpath2};\r\nstatetype s_dogpath2            = {true,SPR_DOG_W2_1,15,(statefunc)T_Path,NULL,&s_dogpath3};\r\nstatetype s_dogpath3            = {true,SPR_DOG_W3_1,20,(statefunc)T_Path,NULL,&s_dogpath3s};\r\nstatetype s_dogpath3s           = {true,SPR_DOG_W3_1,5,NULL,NULL,&s_dogpath4};\r\nstatetype s_dogpath4            = {true,SPR_DOG_W4_1,15,(statefunc)T_Path,NULL,&s_dogpath1};\r\n\r\nstatetype s_dogjump1            = {false,SPR_DOG_JUMP1,10,NULL,NULL,&s_dogjump2};\r\nstatetype s_dogjump2            = {false,SPR_DOG_JUMP2,10,NULL,(statefunc)T_Bite,&s_dogjump3};\r\nstatetype s_dogjump3            = {false,SPR_DOG_JUMP3,10,NULL,NULL,&s_dogjump4};\r\nstatetype s_dogjump4            = {false,SPR_DOG_JUMP1,10,NULL,NULL,&s_dogjump5};\r\nstatetype s_dogjump5            = {false,SPR_DOG_W1_1,10,NULL,NULL,&s_dogchase1};\r\n\r\nstatetype s_dogchase1           = {true,SPR_DOG_W1_1,10,(statefunc)T_DogChase,NULL,&s_dogchase1s};\r\nstatetype s_dogchase1s          = {true,SPR_DOG_W1_1,3,NULL,NULL,&s_dogchase2};\r\nstatetype s_dogchase2           = {true,SPR_DOG_W2_1,8,(statefunc)T_DogChase,NULL,&s_dogchase3};\r\nstatetype s_dogchase3           = {true,SPR_DOG_W3_1,10,(statefunc)T_DogChase,NULL,&s_dogchase3s};\r\nstatetype s_dogchase3s          = {true,SPR_DOG_W3_1,3,NULL,NULL,&s_dogchase4};\r\nstatetype s_dogchase4           = {true,SPR_DOG_W4_1,8,(statefunc)T_DogChase,NULL,&s_dogchase1};\r\n\r\nstatetype s_dogdie1             = {false,SPR_DOG_DIE_1,15,NULL,(statefunc)A_DeathScream,&s_dogdie2};\r\nstatetype s_dogdie2             = {false,SPR_DOG_DIE_2,15,NULL,NULL,&s_dogdie3};\r\nstatetype s_dogdie3             = {false,SPR_DOG_DIE_3,15,NULL,NULL,&s_dogdead};\r\nstatetype s_dogdead             = {false,SPR_DOG_DEAD,15,NULL,NULL,&s_dogdead};\r\n\r\n\r\n//\r\n// officers\r\n//\r\n\r\nextern  statetype s_ofcstand;\r\n\r\nextern  statetype s_ofcpath1;\r\nextern  statetype s_ofcpath1s;\r\nextern  statetype s_ofcpath2;\r\nextern  statetype s_ofcpath3;\r\nextern  statetype s_ofcpath3s;\r\nextern  statetype s_ofcpath4;\r\n\r\nextern  statetype s_ofcpain;\r\nextern  statetype s_ofcpain1;\r\n\r\nextern  statetype s_ofcgiveup;\r\n\r\nextern  statetype s_ofcshoot1;\r\nextern  statetype s_ofcshoot2;\r\nextern  statetype s_ofcshoot3;\r\nextern  statetype s_ofcshoot4;\r\n\r\nextern  statetype s_ofcchase1;\r\nextern  statetype s_ofcchase1s;\r\nextern  statetype s_ofcchase2;\r\nextern  statetype s_ofcchase3;\r\nextern  statetype s_ofcchase3s;\r\nextern  statetype s_ofcchase4;\r\n\r\nextern  statetype s_ofcdie1;\r\nextern  statetype s_ofcdie2;\r\nextern  statetype s_ofcdie3;\r\nextern  statetype s_ofcdie4;\r\nextern  statetype s_ofcdie5;\r\n\r\nstatetype s_ofcstand            = {true,SPR_OFC_S_1,0,(statefunc)T_Stand,NULL,&s_ofcstand};\r\n\r\nstatetype s_ofcpath1            = {true,SPR_OFC_W1_1,20,(statefunc)T_Path,NULL,&s_ofcpath1s};\r\nstatetype s_ofcpath1s           = {true,SPR_OFC_W1_1,5,NULL,NULL,&s_ofcpath2};\r\nstatetype s_ofcpath2            = {true,SPR_OFC_W2_1,15,(statefunc)T_Path,NULL,&s_ofcpath3};\r\nstatetype s_ofcpath3            = {true,SPR_OFC_W3_1,20,(statefunc)T_Path,NULL,&s_ofcpath3s};\r\nstatetype s_ofcpath3s           = {true,SPR_OFC_W3_1,5,NULL,NULL,&s_ofcpath4};\r\nstatetype s_ofcpath4            = {true,SPR_OFC_W4_1,15,(statefunc)T_Path,NULL,&s_ofcpath1};\r\n\r\nstatetype s_ofcpain             = {2,SPR_OFC_PAIN_1,10,NULL,NULL,&s_ofcchase1};\r\nstatetype s_ofcpain1            = {2,SPR_OFC_PAIN_2,10,NULL,NULL,&s_ofcchase1};\r\n\r\nstatetype s_ofcshoot1           = {false,SPR_OFC_SHOOT1,6,NULL,NULL,&s_ofcshoot2};\r\nstatetype s_ofcshoot2           = {false,SPR_OFC_SHOOT2,20,NULL,(statefunc)T_Shoot,&s_ofcshoot3};\r\nstatetype s_ofcshoot3           = {false,SPR_OFC_SHOOT3,10,NULL,NULL,&s_ofcchase1};\r\n\r\nstatetype s_ofcchase1           = {true,SPR_OFC_W1_1,10,(statefunc)T_Chase,NULL,&s_ofcchase1s};\r\nstatetype s_ofcchase1s          = {true,SPR_OFC_W1_1,3,NULL,NULL,&s_ofcchase2};\r\nstatetype s_ofcchase2           = {true,SPR_OFC_W2_1,8,(statefunc)T_Chase,NULL,&s_ofcchase3};\r\nstatetype s_ofcchase3           = {true,SPR_OFC_W3_1,10,(statefunc)T_Chase,NULL,&s_ofcchase3s};\r\nstatetype s_ofcchase3s          = {true,SPR_OFC_W3_1,3,NULL,NULL,&s_ofcchase4};\r\nstatetype s_ofcchase4           = {true,SPR_OFC_W4_1,8,(statefunc)T_Chase,NULL,&s_ofcchase1};\r\n\r\nstatetype s_ofcdie1             = {false,SPR_OFC_DIE_1,11,NULL,(statefunc)A_DeathScream,&s_ofcdie2};\r\nstatetype s_ofcdie2             = {false,SPR_OFC_DIE_2,11,NULL,NULL,&s_ofcdie3};\r\nstatetype s_ofcdie3             = {false,SPR_OFC_DIE_3,11,NULL,NULL,&s_ofcdie4};\r\nstatetype s_ofcdie4             = {false,SPR_OFC_DIE_4,11,NULL,NULL,&s_ofcdie5};\r\nstatetype s_ofcdie5             = {false,SPR_OFC_DEAD,0,NULL,NULL,&s_ofcdie5};\r\n\r\n\r\n//\r\n// mutant\r\n//\r\n\r\nextern  statetype s_mutstand;\r\n\r\nextern  statetype s_mutpath1;\r\nextern  statetype s_mutpath1s;\r\nextern  statetype s_mutpath2;\r\nextern  statetype s_mutpath3;\r\nextern  statetype s_mutpath3s;\r\nextern  statetype s_mutpath4;\r\n\r\nextern  statetype s_mutpain;\r\nextern  statetype s_mutpain1;\r\n\r\nextern  statetype s_mutgiveup;\r\n\r\nextern  statetype s_mutshoot1;\r\nextern  statetype s_mutshoot2;\r\nextern  statetype s_mutshoot3;\r\nextern  statetype s_mutshoot4;\r\n\r\nextern  statetype s_mutchase1;\r\nextern  statetype s_mutchase1s;\r\nextern  statetype s_mutchase2;\r\nextern  statetype s_mutchase3;\r\nextern  statetype s_mutchase3s;\r\nextern  statetype s_mutchase4;\r\n\r\nextern  statetype s_mutdie1;\r\nextern  statetype s_mutdie2;\r\nextern  statetype s_mutdie3;\r\nextern  statetype s_mutdie4;\r\nextern  statetype s_mutdie5;\r\n\r\nstatetype s_mutstand            = {true,SPR_MUT_S_1,0,(statefunc)T_Stand,NULL,&s_mutstand};\r\n\r\nstatetype s_mutpath1            = {true,SPR_MUT_W1_1,20,(statefunc)T_Path,NULL,&s_mutpath1s};\r\nstatetype s_mutpath1s           = {true,SPR_MUT_W1_1,5,NULL,NULL,&s_mutpath2};\r\nstatetype s_mutpath2            = {true,SPR_MUT_W2_1,15,(statefunc)T_Path,NULL,&s_mutpath3};\r\nstatetype s_mutpath3            = {true,SPR_MUT_W3_1,20,(statefunc)T_Path,NULL,&s_mutpath3s};\r\nstatetype s_mutpath3s           = {true,SPR_MUT_W3_1,5,NULL,NULL,&s_mutpath4};\r\nstatetype s_mutpath4            = {true,SPR_MUT_W4_1,15,(statefunc)T_Path,NULL,&s_mutpath1};\r\n\r\nstatetype s_mutpain             = {2,SPR_MUT_PAIN_1,10,NULL,NULL,&s_mutchase1};\r\nstatetype s_mutpain1            = {2,SPR_MUT_PAIN_2,10,NULL,NULL,&s_mutchase1};\r\n\r\nstatetype s_mutshoot1           = {false,SPR_MUT_SHOOT1,6,NULL,(statefunc)T_Shoot,&s_mutshoot2};\r\nstatetype s_mutshoot2           = {false,SPR_MUT_SHOOT2,20,NULL,NULL,&s_mutshoot3};\r\nstatetype s_mutshoot3           = {false,SPR_MUT_SHOOT3,10,NULL,(statefunc)T_Shoot,&s_mutshoot4};\r\nstatetype s_mutshoot4           = {false,SPR_MUT_SHOOT4,20,NULL,NULL,&s_mutchase1};\r\n\r\nstatetype s_mutchase1           = {true,SPR_MUT_W1_1,10,(statefunc)T_Chase,NULL,&s_mutchase1s};\r\nstatetype s_mutchase1s          = {true,SPR_MUT_W1_1,3,NULL,NULL,&s_mutchase2};\r\nstatetype s_mutchase2           = {true,SPR_MUT_W2_1,8,(statefunc)T_Chase,NULL,&s_mutchase3};\r\nstatetype s_mutchase3           = {true,SPR_MUT_W3_1,10,(statefunc)T_Chase,NULL,&s_mutchase3s};\r\nstatetype s_mutchase3s          = {true,SPR_MUT_W3_1,3,NULL,NULL,&s_mutchase4};\r\nstatetype s_mutchase4           = {true,SPR_MUT_W4_1,8,(statefunc)T_Chase,NULL,&s_mutchase1};\r\n\r\nstatetype s_mutdie1             = {false,SPR_MUT_DIE_1,7,NULL,(statefunc)A_DeathScream,&s_mutdie2};\r\nstatetype s_mutdie2             = {false,SPR_MUT_DIE_2,7,NULL,NULL,&s_mutdie3};\r\nstatetype s_mutdie3             = {false,SPR_MUT_DIE_3,7,NULL,NULL,&s_mutdie4};\r\nstatetype s_mutdie4             = {false,SPR_MUT_DIE_4,7,NULL,NULL,&s_mutdie5};\r\nstatetype s_mutdie5             = {false,SPR_MUT_DEAD,0,NULL,NULL,&s_mutdie5};\r\n\r\n\r\n//\r\n// SS\r\n//\r\n\r\nextern  statetype s_ssstand;\r\n\r\nextern  statetype s_sspath1;\r\nextern  statetype s_sspath1s;\r\nextern  statetype s_sspath2;\r\nextern  statetype s_sspath3;\r\nextern  statetype s_sspath3s;\r\nextern  statetype s_sspath4;\r\n\r\nextern  statetype s_sspain;\r\nextern  statetype s_sspain1;\r\n\r\nextern  statetype s_ssshoot1;\r\nextern  statetype s_ssshoot2;\r\nextern  statetype s_ssshoot3;\r\nextern  statetype s_ssshoot4;\r\nextern  statetype s_ssshoot5;\r\nextern  statetype s_ssshoot6;\r\nextern  statetype s_ssshoot7;\r\nextern  statetype s_ssshoot8;\r\nextern  statetype s_ssshoot9;\r\n\r\nextern  statetype s_sschase1;\r\nextern  statetype s_sschase1s;\r\nextern  statetype s_sschase2;\r\nextern  statetype s_sschase3;\r\nextern  statetype s_sschase3s;\r\nextern  statetype s_sschase4;\r\n\r\nextern  statetype s_ssdie1;\r\nextern  statetype s_ssdie2;\r\nextern  statetype s_ssdie3;\r\nextern  statetype s_ssdie4;\r\n\r\nstatetype s_ssstand             = {true,SPR_SS_S_1,0,(statefunc)T_Stand,NULL,&s_ssstand};\r\n\r\nstatetype s_sspath1             = {true,SPR_SS_W1_1,20,(statefunc)T_Path,NULL,&s_sspath1s};\r\nstatetype s_sspath1s            = {true,SPR_SS_W1_1,5,NULL,NULL,&s_sspath2};\r\nstatetype s_sspath2             = {true,SPR_SS_W2_1,15,(statefunc)T_Path,NULL,&s_sspath3};\r\nstatetype s_sspath3             = {true,SPR_SS_W3_1,20,(statefunc)T_Path,NULL,&s_sspath3s};\r\nstatetype s_sspath3s            = {true,SPR_SS_W3_1,5,NULL,NULL,&s_sspath4};\r\nstatetype s_sspath4             = {true,SPR_SS_W4_1,15,(statefunc)T_Path,NULL,&s_sspath1};\r\n\r\nstatetype s_sspain              = {2,SPR_SS_PAIN_1,10,NULL,NULL,&s_sschase1};\r\nstatetype s_sspain1             = {2,SPR_SS_PAIN_2,10,NULL,NULL,&s_sschase1};\r\n\r\nstatetype s_ssshoot1            = {false,SPR_SS_SHOOT1,20,NULL,NULL,&s_ssshoot2};\r\nstatetype s_ssshoot2            = {false,SPR_SS_SHOOT2,20,NULL,(statefunc)T_Shoot,&s_ssshoot3};\r\nstatetype s_ssshoot3            = {false,SPR_SS_SHOOT3,10,NULL,NULL,&s_ssshoot4};\r\nstatetype s_ssshoot4            = {false,SPR_SS_SHOOT2,10,NULL,(statefunc)T_Shoot,&s_ssshoot5};\r\nstatetype s_ssshoot5            = {false,SPR_SS_SHOOT3,10,NULL,NULL,&s_ssshoot6};\r\nstatetype s_ssshoot6            = {false,SPR_SS_SHOOT2,10,NULL,(statefunc)T_Shoot,&s_ssshoot7};\r\nstatetype s_ssshoot7            = {false,SPR_SS_SHOOT3,10,NULL,NULL,&s_ssshoot8};\r\nstatetype s_ssshoot8            = {false,SPR_SS_SHOOT2,10,NULL,(statefunc)T_Shoot,&s_ssshoot9};\r\nstatetype s_ssshoot9            = {false,SPR_SS_SHOOT3,10,NULL,NULL,&s_sschase1};\r\n\r\nstatetype s_sschase1            = {true,SPR_SS_W1_1,10,(statefunc)T_Chase,NULL,&s_sschase1s};\r\nstatetype s_sschase1s           = {true,SPR_SS_W1_1,3,NULL,NULL,&s_sschase2};\r\nstatetype s_sschase2            = {true,SPR_SS_W2_1,8,(statefunc)T_Chase,NULL,&s_sschase3};\r\nstatetype s_sschase3            = {true,SPR_SS_W3_1,10,(statefunc)T_Chase,NULL,&s_sschase3s};\r\nstatetype s_sschase3s           = {true,SPR_SS_W3_1,3,NULL,NULL,&s_sschase4};\r\nstatetype s_sschase4            = {true,SPR_SS_W4_1,8,(statefunc)T_Chase,NULL,&s_sschase1};\r\n\r\nstatetype s_ssdie1              = {false,SPR_SS_DIE_1,15,NULL,(statefunc)A_DeathScream,&s_ssdie2};\r\nstatetype s_ssdie2              = {false,SPR_SS_DIE_2,15,NULL,NULL,&s_ssdie3};\r\nstatetype s_ssdie3              = {false,SPR_SS_DIE_3,15,NULL,NULL,&s_ssdie4};\r\nstatetype s_ssdie4              = {false,SPR_SS_DEAD,0,NULL,NULL,&s_ssdie4};\r\n\r\n\r\n#ifndef SPEAR\r\n//\r\n// hans\r\n//\r\nextern  statetype s_bossstand;\r\n\r\nextern  statetype s_bosschase1;\r\nextern  statetype s_bosschase1s;\r\nextern  statetype s_bosschase2;\r\nextern  statetype s_bosschase3;\r\nextern  statetype s_bosschase3s;\r\nextern  statetype s_bosschase4;\r\n\r\nextern  statetype s_bossdie1;\r\nextern  statetype s_bossdie2;\r\nextern  statetype s_bossdie3;\r\nextern  statetype s_bossdie4;\r\n\r\nextern  statetype s_bossshoot1;\r\nextern  statetype s_bossshoot2;\r\nextern  statetype s_bossshoot3;\r\nextern  statetype s_bossshoot4;\r\nextern  statetype s_bossshoot5;\r\nextern  statetype s_bossshoot6;\r\nextern  statetype s_bossshoot7;\r\nextern  statetype s_bossshoot8;\r\n\r\n\r\nstatetype s_bossstand           = {false,SPR_BOSS_W1,0,(statefunc)T_Stand,NULL,&s_bossstand};\r\n\r\nstatetype s_bosschase1          = {false,SPR_BOSS_W1,10,(statefunc)T_Chase,NULL,&s_bosschase1s};\r\nstatetype s_bosschase1s         = {false,SPR_BOSS_W1,3,NULL,NULL,&s_bosschase2};\r\nstatetype s_bosschase2          = {false,SPR_BOSS_W2,8,(statefunc)T_Chase,NULL,&s_bosschase3};\r\nstatetype s_bosschase3          = {false,SPR_BOSS_W3,10,(statefunc)T_Chase,NULL,&s_bosschase3s};\r\nstatetype s_bosschase3s         = {false,SPR_BOSS_W3,3,NULL,NULL,&s_bosschase4};\r\nstatetype s_bosschase4          = {false,SPR_BOSS_W4,8,(statefunc)T_Chase,NULL,&s_bosschase1};\r\n\r\nstatetype s_bossdie1            = {false,SPR_BOSS_DIE1,15,NULL,(statefunc)A_DeathScream,&s_bossdie2};\r\nstatetype s_bossdie2            = {false,SPR_BOSS_DIE2,15,NULL,NULL,&s_bossdie3};\r\nstatetype s_bossdie3            = {false,SPR_BOSS_DIE3,15,NULL,NULL,&s_bossdie4};\r\nstatetype s_bossdie4            = {false,SPR_BOSS_DEAD,0,NULL,NULL,&s_bossdie4};\r\n\r\nstatetype s_bossshoot1          = {false,SPR_BOSS_SHOOT1,30,NULL,NULL,&s_bossshoot2};\r\nstatetype s_bossshoot2          = {false,SPR_BOSS_SHOOT2,10,NULL,(statefunc)T_Shoot,&s_bossshoot3};\r\nstatetype s_bossshoot3          = {false,SPR_BOSS_SHOOT3,10,NULL,(statefunc)T_Shoot,&s_bossshoot4};\r\nstatetype s_bossshoot4          = {false,SPR_BOSS_SHOOT2,10,NULL,(statefunc)T_Shoot,&s_bossshoot5};\r\nstatetype s_bossshoot5          = {false,SPR_BOSS_SHOOT3,10,NULL,(statefunc)T_Shoot,&s_bossshoot6};\r\nstatetype s_bossshoot6          = {false,SPR_BOSS_SHOOT2,10,NULL,(statefunc)T_Shoot,&s_bossshoot7};\r\nstatetype s_bossshoot7          = {false,SPR_BOSS_SHOOT3,10,NULL,(statefunc)T_Shoot,&s_bossshoot8};\r\nstatetype s_bossshoot8          = {false,SPR_BOSS_SHOOT1,10,NULL,NULL,&s_bosschase1};\r\n\r\n\r\n//\r\n// gretel\r\n//\r\nextern  statetype s_gretelstand;\r\n\r\nextern  statetype s_gretelchase1;\r\nextern  statetype s_gretelchase1s;\r\nextern  statetype s_gretelchase2;\r\nextern  statetype s_gretelchase3;\r\nextern  statetype s_gretelchase3s;\r\nextern  statetype s_gretelchase4;\r\n\r\nextern  statetype s_greteldie1;\r\nextern  statetype s_greteldie2;\r\nextern  statetype s_greteldie3;\r\nextern  statetype s_greteldie4;\r\n\r\nextern  statetype s_gretelshoot1;\r\nextern  statetype s_gretelshoot2;\r\nextern  statetype s_gretelshoot3;\r\nextern  statetype s_gretelshoot4;\r\nextern  statetype s_gretelshoot5;\r\nextern  statetype s_gretelshoot6;\r\nextern  statetype s_gretelshoot7;\r\nextern  statetype s_gretelshoot8;\r\n\r\n\r\nstatetype s_gretelstand         = {false,SPR_GRETEL_W1,0,(statefunc)T_Stand,NULL,&s_gretelstand};\r\n\r\nstatetype s_gretelchase1        = {false,SPR_GRETEL_W1,10,(statefunc)T_Chase,NULL,&s_gretelchase1s};\r\nstatetype s_gretelchase1s       = {false,SPR_GRETEL_W1,3,NULL,NULL,&s_gretelchase2};\r\nstatetype s_gretelchase2        = {false,SPR_GRETEL_W2,8,(statefunc)T_Chase,NULL,&s_gretelchase3};\r\nstatetype s_gretelchase3        = {false,SPR_GRETEL_W3,10,(statefunc)T_Chase,NULL,&s_gretelchase3s};\r\nstatetype s_gretelchase3s       = {false,SPR_GRETEL_W3,3,NULL,NULL,&s_gretelchase4};\r\nstatetype s_gretelchase4        = {false,SPR_GRETEL_W4,8,(statefunc)T_Chase,NULL,&s_gretelchase1};\r\n\r\nstatetype s_greteldie1          = {false,SPR_GRETEL_DIE1,15,NULL,(statefunc)A_DeathScream,&s_greteldie2};\r\nstatetype s_greteldie2          = {false,SPR_GRETEL_DIE2,15,NULL,NULL,&s_greteldie3};\r\nstatetype s_greteldie3          = {false,SPR_GRETEL_DIE3,15,NULL,NULL,&s_greteldie4};\r\nstatetype s_greteldie4          = {false,SPR_GRETEL_DEAD,0,NULL,NULL,&s_greteldie4};\r\n\r\nstatetype s_gretelshoot1        = {false,SPR_GRETEL_SHOOT1,30,NULL,NULL,&s_gretelshoot2};\r\nstatetype s_gretelshoot2        = {false,SPR_GRETEL_SHOOT2,10,NULL,(statefunc)T_Shoot,&s_gretelshoot3};\r\nstatetype s_gretelshoot3        = {false,SPR_GRETEL_SHOOT3,10,NULL,(statefunc)T_Shoot,&s_gretelshoot4};\r\nstatetype s_gretelshoot4        = {false,SPR_GRETEL_SHOOT2,10,NULL,(statefunc)T_Shoot,&s_gretelshoot5};\r\nstatetype s_gretelshoot5        = {false,SPR_GRETEL_SHOOT3,10,NULL,(statefunc)T_Shoot,&s_gretelshoot6};\r\nstatetype s_gretelshoot6        = {false,SPR_GRETEL_SHOOT2,10,NULL,(statefunc)T_Shoot,&s_gretelshoot7};\r\nstatetype s_gretelshoot7        = {false,SPR_GRETEL_SHOOT3,10,NULL,(statefunc)T_Shoot,&s_gretelshoot8};\r\nstatetype s_gretelshoot8        = {false,SPR_GRETEL_SHOOT1,10,NULL,NULL,&s_gretelchase1};\r\n#endif\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnStand\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnStand (enemy_t which, int tilex, int tiley, int dir)\r\n{\r\n    word *map;\r\n    word tile;\r\n\r\n    switch (which)\r\n    {\r\n        case en_guard:\r\n            SpawnNewObj (tilex,tiley,&s_grdstand);\r\n            newobj->speed = SPDPATROL;\r\n            if (!loadedgame)\r\n                gamestate.killtotal++;\r\n            break;\r\n\r\n        case en_officer:\r\n            SpawnNewObj (tilex,tiley,&s_ofcstand);\r\n            newobj->speed = SPDPATROL;\r\n            if (!loadedgame)\r\n                gamestate.killtotal++;\r\n            break;\r\n\r\n        case en_mutant:\r\n            SpawnNewObj (tilex,tiley,&s_mutstand);\r\n            newobj->speed = SPDPATROL;\r\n            if (!loadedgame)\r\n                gamestate.killtotal++;\r\n            break;\r\n\r\n        case en_ss:\r\n            SpawnNewObj (tilex,tiley,&s_ssstand);\r\n            newobj->speed = SPDPATROL;\r\n            if (!loadedgame)\r\n                gamestate.killtotal++;\r\n            break;\r\n    }\r\n\r\n\r\n    map = mapsegs[0]+(tiley<<mapshift)+tilex;\r\n    tile = *map;\r\n    if (tile == AMBUSHTILE)\r\n    {\r\n        tilemap[tilex][tiley] = 0;\r\n\r\n        if (*(map+1) >= AREATILE)\r\n            tile = *(map+1);\r\n        if (*(map-mapwidth) >= AREATILE)\r\n            tile = *(map-mapwidth);\r\n        if (*(map+mapwidth) >= AREATILE)\r\n            tile = *(map+mapwidth);\r\n        if ( *(map-1) >= AREATILE)\r\n            tile = *(map-1);\r\n\r\n        *map = tile;\r\n        newobj->areanumber = tile-AREATILE;\r\n\r\n        newobj->flags |= FL_AMBUSH;\r\n    }\r\n\r\n    newobj->obclass = (classtype)(guardobj + which);\r\n    newobj->hitpoints = starthitpoints[gamestate.difficulty][which];\r\n    newobj->dir = (dirtype)(dir * 2);\r\n    newobj->flags |= FL_SHOOTABLE;\r\n}\r\n\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnDeadGuard\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnDeadGuard (int tilex, int tiley)\r\n{\r\n    SpawnNewObj (tilex,tiley,&s_grddie4);\r\n    DEMOIF_SDL\r\n    {\r\n        newobj->flags |= FL_NONMARK;    // walk through moving enemy fix\r\n    }\r\n    newobj->obclass = inertobj;\r\n}\r\n\r\n\r\n\r\n#ifndef SPEAR\r\n/*\r\n===============\r\n=\r\n= SpawnBoss\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnBoss (int tilex, int tiley)\r\n{\r\n    SpawnNewObj (tilex,tiley,&s_bossstand);\r\n    newobj->speed = SPDPATROL;\r\n\r\n    newobj->obclass = bossobj;\r\n    newobj->hitpoints = starthitpoints[gamestate.difficulty][en_boss];\r\n    newobj->dir = nodir;\r\n    newobj->flags |= FL_SHOOTABLE|FL_AMBUSH;\r\n    if (!loadedgame)\r\n        gamestate.killtotal++;\r\n}\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnGretel\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnGretel (int tilex, int tiley)\r\n{\r\n    SpawnNewObj (tilex,tiley,&s_gretelstand);\r\n    newobj->speed = SPDPATROL;\r\n\r\n    newobj->obclass = gretelobj;\r\n    newobj->hitpoints = starthitpoints[gamestate.difficulty][en_gretel];\r\n    newobj->dir = nodir;\r\n    newobj->flags |= FL_SHOOTABLE|FL_AMBUSH;\r\n    if (!loadedgame)\r\n        gamestate.killtotal++;\r\n}\r\n#endif\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnPatrol\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnPatrol (enemy_t which, int tilex, int tiley, int dir)\r\n{\r\n    switch (which)\r\n    {\r\n        case en_guard:\r\n            SpawnNewObj (tilex,tiley,&s_grdpath1);\r\n            newobj->speed = SPDPATROL;\r\n            if (!loadedgame)\r\n                gamestate.killtotal++;\r\n            break;\r\n\r\n        case en_officer:\r\n            SpawnNewObj (tilex,tiley,&s_ofcpath1);\r\n            newobj->speed = SPDPATROL;\r\n            if (!loadedgame)\r\n                gamestate.killtotal++;\r\n            break;\r\n\r\n        case en_ss:\r\n            SpawnNewObj (tilex,tiley,&s_sspath1);\r\n            newobj->speed = SPDPATROL;\r\n            if (!loadedgame)\r\n                gamestate.killtotal++;\r\n            break;\r\n\r\n        case en_mutant:\r\n            SpawnNewObj (tilex,tiley,&s_mutpath1);\r\n            newobj->speed = SPDPATROL;\r\n            if (!loadedgame)\r\n                gamestate.killtotal++;\r\n            break;\r\n\r\n        case en_dog:\r\n            SpawnNewObj (tilex,tiley,&s_dogpath1);\r\n            newobj->speed = SPDDOG;\r\n            if (!loadedgame)\r\n                gamestate.killtotal++;\r\n            break;\r\n    }\r\n\r\n    newobj->obclass = (classtype)(guardobj+which);\r\n    newobj->dir = (dirtype)(dir*2);\r\n    newobj->hitpoints = starthitpoints[gamestate.difficulty][which];\r\n    newobj->distance = TILEGLOBAL;\r\n    newobj->flags |= FL_SHOOTABLE;\r\n    newobj->active = ac_yes;\r\n\r\n    actorat[newobj->tilex][newobj->tiley] = NULL;           // don't use original spot\r\n\r\n    switch (dir)\r\n    {\r\n        case 0:\r\n            newobj->tilex++;\r\n            break;\r\n        case 1:\r\n            newobj->tiley--;\r\n            break;\r\n        case 2:\r\n            newobj->tilex--;\r\n            break;\r\n        case 3:\r\n            newobj->tiley++;\r\n            break;\r\n    }\r\n\r\n    actorat[newobj->tilex][newobj->tiley] = newobj;\r\n}\r\n\r\n\r\n\r\n/*\r\n==================\r\n=\r\n= A_DeathScream\r\n=\r\n==================\r\n*/\r\n\r\nvoid A_DeathScream (objtype *ob)\r\n{\r\n#ifndef UPLOAD\r\n#ifndef SPEAR\r\n    if (mapon==9 && !US_RndT())\r\n#else\r\n    if ((mapon==18 || mapon==19) && !US_RndT())\r\n#endif\r\n    {\r\n        switch(ob->obclass)\r\n        {\r\n            case mutantobj:\r\n            case guardobj:\r\n            case officerobj:\r\n            case ssobj:\r\n            case dogobj:\r\n                PlaySoundLocActor(DEATHSCREAM6SND,ob);\r\n                return;\r\n        }\r\n    }\r\n#endif\r\n\r\n    switch (ob->obclass)\r\n    {\r\n        case mutantobj:\r\n            PlaySoundLocActor(AHHHGSND,ob);\r\n            break;\r\n\r\n        case guardobj:\r\n        {\r\n            int sounds[9]={ DEATHSCREAM1SND,\r\n                DEATHSCREAM2SND,\r\n                DEATHSCREAM3SND,\r\n#ifndef APOGEE_1_0\r\n                DEATHSCREAM4SND,\r\n                DEATHSCREAM5SND,\r\n                DEATHSCREAM7SND,\r\n                DEATHSCREAM8SND,\r\n                DEATHSCREAM9SND\r\n#endif\r\n            };\r\n\r\n#ifndef UPLOAD\r\n            PlaySoundLocActor(sounds[US_RndT()%8],ob);\r\n#else\r\n            PlaySoundLocActor(sounds[US_RndT()%2],ob);\r\n#endif\r\n            break;\r\n        }\r\n        case officerobj:\r\n            PlaySoundLocActor(NEINSOVASSND,ob);\r\n            break;\r\n        case ssobj:\r\n            PlaySoundLocActor(LEBENSND,ob); // JAB\r\n            break;\r\n        case dogobj:\r\n            PlaySoundLocActor(DOGDEATHSND,ob);      // JAB\r\n            break;\r\n#ifndef SPEAR\r\n        case bossobj:\r\n            SD_PlaySound(MUTTISND);                         // JAB\r\n            break;\r\n        case schabbobj:\r\n            SD_PlaySound(MEINGOTTSND);\r\n            break;\r\n        case fakeobj:\r\n            SD_PlaySound(HITLERHASND);\r\n            break;\r\n        case mechahitlerobj:\r\n            SD_PlaySound(SCHEISTSND);\r\n            break;\r\n        case realhitlerobj:\r\n            SD_PlaySound(EVASND);\r\n            break;\r\n#ifndef APOGEE_1_0\r\n        case gretelobj:\r\n            SD_PlaySound(MEINSND);\r\n            break;\r\n        case giftobj:\r\n            SD_PlaySound(DONNERSND);\r\n            break;\r\n        case fatobj:\r\n            SD_PlaySound(ROSESND);\r\n            break;\r\n#endif\r\n#else\r\n        case spectreobj:\r\n            SD_PlaySound(GHOSTFADESND);\r\n            break;\r\n        case angelobj:\r\n            SD_PlaySound(ANGELDEATHSND);\r\n            break;\r\n        case transobj:\r\n            SD_PlaySound(TRANSDEATHSND);\r\n            break;\r\n        case uberobj:\r\n            SD_PlaySound(UBERDEATHSND);\r\n            break;\r\n        case willobj:\r\n            SD_PlaySound(WILHELMDEATHSND);\r\n            break;\r\n        case deathobj:\r\n            SD_PlaySound(KNIGHTDEATHSND);\r\n            break;\r\n#endif\r\n    }\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                SPEAR ACTORS\r\n\r\n=============================================================================\r\n*/\r\n\r\n#ifdef SPEAR\r\n\r\nvoid T_Launch (objtype *ob);\r\nvoid T_Will (objtype *ob);\r\n\r\nextern  statetype s_angelshoot1;\r\nextern  statetype s_deathshoot1;\r\nextern  statetype s_spark1;\r\n\r\n//\r\n// trans\r\n//\r\nextern  statetype s_transstand;\r\n\r\nextern  statetype s_transchase1;\r\nextern  statetype s_transchase1s;\r\nextern  statetype s_transchase2;\r\nextern  statetype s_transchase3;\r\nextern  statetype s_transchase3s;\r\nextern  statetype s_transchase4;\r\n\r\nextern  statetype s_transdie0;\r\nextern  statetype s_transdie01;\r\nextern  statetype s_transdie1;\r\nextern  statetype s_transdie2;\r\nextern  statetype s_transdie3;\r\nextern  statetype s_transdie4;\r\n\r\nextern  statetype s_transshoot1;\r\nextern  statetype s_transshoot2;\r\nextern  statetype s_transshoot3;\r\nextern  statetype s_transshoot4;\r\nextern  statetype s_transshoot5;\r\nextern  statetype s_transshoot6;\r\nextern  statetype s_transshoot7;\r\nextern  statetype s_transshoot8;\r\n\r\n\r\nstatetype s_transstand          = {false,SPR_TRANS_W1,0,(statefunc)T_Stand,NULL,&s_transstand};\r\n\r\nstatetype s_transchase1         = {false,SPR_TRANS_W1,10,(statefunc)T_Chase,NULL,&s_transchase1s};\r\nstatetype s_transchase1s        = {false,SPR_TRANS_W1,3,NULL,NULL,&s_transchase2};\r\nstatetype s_transchase2         = {false,SPR_TRANS_W2,8,(statefunc)T_Chase,NULL,&s_transchase3};\r\nstatetype s_transchase3         = {false,SPR_TRANS_W3,10,(statefunc)T_Chase,NULL,&s_transchase3s};\r\nstatetype s_transchase3s        = {false,SPR_TRANS_W3,3,NULL,NULL,&s_transchase4};\r\nstatetype s_transchase4         = {false,SPR_TRANS_W4,8,(statefunc)T_Chase,NULL,&s_transchase1};\r\n\r\nstatetype s_transdie0           = {false,SPR_TRANS_W1,1,NULL,(statefunc)A_DeathScream,&s_transdie01};\r\nstatetype s_transdie01          = {false,SPR_TRANS_W1,1,NULL,NULL,&s_transdie1};\r\nstatetype s_transdie1           = {false,SPR_TRANS_DIE1,15,NULL,NULL,&s_transdie2};\r\nstatetype s_transdie2           = {false,SPR_TRANS_DIE2,15,NULL,NULL,&s_transdie3};\r\nstatetype s_transdie3           = {false,SPR_TRANS_DIE3,15,NULL,NULL,&s_transdie4};\r\nstatetype s_transdie4           = {false,SPR_TRANS_DEAD,0,NULL,NULL,&s_transdie4};\r\n\r\nstatetype s_transshoot1         = {false,SPR_TRANS_SHOOT1,30,NULL,NULL,&s_transshoot2};\r\nstatetype s_transshoot2         = {false,SPR_TRANS_SHOOT2,10,NULL,(statefunc)T_Shoot,&s_transshoot3};\r\nstatetype s_transshoot3         = {false,SPR_TRANS_SHOOT3,10,NULL,(statefunc)T_Shoot,&s_transshoot4};\r\nstatetype s_transshoot4         = {false,SPR_TRANS_SHOOT2,10,NULL,(statefunc)T_Shoot,&s_transshoot5};\r\nstatetype s_transshoot5         = {false,SPR_TRANS_SHOOT3,10,NULL,(statefunc)T_Shoot,&s_transshoot6};\r\nstatetype s_transshoot6         = {false,SPR_TRANS_SHOOT2,10,NULL,(statefunc)T_Shoot,&s_transshoot7};\r\nstatetype s_transshoot7         = {false,SPR_TRANS_SHOOT3,10,NULL,(statefunc)T_Shoot,&s_transshoot8};\r\nstatetype s_transshoot8         = {false,SPR_TRANS_SHOOT1,10,NULL,NULL,&s_transchase1};\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnTrans\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnTrans (int tilex, int tiley)\r\n{\r\n    //        word *map;\r\n    //        word tile;\r\n\r\n    if (SoundBlasterPresent && DigiMode != sds_Off)\r\n        s_transdie01.tictime = 105;\r\n\r\n    SpawnNewObj (tilex,tiley,&s_transstand);\r\n    newobj->obclass = transobj;\r\n    newobj->hitpoints = starthitpoints[gamestate.difficulty][en_trans];\r\n    newobj->flags |= FL_SHOOTABLE|FL_AMBUSH;\r\n    if (!loadedgame)\r\n        gamestate.killtotal++;\r\n}\r\n\r\n\r\n//\r\n// uber\r\n//\r\nvoid T_UShoot (objtype *ob);\r\n\r\nextern  statetype s_uberstand;\r\n\r\nextern  statetype s_uberchase1;\r\nextern  statetype s_uberchase1s;\r\nextern  statetype s_uberchase2;\r\nextern  statetype s_uberchase3;\r\nextern  statetype s_uberchase3s;\r\nextern  statetype s_uberchase4;\r\n\r\nextern  statetype s_uberdie0;\r\nextern  statetype s_uberdie01;\r\nextern  statetype s_uberdie1;\r\nextern  statetype s_uberdie2;\r\nextern  statetype s_uberdie3;\r\nextern  statetype s_uberdie4;\r\nextern  statetype s_uberdie5;\r\n\r\nextern  statetype s_ubershoot1;\r\nextern  statetype s_ubershoot2;\r\nextern  statetype s_ubershoot3;\r\nextern  statetype s_ubershoot4;\r\nextern  statetype s_ubershoot5;\r\nextern  statetype s_ubershoot6;\r\nextern  statetype s_ubershoot7;\r\n\r\n\r\nstatetype s_uberstand           = {false,SPR_UBER_W1,0,(statefunc)T_Stand,NULL,&s_uberstand};\r\n\r\nstatetype s_uberchase1          = {false,SPR_UBER_W1,10,(statefunc)T_Chase,NULL,&s_uberchase1s};\r\nstatetype s_uberchase1s         = {false,SPR_UBER_W1,3,NULL,NULL,&s_uberchase2};\r\nstatetype s_uberchase2          = {false,SPR_UBER_W2,8,(statefunc)T_Chase,NULL,&s_uberchase3};\r\nstatetype s_uberchase3          = {false,SPR_UBER_W3,10,(statefunc)T_Chase,NULL,&s_uberchase3s};\r\nstatetype s_uberchase3s         = {false,SPR_UBER_W3,3,NULL,NULL,&s_uberchase4};\r\nstatetype s_uberchase4          = {false,SPR_UBER_W4,8,(statefunc)T_Chase,NULL,&s_uberchase1};\r\n\r\nstatetype s_uberdie0            = {false,SPR_UBER_W1,1,NULL,(statefunc)A_DeathScream,&s_uberdie01};\r\nstatetype s_uberdie01           = {false,SPR_UBER_W1,1,NULL,NULL,&s_uberdie1};\r\nstatetype s_uberdie1            = {false,SPR_UBER_DIE1,15,NULL,NULL,&s_uberdie2};\r\nstatetype s_uberdie2            = {false,SPR_UBER_DIE2,15,NULL,NULL,&s_uberdie3};\r\nstatetype s_uberdie3            = {false,SPR_UBER_DIE3,15,NULL,NULL,&s_uberdie4};\r\nstatetype s_uberdie4            = {false,SPR_UBER_DIE4,15,NULL,NULL,&s_uberdie5};\r\nstatetype s_uberdie5            = {false,SPR_UBER_DEAD,0,NULL,NULL,&s_uberdie5};\r\n\r\nstatetype s_ubershoot1          = {false,SPR_UBER_SHOOT1,30,NULL,NULL,&s_ubershoot2};\r\nstatetype s_ubershoot2          = {false,SPR_UBER_SHOOT2,12,NULL,(statefunc)T_UShoot,&s_ubershoot3};\r\nstatetype s_ubershoot3          = {false,SPR_UBER_SHOOT3,12,NULL,(statefunc)T_UShoot,&s_ubershoot4};\r\nstatetype s_ubershoot4          = {false,SPR_UBER_SHOOT4,12,NULL,(statefunc)T_UShoot,&s_ubershoot5};\r\nstatetype s_ubershoot5          = {false,SPR_UBER_SHOOT3,12,NULL,(statefunc)T_UShoot,&s_ubershoot6};\r\nstatetype s_ubershoot6          = {false,SPR_UBER_SHOOT2,12,NULL,(statefunc)T_UShoot,&s_ubershoot7};\r\nstatetype s_ubershoot7          = {false,SPR_UBER_SHOOT1,12,NULL,NULL,&s_uberchase1};\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnUber\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnUber (int tilex, int tiley)\r\n{\r\n    if (SoundBlasterPresent && DigiMode != sds_Off)\r\n        s_uberdie01.tictime = 70;\r\n\r\n    SpawnNewObj (tilex,tiley,&s_uberstand);\r\n    newobj->obclass = uberobj;\r\n    newobj->hitpoints = starthitpoints[gamestate.difficulty][en_uber];\r\n    newobj->flags |= FL_SHOOTABLE|FL_AMBUSH;\r\n    if (!loadedgame)\r\n        gamestate.killtotal++;\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= T_UShoot\r\n=\r\n===============\r\n*/\r\n\r\nvoid T_UShoot (objtype *ob)\r\n{\r\n    int     dx,dy,dist;\r\n\r\n    T_Shoot (ob);\r\n\r\n    dx = abs(ob->tilex - player->tilex);\r\n    dy = abs(ob->tiley - player->tiley);\r\n    dist = dx>dy ? dx : dy;\r\n    if (dist <= 1)\r\n        TakeDamage (10,ob);\r\n}\r\n\r\n\r\n//\r\n// will\r\n//\r\nextern  statetype s_willstand;\r\n\r\nextern  statetype s_willchase1;\r\nextern  statetype s_willchase1s;\r\nextern  statetype s_willchase2;\r\nextern  statetype s_willchase3;\r\nextern  statetype s_willchase3s;\r\nextern  statetype s_willchase4;\r\n\r\nextern  statetype s_willdie1;\r\nextern  statetype s_willdie2;\r\nextern  statetype s_willdie3;\r\nextern  statetype s_willdie4;\r\nextern  statetype s_willdie5;\r\nextern  statetype s_willdie6;\r\n\r\nextern  statetype s_willshoot1;\r\nextern  statetype s_willshoot2;\r\nextern  statetype s_willshoot3;\r\nextern  statetype s_willshoot4;\r\nextern  statetype s_willshoot5;\r\nextern  statetype s_willshoot6;\r\n\r\n\r\nstatetype s_willstand           = {false,SPR_WILL_W1,0,(statefunc)T_Stand,NULL,&s_willstand};\r\n\r\nstatetype s_willchase1          = {false,SPR_WILL_W1,10,(statefunc)T_Will,NULL,&s_willchase1s};\r\nstatetype s_willchase1s         = {false,SPR_WILL_W1,3,NULL,NULL,&s_willchase2};\r\nstatetype s_willchase2          = {false,SPR_WILL_W2,8,(statefunc)T_Will,NULL,&s_willchase3};\r\nstatetype s_willchase3          = {false,SPR_WILL_W3,10,(statefunc)T_Will,NULL,&s_willchase3s};\r\nstatetype s_willchase3s         = {false,SPR_WILL_W3,3,NULL,NULL,&s_willchase4};\r\nstatetype s_willchase4          = {false,SPR_WILL_W4,8,(statefunc)T_Will,NULL,&s_willchase1};\r\n\r\nstatetype s_willdeathcam        = {false,SPR_WILL_W1,1,NULL,NULL,&s_willdie1};\r\n\r\nstatetype s_willdie1            = {false,SPR_WILL_W1,1,NULL,(statefunc)A_DeathScream,&s_willdie2};\r\nstatetype s_willdie2            = {false,SPR_WILL_W1,10,NULL,NULL,&s_willdie3};\r\nstatetype s_willdie3            = {false,SPR_WILL_DIE1,10,NULL,NULL,&s_willdie4};\r\nstatetype s_willdie4            = {false,SPR_WILL_DIE2,10,NULL,NULL,&s_willdie5};\r\nstatetype s_willdie5            = {false,SPR_WILL_DIE3,10,NULL,NULL,&s_willdie6};\r\nstatetype s_willdie6            = {false,SPR_WILL_DEAD,20,NULL,NULL,&s_willdie6};\r\n\r\nstatetype s_willshoot1          = {false,SPR_WILL_SHOOT1,30,NULL,NULL,&s_willshoot2};\r\nstatetype s_willshoot2          = {false,SPR_WILL_SHOOT2,10,NULL,(statefunc)T_Launch,&s_willshoot3};\r\nstatetype s_willshoot3          = {false,SPR_WILL_SHOOT3,10,NULL,(statefunc)T_Shoot,&s_willshoot4};\r\nstatetype s_willshoot4          = {false,SPR_WILL_SHOOT4,10,NULL,(statefunc)T_Shoot,&s_willshoot5};\r\nstatetype s_willshoot5          = {false,SPR_WILL_SHOOT3,10,NULL,(statefunc)T_Shoot,&s_willshoot6};\r\nstatetype s_willshoot6          = {false,SPR_WILL_SHOOT4,10,NULL,(statefunc)T_Shoot,&s_willchase1};\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnWill\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnWill (int tilex, int tiley)\r\n{\r\n    if (SoundBlasterPresent && DigiMode != sds_Off)\r\n        s_willdie2.tictime = 70;\r\n\r\n    SpawnNewObj (tilex,tiley,&s_willstand);\r\n    newobj->obclass = willobj;\r\n    newobj->hitpoints = starthitpoints[gamestate.difficulty][en_will];\r\n    newobj->flags |= FL_SHOOTABLE|FL_AMBUSH;\r\n    if (!loadedgame)\r\n        gamestate.killtotal++;\r\n}\r\n\r\n\r\n/*\r\n================\r\n=\r\n= T_Will\r\n=\r\n================\r\n*/\r\n\r\nvoid T_Will (objtype *ob)\r\n{\r\n    int32_t move;\r\n    int     dx,dy,dist;\r\n    boolean dodge;\r\n\r\n    dodge = false;\r\n    dx = abs(ob->tilex - player->tilex);\r\n    dy = abs(ob->tiley - player->tiley);\r\n    dist = dx>dy ? dx : dy;\r\n\r\n    if (CheckLine(ob))                                              // got a shot at player?\r\n    {\r\n        ob->hidden = false;\r\n        if ( (unsigned) US_RndT() < (tics<<3) && objfreelist)\r\n        {\r\n            //\r\n            // go into attack frame\r\n            //\r\n            if (ob->obclass == willobj)\r\n                NewState (ob,&s_willshoot1);\r\n            else if (ob->obclass == angelobj)\r\n                NewState (ob,&s_angelshoot1);\r\n            else\r\n                NewState (ob,&s_deathshoot1);\r\n            return;\r\n        }\r\n        dodge = true;\r\n    }\r\n    else\r\n        ob->hidden = true;\r\n\r\n    if (ob->dir == nodir)\r\n    {\r\n        if (dodge)\r\n            SelectDodgeDir (ob);\r\n        else\r\n            SelectChaseDir (ob);\r\n        if (ob->dir == nodir)\r\n            return;                                                 // object is blocked in\r\n    }\r\n\r\n    move = ob->speed*tics;\r\n\r\n    while (move)\r\n    {\r\n        if (ob->distance < 0)\r\n        {\r\n            //\r\n            // waiting for a door to open\r\n            //\r\n            OpenDoor (-ob->distance-1);\r\n            if (doorobjlist[-ob->distance-1].action != dr_open)\r\n                return;\r\n            ob->distance = TILEGLOBAL;      // go ahead, the door is now open\r\n            TryWalk(ob);\r\n        }\r\n\r\n        if (move < ob->distance)\r\n        {\r\n            MoveObj (ob,move);\r\n            break;\r\n        }\r\n\r\n        //\r\n        // reached goal tile, so select another one\r\n        //\r\n\r\n        //\r\n        // fix position to account for round off during moving\r\n        //\r\n        ob->x = ((int32_t)ob->tilex<<TILESHIFT)+TILEGLOBAL/2;\r\n        ob->y = ((int32_t)ob->tiley<<TILESHIFT)+TILEGLOBAL/2;\r\n\r\n        move -= ob->distance;\r\n\r\n        if (dist <4)\r\n            SelectRunDir (ob);\r\n        else if (dodge)\r\n            SelectDodgeDir (ob);\r\n        else\r\n            SelectChaseDir (ob);\r\n\r\n        if (ob->dir == nodir)\r\n            return;                                                 // object is blocked in\r\n    }\r\n\r\n}\r\n\r\n\r\n//\r\n// death\r\n//\r\nextern  statetype s_deathstand;\r\n\r\nextern  statetype s_deathchase1;\r\nextern  statetype s_deathchase1s;\r\nextern  statetype s_deathchase2;\r\nextern  statetype s_deathchase3;\r\nextern  statetype s_deathchase3s;\r\nextern  statetype s_deathchase4;\r\n\r\nextern  statetype s_deathdie1;\r\nextern  statetype s_deathdie2;\r\nextern  statetype s_deathdie3;\r\nextern  statetype s_deathdie4;\r\nextern  statetype s_deathdie5;\r\nextern  statetype s_deathdie6;\r\nextern  statetype s_deathdie7;\r\nextern  statetype s_deathdie8;\r\nextern  statetype s_deathdie9;\r\n\r\nextern  statetype s_deathshoot1;\r\nextern  statetype s_deathshoot2;\r\nextern  statetype s_deathshoot3;\r\nextern  statetype s_deathshoot4;\r\nextern  statetype s_deathshoot5;\r\n\r\n\r\nstatetype s_deathstand          = {false,SPR_DEATH_W1,0,(statefunc)T_Stand,NULL,&s_deathstand};\r\n\r\nstatetype s_deathchase1         = {false,SPR_DEATH_W1,10,(statefunc)T_Will,NULL,&s_deathchase1s};\r\nstatetype s_deathchase1s        = {false,SPR_DEATH_W1,3,NULL,NULL,&s_deathchase2};\r\nstatetype s_deathchase2         = {false,SPR_DEATH_W2,8,(statefunc)T_Will,NULL,&s_deathchase3};\r\nstatetype s_deathchase3         = {false,SPR_DEATH_W3,10,(statefunc)T_Will,NULL,&s_deathchase3s};\r\nstatetype s_deathchase3s        = {false,SPR_DEATH_W3,3,NULL,NULL,&s_deathchase4};\r\nstatetype s_deathchase4         = {false,SPR_DEATH_W4,8,(statefunc)T_Will,NULL,&s_deathchase1};\r\n\r\nstatetype s_deathdeathcam       = {false,SPR_DEATH_W1,1,NULL,NULL,&s_deathdie1};\r\n\r\nstatetype s_deathdie1           = {false,SPR_DEATH_W1,1,NULL,(statefunc)A_DeathScream,&s_deathdie2};\r\nstatetype s_deathdie2           = {false,SPR_DEATH_W1,10,NULL,NULL,&s_deathdie3};\r\nstatetype s_deathdie3           = {false,SPR_DEATH_DIE1,10,NULL,NULL,&s_deathdie4};\r\nstatetype s_deathdie4           = {false,SPR_DEATH_DIE2,10,NULL,NULL,&s_deathdie5};\r\nstatetype s_deathdie5           = {false,SPR_DEATH_DIE3,10,NULL,NULL,&s_deathdie6};\r\nstatetype s_deathdie6           = {false,SPR_DEATH_DIE4,10,NULL,NULL,&s_deathdie7};\r\nstatetype s_deathdie7           = {false,SPR_DEATH_DIE5,10,NULL,NULL,&s_deathdie8};\r\nstatetype s_deathdie8           = {false,SPR_DEATH_DIE6,10,NULL,NULL,&s_deathdie9};\r\nstatetype s_deathdie9           = {false,SPR_DEATH_DEAD,0,NULL,NULL,&s_deathdie9};\r\n\r\nstatetype s_deathshoot1         = {false,SPR_DEATH_SHOOT1,30,NULL,NULL,&s_deathshoot2};\r\nstatetype s_deathshoot2         = {false,SPR_DEATH_SHOOT2,10,NULL,(statefunc)T_Launch,&s_deathshoot3};\r\nstatetype s_deathshoot3         = {false,SPR_DEATH_SHOOT4,10,NULL,(statefunc)T_Shoot,&s_deathshoot4};\r\nstatetype s_deathshoot4         = {false,SPR_DEATH_SHOOT3,10,NULL,(statefunc)T_Launch,&s_deathshoot5};\r\nstatetype s_deathshoot5         = {false,SPR_DEATH_SHOOT4,10,NULL,(statefunc)T_Shoot,&s_deathchase1};\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnDeath\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnDeath (int tilex, int tiley)\r\n{\r\n    if (SoundBlasterPresent && DigiMode != sds_Off)\r\n        s_deathdie2.tictime = 105;\r\n\r\n    SpawnNewObj (tilex,tiley,&s_deathstand);\r\n    newobj->obclass = deathobj;\r\n    newobj->hitpoints = starthitpoints[gamestate.difficulty][en_death];\r\n    newobj->flags |= FL_SHOOTABLE|FL_AMBUSH;\r\n    if (!loadedgame)\r\n        gamestate.killtotal++;\r\n}\r\n\r\n/*\r\n===============\r\n=\r\n= T_Launch\r\n=\r\n===============\r\n*/\r\n\r\nvoid T_Launch (objtype *ob)\r\n{\r\n    int32_t deltax,deltay;\r\n    float   angle;\r\n    int     iangle;\r\n\r\n    deltax = player->x - ob->x;\r\n    deltay = ob->y - player->y;\r\n    angle = (float) atan2 ((float) deltay, (float) deltax);\r\n    if (angle<0)\r\n        angle = (float) (M_PI*2+angle);\r\n    iangle = (int) (angle/(M_PI*2)*ANGLES);\r\n    if (ob->obclass == deathobj)\r\n    {\r\n        T_Shoot (ob);\r\n        if (ob->state == &s_deathshoot2)\r\n        {\r\n            iangle-=4;\r\n            if (iangle<0)\r\n                iangle+=ANGLES;\r\n        }\r\n        else\r\n        {\r\n            iangle+=4;\r\n            if (iangle>=ANGLES)\r\n                iangle-=ANGLES;\r\n        }\r\n    }\r\n\r\n    GetNewActor ();\r\n    newobj->state = &s_rocket;\r\n    newobj->ticcount = 1;\r\n\r\n    newobj->tilex = ob->tilex;\r\n    newobj->tiley = ob->tiley;\r\n    newobj->x = ob->x;\r\n    newobj->y = ob->y;\r\n    newobj->obclass = rocketobj;\r\n    switch(ob->obclass)\r\n    {\r\n        case deathobj:\r\n            newobj->state = &s_hrocket;\r\n            newobj->obclass = hrocketobj;\r\n            PlaySoundLocActor (KNIGHTMISSILESND,newobj);\r\n            break;\r\n        case angelobj:\r\n            newobj->state = &s_spark1;\r\n            newobj->obclass = sparkobj;\r\n            PlaySoundLocActor (ANGELFIRESND,newobj);\r\n            break;\r\n        default:\r\n            PlaySoundLocActor (MISSILEFIRESND,newobj);\r\n    }\r\n\r\n    newobj->dir = nodir;\r\n    newobj->angle = iangle;\r\n    newobj->speed = 0x2000l;\r\n    newobj->flags = FL_NEVERMARK;\r\n    newobj->active = ac_yes;\r\n}\r\n\r\n\r\n\r\n//\r\n// angel\r\n//\r\nvoid A_Relaunch (objtype *ob);\r\nvoid A_Victory (objtype *ob);\r\nvoid A_StartAttack (objtype *ob);\r\nvoid A_Breathing (objtype *ob);\r\n\r\nextern  statetype s_angelstand;\r\n\r\nextern  statetype s_angelchase1;\r\nextern  statetype s_angelchase1s;\r\nextern  statetype s_angelchase2;\r\nextern  statetype s_angelchase3;\r\nextern  statetype s_angelchase3s;\r\nextern  statetype s_angelchase4;\r\n\r\nextern  statetype s_angeldie1;\r\nextern  statetype s_angeldie11;\r\nextern  statetype s_angeldie2;\r\nextern  statetype s_angeldie3;\r\nextern  statetype s_angeldie4;\r\nextern  statetype s_angeldie5;\r\nextern  statetype s_angeldie6;\r\nextern  statetype s_angeldie7;\r\nextern  statetype s_angeldie8;\r\nextern  statetype s_angeldie9;\r\n\r\nextern  statetype s_angelshoot1;\r\nextern  statetype s_angelshoot2;\r\nextern  statetype s_angelshoot3;\r\nextern  statetype s_angelshoot4;\r\nextern  statetype s_angelshoot5;\r\nextern  statetype s_angelshoot6;\r\n\r\nextern  statetype s_angeltired;\r\nextern  statetype s_angeltired2;\r\nextern  statetype s_angeltired3;\r\nextern  statetype s_angeltired4;\r\nextern  statetype s_angeltired5;\r\nextern  statetype s_angeltired6;\r\nextern  statetype s_angeltired7;\r\n\r\nextern  statetype s_spark1;\r\nextern  statetype s_spark2;\r\nextern  statetype s_spark3;\r\nextern  statetype s_spark4;\r\n\r\n\r\nstatetype s_angelstand          = {false,SPR_ANGEL_W1,0,(statefunc)T_Stand,NULL,&s_angelstand};\r\n\r\nstatetype s_angelchase1         = {false,SPR_ANGEL_W1,10,(statefunc)T_Will,NULL,&s_angelchase1s};\r\nstatetype s_angelchase1s        = {false,SPR_ANGEL_W1,3,NULL,NULL,&s_angelchase2};\r\nstatetype s_angelchase2         = {false,SPR_ANGEL_W2,8,(statefunc)T_Will,NULL,&s_angelchase3};\r\nstatetype s_angelchase3         = {false,SPR_ANGEL_W3,10,(statefunc)T_Will,NULL,&s_angelchase3s};\r\nstatetype s_angelchase3s        = {false,SPR_ANGEL_W3,3,NULL,NULL,&s_angelchase4};\r\nstatetype s_angelchase4         = {false,SPR_ANGEL_W4,8,(statefunc)T_Will,NULL,&s_angelchase1};\r\n\r\nstatetype s_angeldie1           = {false,SPR_ANGEL_W1,1,NULL,(statefunc)A_DeathScream,&s_angeldie11};\r\nstatetype s_angeldie11          = {false,SPR_ANGEL_W1,1,NULL,NULL,&s_angeldie2};\r\nstatetype s_angeldie2           = {false,SPR_ANGEL_DIE1,10,NULL,(statefunc)A_Slurpie,&s_angeldie3};\r\nstatetype s_angeldie3           = {false,SPR_ANGEL_DIE2,10,NULL,NULL,&s_angeldie4};\r\nstatetype s_angeldie4           = {false,SPR_ANGEL_DIE3,10,NULL,NULL,&s_angeldie5};\r\nstatetype s_angeldie5           = {false,SPR_ANGEL_DIE4,10,NULL,NULL,&s_angeldie6};\r\nstatetype s_angeldie6           = {false,SPR_ANGEL_DIE5,10,NULL,NULL,&s_angeldie7};\r\nstatetype s_angeldie7           = {false,SPR_ANGEL_DIE6,10,NULL,NULL,&s_angeldie8};\r\nstatetype s_angeldie8           = {false,SPR_ANGEL_DIE7,10,NULL,NULL,&s_angeldie9};\r\nstatetype s_angeldie9           = {false,SPR_ANGEL_DEAD,130,NULL,(statefunc)A_Victory,&s_angeldie9};\r\n\r\nstatetype s_angelshoot1         = {false,SPR_ANGEL_SHOOT1,10,NULL,(statefunc)A_StartAttack,&s_angelshoot2};\r\nstatetype s_angelshoot2         = {false,SPR_ANGEL_SHOOT2,20,NULL,(statefunc)T_Launch,&s_angelshoot3};\r\nstatetype s_angelshoot3         = {false,SPR_ANGEL_SHOOT1,10,NULL,(statefunc)A_Relaunch,&s_angelshoot2};\r\n\r\nstatetype s_angeltired          = {false,SPR_ANGEL_TIRED1,40,NULL,(statefunc)A_Breathing,&s_angeltired2};\r\nstatetype s_angeltired2         = {false,SPR_ANGEL_TIRED2,40,NULL,NULL,&s_angeltired3};\r\nstatetype s_angeltired3         = {false,SPR_ANGEL_TIRED1,40,NULL,(statefunc)A_Breathing,&s_angeltired4};\r\nstatetype s_angeltired4         = {false,SPR_ANGEL_TIRED2,40,NULL,NULL,&s_angeltired5};\r\nstatetype s_angeltired5         = {false,SPR_ANGEL_TIRED1,40,NULL,(statefunc)A_Breathing,&s_angeltired6};\r\nstatetype s_angeltired6         = {false,SPR_ANGEL_TIRED2,40,NULL,NULL,&s_angeltired7};\r\nstatetype s_angeltired7         = {false,SPR_ANGEL_TIRED1,40,NULL,(statefunc)A_Breathing,&s_angelchase1};\r\n\r\nstatetype s_spark1              = {false,SPR_SPARK1,6,(statefunc)T_Projectile,NULL,&s_spark2};\r\nstatetype s_spark2              = {false,SPR_SPARK2,6,(statefunc)T_Projectile,NULL,&s_spark3};\r\nstatetype s_spark3              = {false,SPR_SPARK3,6,(statefunc)T_Projectile,NULL,&s_spark4};\r\nstatetype s_spark4              = {false,SPR_SPARK4,6,(statefunc)T_Projectile,NULL,&s_spark1};\r\n\r\n\r\nvoid A_Slurpie (objtype *)\r\n{\r\n    SD_PlaySound(SLURPIESND);\r\n}\r\n\r\nvoid A_Breathing (objtype *)\r\n{\r\n    SD_PlaySound(ANGELTIREDSND);\r\n}\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnAngel\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnAngel (int tilex, int tiley)\r\n{\r\n    if (SoundBlasterPresent && DigiMode != sds_Off)\r\n        s_angeldie11.tictime = 105;\r\n\r\n    SpawnNewObj (tilex,tiley,&s_angelstand);\r\n    newobj->obclass = angelobj;\r\n    newobj->hitpoints = starthitpoints[gamestate.difficulty][en_angel];\r\n    newobj->flags |= FL_SHOOTABLE|FL_AMBUSH;\r\n    if (!loadedgame)\r\n        gamestate.killtotal++;\r\n}\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= A_Victory\r\n=\r\n=================\r\n*/\r\n\r\nvoid A_Victory (objtype *)\r\n{\r\n    playstate = ex_victorious;\r\n}\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= A_StartAttack\r\n=\r\n=================\r\n*/\r\n\r\nvoid A_StartAttack (objtype *ob)\r\n{\r\n    ob->temp1 = 0;\r\n}\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= A_Relaunch\r\n=\r\n=================\r\n*/\r\n\r\nvoid A_Relaunch (objtype *ob)\r\n{\r\n    if (++ob->temp1 == 3)\r\n    {\r\n        NewState (ob,&s_angeltired);\r\n        return;\r\n    }\r\n\r\n    if (US_RndT()&1)\r\n    {\r\n        NewState (ob,&s_angelchase1);\r\n        return;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n//\r\n// spectre\r\n//\r\nvoid T_SpectreWait (objtype *ob);\r\nvoid A_Dormant (objtype *ob);\r\n\r\nextern  statetype s_spectrewait1;\r\nextern  statetype s_spectrewait2;\r\nextern  statetype s_spectrewait3;\r\nextern  statetype s_spectrewait4;\r\n\r\nextern  statetype s_spectrechase1;\r\nextern  statetype s_spectrechase2;\r\nextern  statetype s_spectrechase3;\r\nextern  statetype s_spectrechase4;\r\n\r\nextern  statetype s_spectredie1;\r\nextern  statetype s_spectredie2;\r\nextern  statetype s_spectredie3;\r\nextern  statetype s_spectredie4;\r\n\r\nextern  statetype s_spectrewake;\r\n\r\nstatetype s_spectrewait1        = {false,SPR_SPECTRE_W1,10,(statefunc)T_Stand,NULL,&s_spectrewait2};\r\nstatetype s_spectrewait2        = {false,SPR_SPECTRE_W2,10,(statefunc)T_Stand,NULL,&s_spectrewait3};\r\nstatetype s_spectrewait3        = {false,SPR_SPECTRE_W3,10,(statefunc)T_Stand,NULL,&s_spectrewait4};\r\nstatetype s_spectrewait4        = {false,SPR_SPECTRE_W4,10,(statefunc)T_Stand,NULL,&s_spectrewait1};\r\n\r\nstatetype s_spectrechase1       = {false,SPR_SPECTRE_W1,10,(statefunc)T_Ghosts,NULL,&s_spectrechase2};\r\nstatetype s_spectrechase2       = {false,SPR_SPECTRE_W2,10,(statefunc)T_Ghosts,NULL,&s_spectrechase3};\r\nstatetype s_spectrechase3       = {false,SPR_SPECTRE_W3,10,(statefunc)T_Ghosts,NULL,&s_spectrechase4};\r\nstatetype s_spectrechase4       = {false,SPR_SPECTRE_W4,10,(statefunc)T_Ghosts,NULL,&s_spectrechase1};\r\n\r\nstatetype s_spectredie1         = {false,SPR_SPECTRE_F1,10,NULL,NULL,&s_spectredie2};\r\nstatetype s_spectredie2         = {false,SPR_SPECTRE_F2,10,NULL,NULL,&s_spectredie3};\r\nstatetype s_spectredie3         = {false,SPR_SPECTRE_F3,10,NULL,NULL,&s_spectredie4};\r\nstatetype s_spectredie4         = {false,SPR_SPECTRE_F4,300,NULL,NULL,&s_spectrewake};\r\nstatetype s_spectrewake         = {false,SPR_SPECTRE_F4,10,NULL,(statefunc)A_Dormant,&s_spectrewake};\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnSpectre\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnSpectre (int tilex, int tiley)\r\n{\r\n    SpawnNewObj (tilex,tiley,&s_spectrewait1);\r\n    newobj->obclass = spectreobj;\r\n    newobj->hitpoints = starthitpoints[gamestate.difficulty][en_spectre];\r\n    newobj->flags |= FL_SHOOTABLE|FL_AMBUSH|FL_BONUS; // |FL_NEVERMARK|FL_NONMARK;\r\n    if (!loadedgame)\r\n        gamestate.killtotal++;\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= A_Dormant\r\n=\r\n===============\r\n*/\r\n\r\nvoid A_Dormant (objtype *ob)\r\n{\r\n    int32_t     deltax,deltay;\r\n    int         xl,xh,yl,yh;\r\n    int         x,y;\r\n    uintptr_t   tile;\r\n\r\n    deltax = ob->x - player->x;\r\n    if (deltax < -MINACTORDIST || deltax > MINACTORDIST)\r\n        goto moveok;\r\n    deltay = ob->y - player->y;\r\n    if (deltay < -MINACTORDIST || deltay > MINACTORDIST)\r\n        goto moveok;\r\n\r\n    return;\r\nmoveok:\r\n\r\n    xl = (ob->x-MINDIST) >> TILESHIFT;\r\n    xh = (ob->x+MINDIST) >> TILESHIFT;\r\n    yl = (ob->y-MINDIST) >> TILESHIFT;\r\n    yh = (ob->y+MINDIST) >> TILESHIFT;\r\n\r\n    for (y=yl ; y<=yh ; y++)\r\n        for (x=xl ; x<=xh ; x++)\r\n        {\r\n            tile = (uintptr_t)actorat[x][y];\r\n            if (!tile)\r\n                continue;\r\n            if (!ISPOINTER(tile))\r\n                return;\r\n            if (((objtype *)tile)->flags&FL_SHOOTABLE)\r\n                return;\r\n        }\r\n\r\n        ob->flags |= FL_AMBUSH | FL_SHOOTABLE;\r\n        ob->flags &= ~FL_ATTACKMODE;\r\n        ob->flags &= ~FL_NONMARK;      // stuck bugfix 1\r\n        ob->dir = nodir;\r\n        NewState (ob,&s_spectrewait1);\r\n}\r\n\r\n\r\n#endif\r\n\r\n/*\r\n=============================================================================\r\n\r\n                            SCHABBS / GIFT / FAT\r\n\r\n=============================================================================\r\n*/\r\n\r\n#ifndef SPEAR\r\n/*\r\n===============\r\n=\r\n= SpawnGhosts\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnGhosts (int which, int tilex, int tiley)\r\n{\r\n    switch(which)\r\n    {\r\n        case en_blinky:\r\n            SpawnNewObj (tilex,tiley,&s_blinkychase1);\r\n            break;\r\n        case en_clyde:\r\n            SpawnNewObj (tilex,tiley,&s_clydechase1);\r\n            break;\r\n        case en_pinky:\r\n            SpawnNewObj (tilex,tiley,&s_pinkychase1);\r\n            break;\r\n        case en_inky:\r\n            SpawnNewObj (tilex,tiley,&s_inkychase1);\r\n            break;\r\n    }\r\n\r\n    newobj->obclass = ghostobj;\r\n    newobj->speed = SPDDOG;\r\n\r\n    newobj->dir = east;\r\n    newobj->flags |= FL_AMBUSH;\r\n    if (!loadedgame)\r\n    {\r\n        gamestate.killtotal++;\r\n        gamestate.killcount++;\r\n    }\r\n}\r\n\r\n\r\n\r\nvoid    T_Gift (objtype *ob);\r\nvoid    T_GiftThrow (objtype *ob);\r\n\r\nvoid    T_Fat (objtype *ob);\r\nvoid    T_FatThrow (objtype *ob);\r\n\r\n//\r\n// schabb\r\n//\r\nextern  statetype s_schabbstand;\r\n\r\nextern  statetype s_schabbchase1;\r\nextern  statetype s_schabbchase1s;\r\nextern  statetype s_schabbchase2;\r\nextern  statetype s_schabbchase3;\r\nextern  statetype s_schabbchase3s;\r\nextern  statetype s_schabbchase4;\r\n\r\nextern  statetype s_schabbdie1;\r\nextern  statetype s_schabbdie2;\r\nextern  statetype s_schabbdie3;\r\nextern  statetype s_schabbdie4;\r\nextern  statetype s_schabbdie5;\r\nextern  statetype s_schabbdie6;\r\n\r\nextern  statetype s_schabbshoot1;\r\nextern  statetype s_schabbshoot2;\r\n\r\nextern  statetype s_needle1;\r\nextern  statetype s_needle2;\r\nextern  statetype s_needle3;\r\nextern  statetype s_needle4;\r\n\r\nextern  statetype s_schabbdeathcam;\r\n\r\n\r\nstatetype s_schabbstand         = {false,SPR_SCHABB_W1,0,(statefunc)T_Stand,NULL,&s_schabbstand};\r\n\r\nstatetype s_schabbchase1        = {false,SPR_SCHABB_W1,10,(statefunc)T_Schabb,NULL,&s_schabbchase1s};\r\nstatetype s_schabbchase1s       = {false,SPR_SCHABB_W1,3,NULL,NULL,&s_schabbchase2};\r\nstatetype s_schabbchase2        = {false,SPR_SCHABB_W2,8,(statefunc)T_Schabb,NULL,&s_schabbchase3};\r\nstatetype s_schabbchase3        = {false,SPR_SCHABB_W3,10,(statefunc)T_Schabb,NULL,&s_schabbchase3s};\r\nstatetype s_schabbchase3s       = {false,SPR_SCHABB_W3,3,NULL,NULL,&s_schabbchase4};\r\nstatetype s_schabbchase4        = {false,SPR_SCHABB_W4,8,(statefunc)T_Schabb,NULL,&s_schabbchase1};\r\n\r\nstatetype s_schabbdeathcam      = {false,SPR_SCHABB_W1,1,NULL,NULL,&s_schabbdie1};\r\n\r\nstatetype s_schabbdie1          = {false,SPR_SCHABB_W1,10,NULL,(statefunc)A_DeathScream,&s_schabbdie2};\r\nstatetype s_schabbdie2          = {false,SPR_SCHABB_W1,10,NULL,NULL,&s_schabbdie3};\r\nstatetype s_schabbdie3          = {false,SPR_SCHABB_DIE1,10,NULL,NULL,&s_schabbdie4};\r\nstatetype s_schabbdie4          = {false,SPR_SCHABB_DIE2,10,NULL,NULL,&s_schabbdie5};\r\nstatetype s_schabbdie5          = {false,SPR_SCHABB_DIE3,10,NULL,NULL,&s_schabbdie6};\r\nstatetype s_schabbdie6          = {false,SPR_SCHABB_DEAD,20,NULL,(statefunc)A_StartDeathCam,&s_schabbdie6};\r\n\r\nstatetype s_schabbshoot1        = {false,SPR_SCHABB_SHOOT1,30,NULL,NULL,&s_schabbshoot2};\r\nstatetype s_schabbshoot2        = {false,SPR_SCHABB_SHOOT2,10,NULL,(statefunc)T_SchabbThrow,&s_schabbchase1};\r\n\r\nstatetype s_needle1             = {false,SPR_HYPO1,6,(statefunc)T_Projectile,NULL,&s_needle2};\r\nstatetype s_needle2             = {false,SPR_HYPO2,6,(statefunc)T_Projectile,NULL,&s_needle3};\r\nstatetype s_needle3             = {false,SPR_HYPO3,6,(statefunc)T_Projectile,NULL,&s_needle4};\r\nstatetype s_needle4             = {false,SPR_HYPO4,6,(statefunc)T_Projectile,NULL,&s_needle1};\r\n\r\n\r\n//\r\n// gift\r\n//\r\nextern  statetype s_giftstand;\r\n\r\nextern  statetype s_giftchase1;\r\nextern  statetype s_giftchase1s;\r\nextern  statetype s_giftchase2;\r\nextern  statetype s_giftchase3;\r\nextern  statetype s_giftchase3s;\r\nextern  statetype s_giftchase4;\r\n\r\nextern  statetype s_giftdie1;\r\nextern  statetype s_giftdie2;\r\nextern  statetype s_giftdie3;\r\nextern  statetype s_giftdie4;\r\nextern  statetype s_giftdie5;\r\nextern  statetype s_giftdie6;\r\n\r\nextern  statetype s_giftshoot1;\r\nextern  statetype s_giftshoot2;\r\n\r\nextern  statetype s_needle1;\r\nextern  statetype s_needle2;\r\nextern  statetype s_needle3;\r\nextern  statetype s_needle4;\r\n\r\nextern  statetype s_giftdeathcam;\r\n\r\nextern  statetype s_boom1;\r\nextern  statetype s_boom2;\r\nextern  statetype s_boom3;\r\n\r\n\r\nstatetype s_giftstand           = {false,SPR_GIFT_W1,0,(statefunc)T_Stand,NULL,&s_giftstand};\r\n\r\nstatetype s_giftchase1          = {false,SPR_GIFT_W1,10,(statefunc)T_Gift,NULL,&s_giftchase1s};\r\nstatetype s_giftchase1s         = {false,SPR_GIFT_W1,3,NULL,NULL,&s_giftchase2};\r\nstatetype s_giftchase2          = {false,SPR_GIFT_W2,8,(statefunc)T_Gift,NULL,&s_giftchase3};\r\nstatetype s_giftchase3          = {false,SPR_GIFT_W3,10,(statefunc)T_Gift,NULL,&s_giftchase3s};\r\nstatetype s_giftchase3s         = {false,SPR_GIFT_W3,3,NULL,NULL,&s_giftchase4};\r\nstatetype s_giftchase4          = {false,SPR_GIFT_W4,8,(statefunc)T_Gift,NULL,&s_giftchase1};\r\n\r\nstatetype s_giftdeathcam        = {false,SPR_GIFT_W1,1,NULL,NULL,&s_giftdie1};\r\n\r\nstatetype s_giftdie1            = {false,SPR_GIFT_W1,1,NULL,(statefunc)A_DeathScream,&s_giftdie2};\r\nstatetype s_giftdie2            = {false,SPR_GIFT_W1,10,NULL,NULL,&s_giftdie3};\r\nstatetype s_giftdie3            = {false,SPR_GIFT_DIE1,10,NULL,NULL,&s_giftdie4};\r\nstatetype s_giftdie4            = {false,SPR_GIFT_DIE2,10,NULL,NULL,&s_giftdie5};\r\nstatetype s_giftdie5            = {false,SPR_GIFT_DIE3,10,NULL,NULL,&s_giftdie6};\r\nstatetype s_giftdie6            = {false,SPR_GIFT_DEAD,20,NULL,(statefunc)A_StartDeathCam,&s_giftdie6};\r\n\r\nstatetype s_giftshoot1          = {false,SPR_GIFT_SHOOT1,30,NULL,NULL,&s_giftshoot2};\r\nstatetype s_giftshoot2          = {false,SPR_GIFT_SHOOT2,10,NULL,(statefunc)T_GiftThrow,&s_giftchase1};\r\n\r\n\r\n//\r\n// fat\r\n//\r\nextern  statetype s_fatstand;\r\n\r\nextern  statetype s_fatchase1;\r\nextern  statetype s_fatchase1s;\r\nextern  statetype s_fatchase2;\r\nextern  statetype s_fatchase3;\r\nextern  statetype s_fatchase3s;\r\nextern  statetype s_fatchase4;\r\n\r\nextern  statetype s_fatdie1;\r\nextern  statetype s_fatdie2;\r\nextern  statetype s_fatdie3;\r\nextern  statetype s_fatdie4;\r\nextern  statetype s_fatdie5;\r\nextern  statetype s_fatdie6;\r\n\r\nextern  statetype s_fatshoot1;\r\nextern  statetype s_fatshoot2;\r\nextern  statetype s_fatshoot3;\r\nextern  statetype s_fatshoot4;\r\nextern  statetype s_fatshoot5;\r\nextern  statetype s_fatshoot6;\r\n\r\nextern  statetype s_needle1;\r\nextern  statetype s_needle2;\r\nextern  statetype s_needle3;\r\nextern  statetype s_needle4;\r\n\r\nextern  statetype s_fatdeathcam;\r\n\r\n\r\nstatetype s_fatstand            = {false,SPR_FAT_W1,0,(statefunc)T_Stand,NULL,&s_fatstand};\r\n\r\nstatetype s_fatchase1           = {false,SPR_FAT_W1,10,(statefunc)T_Fat,NULL,&s_fatchase1s};\r\nstatetype s_fatchase1s          = {false,SPR_FAT_W1,3,NULL,NULL,&s_fatchase2};\r\nstatetype s_fatchase2           = {false,SPR_FAT_W2,8,(statefunc)T_Fat,NULL,&s_fatchase3};\r\nstatetype s_fatchase3           = {false,SPR_FAT_W3,10,(statefunc)T_Fat,NULL,&s_fatchase3s};\r\nstatetype s_fatchase3s          = {false,SPR_FAT_W3,3,NULL,NULL,&s_fatchase4};\r\nstatetype s_fatchase4           = {false,SPR_FAT_W4,8,(statefunc)T_Fat,NULL,&s_fatchase1};\r\n\r\nstatetype s_fatdeathcam         = {false,SPR_FAT_W1,1,NULL,NULL,&s_fatdie1};\r\n\r\nstatetype s_fatdie1             = {false,SPR_FAT_W1,1,NULL,(statefunc)A_DeathScream,&s_fatdie2};\r\nstatetype s_fatdie2             = {false,SPR_FAT_W1,10,NULL,NULL,&s_fatdie3};\r\nstatetype s_fatdie3             = {false,SPR_FAT_DIE1,10,NULL,NULL,&s_fatdie4};\r\nstatetype s_fatdie4             = {false,SPR_FAT_DIE2,10,NULL,NULL,&s_fatdie5};\r\nstatetype s_fatdie5             = {false,SPR_FAT_DIE3,10,NULL,NULL,&s_fatdie6};\r\nstatetype s_fatdie6             = {false,SPR_FAT_DEAD,20,NULL,(statefunc)A_StartDeathCam,&s_fatdie6};\r\n\r\nstatetype s_fatshoot1           = {false,SPR_FAT_SHOOT1,30,NULL,NULL,&s_fatshoot2};\r\nstatetype s_fatshoot2           = {false,SPR_FAT_SHOOT2,10,NULL,(statefunc)T_GiftThrow,&s_fatshoot3};\r\nstatetype s_fatshoot3           = {false,SPR_FAT_SHOOT3,10,NULL,(statefunc)T_Shoot,&s_fatshoot4};\r\nstatetype s_fatshoot4           = {false,SPR_FAT_SHOOT4,10,NULL,(statefunc)T_Shoot,&s_fatshoot5};\r\nstatetype s_fatshoot5           = {false,SPR_FAT_SHOOT3,10,NULL,(statefunc)T_Shoot,&s_fatshoot6};\r\nstatetype s_fatshoot6           = {false,SPR_FAT_SHOOT4,10,NULL,(statefunc)T_Shoot,&s_fatchase1};\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnSchabbs\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnSchabbs (int tilex, int tiley)\r\n{\r\n    if (DigiMode != sds_Off)\r\n        s_schabbdie2.tictime = 140;\r\n    else\r\n        s_schabbdie2.tictime = 5;\r\n\r\n    SpawnNewObj (tilex,tiley,&s_schabbstand);\r\n    newobj->speed = SPDPATROL;\r\n\r\n    newobj->obclass = schabbobj;\r\n    newobj->hitpoints = starthitpoints[gamestate.difficulty][en_schabbs];\r\n    newobj->dir = nodir;\r\n    newobj->flags |= FL_SHOOTABLE|FL_AMBUSH;\r\n    if (!loadedgame)\r\n        gamestate.killtotal++;\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnGift\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnGift (int tilex, int tiley)\r\n{\r\n    if (DigiMode != sds_Off)\r\n        s_giftdie2.tictime = 140;\r\n    else\r\n        s_giftdie2.tictime = 5;\r\n\r\n    SpawnNewObj (tilex,tiley,&s_giftstand);\r\n    newobj->speed = SPDPATROL;\r\n\r\n    newobj->obclass = giftobj;\r\n    newobj->hitpoints = starthitpoints[gamestate.difficulty][en_gift];\r\n    newobj->dir = nodir;\r\n    newobj->flags |= FL_SHOOTABLE|FL_AMBUSH;\r\n    if (!loadedgame)\r\n        gamestate.killtotal++;\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnFat\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnFat (int tilex, int tiley)\r\n{\r\n    if (DigiMode != sds_Off)\r\n        s_fatdie2.tictime = 140;\r\n    else\r\n        s_fatdie2.tictime = 5;\r\n\r\n    SpawnNewObj (tilex,tiley,&s_fatstand);\r\n    newobj->speed = SPDPATROL;\r\n\r\n    newobj->obclass = fatobj;\r\n    newobj->hitpoints = starthitpoints[gamestate.difficulty][en_fat];\r\n    newobj->dir = nodir;\r\n    newobj->flags |= FL_SHOOTABLE|FL_AMBUSH;\r\n    if (!loadedgame)\r\n        gamestate.killtotal++;\r\n}\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= T_SchabbThrow\r\n=\r\n=================\r\n*/\r\n\r\nvoid T_SchabbThrow (objtype *ob)\r\n{\r\n    int32_t deltax,deltay;\r\n    float   angle;\r\n    int     iangle;\r\n\r\n    deltax = player->x - ob->x;\r\n    deltay = ob->y - player->y;\r\n    angle = (float) atan2((float) deltay, (float) deltax);\r\n    if (angle<0)\r\n        angle = (float) (M_PI*2+angle);\r\n    iangle = (int) (angle/(M_PI*2)*ANGLES);\r\n\r\n    GetNewActor ();\r\n    newobj->state = &s_needle1;\r\n    newobj->ticcount = 1;\r\n\r\n    newobj->tilex = ob->tilex;\r\n    newobj->tiley = ob->tiley;\r\n    newobj->x = ob->x;\r\n    newobj->y = ob->y;\r\n    newobj->obclass = needleobj;\r\n    newobj->dir = nodir;\r\n    newobj->angle = iangle;\r\n    newobj->speed = 0x2000l;\r\n\r\n    newobj->flags = FL_NEVERMARK;\r\n    newobj->active = ac_yes;\r\n\r\n    PlaySoundLocActor (SCHABBSTHROWSND,newobj);\r\n}\r\n\r\n/*\r\n=================\r\n=\r\n= T_GiftThrow\r\n=\r\n=================\r\n*/\r\n\r\nvoid T_GiftThrow (objtype *ob)\r\n{\r\n    int32_t deltax,deltay;\r\n    float   angle;\r\n    int     iangle;\r\n\r\n    deltax = player->x - ob->x;\r\n    deltay = ob->y - player->y;\r\n    angle = (float) atan2((float) deltay, (float) deltax);\r\n    if (angle<0)\r\n        angle = (float) (M_PI*2+angle);\r\n    iangle = (int) (angle/(M_PI*2)*ANGLES);\r\n\r\n    GetNewActor ();\r\n    newobj->state = &s_rocket;\r\n    newobj->ticcount = 1;\r\n\r\n    newobj->tilex = ob->tilex;\r\n    newobj->tiley = ob->tiley;\r\n    newobj->x = ob->x;\r\n    newobj->y = ob->y;\r\n    newobj->obclass = rocketobj;\r\n    newobj->dir = nodir;\r\n    newobj->angle = iangle;\r\n    newobj->speed = 0x2000l;\r\n    newobj->flags = FL_NEVERMARK;\r\n    newobj->active = ac_yes;\r\n\r\n#ifndef APOGEE_1_0          // T_GiftThrow will never be called in shareware v1.0\r\n    PlaySoundLocActor (MISSILEFIRESND,newobj);\r\n#endif\r\n}\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= T_Schabb\r\n=\r\n=================\r\n*/\r\n\r\nvoid T_Schabb (objtype *ob)\r\n{\r\n    int32_t move;\r\n    int     dx,dy,dist;\r\n    boolean dodge;\r\n\r\n    dodge = false;\r\n    dx = abs(ob->tilex - player->tilex);\r\n    dy = abs(ob->tiley - player->tiley);\r\n    dist = dx>dy ? dx : dy;\r\n\r\n    if (CheckLine(ob))                                              // got a shot at player?\r\n    {\r\n        ob->hidden = false;\r\n        if ( (unsigned) US_RndT() < (tics<<3) && objfreelist)\r\n        {\r\n            //\r\n            // go into attack frame\r\n            //\r\n            NewState (ob,&s_schabbshoot1);\r\n            return;\r\n        }\r\n        dodge = true;\r\n    }\r\n    else\r\n        ob->hidden = true;\r\n\r\n    if (ob->dir == nodir)\r\n    {\r\n        if (dodge)\r\n            SelectDodgeDir (ob);\r\n        else\r\n            SelectChaseDir (ob);\r\n        if (ob->dir == nodir)\r\n            return;                                                 // object is blocked in\r\n    }\r\n\r\n    move = ob->speed*tics;\r\n\r\n    while (move)\r\n    {\r\n        if (ob->distance < 0)\r\n        {\r\n            //\r\n            // waiting for a door to open\r\n            //\r\n            OpenDoor (-ob->distance-1);\r\n            if (doorobjlist[-ob->distance-1].action != dr_open)\r\n                return;\r\n            ob->distance = TILEGLOBAL;      // go ahead, the door is now open\r\n            TryWalk(ob);\r\n        }\r\n\r\n        if (move < ob->distance)\r\n        {\r\n            MoveObj (ob,move);\r\n            break;\r\n        }\r\n\r\n        //\r\n        // reached goal tile, so select another one\r\n        //\r\n\r\n        //\r\n        // fix position to account for round off during moving\r\n        //\r\n        ob->x = ((int32_t)ob->tilex<<TILESHIFT)+TILEGLOBAL/2;\r\n        ob->y = ((int32_t)ob->tiley<<TILESHIFT)+TILEGLOBAL/2;\r\n\r\n        move -= ob->distance;\r\n\r\n        if (dist <4)\r\n            SelectRunDir (ob);\r\n        else if (dodge)\r\n            SelectDodgeDir (ob);\r\n        else\r\n            SelectChaseDir (ob);\r\n\r\n        if (ob->dir == nodir)\r\n            return;                                                 // object is blocked in\r\n    }\r\n}\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= T_Gift\r\n=\r\n=================\r\n*/\r\n\r\nvoid T_Gift (objtype *ob)\r\n{\r\n    int32_t move;\r\n    int     dx,dy,dist;\r\n    boolean dodge;\r\n\r\n    dodge = false;\r\n    dx = abs(ob->tilex - player->tilex);\r\n    dy = abs(ob->tiley - player->tiley);\r\n    dist = dx>dy ? dx : dy;\r\n\r\n    if (CheckLine(ob))                                              // got a shot at player?\r\n    {\r\n        ob->hidden = false;\r\n        if ( (unsigned) US_RndT() < (tics<<3) && objfreelist)\r\n        {\r\n            //\r\n            // go into attack frame\r\n            //\r\n            NewState (ob,&s_giftshoot1);\r\n            return;\r\n        }\r\n        dodge = true;\r\n    }\r\n    else\r\n        ob->hidden = true;\r\n\r\n    if (ob->dir == nodir)\r\n    {\r\n        if (dodge)\r\n            SelectDodgeDir (ob);\r\n        else\r\n            SelectChaseDir (ob);\r\n        if (ob->dir == nodir)\r\n            return;                                                 // object is blocked in\r\n    }\r\n\r\n    move = ob->speed*tics;\r\n\r\n    while (move)\r\n    {\r\n        if (ob->distance < 0)\r\n        {\r\n            //\r\n            // waiting for a door to open\r\n            //\r\n            OpenDoor (-ob->distance-1);\r\n            if (doorobjlist[-ob->distance-1].action != dr_open)\r\n                return;\r\n            ob->distance = TILEGLOBAL;      // go ahead, the door is now open\r\n            TryWalk(ob);\r\n        }\r\n\r\n        if (move < ob->distance)\r\n        {\r\n            MoveObj (ob,move);\r\n            break;\r\n        }\r\n\r\n        //\r\n        // reached goal tile, so select another one\r\n        //\r\n\r\n        //\r\n        // fix position to account for round off during moving\r\n        //\r\n        ob->x = ((int32_t)ob->tilex<<TILESHIFT)+TILEGLOBAL/2;\r\n        ob->y = ((int32_t)ob->tiley<<TILESHIFT)+TILEGLOBAL/2;\r\n\r\n        move -= ob->distance;\r\n\r\n        if (dist <4)\r\n            SelectRunDir (ob);\r\n        else if (dodge)\r\n            SelectDodgeDir (ob);\r\n        else\r\n            SelectChaseDir (ob);\r\n\r\n        if (ob->dir == nodir)\r\n            return;                                                 // object is blocked in\r\n    }\r\n}\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= T_Fat\r\n=\r\n=================\r\n*/\r\n\r\nvoid T_Fat (objtype *ob)\r\n{\r\n    int32_t move;\r\n    int     dx,dy,dist;\r\n    boolean dodge;\r\n\r\n    dodge = false;\r\n    dx = abs(ob->tilex - player->tilex);\r\n    dy = abs(ob->tiley - player->tiley);\r\n    dist = dx>dy ? dx : dy;\r\n\r\n    if (CheckLine(ob))                                              // got a shot at player?\r\n    {\r\n        ob->hidden = false;\r\n        if ( (unsigned) US_RndT() < (tics<<3) && objfreelist)\r\n        {\r\n            //\r\n            // go into attack frame\r\n            //\r\n            NewState (ob,&s_fatshoot1);\r\n            return;\r\n        }\r\n        dodge = true;\r\n    }\r\n    else\r\n        ob->hidden = true;\r\n\r\n    if (ob->dir == nodir)\r\n    {\r\n        if (dodge)\r\n            SelectDodgeDir (ob);\r\n        else\r\n            SelectChaseDir (ob);\r\n        if (ob->dir == nodir)\r\n            return;                                                 // object is blocked in\r\n    }\r\n\r\n    move = ob->speed*tics;\r\n\r\n    while (move)\r\n    {\r\n        if (ob->distance < 0)\r\n        {\r\n            //\r\n            // waiting for a door to open\r\n            //\r\n            OpenDoor (-ob->distance-1);\r\n            if (doorobjlist[-ob->distance-1].action != dr_open)\r\n                return;\r\n            ob->distance = TILEGLOBAL;      // go ahead, the door is now open\r\n            TryWalk(ob);\r\n        }\r\n\r\n        if (move < ob->distance)\r\n        {\r\n            MoveObj (ob,move);\r\n            break;\r\n        }\r\n\r\n        //\r\n        // reached goal tile, so select another one\r\n        //\r\n\r\n        //\r\n        // fix position to account for round off during moving\r\n        //\r\n        ob->x = ((int32_t)ob->tilex<<TILESHIFT)+TILEGLOBAL/2;\r\n        ob->y = ((int32_t)ob->tiley<<TILESHIFT)+TILEGLOBAL/2;\r\n\r\n        move -= ob->distance;\r\n\r\n        if (dist <4)\r\n            SelectRunDir (ob);\r\n        else if (dodge)\r\n            SelectDodgeDir (ob);\r\n        else\r\n            SelectChaseDir (ob);\r\n\r\n        if (ob->dir == nodir)\r\n            return;                                                 // object is blocked in\r\n    }\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                    HITLERS\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n//\r\n// fake\r\n//\r\nextern  statetype s_fakestand;\r\n\r\nextern  statetype s_fakechase1;\r\nextern  statetype s_fakechase1s;\r\nextern  statetype s_fakechase2;\r\nextern  statetype s_fakechase3;\r\nextern  statetype s_fakechase3s;\r\nextern  statetype s_fakechase4;\r\n\r\nextern  statetype s_fakedie1;\r\nextern  statetype s_fakedie2;\r\nextern  statetype s_fakedie3;\r\nextern  statetype s_fakedie4;\r\nextern  statetype s_fakedie5;\r\nextern  statetype s_fakedie6;\r\n\r\nextern  statetype s_fakeshoot1;\r\nextern  statetype s_fakeshoot2;\r\nextern  statetype s_fakeshoot3;\r\nextern  statetype s_fakeshoot4;\r\nextern  statetype s_fakeshoot5;\r\nextern  statetype s_fakeshoot6;\r\nextern  statetype s_fakeshoot7;\r\nextern  statetype s_fakeshoot8;\r\nextern  statetype s_fakeshoot9;\r\n\r\nextern  statetype s_fire1;\r\nextern  statetype s_fire2;\r\n\r\nstatetype s_fakestand           = {false,SPR_FAKE_W1,0,(statefunc)T_Stand,NULL,&s_fakestand};\r\n\r\nstatetype s_fakechase1          = {false,SPR_FAKE_W1,10,(statefunc)T_Fake,NULL,&s_fakechase1s};\r\nstatetype s_fakechase1s         = {false,SPR_FAKE_W1,3,NULL,NULL,&s_fakechase2};\r\nstatetype s_fakechase2          = {false,SPR_FAKE_W2,8,(statefunc)T_Fake,NULL,&s_fakechase3};\r\nstatetype s_fakechase3          = {false,SPR_FAKE_W3,10,(statefunc)T_Fake,NULL,&s_fakechase3s};\r\nstatetype s_fakechase3s         = {false,SPR_FAKE_W3,3,NULL,NULL,&s_fakechase4};\r\nstatetype s_fakechase4          = {false,SPR_FAKE_W4,8,(statefunc)T_Fake,NULL,&s_fakechase1};\r\n\r\nstatetype s_fakedie1            = {false,SPR_FAKE_DIE1,10,NULL,(statefunc)A_DeathScream,&s_fakedie2};\r\nstatetype s_fakedie2            = {false,SPR_FAKE_DIE2,10,NULL,NULL,&s_fakedie3};\r\nstatetype s_fakedie3            = {false,SPR_FAKE_DIE3,10,NULL,NULL,&s_fakedie4};\r\nstatetype s_fakedie4            = {false,SPR_FAKE_DIE4,10,NULL,NULL,&s_fakedie5};\r\nstatetype s_fakedie5            = {false,SPR_FAKE_DIE5,10,NULL,NULL,&s_fakedie6};\r\nstatetype s_fakedie6            = {false,SPR_FAKE_DEAD,0,NULL,NULL,&s_fakedie6};\r\n\r\nstatetype s_fakeshoot1          = {false,SPR_FAKE_SHOOT,8,NULL,(statefunc)T_FakeFire,&s_fakeshoot2};\r\nstatetype s_fakeshoot2          = {false,SPR_FAKE_SHOOT,8,NULL,(statefunc)T_FakeFire,&s_fakeshoot3};\r\nstatetype s_fakeshoot3          = {false,SPR_FAKE_SHOOT,8,NULL,(statefunc)T_FakeFire,&s_fakeshoot4};\r\nstatetype s_fakeshoot4          = {false,SPR_FAKE_SHOOT,8,NULL,(statefunc)T_FakeFire,&s_fakeshoot5};\r\nstatetype s_fakeshoot5          = {false,SPR_FAKE_SHOOT,8,NULL,(statefunc)T_FakeFire,&s_fakeshoot6};\r\nstatetype s_fakeshoot6          = {false,SPR_FAKE_SHOOT,8,NULL,(statefunc)T_FakeFire,&s_fakeshoot7};\r\nstatetype s_fakeshoot7          = {false,SPR_FAKE_SHOOT,8,NULL,(statefunc)T_FakeFire,&s_fakeshoot8};\r\nstatetype s_fakeshoot8          = {false,SPR_FAKE_SHOOT,8,NULL,(statefunc)T_FakeFire,&s_fakeshoot9};\r\nstatetype s_fakeshoot9          = {false,SPR_FAKE_SHOOT,8,NULL,NULL,&s_fakechase1};\r\n\r\nstatetype s_fire1               = {false,SPR_FIRE1,6,NULL,(statefunc)T_Projectile,&s_fire2};\r\nstatetype s_fire2               = {false,SPR_FIRE2,6,NULL,(statefunc)T_Projectile,&s_fire1};\r\n\r\n//\r\n// hitler\r\n//\r\nextern  statetype s_mechachase1;\r\nextern  statetype s_mechachase1s;\r\nextern  statetype s_mechachase2;\r\nextern  statetype s_mechachase3;\r\nextern  statetype s_mechachase3s;\r\nextern  statetype s_mechachase4;\r\n\r\nextern  statetype s_mechadie1;\r\nextern  statetype s_mechadie2;\r\nextern  statetype s_mechadie3;\r\nextern  statetype s_mechadie4;\r\n\r\nextern  statetype s_mechashoot1;\r\nextern  statetype s_mechashoot2;\r\nextern  statetype s_mechashoot3;\r\nextern  statetype s_mechashoot4;\r\nextern  statetype s_mechashoot5;\r\nextern  statetype s_mechashoot6;\r\n\r\n\r\nextern  statetype s_hitlerchase1;\r\nextern  statetype s_hitlerchase1s;\r\nextern  statetype s_hitlerchase2;\r\nextern  statetype s_hitlerchase3;\r\nextern  statetype s_hitlerchase3s;\r\nextern  statetype s_hitlerchase4;\r\n\r\nextern  statetype s_hitlerdie1;\r\nextern  statetype s_hitlerdie2;\r\nextern  statetype s_hitlerdie3;\r\nextern  statetype s_hitlerdie4;\r\nextern  statetype s_hitlerdie5;\r\nextern  statetype s_hitlerdie6;\r\nextern  statetype s_hitlerdie7;\r\nextern  statetype s_hitlerdie8;\r\nextern  statetype s_hitlerdie9;\r\nextern  statetype s_hitlerdie10;\r\n\r\nextern  statetype s_hitlershoot1;\r\nextern  statetype s_hitlershoot2;\r\nextern  statetype s_hitlershoot3;\r\nextern  statetype s_hitlershoot4;\r\nextern  statetype s_hitlershoot5;\r\nextern  statetype s_hitlershoot6;\r\n\r\nextern  statetype s_hitlerdeathcam;\r\n\r\nstatetype s_mechastand          = {false,SPR_MECHA_W1,0,(statefunc)T_Stand,NULL,&s_mechastand};\r\n\r\nstatetype s_mechachase1         = {false,SPR_MECHA_W1,10,(statefunc)T_Chase,(statefunc)A_MechaSound,&s_mechachase1s};\r\nstatetype s_mechachase1s        = {false,SPR_MECHA_W1,6,NULL,NULL,&s_mechachase2};\r\nstatetype s_mechachase2         = {false,SPR_MECHA_W2,8,(statefunc)T_Chase,NULL,&s_mechachase3};\r\nstatetype s_mechachase3         = {false,SPR_MECHA_W3,10,(statefunc)T_Chase,(statefunc)A_MechaSound,&s_mechachase3s};\r\nstatetype s_mechachase3s        = {false,SPR_MECHA_W3,6,NULL,NULL,&s_mechachase4};\r\nstatetype s_mechachase4         = {false,SPR_MECHA_W4,8,(statefunc)T_Chase,NULL,&s_mechachase1};\r\n\r\nstatetype s_mechadie1           = {false,SPR_MECHA_DIE1,10,NULL,(statefunc)A_DeathScream,&s_mechadie2};\r\nstatetype s_mechadie2           = {false,SPR_MECHA_DIE2,10,NULL,NULL,&s_mechadie3};\r\nstatetype s_mechadie3           = {false,SPR_MECHA_DIE3,10,NULL,(statefunc)A_HitlerMorph,&s_mechadie4};\r\nstatetype s_mechadie4           = {false,SPR_MECHA_DEAD,0,NULL,NULL,&s_mechadie4};\r\n\r\nstatetype s_mechashoot1         = {false,SPR_MECHA_SHOOT1,30,NULL,NULL,&s_mechashoot2};\r\nstatetype s_mechashoot2         = {false,SPR_MECHA_SHOOT2,10,NULL,(statefunc)T_Shoot,&s_mechashoot3};\r\nstatetype s_mechashoot3         = {false,SPR_MECHA_SHOOT3,10,NULL,(statefunc)T_Shoot,&s_mechashoot4};\r\nstatetype s_mechashoot4         = {false,SPR_MECHA_SHOOT2,10,NULL,(statefunc)T_Shoot,&s_mechashoot5};\r\nstatetype s_mechashoot5         = {false,SPR_MECHA_SHOOT3,10,NULL,(statefunc)T_Shoot,&s_mechashoot6};\r\nstatetype s_mechashoot6         = {false,SPR_MECHA_SHOOT2,10,NULL,(statefunc)T_Shoot,&s_mechachase1};\r\n\r\n\r\nstatetype s_hitlerchase1        = {false,SPR_HITLER_W1,6,(statefunc)T_Chase,NULL,&s_hitlerchase1s};\r\nstatetype s_hitlerchase1s       = {false,SPR_HITLER_W1,4,NULL,NULL,&s_hitlerchase2};\r\nstatetype s_hitlerchase2        = {false,SPR_HITLER_W2,2,(statefunc)T_Chase,NULL,&s_hitlerchase3};\r\nstatetype s_hitlerchase3        = {false,SPR_HITLER_W3,6,(statefunc)T_Chase,NULL,&s_hitlerchase3s};\r\nstatetype s_hitlerchase3s       = {false,SPR_HITLER_W3,4,NULL,NULL,&s_hitlerchase4};\r\nstatetype s_hitlerchase4        = {false,SPR_HITLER_W4,2,(statefunc)T_Chase,NULL,&s_hitlerchase1};\r\n\r\nstatetype s_hitlerdeathcam      = {false,SPR_HITLER_W1,10,NULL,NULL,&s_hitlerdie1};\r\n\r\nstatetype s_hitlerdie1          = {false,SPR_HITLER_W1,1,NULL,(statefunc)A_DeathScream,&s_hitlerdie2};\r\nstatetype s_hitlerdie2          = {false,SPR_HITLER_W1,10,NULL,NULL,&s_hitlerdie3};\r\nstatetype s_hitlerdie3          = {false,SPR_HITLER_DIE1,10,NULL,(statefunc)A_Slurpie,&s_hitlerdie4};\r\nstatetype s_hitlerdie4          = {false,SPR_HITLER_DIE2,10,NULL,NULL,&s_hitlerdie5};\r\nstatetype s_hitlerdie5          = {false,SPR_HITLER_DIE3,10,NULL,NULL,&s_hitlerdie6};\r\nstatetype s_hitlerdie6          = {false,SPR_HITLER_DIE4,10,NULL,NULL,&s_hitlerdie7};\r\nstatetype s_hitlerdie7          = {false,SPR_HITLER_DIE5,10,NULL,NULL,&s_hitlerdie8};\r\nstatetype s_hitlerdie8          = {false,SPR_HITLER_DIE6,10,NULL,NULL,&s_hitlerdie9};\r\nstatetype s_hitlerdie9          = {false,SPR_HITLER_DIE7,10,NULL,NULL,&s_hitlerdie10};\r\nstatetype s_hitlerdie10         = {false,SPR_HITLER_DEAD,20,NULL,(statefunc)A_StartDeathCam,&s_hitlerdie10};\r\n\r\nstatetype s_hitlershoot1        = {false,SPR_HITLER_SHOOT1,30,NULL,NULL,&s_hitlershoot2};\r\nstatetype s_hitlershoot2        = {false,SPR_HITLER_SHOOT2,10,NULL,(statefunc)T_Shoot,&s_hitlershoot3};\r\nstatetype s_hitlershoot3        = {false,SPR_HITLER_SHOOT3,10,NULL,(statefunc)T_Shoot,&s_hitlershoot4};\r\nstatetype s_hitlershoot4        = {false,SPR_HITLER_SHOOT2,10,NULL,(statefunc)T_Shoot,&s_hitlershoot5};\r\nstatetype s_hitlershoot5        = {false,SPR_HITLER_SHOOT3,10,NULL,(statefunc)T_Shoot,&s_hitlershoot6};\r\nstatetype s_hitlershoot6        = {false,SPR_HITLER_SHOOT2,10,NULL,(statefunc)T_Shoot,&s_hitlerchase1};\r\n\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnFakeHitler\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnFakeHitler (int tilex, int tiley)\r\n{\r\n    if (DigiMode != sds_Off)\r\n        s_hitlerdie2.tictime = 140;\r\n    else\r\n        s_hitlerdie2.tictime = 5;\r\n\r\n    SpawnNewObj (tilex,tiley,&s_fakestand);\r\n    newobj->speed = SPDPATROL;\r\n\r\n    newobj->obclass = fakeobj;\r\n    newobj->hitpoints = starthitpoints[gamestate.difficulty][en_fake];\r\n    newobj->dir = nodir;\r\n    newobj->flags |= FL_SHOOTABLE|FL_AMBUSH;\r\n    if (!loadedgame)\r\n        gamestate.killtotal++;\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnHitler\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnHitler (int tilex, int tiley)\r\n{\r\n    if (DigiMode != sds_Off)\r\n        s_hitlerdie2.tictime = 140;\r\n    else\r\n        s_hitlerdie2.tictime = 5;\r\n\r\n\r\n    SpawnNewObj (tilex,tiley,&s_mechastand);\r\n    newobj->speed = SPDPATROL;\r\n\r\n    newobj->obclass = mechahitlerobj;\r\n    newobj->hitpoints = starthitpoints[gamestate.difficulty][en_hitler];\r\n    newobj->dir = nodir;\r\n    newobj->flags |= FL_SHOOTABLE|FL_AMBUSH;\r\n    if (!loadedgame)\r\n        gamestate.killtotal++;\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= A_HitlerMorph\r\n=\r\n===============\r\n*/\r\n\r\nvoid A_HitlerMorph (objtype *ob)\r\n{\r\n    short hitpoints[4]={500,700,800,900};\r\n\r\n    SpawnNewObj (ob->tilex,ob->tiley,&s_hitlerchase1);\r\n    newobj->speed = SPDPATROL*5;\r\n\r\n    newobj->x = ob->x;\r\n    newobj->y = ob->y;\r\n\r\n    newobj->distance = ob->distance;\r\n    newobj->dir = ob->dir;\r\n    newobj->flags = ob->flags | FL_SHOOTABLE;\r\n    newobj->flags &= ~FL_NONMARK;   // hitler stuck with nodir fix\r\n\r\n    newobj->obclass = realhitlerobj;\r\n    newobj->hitpoints = hitpoints[gamestate.difficulty];\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////\r\n//\r\n// A_MechaSound\r\n// A_Slurpie\r\n//\r\n////////////////////////////////////////////////////////\r\nvoid A_MechaSound (objtype *ob)\r\n{\r\n    if (areabyplayer[ob->areanumber])\r\n        PlaySoundLocActor (MECHSTEPSND,ob);\r\n}\r\n\r\nvoid A_Slurpie (objtype *)\r\n{\r\n    SD_PlaySound(SLURPIESND);\r\n}\r\n\r\n/*\r\n=================\r\n=\r\n= T_FakeFire\r\n=\r\n=================\r\n*/\r\n\r\nvoid T_FakeFire (objtype *ob)\r\n{\r\n    int32_t deltax,deltay;\r\n    float   angle;\r\n    int     iangle;\r\n\r\n    if (!objfreelist)       // stop shooting if over MAXACTORS\r\n    {\r\n        NewState (ob,&s_fakechase1);\r\n        return;\r\n    }\r\n\r\n    deltax = player->x - ob->x;\r\n    deltay = ob->y - player->y;\r\n    angle = (float) atan2((float) deltay, (float) deltax);\r\n    if (angle<0)\r\n        angle = (float)(M_PI*2+angle);\r\n    iangle = (int) (angle/(M_PI*2)*ANGLES);\r\n\r\n    GetNewActor ();\r\n    newobj->state = &s_fire1;\r\n    newobj->ticcount = 1;\r\n\r\n    newobj->tilex = ob->tilex;\r\n    newobj->tiley = ob->tiley;\r\n    newobj->x = ob->x;\r\n    newobj->y = ob->y;\r\n    newobj->dir = nodir;\r\n    newobj->angle = iangle;\r\n    newobj->obclass = fireobj;\r\n    newobj->speed = 0x1200l;\r\n    newobj->flags = FL_NEVERMARK;\r\n    newobj->active = ac_yes;\r\n\r\n    PlaySoundLocActor (FLAMETHROWERSND,newobj);\r\n}\r\n\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= T_Fake\r\n=\r\n=================\r\n*/\r\n\r\nvoid T_Fake (objtype *ob)\r\n{\r\n    int32_t move;\r\n\r\n    if (CheckLine(ob))                      // got a shot at player?\r\n    {\r\n        ob->hidden = false;\r\n        if ( (unsigned) US_RndT() < (tics<<1) && objfreelist)\r\n        {\r\n            //\r\n            // go into attack frame\r\n            //\r\n            NewState (ob,&s_fakeshoot1);\r\n            return;\r\n        }\r\n    }\r\n    else\r\n        ob->hidden = true;\r\n\r\n    if (ob->dir == nodir)\r\n    {\r\n        SelectDodgeDir (ob);\r\n        if (ob->dir == nodir)\r\n            return;                                                 // object is blocked in\r\n    }\r\n\r\n    move = ob->speed*tics;\r\n\r\n    while (move)\r\n    {\r\n        if (move < ob->distance)\r\n        {\r\n            MoveObj (ob,move);\r\n            break;\r\n        }\r\n\r\n        //\r\n        // reached goal tile, so select another one\r\n        //\r\n\r\n        //\r\n        // fix position to account for round off during moving\r\n        //\r\n        ob->x = ((int32_t)ob->tilex<<TILESHIFT)+TILEGLOBAL/2;\r\n        ob->y = ((int32_t)ob->tiley<<TILESHIFT)+TILEGLOBAL/2;\r\n\r\n        move -= ob->distance;\r\n\r\n        SelectDodgeDir (ob);\r\n\r\n        if (ob->dir == nodir)\r\n            return;                                                 // object is blocked in\r\n    }\r\n}\r\n\r\n#endif\r\n/*\r\n============================================================================\r\n\r\nSTAND\r\n\r\n============================================================================\r\n*/\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= T_Stand\r\n=\r\n===============\r\n*/\r\n\r\nvoid T_Stand (objtype *ob)\r\n{\r\n    SightPlayer (ob);\r\n}\r\n\r\n\r\n/*\r\n============================================================================\r\n\r\nCHASE\r\n\r\n============================================================================\r\n*/\r\n\r\n/*\r\n=================\r\n=\r\n= T_Chase\r\n=\r\n=================\r\n*/\r\n\r\nvoid T_Chase (objtype *ob)\r\n{\r\n    int32_t move,target;\r\n    int     dx,dy,dist,chance;\r\n    boolean dodge;\r\n\r\n    if (gamestate.victoryflag)\r\n        return;\r\n\r\n    dodge = false;\r\n    if (CheckLine(ob))      // got a shot at player?\r\n    {\r\n        ob->hidden = false;\r\n        dx = abs(ob->tilex - player->tilex);\r\n        dy = abs(ob->tiley - player->tiley);\r\n        dist = dx>dy ? dx : dy;\r\n\r\n#ifdef PLAYDEMOLIKEORIGINAL\r\n        if(DEMOCOND_ORIG)\r\n        {\r\n            if(!dist || (dist == 1 && ob->distance < 0x4000))\r\n                chance = 300;\r\n            else\r\n                chance = (tics<<4)/dist;\r\n        }\r\n        else\r\n#endif\r\n        {\r\n            if (dist)\r\n                chance = (tics<<4)/dist;\r\n            else\r\n                chance = 300;\r\n\r\n            if (dist == 1)\r\n            {\r\n                target = abs(ob->x - player->x);\r\n                if (target < 0x14000l)\r\n                {\r\n                    target = abs(ob->y - player->y);\r\n                    if (target < 0x14000l)\r\n                        chance = 300;\r\n                }\r\n            }\r\n        }\r\n\r\n        if ( US_RndT()<chance)\r\n        {\r\n            //\r\n            // go into attack frame\r\n            //\r\n            switch (ob->obclass)\r\n            {\r\n                case guardobj:\r\n                    NewState (ob,&s_grdshoot1);\r\n                    break;\r\n                case officerobj:\r\n                    NewState (ob,&s_ofcshoot1);\r\n                    break;\r\n                case mutantobj:\r\n                    NewState (ob,&s_mutshoot1);\r\n                    break;\r\n                case ssobj:\r\n                    NewState (ob,&s_ssshoot1);\r\n                    break;\r\n#ifndef SPEAR\r\n                case bossobj:\r\n                    NewState (ob,&s_bossshoot1);\r\n                    break;\r\n                case gretelobj:\r\n                    NewState (ob,&s_gretelshoot1);\r\n                    break;\r\n                case mechahitlerobj:\r\n                    NewState (ob,&s_mechashoot1);\r\n                    break;\r\n                case realhitlerobj:\r\n                    NewState (ob,&s_hitlershoot1);\r\n                    break;\r\n#else\r\n                case angelobj:\r\n                    NewState (ob,&s_angelshoot1);\r\n                    break;\r\n                case transobj:\r\n                    NewState (ob,&s_transshoot1);\r\n                    break;\r\n                case uberobj:\r\n                    NewState (ob,&s_ubershoot1);\r\n                    break;\r\n                case willobj:\r\n                    NewState (ob,&s_willshoot1);\r\n                    break;\r\n                case deathobj:\r\n                    NewState (ob,&s_deathshoot1);\r\n                    break;\r\n#endif\r\n            }\r\n            return;\r\n        }\r\n        dodge = true;\r\n    }\r\n    else\r\n        ob->hidden = true;\r\n\r\n    if (ob->dir == nodir)\r\n    {\r\n        if (dodge)\r\n            SelectDodgeDir (ob);\r\n        else\r\n            SelectChaseDir (ob);\r\n        if (ob->dir == nodir)\r\n            return;                                                 // object is blocked in\r\n    }\r\n\r\n    move = ob->speed*tics;\r\n\r\n    while (move)\r\n    {\r\n        if (ob->distance < 0)\r\n        {\r\n            //\r\n            // waiting for a door to open\r\n            //\r\n            OpenDoor (-ob->distance-1);\r\n            if (doorobjlist[-ob->distance-1].action != dr_open)\r\n                return;\r\n            ob->distance = TILEGLOBAL;      // go ahead, the door is now open\r\n            DEMOIF_SDL\r\n            {\r\n                TryWalk(ob);\r\n            }\r\n        }\r\n\r\n        if (move < ob->distance)\r\n        {\r\n            MoveObj (ob,move);\r\n            break;\r\n        }\r\n\r\n        //\r\n        // reached goal tile, so select another one\r\n        //\r\n\r\n        //\r\n        // fix position to account for round off during moving\r\n        //\r\n        ob->x = ((int32_t)ob->tilex<<TILESHIFT)+TILEGLOBAL/2;\r\n        ob->y = ((int32_t)ob->tiley<<TILESHIFT)+TILEGLOBAL/2;\r\n\r\n        move -= ob->distance;\r\n\r\n        if (dodge)\r\n            SelectDodgeDir (ob);\r\n        else\r\n            SelectChaseDir (ob);\r\n\r\n        if (ob->dir == nodir)\r\n            return;                                                 // object is blocked in\r\n    }\r\n}\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= T_Ghosts\r\n=\r\n=================\r\n*/\r\n\r\nvoid T_Ghosts (objtype *ob)\r\n{\r\n    int32_t move;\r\n\r\n    if (ob->dir == nodir)\r\n    {\r\n        SelectChaseDir (ob);\r\n        if (ob->dir == nodir)\r\n            return;                                                 // object is blocked in\r\n    }\r\n\r\n    move = ob->speed*tics;\r\n\r\n    while (move)\r\n    {\r\n        if (move < ob->distance)\r\n        {\r\n            MoveObj (ob,move);\r\n            break;\r\n        }\r\n\r\n        //\r\n        // reached goal tile, so select another one\r\n        //\r\n\r\n        //\r\n        // fix position to account for round off during moving\r\n        //\r\n        ob->x = ((int32_t)ob->tilex<<TILESHIFT)+TILEGLOBAL/2;\r\n        ob->y = ((int32_t)ob->tiley<<TILESHIFT)+TILEGLOBAL/2;\r\n\r\n        move -= ob->distance;\r\n\r\n        SelectChaseDir (ob);\r\n\r\n        if (ob->dir == nodir)\r\n            return;                                                 // object is blocked in\r\n    }\r\n}\r\n\r\n/*\r\n=================\r\n=\r\n= T_DogChase\r\n=\r\n=================\r\n*/\r\n\r\nvoid T_DogChase (objtype *ob)\r\n{\r\n    int32_t    move;\r\n    int32_t    dx,dy;\r\n\r\n\r\n    if (ob->dir == nodir)\r\n    {\r\n        SelectDodgeDir (ob);\r\n        if (ob->dir == nodir)\r\n            return;                                                 // object is blocked in\r\n    }\r\n\r\n    move = ob->speed*tics;\r\n\r\n    while (move)\r\n    {\r\n        //\r\n        // check for byte range\r\n        //\r\n        dx = player->x - ob->x;\r\n        if (dx<0)\r\n            dx = -dx;\r\n        dx -= move;\r\n        if (dx <= MINACTORDIST)\r\n        {\r\n            dy = player->y - ob->y;\r\n            if (dy<0)\r\n                dy = -dy;\r\n            dy -= move;\r\n            if (dy <= MINACTORDIST)\r\n            {\r\n                NewState (ob,&s_dogjump1);\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (move < ob->distance)\r\n        {\r\n            MoveObj (ob,move);\r\n            break;\r\n        }\r\n\r\n        //\r\n        // reached goal tile, so select another one\r\n        //\r\n\r\n        //\r\n        // fix position to account for round off during moving\r\n        //\r\n        ob->x = ((int32_t)ob->tilex<<TILESHIFT)+TILEGLOBAL/2;\r\n        ob->y = ((int32_t)ob->tiley<<TILESHIFT)+TILEGLOBAL/2;\r\n\r\n        move -= ob->distance;\r\n\r\n        SelectDodgeDir (ob);\r\n\r\n        if (ob->dir == nodir)\r\n            return;                                                 // object is blocked in\r\n    }\r\n}\r\n\r\n\r\n\r\n/*\r\n============================================================================\r\n\r\n                                    PATH\r\n\r\n============================================================================\r\n*/\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= SelectPathDir\r\n=\r\n===============\r\n*/\r\n\r\nvoid SelectPathDir (objtype *ob)\r\n{\r\n    unsigned spot;\r\n\r\n    spot = MAPSPOT(ob->tilex,ob->tiley,1)-ICONARROWS;\r\n\r\n    if (spot<8)\r\n    {\r\n        // new direction\r\n        ob->dir = (dirtype)(spot);\r\n    }\r\n\r\n    ob->distance = TILEGLOBAL;\r\n\r\n    if (!TryWalk (ob))\r\n        ob->dir = nodir;\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= T_Path\r\n=\r\n===============\r\n*/\r\n\r\nvoid T_Path (objtype *ob)\r\n{\r\n    int32_t    move;\r\n\r\n    if (SightPlayer (ob))\r\n        return;\r\n\r\n    if (ob->dir == nodir)\r\n    {\r\n        SelectPathDir (ob);\r\n        if (ob->dir == nodir)\r\n            return;                                 // all movement is blocked\r\n    }\r\n\r\n\r\n    move = ob->speed*tics;\r\n\r\n    while (move)\r\n    {\r\n        if (ob->distance < 0)\r\n        {\r\n            //\r\n            // waiting for a door to open\r\n            //\r\n            OpenDoor (-ob->distance-1);\r\n            if (doorobjlist[-ob->distance-1].action != dr_open)\r\n                return;\r\n            ob->distance = TILEGLOBAL;      // go ahead, the door is now open\r\n            DEMOIF_SDL\r\n            {\r\n                TryWalk(ob);\r\n            }\r\n        }\r\n\r\n        if (move < ob->distance)\r\n        {\r\n            MoveObj (ob,move);\r\n            break;\r\n        }\r\n\r\n        if (ob->tilex>MAPSIZE || ob->tiley>MAPSIZE)\r\n        {\r\n            sprintf (str, \"T_Path hit a wall at %u,%u, dir %u\",\r\n                ob->tilex,ob->tiley,ob->dir);\r\n            Quit (str);\r\n        }\r\n\r\n        ob->x = ((int32_t)ob->tilex<<TILESHIFT)+TILEGLOBAL/2;\r\n        ob->y = ((int32_t)ob->tiley<<TILESHIFT)+TILEGLOBAL/2;\r\n        move -= ob->distance;\r\n\r\n        SelectPathDir (ob);\r\n\r\n        if (ob->dir == nodir)\r\n            return;                                 // all movement is blocked\r\n    }\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                    FIGHT\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= T_Shoot\r\n=\r\n= Try to damage the player, based on skill level and player's speed\r\n=\r\n===============\r\n*/\r\n\r\nvoid T_Shoot (objtype *ob)\r\n{\r\n    int     dx,dy,dist;\r\n    int     hitchance,damage;\r\n\r\n    hitchance = 128;\r\n\r\n    if (!areabyplayer[ob->areanumber])\r\n        return;\r\n\r\n    if (CheckLine (ob))                    // player is not behind a wall\r\n    {\r\n        dx = abs(ob->tilex - player->tilex);\r\n        dy = abs(ob->tiley - player->tiley);\r\n        dist = dx>dy ? dx:dy;\r\n\r\n        if (ob->obclass == ssobj || ob->obclass == bossobj)\r\n            dist = dist*2/3;                                        // ss are better shots\r\n\r\n        if (thrustspeed >= RUNSPEED)\r\n        {\r\n            if (ob->flags&FL_VISABLE)\r\n                hitchance = 160-dist*16;                // player can see to dodge\r\n            else\r\n                hitchance = 160-dist*8;\r\n        }\r\n        else\r\n        {\r\n            if (ob->flags&FL_VISABLE)\r\n                hitchance = 256-dist*16;                // player can see to dodge\r\n            else\r\n                hitchance = 256-dist*8;\r\n        }\r\n\r\n        // see if the shot was a hit\r\n\r\n        if (US_RndT()<hitchance)\r\n        {\r\n            if (dist<2)\r\n                damage = US_RndT()>>2;\r\n            else if (dist<4)\r\n                damage = US_RndT()>>3;\r\n            else\r\n                damage = US_RndT()>>4;\r\n\r\n            TakeDamage (damage,ob);\r\n        }\r\n    }\r\n\r\n    switch(ob->obclass)\r\n    {\r\n        case ssobj:\r\n            PlaySoundLocActor(SSFIRESND,ob);\r\n            break;\r\n#ifndef SPEAR\r\n#ifndef APOGEE_1_0\r\n        case giftobj:\r\n        case fatobj:\r\n            PlaySoundLocActor(MISSILEFIRESND,ob);\r\n            break;\r\n#endif\r\n        case mechahitlerobj:\r\n        case realhitlerobj:\r\n        case bossobj:\r\n            PlaySoundLocActor(BOSSFIRESND,ob);\r\n            break;\r\n        case schabbobj:\r\n            PlaySoundLocActor(SCHABBSTHROWSND,ob);\r\n            break;\r\n        case fakeobj:\r\n            PlaySoundLocActor(FLAMETHROWERSND,ob);\r\n            break;\r\n#endif\r\n        default:\r\n            PlaySoundLocActor(NAZIFIRESND,ob);\r\n    }\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= T_Bite\r\n=\r\n===============\r\n*/\r\n\r\nvoid T_Bite (objtype *ob)\r\n{\r\n    int32_t    dx,dy;\r\n\r\n    PlaySoundLocActor(DOGATTACKSND,ob);     // JAB\r\n\r\n    dx = player->x - ob->x;\r\n    if (dx<0)\r\n        dx = -dx;\r\n    dx -= TILEGLOBAL;\r\n    if (dx <= MINACTORDIST)\r\n    {\r\n        dy = player->y - ob->y;\r\n        if (dy<0)\r\n            dy = -dy;\r\n        dy -= TILEGLOBAL;\r\n        if (dy <= MINACTORDIST)\r\n        {\r\n            if (US_RndT()<180)\r\n            {\r\n                TakeDamage (US_RndT()>>4,ob);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n#ifndef SPEAR\r\n/*\r\n============================================================================\r\n\r\n                                    BJ VICTORY\r\n\r\n============================================================================\r\n*/\r\n\r\n\r\n//\r\n// BJ victory\r\n//\r\n\r\nvoid T_BJRun (objtype *ob);\r\nvoid T_BJJump (objtype *ob);\r\nvoid T_BJDone (objtype *ob);\r\nvoid T_BJYell (objtype *ob);\r\n\r\nvoid T_DeathCam (objtype *ob);\r\n\r\nextern  statetype s_bjrun1;\r\nextern  statetype s_bjrun1s;\r\nextern  statetype s_bjrun2;\r\nextern  statetype s_bjrun3;\r\nextern  statetype s_bjrun3s;\r\nextern  statetype s_bjrun4;\r\n\r\nextern  statetype s_bjjump1;\r\nextern  statetype s_bjjump2;\r\nextern  statetype s_bjjump3;\r\nextern  statetype s_bjjump4;\r\n\r\n\r\nstatetype s_bjrun1              = {false,SPR_BJ_W1,12,(statefunc)T_BJRun,NULL,&s_bjrun1s};\r\nstatetype s_bjrun1s             = {false,SPR_BJ_W1,3, NULL,NULL,&s_bjrun2};\r\nstatetype s_bjrun2              = {false,SPR_BJ_W2,8,(statefunc)T_BJRun,NULL,&s_bjrun3};\r\nstatetype s_bjrun3              = {false,SPR_BJ_W3,12,(statefunc)T_BJRun,NULL,&s_bjrun3s};\r\nstatetype s_bjrun3s             = {false,SPR_BJ_W3,3, NULL,NULL,&s_bjrun4};\r\nstatetype s_bjrun4              = {false,SPR_BJ_W4,8,(statefunc)T_BJRun,NULL,&s_bjrun1};\r\n\r\n\r\nstatetype s_bjjump1             = {false,SPR_BJ_JUMP1,14,(statefunc)T_BJJump,NULL,&s_bjjump2};\r\nstatetype s_bjjump2             = {false,SPR_BJ_JUMP2,14,(statefunc)T_BJJump,(statefunc)T_BJYell,&s_bjjump3};\r\nstatetype s_bjjump3             = {false,SPR_BJ_JUMP3,14,(statefunc)T_BJJump,NULL,&s_bjjump4};\r\nstatetype s_bjjump4             = {false,SPR_BJ_JUMP4,300,NULL,(statefunc)T_BJDone,&s_bjjump4};\r\n\r\n\r\nstatetype s_deathcam            = {false,0,0,NULL,NULL,NULL};\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnBJVictory\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnBJVictory (void)\r\n{\r\n    SpawnNewObj (player->tilex,player->tiley+1,&s_bjrun1);\r\n    newobj->x = player->x;\r\n    newobj->y = player->y;\r\n    newobj->obclass = bjobj;\r\n    newobj->dir = north;\r\n    newobj->temp1 = 6;                      // tiles to run forward\r\n}\r\n\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= T_BJRun\r\n=\r\n===============\r\n*/\r\n\r\nvoid T_BJRun (objtype *ob)\r\n{\r\n    int32_t    move;\r\n\r\n    move = BJRUNSPEED*tics;\r\n\r\n    while (move)\r\n    {\r\n        if (move < ob->distance)\r\n        {\r\n            MoveObj (ob,move);\r\n            break;\r\n        }\r\n\r\n\r\n        ob->x = ((int32_t)ob->tilex<<TILESHIFT)+TILEGLOBAL/2;\r\n        ob->y = ((int32_t)ob->tiley<<TILESHIFT)+TILEGLOBAL/2;\r\n        move -= ob->distance;\r\n\r\n        SelectPathDir (ob);\r\n\r\n        if ( !(--ob->temp1) )\r\n        {\r\n            NewState (ob,&s_bjjump1);\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= T_BJJump\r\n=\r\n===============\r\n*/\r\n\r\nvoid T_BJJump (objtype *ob)\r\n{\r\n    int32_t    move;\r\n\r\n    move = BJJUMPSPEED*tics;\r\n    MoveObj (ob,move);\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= T_BJYell\r\n=\r\n===============\r\n*/\r\n\r\nvoid T_BJYell (objtype *ob)\r\n{\r\n    PlaySoundLocActor(YEAHSND,ob);  // JAB\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= T_BJDone\r\n=\r\n===============\r\n*/\r\n\r\nvoid T_BJDone (objtype *)\r\n{\r\n    playstate = ex_victorious;                              // exit castle tile\r\n}\r\n\r\n\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= CheckPosition\r\n=\r\n===============\r\n*/\r\n\r\nboolean CheckPosition (objtype *ob)\r\n{\r\n    int     x,y,xl,yl,xh,yh;\r\n    objtype *check;\r\n\r\n    xl = (ob->x-PLAYERSIZE) >> TILESHIFT;\r\n    yl = (ob->y-PLAYERSIZE) >> TILESHIFT;\r\n\r\n    xh = (ob->x+PLAYERSIZE) >> TILESHIFT;\r\n    yh = (ob->y+PLAYERSIZE) >> TILESHIFT;\r\n\r\n    //\r\n    // check for solid walls\r\n    //\r\n    for (y=yl;y<=yh;y++)\r\n    {\r\n        for (x=xl;x<=xh;x++)\r\n        {\r\n            check = actorat[x][y];\r\n            if (check && !ISPOINTER(check))\r\n                return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= A_StartDeathCam\r\n=\r\n===============\r\n*/\r\n\r\nvoid    A_StartDeathCam (objtype *ob)\r\n{\r\n    int32_t dx,dy;\r\n    float   fangle;\r\n    int32_t xmove,ymove;\r\n    int32_t dist;\r\n\r\n    FinishPaletteShifts ();\r\n\r\n    VW_WaitVBL (100);\r\n\r\n    if (gamestate.victoryflag)\r\n    {\r\n        playstate = ex_victorious;                              // exit castle tile\r\n        return;\r\n    }\r\n\r\n    if(usedoublebuffering) VH_UpdateScreen();\r\n\r\n    gamestate.victoryflag = true;\r\n    unsigned fadeheight = viewsize != 21 ? screenHeight-scaleFactor*STATUSLINES : screenHeight;\r\n    VL_BarScaledCoord (0, 0, screenWidth, fadeheight, bordercol);\r\n    FizzleFade(screenBuffer, 0, 0, screenWidth, fadeheight, 70, false);\r\n\r\n    if (bordercol != VIEWCOLOR)\r\n    {\r\n        CA_CacheGrChunk (STARTFONT+1);\r\n        fontnumber = 1;\r\n        SETFONTCOLOR(15,bordercol);\r\n        PrintX = 68; PrintY = 45;\r\n        US_Print (STR_SEEAGAIN);\r\n        UNCACHEGRCHUNK(STARTFONT+1);\r\n    }\r\n    else\r\n    {\r\n        CacheLump(LEVELEND_LUMP_START,LEVELEND_LUMP_END);\r\n#ifdef JAPAN\r\n#ifndef JAPDEMO\r\n        CA_CacheScreen(C_LETSSEEPIC);\r\n#endif\r\n#else\r\n        Write(0,7,STR_SEEAGAIN);\r\n#endif\r\n    }\r\n\r\n    VW_UpdateScreen ();\r\n    if(usedoublebuffering) VH_UpdateScreen();\r\n\r\n    IN_UserInput(300);\r\n\r\n    //\r\n    // line angle up exactly\r\n    //\r\n    NewState (player,&s_deathcam);\r\n\r\n    player->x = gamestate.killx;\r\n    player->y = gamestate.killy;\r\n\r\n    dx = ob->x - player->x;\r\n    dy = player->y - ob->y;\r\n\r\n    fangle = (float) atan2((float) dy, (float) dx);          // returns -pi to pi\r\n    if (fangle<0)\r\n        fangle = (float) (M_PI*2+fangle);\r\n\r\n    player->angle = (short) (fangle/(M_PI*2)*ANGLES);\r\n\r\n    //\r\n    // try to position as close as possible without being in a wall\r\n    //\r\n    dist = 0x14000l;\r\n    do\r\n    {\r\n        xmove = FixedMul(dist,costable[player->angle]);\r\n        ymove = -FixedMul(dist,sintable[player->angle]);\r\n\r\n        player->x = ob->x - xmove;\r\n        player->y = ob->y - ymove;\r\n        dist += 0x1000;\r\n\r\n    } while (!CheckPosition (player));\r\n    plux = (word)(player->x >> UNSIGNEDSHIFT);                      // scale to fit in unsigned\r\n    pluy = (word)(player->y >> UNSIGNEDSHIFT);\r\n    player->tilex = (word)(player->x >> TILESHIFT);         // scale to tile values\r\n    player->tiley = (word)(player->y >> TILESHIFT);\r\n\r\n    //\r\n    // go back to the game\r\n    //\r\n\r\n    DrawPlayBorder ();\r\n\r\n    fizzlein = true;\r\n\r\n    switch (ob->obclass)\r\n    {\r\n#ifndef SPEAR\r\n        case schabbobj:\r\n            NewState (ob,&s_schabbdeathcam);\r\n            break;\r\n        case realhitlerobj:\r\n            NewState (ob,&s_hitlerdeathcam);\r\n            break;\r\n        case giftobj:\r\n            NewState (ob,&s_giftdeathcam);\r\n            break;\r\n        case fatobj:\r\n            NewState (ob,&s_fatdeathcam);\r\n            break;\r\n#endif\r\n    }\r\n}\r\n\r\n#endif\r\n","// WL_AGENT.C\r\n\r\n#include \"wl_def.h\"\r\n#pragma hdrstop\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define MAXMOUSETURN    10\r\n\r\n\r\n#define MOVESCALE       150l\r\n#define BACKMOVESCALE   100l\r\n#define ANGLESCALE      20\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n\r\n//\r\n// player state info\r\n//\r\nint32_t         thrustspeed;\r\n\r\nword            plux,pluy;          // player coordinates scaled to unsigned\r\n\r\nshort           anglefrac;\r\n\r\nobjtype        *LastAttacker;\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                                 LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\nvoid    T_Player (objtype *ob);\r\nvoid    T_Attack (objtype *ob);\r\n\r\nstatetype   s_player = {false,0,0,(statefunc) T_Player,NULL,NULL};\r\nstatetype   s_attack = {false,0,0,(statefunc) T_Attack,NULL,NULL};\r\n\r\nstruct atkinf\r\n{\r\n    int8_t    tics,attack,frame;              // attack is 1 for gun, 2 for knife\r\n} attackinfo[4][14] =\r\n{\r\n    { {6,0,1},{6,2,2},{6,0,3},{6,-1,4} },\r\n    { {6,0,1},{6,1,2},{6,0,3},{6,-1,4} },\r\n    { {6,0,1},{6,1,2},{6,3,3},{6,-1,4} },\r\n    { {6,0,1},{6,1,2},{6,4,3},{6,-1,4} },\r\n};\r\n\r\n//===========================================================================\r\n\r\n//----------\r\n\r\nvoid Attack (void);\r\nvoid Use (void);\r\nvoid Search (objtype *ob);\r\nvoid SelectWeapon (void);\r\nvoid SelectItem (void);\r\n\r\n//----------\r\n\r\nboolean TryMove (objtype *ob);\r\nvoid T_Player (objtype *ob);\r\n\r\nvoid ClipMove (objtype *ob, int32_t xmove, int32_t ymove);\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                CONTROL STUFF\r\n\r\n=============================================================================\r\n*/\r\n\r\n/*\r\n======================\r\n=\r\n= CheckWeaponChange\r\n=\r\n= Keys 1-4 change weapons\r\n=\r\n======================\r\n*/\r\n\r\nvoid CheckWeaponChange (void)\r\n{\r\n    int newWeapon = -1;\r\n\r\n    if (!gamestate.ammo)            // must use knife with no ammo\r\n        return;\r\n\r\n    if(buttonstate[bt_nextweapon] && !buttonheld[bt_nextweapon])\r\n    {\r\n        newWeapon = gamestate.weapon + 1;\r\n        if(newWeapon > gamestate.bestweapon) newWeapon = 0;\r\n    }\r\n    else if(buttonstate[bt_prevweapon] && !buttonheld[bt_prevweapon])\r\n    {\r\n        newWeapon = gamestate.weapon - 1;\r\n        if(newWeapon < 0) newWeapon = gamestate.bestweapon;\r\n    }\r\n    else\r\n    {\r\n        for(int i = wp_knife; i <= gamestate.bestweapon; i++)\r\n        {\r\n            if (buttonstate[bt_readyknife + i - wp_knife])\r\n            {\r\n                newWeapon = i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if(newWeapon != -1)\r\n    {\r\n        gamestate.weapon = gamestate.chosenweapon = (weapontype) newWeapon;\r\n        DrawWeapon();\r\n    }\r\n}\r\n\r\n\r\n/*\r\n=======================\r\n=\r\n= ControlMovement\r\n=\r\n= Takes controlx,controly, and buttonstate[bt_strafe]\r\n=\r\n= Changes the player's angle and position\r\n=\r\n= There is an angle hack because when going 70 fps, the roundoff becomes\r\n= significant\r\n=\r\n=======================\r\n*/\r\n\r\nvoid ControlMovement (objtype *ob)\r\n{\r\n    int32_t oldx,oldy;\r\n    int     angle;\r\n    int     angleunits;\r\n\r\n    thrustspeed = 0;\r\n\r\n    oldx = player->x;\r\n    oldy = player->y;\r\n\r\n    if(buttonstate[bt_strafeleft])\r\n    {\r\n        angle = ob->angle + ANGLES/4;\r\n        if(angle >= ANGLES)\r\n            angle -= ANGLES;\r\n        if(buttonstate[bt_run])\r\n            Thrust(angle, RUNMOVE * MOVESCALE * tics);\r\n        else\r\n            Thrust(angle, BASEMOVE * MOVESCALE * tics);\r\n    }\r\n\r\n    if(buttonstate[bt_straferight])\r\n    {\r\n        angle = ob->angle - ANGLES/4;\r\n        if(angle < 0)\r\n            angle += ANGLES;\r\n        if(buttonstate[bt_run])\r\n            Thrust(angle, RUNMOVE * MOVESCALE * tics );\r\n        else\r\n            Thrust(angle, BASEMOVE * MOVESCALE * tics);\r\n    }\r\n\r\n    //\r\n    // side to side move\r\n    //\r\n    if (buttonstate[bt_strafe])\r\n    {\r\n        //\r\n        // strafing\r\n        //\r\n        //\r\n        if (controlx > 0)\r\n        {\r\n            angle = ob->angle - ANGLES/4;\r\n            if (angle < 0)\r\n                angle += ANGLES;\r\n            Thrust (angle,controlx*MOVESCALE);      // move to left\r\n        }\r\n        else if (controlx < 0)\r\n        {\r\n            angle = ob->angle + ANGLES/4;\r\n            if (angle >= ANGLES)\r\n                angle -= ANGLES;\r\n            Thrust (angle,-controlx*MOVESCALE);     // move to right\r\n        }\r\n    }\r\n    else\r\n    {\r\n        //\r\n        // not strafing\r\n        //\r\n        anglefrac += controlx;\r\n        angleunits = anglefrac/ANGLESCALE;\r\n        anglefrac -= angleunits*ANGLESCALE;\r\n        ob->angle -= angleunits;\r\n\r\n        if (ob->angle >= ANGLES)\r\n            ob->angle -= ANGLES;\r\n        if (ob->angle < 0)\r\n            ob->angle += ANGLES;\r\n\r\n    }\r\n\r\n    //\r\n    // forward/backwards move\r\n    //\r\n    if (controly < 0)\r\n    {\r\n        Thrust (ob->angle,-controly*MOVESCALE); // move forwards\r\n    }\r\n    else if (controly > 0)\r\n    {\r\n        angle = ob->angle + ANGLES/2;\r\n        if (angle >= ANGLES)\r\n            angle -= ANGLES;\r\n        Thrust (angle,controly*BACKMOVESCALE);          // move backwards\r\n    }\r\n\r\n    if (gamestate.victoryflag)              // watching the BJ actor\r\n        return;\r\n}\r\n\r\n/*\r\n=============================================================================\r\n\r\n                            STATUS WINDOW STUFF\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n/*\r\n==================\r\n=\r\n= StatusDrawPic\r\n=\r\n==================\r\n*/\r\n\r\nvoid StatusDrawPic (unsigned x, unsigned y, unsigned picnum)\r\n{\r\n    LatchDrawPicScaledCoord ((screenWidth-scaleFactor*320)/16 + scaleFactor*x,\r\n        screenHeight-scaleFactor*(STATUSLINES-y),picnum);\r\n}\r\n\r\nvoid StatusDrawFace(unsigned picnum)\r\n{\r\n    StatusDrawPic(17, 4, picnum);\r\n\r\n}\r\n\r\n\r\n/*\r\n==================\r\n=\r\n= DrawFace\r\n=\r\n==================\r\n*/\r\n\r\nvoid DrawFace (void)\r\n{\r\n    if(viewsize == 21 && ingame) return;\r\n    if (SD_SoundPlaying() == GETGATLINGSND)\r\n        StatusDrawFace(GOTGATLINGPIC);\r\n    else if (gamestate.health)\r\n    {\r\n#ifdef SPEAR\r\n        if (godmode)\r\n            StatusDrawFace(GODMODEFACE1PIC+gamestate.faceframe);\r\n        else\r\n#endif\r\n            StatusDrawFace(FACE1APIC+3*((100-gamestate.health)/16)+gamestate.faceframe);\r\n    }\r\n    else\r\n    {\r\n#ifndef SPEAR\r\n        if (LastAttacker && LastAttacker->obclass == needleobj)\r\n            StatusDrawFace(MUTANTBJPIC);\r\n        else\r\n#endif\r\n            StatusDrawFace(FACE8APIC);\r\n    }\r\n}\r\n\r\n/*\r\n===============\r\n=\r\n= UpdateFace\r\n=\r\n= Calls draw face if time to change\r\n=\r\n===============\r\n*/\r\n\r\nint facecount = 0;\r\nint facetimes = 0;\r\n\r\nvoid UpdateFace (void)\r\n{\r\n    // don't make demo depend on sound playback\r\n    if(demoplayback || demorecord)\r\n    {\r\n        if(facetimes > 0)\r\n        {\r\n            facetimes--;\r\n            return;\r\n        }\r\n    }\r\n    else if(SD_SoundPlaying() == GETGATLINGSND)\r\n        return;\r\n\r\n    facecount += tics;\r\n    if (facecount > US_RndT())\r\n    {\r\n        gamestate.faceframe = (US_RndT()>>6);\r\n        if (gamestate.faceframe==3)\r\n            gamestate.faceframe = 1;\r\n\r\n        facecount = 0;\r\n        DrawFace ();\r\n    }\r\n}\r\n\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= LatchNumber\r\n=\r\n= right justifies and pads with blanks\r\n=\r\n===============\r\n*/\r\n\r\nstatic void LatchNumber (int x, int y, unsigned width, int32_t number)\r\n{\r\n    unsigned length,c;\r\n    char    str[20];\r\n\r\n    ltoa (number,str,10);\r\n\r\n    length = (unsigned) strlen (str);\r\n\r\n    while (length<width)\r\n    {\r\n        StatusDrawPic (x,y,N_BLANKPIC);\r\n        x++;\r\n        width--;\r\n    }\r\n\r\n    c = length <= width ? 0 : length-width;\r\n\r\n    while (c<length)\r\n    {\r\n        StatusDrawPic (x,y,str[c]-'0'+ N_0PIC);\r\n        x++;\r\n        c++;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= DrawHealth\r\n=\r\n===============\r\n*/\r\n\r\nvoid DrawHealth (void)\r\n{\r\n    if(viewsize == 21 && ingame) return;\r\n    LatchNumber (21,16,3,gamestate.health);\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= TakeDamage\r\n=\r\n===============\r\n*/\r\n\r\nvoid TakeDamage (int points,objtype *attacker)\r\n{\r\n    LastAttacker = attacker;\r\n\r\n    if (gamestate.victoryflag)\r\n        return;\r\n    if (gamestate.difficulty==gd_baby)\r\n        points>>=2;\r\n\r\n    if (!godmode)\r\n        gamestate.health -= points;\r\n\r\n    if (gamestate.health<=0)\r\n    {\r\n        gamestate.health = 0;\r\n        playstate = ex_died;\r\n        killerobj = attacker;\r\n    }\r\n\r\n    if (godmode != 2)\r\n        StartDamageFlash (points);\r\n\r\n    DrawHealth ();\r\n    DrawFace ();\r\n\r\n    //\r\n    // MAKE BJ'S EYES BUG IF MAJOR DAMAGE!\r\n    //\r\n#ifdef SPEAR\r\n    if (points > 30 && gamestate.health!=0 && !godmode && viewsize != 21)\r\n    {\r\n        StatusDrawFace(BJOUCHPIC);\r\n        facecount = 0;\r\n    }\r\n#endif\r\n}\r\n\r\n/*\r\n===============\r\n=\r\n= HealSelf\r\n=\r\n===============\r\n*/\r\n\r\nvoid HealSelf (int points)\r\n{\r\n    gamestate.health += points;\r\n    if (gamestate.health>100)\r\n        gamestate.health = 100;\r\n\r\n    DrawHealth ();\r\n    DrawFace ();\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= DrawLevel\r\n=\r\n===============\r\n*/\r\n\r\nvoid DrawLevel (void)\r\n{\r\n    if(viewsize == 21 && ingame) return;\r\n#ifdef SPEAR\r\n    if (gamestate.mapon == 20)\r\n        LatchNumber (2,16,2,18);\r\n    else\r\n#endif\r\n        LatchNumber (2,16,2,gamestate.mapon+1);\r\n}\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= DrawLives\r\n=\r\n===============\r\n*/\r\n\r\nvoid DrawLives (void)\r\n{\r\n    if(viewsize == 21 && ingame) return;\r\n    LatchNumber (14,16,1,gamestate.lives);\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= GiveExtraMan\r\n=\r\n===============\r\n*/\r\n\r\nvoid GiveExtraMan (void)\r\n{\r\n    if (gamestate.lives<9)\r\n        gamestate.lives++;\r\n    DrawLives ();\r\n    SD_PlaySound (BONUS1UPSND);\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n===============\r\n=\r\n= DrawScore\r\n=\r\n===============\r\n*/\r\n\r\nvoid DrawScore (void)\r\n{\r\n    if(viewsize == 21 && ingame) return;\r\n    LatchNumber (6,16,6,gamestate.score);\r\n}\r\n\r\n/*\r\n===============\r\n=\r\n= GivePoints\r\n=\r\n===============\r\n*/\r\n\r\nvoid GivePoints (int32_t points)\r\n{\r\n    gamestate.score += points;\r\n    while (gamestate.score >= gamestate.nextextra)\r\n    {\r\n        gamestate.nextextra += EXTRAPOINTS;\r\n        GiveExtraMan ();\r\n    }\r\n    DrawScore ();\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n==================\r\n=\r\n= DrawWeapon\r\n=\r\n==================\r\n*/\r\n\r\nvoid DrawWeapon (void)\r\n{\r\n    if(viewsize == 21 && ingame) return;\r\n    StatusDrawPic (32,8,KNIFEPIC+gamestate.weapon);\r\n}\r\n\r\n\r\n/*\r\n==================\r\n=\r\n= DrawKeys\r\n=\r\n==================\r\n*/\r\n\r\nvoid DrawKeys (void)\r\n{\r\n    if(viewsize == 21 && ingame) return;\r\n    if (gamestate.keys & 1)\r\n        StatusDrawPic (30,4,GOLDKEYPIC);\r\n    else\r\n        StatusDrawPic (30,4,NOKEYPIC);\r\n\r\n    if (gamestate.keys & 2)\r\n        StatusDrawPic (30,20,SILVERKEYPIC);\r\n    else\r\n        StatusDrawPic (30,20,NOKEYPIC);\r\n}\r\n\r\n/*\r\n==================\r\n=\r\n= GiveWeapon\r\n=\r\n==================\r\n*/\r\n\r\nvoid GiveWeapon (int weapon)\r\n{\r\n    GiveAmmo (6);\r\n\r\n    if (gamestate.bestweapon<weapon)\r\n        gamestate.bestweapon = gamestate.weapon\r\n        = gamestate.chosenweapon = (weapontype) weapon;\r\n\r\n    DrawWeapon ();\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n===============\r\n=\r\n= DrawAmmo\r\n=\r\n===============\r\n*/\r\n\r\nvoid DrawAmmo (void)\r\n{\r\n    if(viewsize == 21 && ingame) return;\r\n    LatchNumber (27,16,2,gamestate.ammo);\r\n}\r\n\r\n/*\r\n===============\r\n=\r\n= GiveAmmo\r\n=\r\n===============\r\n*/\r\n\r\nvoid GiveAmmo (int ammo)\r\n{\r\n    if (!gamestate.ammo)                            // knife was out\r\n    {\r\n        if (!gamestate.attackframe)\r\n        {\r\n            gamestate.weapon = gamestate.chosenweapon;\r\n            DrawWeapon ();\r\n        }\r\n    }\r\n    gamestate.ammo += ammo;\r\n    if (gamestate.ammo > 99)\r\n        gamestate.ammo = 99;\r\n    DrawAmmo ();\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n==================\r\n=\r\n= GiveKey\r\n=\r\n==================\r\n*/\r\n\r\nvoid GiveKey (int key)\r\n{\r\n    gamestate.keys |= (1<<key);\r\n    DrawKeys ();\r\n}\r\n\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                MOVEMENT\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n/*\r\n===================\r\n=\r\n= GetBonus\r\n=\r\n===================\r\n*/\r\nvoid GetBonus (statobj_t *check)\r\n{\r\n    switch (check->itemnumber)\r\n    {\r\n        case    bo_firstaid:\r\n            if (gamestate.health == 100)\r\n                return;\r\n\r\n            SD_PlaySound (HEALTH2SND);\r\n            HealSelf (25);\r\n            break;\r\n\r\n        case    bo_key1:\r\n        case    bo_key2:\r\n        case    bo_key3:\r\n        case    bo_key4:\r\n            GiveKey (check->itemnumber - bo_key1);\r\n            SD_PlaySound (GETKEYSND);\r\n            break;\r\n\r\n        case    bo_cross:\r\n            SD_PlaySound (BONUS1SND);\r\n            GivePoints (100);\r\n            gamestate.treasurecount++;\r\n            break;\r\n        case    bo_chalice:\r\n            SD_PlaySound (BONUS2SND);\r\n            GivePoints (500);\r\n            gamestate.treasurecount++;\r\n            break;\r\n        case    bo_bible:\r\n            SD_PlaySound (BONUS3SND);\r\n            GivePoints (1000);\r\n            gamestate.treasurecount++;\r\n            break;\r\n        case    bo_crown:\r\n            SD_PlaySound (BONUS4SND);\r\n            GivePoints (5000);\r\n            gamestate.treasurecount++;\r\n            break;\r\n\r\n        case    bo_clip:\r\n            if (gamestate.ammo == 99)\r\n                return;\r\n\r\n            SD_PlaySound (GETAMMOSND);\r\n            GiveAmmo (8);\r\n            break;\r\n        case    bo_clip2:\r\n            if (gamestate.ammo == 99)\r\n                return;\r\n\r\n            SD_PlaySound (GETAMMOSND);\r\n            GiveAmmo (4);\r\n            break;\r\n\r\n#ifdef SPEAR\r\n        case    bo_25clip:\r\n            if (gamestate.ammo == 99)\r\n                return;\r\n\r\n            SD_PlaySound (GETAMMOBOXSND);\r\n            GiveAmmo (25);\r\n            break;\r\n#endif\r\n\r\n        case    bo_machinegun:\r\n            SD_PlaySound (GETMACHINESND);\r\n            GiveWeapon (wp_machinegun);\r\n            break;\r\n        case    bo_chaingun:\r\n            SD_PlaySound (GETGATLINGSND);\r\n            facetimes = 38;\r\n            GiveWeapon (wp_chaingun);\r\n\r\n            if(viewsize != 21)\r\n                StatusDrawFace (GOTGATLINGPIC);\r\n            facecount = 0;\r\n            break;\r\n\r\n        case    bo_fullheal:\r\n            SD_PlaySound (BONUS1UPSND);\r\n            HealSelf (99);\r\n            GiveAmmo (25);\r\n            GiveExtraMan ();\r\n            gamestate.treasurecount++;\r\n            break;\r\n\r\n        case    bo_food:\r\n            if (gamestate.health == 100)\r\n                return;\r\n\r\n            SD_PlaySound (HEALTH1SND);\r\n            HealSelf (10);\r\n            break;\r\n\r\n        case    bo_alpo:\r\n            if (gamestate.health == 100)\r\n                return;\r\n\r\n            SD_PlaySound (HEALTH1SND);\r\n            HealSelf (4);\r\n            break;\r\n\r\n        case    bo_gibs:\r\n            if (gamestate.health >10)\r\n                return;\r\n\r\n            SD_PlaySound (SLURPIESND);\r\n            HealSelf (1);\r\n            break;\r\n\r\n#ifdef SPEAR\r\n        case    bo_spear:\r\n            spearflag = true;\r\n            spearx = player->x;\r\n            speary = player->y;\r\n            spearangle = player->angle;\r\n            playstate = ex_completed;\r\n#endif\r\n    }\r\n\r\n    StartBonusFlash ();\r\n    check->shapenum = -1;                   // remove from list\r\n}\r\n\r\n/*\r\n===================\r\n=\r\n= TryMove\r\n=\r\n= returns true if move ok\r\n= debug: use pointers to optimize\r\n===================\r\n*/\r\n\r\nboolean TryMove (objtype *ob)\r\n{\r\n    int         xl,yl,xh,yh,x,y;\r\n    objtype    *check;\r\n    int32_t     deltax,deltay;\r\n\r\n    xl = (ob->x-PLAYERSIZE) >>TILESHIFT;\r\n    yl = (ob->y-PLAYERSIZE) >>TILESHIFT;\r\n\r\n    xh = (ob->x+PLAYERSIZE) >>TILESHIFT;\r\n    yh = (ob->y+PLAYERSIZE) >>TILESHIFT;\r\n\r\n#define PUSHWALLMINDIST PLAYERSIZE\r\n\r\n    //\r\n    // check for solid walls\r\n    //\r\n    for (y=yl;y<=yh;y++)\r\n    {\r\n        for (x=xl;x<=xh;x++)\r\n        {\r\n            check = actorat[x][y];\r\n            if (check && !ISPOINTER(check))\r\n            {\r\n                if(tilemap[x][y]==64 && x==pwallx && y==pwally)   // back of moving pushwall?\r\n                {\r\n                    switch(pwalldir)\r\n                    {\r\n                        case di_north:\r\n                            if(ob->y-PUSHWALLMINDIST<=(pwally<<TILESHIFT)+((63-pwallpos)<<10))\r\n                                return false;\r\n                            break;\r\n                        case di_west:\r\n                            if(ob->x-PUSHWALLMINDIST<=(pwallx<<TILESHIFT)+((63-pwallpos)<<10))\r\n                                return false;\r\n                            break;\r\n                        case di_east:\r\n                            if(ob->x+PUSHWALLMINDIST>=(pwallx<<TILESHIFT)+(pwallpos<<10))\r\n                                return false;\r\n                            break;\r\n                        case di_south:\r\n                            if(ob->y+PUSHWALLMINDIST>=(pwally<<TILESHIFT)+(pwallpos<<10))\r\n                                return false;\r\n                            break;\r\n                    }\r\n                }\r\n                else return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    //\r\n    // check for actors\r\n    //\r\n    if (yl>0)\r\n        yl--;\r\n    if (yh<MAPSIZE-1)\r\n        yh++;\r\n    if (xl>0)\r\n        xl--;\r\n    if (xh<MAPSIZE-1)\r\n        xh++;\r\n\r\n    for (y=yl;y<=yh;y++)\r\n    {\r\n        for (x=xl;x<=xh;x++)\r\n        {\r\n            check = actorat[x][y];\r\n            if (ISPOINTER(check) && check != player && (check->flags & FL_SHOOTABLE) )\r\n            {\r\n                deltax = ob->x - check->x;\r\n                if (deltax < -MINACTORDIST || deltax > MINACTORDIST)\r\n                    continue;\r\n                deltay = ob->y - check->y;\r\n                if (deltay < -MINACTORDIST || deltay > MINACTORDIST)\r\n                    continue;\r\n\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n/*\r\n===================\r\n=\r\n= ClipMove\r\n=\r\n===================\r\n*/\r\n\r\nvoid ClipMove (objtype *ob, int32_t xmove, int32_t ymove)\r\n{\r\n    int32_t    basex,basey;\r\n\r\n    basex = ob->x;\r\n    basey = ob->y;\r\n\r\n    ob->x = basex+xmove;\r\n    ob->y = basey+ymove;\r\n    if (TryMove (ob))\r\n        return;\r\n\r\n#ifndef REMDEBUG\r\n    if (noclip && ob->x > 2*TILEGLOBAL && ob->y > 2*TILEGLOBAL\r\n        && ob->x < (((int32_t)(mapwidth-1))<<TILESHIFT)\r\n        && ob->y < (((int32_t)(mapheight-1))<<TILESHIFT) )\r\n        return;         // walk through walls\r\n#endif\r\n\r\n    if (!SD_SoundPlaying())\r\n        SD_PlaySound (HITWALLSND);\r\n\r\n    ob->x = basex+xmove;\r\n    ob->y = basey;\r\n    if (TryMove (ob))\r\n        return;\r\n\r\n    ob->x = basex;\r\n    ob->y = basey+ymove;\r\n    if (TryMove (ob))\r\n        return;\r\n\r\n    ob->x = basex;\r\n    ob->y = basey;\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n===================\r\n=\r\n= VictoryTile\r\n=\r\n===================\r\n*/\r\n\r\nvoid VictoryTile (void)\r\n{\r\n#ifndef SPEAR\r\n    SpawnBJVictory ();\r\n#endif\r\n\r\n    gamestate.victoryflag = true;\r\n}\r\n\r\n/*\r\n===================\r\n=\r\n= Thrust\r\n=\r\n===================\r\n*/\r\n\r\n// For player movement in demos exactly as in the original Wolf3D v1.4 source code\r\nstatic fixed FixedByFracOrig(fixed a, fixed b)\r\n{\r\n    int sign = 0;\r\n    if(b == 65536)\r\n        b = 65535;\r\n    else\r\n        if(b == -65536) b = 65535, sign = 1;\r\n    else\r\n        if(b < 0) b = (-b), sign = 1;\r\n\r\n    if(a < 0)\r\n    {\r\n        a = -a;\r\n        sign = !sign;\r\n    }\r\n    fixed res = (fixed)(((int64_t) a * b) >> 16);\r\n    \r\n    if(sign)\r\n        res = -res;\r\n    return res;\r\n}\r\n\r\nvoid Thrust (int angle, int32_t speed)\r\n{\r\n    int32_t xmove,ymove;\r\n    unsigned offset;\r\n\r\n\r\n    //\r\n    // ZERO FUNNY COUNTER IF MOVED!\r\n    //\r\n#ifdef SPEAR\r\n    if (speed)\r\n        funnyticount = 0;\r\n#endif\r\n\r\n    thrustspeed += speed;\r\n    //\r\n    // moving bounds speed\r\n    //\r\n    if (speed >= MINDIST*2)\r\n        speed = MINDIST*2-1;\r\n\r\n    xmove = DEMOCHOOSE_ORIG_SDL(\r\n                FixedByFracOrig(speed, costable[angle]),\r\n                FixedMul(speed,costable[angle]));\r\n    ymove = DEMOCHOOSE_ORIG_SDL(\r\n                -FixedByFracOrig(speed, sintable[angle]),\r\n                -FixedMul(speed,sintable[angle]));\r\n\r\n    ClipMove(player,xmove,ymove);\r\n\r\n    player->tilex = (short)(player->x >> TILESHIFT);                // scale to tile values\r\n    player->tiley = (short)(player->y >> TILESHIFT);\r\n\r\n    offset = (player->tiley<<mapshift)+player->tilex;\r\n    player->areanumber = *(mapsegs[0] + offset) -AREATILE;\r\n\r\n    if (*(mapsegs[1] + offset) == EXITTILE)\r\n        VictoryTile ();\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                ACTIONS\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= Cmd_Fire\r\n=\r\n===============\r\n*/\r\n\r\nvoid Cmd_Fire (void)\r\n{\r\n    buttonheld[bt_attack] = true;\r\n\r\n    gamestate.weaponframe = 0;\r\n\r\n    player->state = &s_attack;\r\n\r\n    gamestate.attackframe = 0;\r\n    gamestate.attackcount =\r\n        attackinfo[gamestate.weapon][gamestate.attackframe].tics;\r\n    gamestate.weaponframe =\r\n        attackinfo[gamestate.weapon][gamestate.attackframe].frame;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n===============\r\n=\r\n= Cmd_Use\r\n=\r\n===============\r\n*/\r\n\r\nvoid Cmd_Use (void)\r\n{\r\n    int     checkx,checky,doornum,dir;\r\n    boolean elevatorok;\r\n\r\n    //\r\n    // find which cardinal direction the player is facing\r\n    //\r\n    if (player->angle < ANGLES/8 || player->angle > 7*ANGLES/8)\r\n    {\r\n        checkx = player->tilex + 1;\r\n        checky = player->tiley;\r\n        dir = di_east;\r\n        elevatorok = true;\r\n    }\r\n    else if (player->angle < 3*ANGLES/8)\r\n    {\r\n        checkx = player->tilex;\r\n        checky = player->tiley-1;\r\n        dir = di_north;\r\n        elevatorok = false;\r\n    }\r\n    else if (player->angle < 5*ANGLES/8)\r\n    {\r\n        checkx = player->tilex - 1;\r\n        checky = player->tiley;\r\n        dir = di_west;\r\n        elevatorok = true;\r\n    }\r\n    else\r\n    {\r\n        checkx = player->tilex;\r\n        checky = player->tiley + 1;\r\n        dir = di_south;\r\n        elevatorok = false;\r\n    }\r\n\r\n    doornum = tilemap[checkx][checky];\r\n    if (*(mapsegs[1]+(checky<<mapshift)+checkx) == PUSHABLETILE)\r\n    {\r\n        //\r\n        // pushable wall\r\n        //\r\n\r\n        PushWall (checkx,checky,dir);\r\n        return;\r\n    }\r\n    if (!buttonheld[bt_use] && doornum == ELEVATORTILE && elevatorok)\r\n    {\r\n        //\r\n        // use elevator\r\n        //\r\n        buttonheld[bt_use] = true;\r\n\r\n        tilemap[checkx][checky]++;              // flip switch\r\n        if (*(mapsegs[0]+(player->tiley<<mapshift)+player->tilex) == ALTELEVATORTILE)\r\n            playstate = ex_secretlevel;\r\n        else\r\n            playstate = ex_completed;\r\n        SD_PlaySound (LEVELDONESND);\r\n        SD_WaitSoundDone();\r\n    }\r\n    else if (!buttonheld[bt_use] && doornum & 0x80)\r\n    {\r\n        buttonheld[bt_use] = true;\r\n        OperateDoor (doornum & ~0x80);\r\n    }\r\n    else\r\n        SD_PlaySound (DONOTHINGSND);\r\n}\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                PLAYER CONTROL\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnPlayer\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnPlayer (int tilex, int tiley, int dir)\r\n{\r\n    player->obclass = playerobj;\r\n    player->active = ac_yes;\r\n    player->tilex = tilex;\r\n    player->tiley = tiley;\r\n    player->areanumber = (byte) *(mapsegs[0]+(player->tiley<<mapshift)+player->tilex);\r\n    player->x = ((int32_t)tilex<<TILESHIFT)+TILEGLOBAL/2;\r\n    player->y = ((int32_t)tiley<<TILESHIFT)+TILEGLOBAL/2;\r\n    player->state = &s_player;\r\n    player->angle = (1-dir)*90;\r\n    if (player->angle<0)\r\n        player->angle += ANGLES;\r\n    player->flags = FL_NEVERMARK;\r\n    Thrust (0,0);                           // set some variables\r\n\r\n    InitAreas ();\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n===============\r\n=\r\n= T_KnifeAttack\r\n=\r\n= Update player hands, and try to do damage when the proper frame is reached\r\n=\r\n===============\r\n*/\r\n\r\nvoid    KnifeAttack (objtype *ob)\r\n{\r\n    objtype *check,*closest;\r\n    int32_t  dist;\r\n\r\n    SD_PlaySound (ATKKNIFESND);\r\n    // actually fire\r\n    dist = 0x7fffffff;\r\n    closest = NULL;\r\n    for (check=ob->next; check; check=check->next)\r\n    {\r\n        if ( (check->flags & FL_SHOOTABLE) && (check->flags & FL_VISABLE)\r\n            && abs(check->viewx-centerx) < shootdelta)\r\n        {\r\n            if (check->transx < dist)\r\n            {\r\n                dist = check->transx;\r\n                closest = check;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!closest || dist > 0x18000l)\r\n    {\r\n        // missed\r\n        return;\r\n    }\r\n\r\n    // hit something\r\n    DamageActor (closest,US_RndT() >> 4);\r\n}\r\n\r\n\r\n\r\nvoid    GunAttack (objtype *ob)\r\n{\r\n    objtype *check,*closest,*oldclosest;\r\n    int      damage;\r\n    int      dx,dy,dist;\r\n    int32_t  viewdist;\r\n\r\n    switch (gamestate.weapon)\r\n    {\r\n        case wp_pistol:\r\n            SD_PlaySound (ATKPISTOLSND);\r\n            break;\r\n        case wp_machinegun:\r\n            SD_PlaySound (ATKMACHINEGUNSND);\r\n            break;\r\n        case wp_chaingun:\r\n            SD_PlaySound (ATKGATLINGSND);\r\n            break;\r\n    }\r\n\r\n    madenoise = true;\r\n\r\n    //\r\n    // find potential targets\r\n    //\r\n    viewdist = 0x7fffffffl;\r\n    closest = NULL;\r\n\r\n    while (1)\r\n    {\r\n        oldclosest = closest;\r\n\r\n        for (check=ob->next ; check ; check=check->next)\r\n        {\r\n            if ((check->flags & FL_SHOOTABLE) && (check->flags & FL_VISABLE)\r\n                && abs(check->viewx-centerx) < shootdelta)\r\n            {\r\n                if (check->transx < viewdist)\r\n                {\r\n                    viewdist = check->transx;\r\n                    closest = check;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (closest == oldclosest)\r\n            return;                                         // no more targets, all missed\r\n\r\n        //\r\n        // trace a line from player to enemey\r\n        //\r\n        if (CheckLine(closest))\r\n            break;\r\n    }\r\n\r\n    //\r\n    // hit something\r\n    //\r\n    dx = ABS(closest->tilex - player->tilex);\r\n    dy = ABS(closest->tiley - player->tiley);\r\n    dist = dx>dy ? dx:dy;\r\n    if (dist<2)\r\n        damage = US_RndT() / 4;\r\n    else if (dist<4)\r\n        damage = US_RndT() / 6;\r\n    else\r\n    {\r\n        if ( (US_RndT() / 12) < dist)           // missed\r\n            return;\r\n        damage = US_RndT() / 6;\r\n    }\r\n    DamageActor (closest,damage);\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n===============\r\n=\r\n= VictorySpin\r\n=\r\n===============\r\n*/\r\n\r\nvoid VictorySpin (void)\r\n{\r\n    int32_t    desty;\r\n\r\n    if (player->angle > 270)\r\n    {\r\n        player->angle -= (short)(tics * 3);\r\n        if (player->angle < 270)\r\n            player->angle = 270;\r\n    }\r\n    else if (player->angle < 270)\r\n    {\r\n        player->angle += (short)(tics * 3);\r\n        if (player->angle > 270)\r\n            player->angle = 270;\r\n    }\r\n\r\n    desty = (((int32_t)player->tiley-5)<<TILESHIFT)-0x3000;\r\n\r\n    if (player->y > desty)\r\n    {\r\n        player->y -= tics*4096;\r\n        if (player->y < desty)\r\n            player->y = desty;\r\n    }\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n===============\r\n=\r\n= T_Attack\r\n=\r\n===============\r\n*/\r\n\r\nvoid    T_Attack (objtype *ob)\r\n{\r\n    struct  atkinf  *cur;\r\n\r\n    UpdateFace ();\r\n\r\n    if (gamestate.victoryflag)              // watching the BJ actor\r\n    {\r\n        VictorySpin ();\r\n        return;\r\n    }\r\n\r\n    if ( buttonstate[bt_use] && !buttonheld[bt_use] )\r\n        buttonstate[bt_use] = false;\r\n\r\n    if ( buttonstate[bt_attack] && !buttonheld[bt_attack])\r\n        buttonstate[bt_attack] = false;\r\n\r\n    ControlMovement (ob);\r\n    if (gamestate.victoryflag)              // watching the BJ actor\r\n        return;\r\n\r\n    plux = (word) (player->x >> UNSIGNEDSHIFT);                     // scale to fit in unsigned\r\n    pluy = (word) (player->y >> UNSIGNEDSHIFT);\r\n    player->tilex = (short)(player->x >> TILESHIFT);                // scale to tile values\r\n    player->tiley = (short)(player->y >> TILESHIFT);\r\n\r\n    //\r\n    // change frame and fire\r\n    //\r\n    gamestate.attackcount -= (short) tics;\r\n    while (gamestate.attackcount <= 0)\r\n    {\r\n        cur = &attackinfo[gamestate.weapon][gamestate.attackframe];\r\n        switch (cur->attack)\r\n        {\r\n            case -1:\r\n                ob->state = &s_player;\r\n                if (!gamestate.ammo)\r\n                {\r\n                    gamestate.weapon = wp_knife;\r\n                    DrawWeapon ();\r\n                }\r\n                else\r\n                {\r\n                    if (gamestate.weapon != gamestate.chosenweapon)\r\n                    {\r\n                        gamestate.weapon = gamestate.chosenweapon;\r\n                        DrawWeapon ();\r\n                    }\r\n                }\r\n                gamestate.attackframe = gamestate.weaponframe = 0;\r\n                return;\r\n\r\n            case 4:\r\n                if (!gamestate.ammo)\r\n                    break;\r\n                if (buttonstate[bt_attack])\r\n                    gamestate.attackframe -= 2;\r\n            case 1:\r\n                if (!gamestate.ammo)\r\n                {       // can only happen with chain gun\r\n                    gamestate.attackframe++;\r\n                    break;\r\n                }\r\n                GunAttack (ob);\r\n                if (!ammocheat)\r\n                    gamestate.ammo--;\r\n                DrawAmmo ();\r\n                break;\r\n\r\n            case 2:\r\n                KnifeAttack (ob);\r\n                break;\r\n\r\n            case 3:\r\n                if (gamestate.ammo && buttonstate[bt_attack])\r\n                    gamestate.attackframe -= 2;\r\n                break;\r\n        }\r\n\r\n        gamestate.attackcount += cur->tics;\r\n        gamestate.attackframe++;\r\n        gamestate.weaponframe =\r\n            attackinfo[gamestate.weapon][gamestate.attackframe].frame;\r\n    }\r\n}\r\n\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n===============\r\n=\r\n= T_Player\r\n=\r\n===============\r\n*/\r\n\r\nvoid    T_Player (objtype *ob)\r\n{\r\n    if (gamestate.victoryflag)              // watching the BJ actor\r\n    {\r\n        VictorySpin ();\r\n        return;\r\n    }\r\n\r\n    UpdateFace ();\r\n    CheckWeaponChange ();\r\n\r\n    if ( buttonstate[bt_use] )\r\n        Cmd_Use ();\r\n\r\n    if ( buttonstate[bt_attack] && !buttonheld[bt_attack])\r\n        Cmd_Fire ();\r\n\r\n    ControlMovement (ob);\r\n    if (gamestate.victoryflag)              // watching the BJ actor\r\n        return;\r\n\r\n    plux = (word) (player->x >> UNSIGNEDSHIFT);                     // scale to fit in unsigned\r\n    pluy = (word) (player->y >> UNSIGNEDSHIFT);\r\n    player->tilex = (short)(player->x >> TILESHIFT);                // scale to tile values\r\n    player->tiley = (short)(player->y >> TILESHIFT);\r\n}\r\n","// WL_DEBUG.C\r\n\r\n#ifdef _WIN32\r\n    #include <io.h>\r\n#else\r\n    #include <unistd.h>\r\n#endif\r\n\r\n#include \"wl_def.h\"\r\n#pragma hdrstop\r\n\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                                 LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define VIEWTILEX       (viewwidth/16)\r\n#define VIEWTILEY       (viewheight/16)\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                                 GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\n#ifdef DEBUGKEYS\r\n\r\nint DebugKeys (void);\r\n\r\n\r\n// from WL_DRAW.C\r\n\r\nvoid ScalePost();\r\nvoid SimpleScaleShape (int xcenter, int shapenum, unsigned height);\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                                 LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nint     maporgx;\r\nint     maporgy;\r\n\r\n\r\nvoid ViewMap (void);\r\n\r\n//===========================================================================\r\n\r\n/*\r\n==================\r\n=\r\n= CountObjects\r\n=\r\n==================\r\n*/\r\n\r\nvoid CountObjects (void)\r\n{\r\n    int     i,total,count,active,inactive,doors;\r\n    objtype *obj;\r\n\r\n    CenterWindow (17,7);\r\n    active = inactive = count = doors = 0;\r\n\r\n    US_Print (\"Total statics :\");\r\n    total = (int)(laststatobj-&statobjlist[0]);\r\n    US_PrintUnsigned (total);\r\n\r\n    char str[60];\r\n    sprintf(str,\"\\nlaststatobj=%.8X\",(int32_t)(uintptr_t)laststatobj);\r\n    US_Print(str);\r\n\r\n    US_Print (\"\\nIn use statics:\");\r\n    for (i=0;i<total;i++)\r\n    {\r\n        if (statobjlist[i].shapenum != -1)\r\n            count++;\r\n        else\r\n            doors++;        //debug\r\n    }\r\n    US_PrintUnsigned (count);\r\n\r\n    US_Print (\"\\nDoors         :\");\r\n    US_PrintUnsigned (doornum);\r\n\r\n    for (obj=player->next;obj;obj=obj->next)\r\n    {\r\n        if (obj->active)\r\n            active++;\r\n        else\r\n            inactive++;\r\n    }\r\n\r\n    US_Print (\"\\nTotal actors  :\");\r\n    US_PrintUnsigned (active+inactive);\r\n\r\n    US_Print (\"\\nActive actors :\");\r\n    US_PrintUnsigned (active);\r\n\r\n    VW_UpdateScreen();\r\n    IN_Ack ();\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n===================\r\n=\r\n= PictureGrabber\r\n=\r\n===================\r\n*/\r\nvoid PictureGrabber (void)\r\n{\r\n    static char fname[] = \"WSHOT000.BMP\";\r\n\r\n    for(int i = 0; i < 1000; i++)\r\n    {\r\n        fname[7] = i % 10 + '0';\r\n        fname[6] = (i / 10) % 10 + '0';\r\n        fname[5] = i / 100 + '0';\r\n        int file = open(fname, O_RDONLY | O_BINARY);\r\n        if(file == -1) break;       // file does not exist, so use that filename\r\n        close(file);\r\n    }\r\n\r\n    // overwrites WSHOT999.BMP if all wshot files exist\r\n\r\n    SDL_SaveBMP(curSurface, fname);\r\n\r\n    CenterWindow (18,2);\r\n    US_PrintCentered (\"Screenshot taken\");\r\n    VW_UpdateScreen();\r\n    IN_Ack();\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n===================\r\n=\r\n= BasicOverhead\r\n=\r\n===================\r\n*/\r\n\r\nvoid BasicOverhead (void)\r\n{\r\n    int x, y, z, offx, offy;\r\n\r\n    z = 128/MAPSIZE; // zoom scale\r\n    offx = 320/2;\r\n    offy = (160-MAPSIZE*z)/2;\r\n\r\n#ifdef MAPBORDER\r\n    int temp = viewsize;\r\n    NewViewSize(16);\r\n    DrawPlayBorder();\r\n#endif\r\n\r\n    // right side (raw)\r\n\r\n    for(x=0;x<MAPSIZE;x++)\r\n        for(y=0;y<MAPSIZE;y++)\r\n            VWB_Bar(x*z+offx, y*z+offy,z,z,(unsigned)(uintptr_t)actorat[x][y]);\r\n\r\n    // left side (filtered)\r\n\r\n    uintptr_t tile;\r\n    int color;\r\n    offx -= 128;\r\n\r\n    for(x=0;x<MAPSIZE;x++)\r\n    {\r\n        for(y=0;y<MAPSIZE;y++)\r\n        {\r\n            tile = (uintptr_t)actorat[x][y];\r\n            if (ISPOINTER(tile) && ((objtype *)tile)->flags&FL_SHOOTABLE) color = 72;  // enemy\r\n            else if (!tile || ISPOINTER(tile))\r\n            {\r\n                if (spotvis[x][y]) color = 111;  // visable\r\n                else color = 0;  // nothing\r\n            }\r\n            else if (MAPSPOT(x,y,1) == PUSHABLETILE) color = 171;  // pushwall\r\n            else if (tile == 64) color = 158; // solid obj\r\n            else if (tile < 128) color = 154;  // walls\r\n            else if (tile < 256) color = 146;  // doors\r\n\r\n            VWB_Bar(x*z+offx, y*z+offy,z,z,color);\r\n        }\r\n    }\r\n\r\n    VWB_Bar(player->tilex*z+offx,player->tiley*z+offy,z,z,15); // player\r\n\r\n    // resize the border to match\r\n\r\n    VW_UpdateScreen();\r\n    IN_Ack();\r\n\r\n#ifdef MAPBORDER\r\n    NewViewSize(temp);\r\n    DrawPlayBorder();\r\n#endif\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n================\r\n=\r\n= ShapeTest\r\n=\r\n================\r\n*/\r\n\r\nvoid ShapeTest (void)\r\n{\r\n    //TODO\r\n#if NOTYET\r\n    extern  word    NumDigi;\r\n    extern  word    *DigiList;\r\n    extern  int     postx;\r\n    extern  byte    *postsource;\r\n    static  char    buf[10];\r\n\r\n    boolean         done;\r\n    ScanCode        scan;\r\n    int             i,j,k,x;\r\n    longword        l;\r\n    byte            *addr;\r\n    soundnames      sound;\r\n    //      PageListStruct  far *page;\r\n\r\n    CenterWindow(20,16);\r\n    VW_UpdateScreen();\r\n    for (i = 0,done = false; !done;)\r\n    {\r\n        US_ClearWindow();\r\n        sound = (soundnames) -1;\r\n\r\n        //              page = &PMPages[i];\r\n        US_Print(\" Page #\");\r\n        US_PrintUnsigned(i);\r\n        if (i < PMSpriteStart)\r\n            US_Print(\" (Wall)\");\r\n        else if (i < PMSoundStart)\r\n            US_Print(\" (Sprite)\");\r\n        else if (i == ChunksInFile - 1)\r\n            US_Print(\" (Sound Info)\");\r\n        else\r\n            US_Print(\" (Sound)\");\r\n\r\n        /*              US_Print(\"\\n XMS: \");\r\n        if (page->xmsPage != -1)\r\n        US_PrintUnsigned(page->xmsPage);\r\n        else\r\n        US_Print(\"No\");\r\n\r\n        US_Print(\"\\n Main: \");\r\n        if (page->mainPage != -1)\r\n        US_PrintUnsigned(page->mainPage);\r\n        else if (page->emsPage != -1)\r\n        {\r\n        US_Print(\"EMS \");\r\n        US_PrintUnsigned(page->emsPage);\r\n        }\r\n        else\r\n        US_Print(\"No\");\r\n\r\n        US_Print(\"\\n Last hit: \");\r\n        US_PrintUnsigned(page->lastHit);*/\r\n\r\n        US_Print(\"\\n Address: \");\r\n        addr = (byte *) PM_GetPage(i);\r\n        sprintf(buf,\"0x%08X\",(int32_t) addr);\r\n        US_Print(buf);\r\n\r\n        if (addr)\r\n        {\r\n            if (i < PMSpriteStart)\r\n            {\r\n                //\r\n                // draw the wall\r\n                //\r\n                vbuf += 32*SCREENWIDTH;\r\n                postx = 128;\r\n                postsource = addr;\r\n                for (x=0;x<64;x++,postx++,postsource+=64)\r\n                {\r\n                    wallheight[postx] = 256;\r\n                    ScalePost ();\r\n                }\r\n                vbuf -= 32*SCREENWIDTH;\r\n            }\r\n            else if (i < PMSoundStart)\r\n            {\r\n                //\r\n                // draw the sprite\r\n                //\r\n                vbuf += 32*SCREENWIDTH;\r\n                SimpleScaleShape (160, i-PMSpriteStart, 64);\r\n                vbuf -= 32*SCREENWIDTH;\r\n            }\r\n            else if (i == ChunksInFile - 1)\r\n            {\r\n                US_Print(\"\\n\\n Number of sounds: \");\r\n                US_PrintUnsigned(NumDigi);\r\n                for (l = j = k = 0;j < NumDigi;j++)\r\n                {\r\n                    l += DigiList[(j * 2) + 1];\r\n                    k += (DigiList[(j * 2) + 1] + (PMPageSize - 1)) / PMPageSize;\r\n                }\r\n                US_Print(\"\\n Total bytes: \");\r\n                US_PrintUnsigned(l);\r\n                US_Print(\"\\n Total pages: \");\r\n                US_PrintUnsigned(k);\r\n            }\r\n            else\r\n            {\r\n                byte *dp = addr;\r\n                for (j = 0;j < NumDigi;j++)\r\n                {\r\n                    k = (DigiList[(j * 2) + 1] + (PMPageSize - 1)) / PMPageSize;\r\n                    if ((i >= PMSoundStart + DigiList[j * 2])\r\n                            && (i < PMSoundStart + DigiList[j * 2] + k))\r\n                        break;\r\n                }\r\n                if (j < NumDigi)\r\n                {\r\n                    sound = (soundnames) j;\r\n                    US_Print(\"\\n Sound #\");\r\n                    US_PrintUnsigned(j);\r\n                    US_Print(\"\\n Segment #\");\r\n                    US_PrintUnsigned(i - PMSoundStart - DigiList[j * 2]);\r\n                }\r\n                for (j = 0;j < PageLengths[i];j += 32)\r\n                {\r\n                    byte v = dp[j];\r\n                    int v2 = (unsigned)v;\r\n                    v2 -= 128;\r\n                    v2 /= 4;\r\n                    if (v2 < 0)\r\n                        VWB_Vlin(WindowY + WindowH - 32 + v2,\r\n                        WindowY + WindowH - 32,\r\n                        WindowX + 8 + (j / 32),BLACK);\r\n                    else\r\n                        VWB_Vlin(WindowY + WindowH - 32,\r\n                        WindowY + WindowH - 32 + v2,\r\n                        WindowX + 8 + (j / 32),BLACK);\r\n                }\r\n            }\r\n        }\r\n\r\n        VW_UpdateScreen();\r\n\r\n        IN_Ack();\r\n        scan = LastScan;\r\n\r\n        IN_ClearKey(scan);\r\n        switch (scan)\r\n        {\r\n            case sc_LeftArrow:\r\n                if (i)\r\n                    i--;\r\n                break;\r\n            case sc_RightArrow:\r\n                if (++i >= ChunksInFile)\r\n                    i--;\r\n                break;\r\n            case sc_W:      // Walls\r\n                i = 0;\r\n                break;\r\n            case sc_S:      // Sprites\r\n                i = PMSpriteStart;\r\n                break;\r\n            case sc_D:      // Digitized\r\n                i = PMSoundStart;\r\n                break;\r\n            case sc_I:      // Digitized info\r\n                i = ChunksInFile - 1;\r\n                break;\r\n/*            case sc_L:      // Load all pages\r\n                for (j = 0;j < ChunksInFile;j++)\r\n                    PM_GetPage(j);\r\n                break;*/\r\n            case sc_P:\r\n                if (sound != -1)\r\n                    SD_PlayDigitized(sound,8,8);\r\n                break;\r\n            case sc_Escape:\r\n                done = true;\r\n                break;\r\n/*            case sc_Enter:\r\n                PM_GetPage(i);\r\n                break;*/\r\n        }\r\n    }\r\n    SD_StopDigitized();\r\n#endif\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n================\r\n=\r\n= DebugKeys\r\n=\r\n================\r\n*/\r\n\r\nint DebugKeys (void)\r\n{\r\n    boolean esc;\r\n    int level;\r\n\r\n    if (Keyboard[sc_B])             // B = border color\r\n    {\r\n        CenterWindow(20,3);\r\n        PrintY+=6;\r\n        US_Print(\" Border color (0-56): \");\r\n        VW_UpdateScreen();\r\n        esc = !US_LineInput (px,py,str,NULL,true,2,0);\r\n        if (!esc)\r\n        {\r\n            level = atoi (str);\r\n            if (level>=0 && level<=99)\r\n            {\r\n                if (level<30) level += 31;\r\n                else\r\n                {\r\n                    if (level > 56) level=31;\r\n                    else level -= 26;\r\n                }\r\n\r\n                bordercol=level*4+3;\r\n\r\n                if (bordercol == VIEWCOLOR)\r\n                    DrawStatusBorder(bordercol);\r\n\r\n                DrawPlayBorder();\r\n\r\n                return 0;\r\n            }\r\n        }\r\n        return 1;\r\n    }\r\n    if (Keyboard[sc_C])             // C = count objects\r\n    {\r\n        CountObjects();\r\n        return 1;\r\n    }\r\n    if (Keyboard[sc_D])             // D = Darkone's FPS counter\r\n    {\r\n        CenterWindow (22,2);\r\n        if (fpscounter)\r\n            US_PrintCentered (\"Darkone's FPS Counter OFF\");\r\n        else\r\n            US_PrintCentered (\"Darkone's FPS Counter ON\");\r\n        VW_UpdateScreen();\r\n        IN_Ack();\r\n        fpscounter ^= 1;\r\n        return 1;\r\n    }\r\n    if (Keyboard[sc_E])             // E = quit level\r\n        playstate = ex_completed;\r\n\r\n    if (Keyboard[sc_F])             // F = facing spot\r\n    {\r\n        char str[60];\r\n        CenterWindow (14,6);\r\n        US_Print (\"x:\");     US_PrintUnsigned (player->x);\r\n        US_Print (\" (\");     US_PrintUnsigned (player->x%65536);\r\n        US_Print (\")\\ny:\");  US_PrintUnsigned (player->y);\r\n        US_Print (\" (\");     US_PrintUnsigned (player->y%65536);\r\n        US_Print (\")\\nA:\");  US_PrintUnsigned (player->angle);\r\n        US_Print (\" X:\");    US_PrintUnsigned (player->tilex);\r\n        US_Print (\" Y:\");    US_PrintUnsigned (player->tiley);\r\n        US_Print (\"\\n1:\");   US_PrintUnsigned (tilemap[player->tilex][player->tiley]);\r\n        sprintf(str,\" 2:%.8X\",(unsigned)(uintptr_t)actorat[player->tilex][player->tiley]); US_Print(str);\r\n        US_Print (\"\\nf 1:\"); US_PrintUnsigned (player->areanumber);\r\n        US_Print (\" 2:\");    US_PrintUnsigned (MAPSPOT(player->tilex,player->tiley,1));\r\n        US_Print (\" 3:\");\r\n        if ((unsigned)(uintptr_t)actorat[player->tilex][player->tiley] < 256)\r\n            US_PrintUnsigned (spotvis[player->tilex][player->tiley]);\r\n        else\r\n            US_PrintUnsigned (actorat[player->tilex][player->tiley]->flags);\r\n        VW_UpdateScreen();\r\n        IN_Ack();\r\n        return 1;\r\n    }\r\n\r\n    if (Keyboard[sc_G])             // G = god mode\r\n    {\r\n        CenterWindow (12,2);\r\n        if (godmode == 0)\r\n            US_PrintCentered (\"God mode ON\");\r\n        else if (godmode == 1)\r\n            US_PrintCentered (\"God (no flash)\");\r\n        else if (godmode == 2)\r\n            US_PrintCentered (\"God mode OFF\");\r\n\r\n        VW_UpdateScreen();\r\n        IN_Ack();\r\n        if (godmode != 2)\r\n            godmode++;\r\n        else\r\n            godmode = 0;\r\n        return 1;\r\n    }\r\n    if (Keyboard[sc_H])             // H = hurt self\r\n    {\r\n        IN_ClearKeysDown ();\r\n        TakeDamage (16,NULL);\r\n    }\r\n    else if (Keyboard[sc_I])        // I = item cheat\r\n    {\r\n        CenterWindow (12,3);\r\n        US_PrintCentered (\"Free items!\");\r\n        VW_UpdateScreen();\r\n        GivePoints (100000);\r\n        HealSelf (99);\r\n        if (gamestate.bestweapon<wp_chaingun)\r\n            GiveWeapon (gamestate.bestweapon+1);\r\n        gamestate.ammo += 50;\r\n        if (gamestate.ammo > 99)\r\n            gamestate.ammo = 99;\r\n        DrawAmmo ();\r\n        IN_Ack ();\r\n        return 1;\r\n    }\r\n    else if (Keyboard[sc_K])        // K = give keys\r\n    {\r\n        CenterWindow(16,3);\r\n        PrintY+=6;\r\n        US_Print(\"  Give Key (1-4): \");\r\n        VW_UpdateScreen();\r\n        esc = !US_LineInput (px,py,str,NULL,true,1,0);\r\n        if (!esc)\r\n        {\r\n            level = atoi (str);\r\n            if (level>0 && level<5)\r\n                GiveKey(level-1);\r\n        }\r\n        return 1;\r\n    }\r\n    else if (Keyboard[sc_L])        // L = level ratios\r\n    {\r\n        byte x,start,end=LRpack;\r\n\r\n        if (end == 8)   // wolf3d\r\n        {\r\n            CenterWindow(17,10);\r\n            start = 0;\r\n        }\r\n        else            // sod\r\n        {\r\n            CenterWindow(17,12);\r\n            start = 0; end = 10;\r\n        }\r\nagain:\r\n        for(x=start;x<end;x++)\r\n        {\r\n            US_PrintUnsigned(x+1);\r\n            US_Print(\" \");\r\n            US_PrintUnsigned(LevelRatios[x].time/60);\r\n            US_Print(\":\");\r\n            if (LevelRatios[x].time%60 < 10)\r\n                US_Print(\"0\");\r\n            US_PrintUnsigned(LevelRatios[x].time%60);\r\n            US_Print(\" \");\r\n            US_PrintUnsigned(LevelRatios[x].kill);\r\n            US_Print(\"% \");\r\n            US_PrintUnsigned(LevelRatios[x].secret);\r\n            US_Print(\"% \");\r\n            US_PrintUnsigned(LevelRatios[x].treasure);\r\n            US_Print(\"%\\n\");\r\n        }\r\n        VW_UpdateScreen();\r\n        IN_Ack();\r\n        if (end == 10 && gamestate.mapon > 9)\r\n        {\r\n            start = 10; end = 20;\r\n            CenterWindow(17,12);\r\n            goto again;\r\n        }\r\n\r\n        return 1;\r\n    }\r\n    else if (Keyboard[sc_N])        // N = no clip\r\n    {\r\n        noclip^=1;\r\n        CenterWindow (18,3);\r\n        if (noclip)\r\n            US_PrintCentered (\"No clipping ON\");\r\n        else\r\n            US_PrintCentered (\"No clipping OFF\");\r\n        VW_UpdateScreen();\r\n        IN_Ack ();\r\n        return 1;\r\n    }\r\n    else if (Keyboard[sc_O])        // O = basic overhead\r\n    {\r\n        BasicOverhead();\r\n        return 1;\r\n    }\r\n    else if(Keyboard[sc_P])         // P = Ripper's picture grabber\r\n    {\r\n        PictureGrabber();\r\n        return 1;\r\n    }\r\n    else if (Keyboard[sc_Q])        // Q = fast quit\r\n        Quit (NULL);\r\n    else if (Keyboard[sc_S])        // S = slow motion\r\n    {\r\n        CenterWindow(30,3);\r\n        PrintY+=6;\r\n        US_Print(\" Slow Motion steps (default 14): \");\r\n        VW_UpdateScreen();\r\n        esc = !US_LineInput (px,py,str,NULL,true,2,0);\r\n        if (!esc)\r\n        {\r\n            level = atoi (str);\r\n            if (level>=0 && level<=50)\r\n                singlestep = level;\r\n        }\r\n        return 1;\r\n    }\r\n    else if (Keyboard[sc_T])        // T = shape test\r\n    {\r\n        ShapeTest ();\r\n        return 1;\r\n    }\r\n    else if (Keyboard[sc_V])        // V = extra VBLs\r\n    {\r\n        CenterWindow(30,3);\r\n        PrintY+=6;\r\n        US_Print(\"  Add how many extra VBLs(0-8): \");\r\n        VW_UpdateScreen();\r\n        esc = !US_LineInput (px,py,str,NULL,true,1,0);\r\n        if (!esc)\r\n        {\r\n            level = atoi (str);\r\n            if (level>=0 && level<=8)\r\n                extravbls = level;\r\n        }\r\n        return 1;\r\n    }\r\n    else if (Keyboard[sc_W])        // W = warp to level\r\n    {\r\n        CenterWindow(26,3);\r\n        PrintY+=6;\r\n#ifndef SPEAR\r\n        US_Print(\"  Warp to which level(1-10): \");\r\n#else\r\n        US_Print(\"  Warp to which level(1-21): \");\r\n#endif\r\n        VW_UpdateScreen();\r\n        esc = !US_LineInput (px,py,str,NULL,true,2,0);\r\n        if (!esc)\r\n        {\r\n            level = atoi (str);\r\n#ifndef SPEAR\r\n            if (level>0 && level<11)\r\n#else\r\n            if (level>0 && level<22)\r\n#endif\r\n            {\r\n                gamestate.mapon = level-1;\r\n                playstate = ex_warped;\r\n            }\r\n        }\r\n        return 1;\r\n    }\r\n    else if (Keyboard[sc_X])        // X = item cheat\r\n    {\r\n        CenterWindow (12,3);\r\n        US_PrintCentered (\"Extra stuff!\");\r\n        VW_UpdateScreen();\r\n        // DEBUG: put stuff here\r\n        IN_Ack ();\r\n        return 1;\r\n    }\r\n\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n#if 0\r\n/*\r\n===================\r\n=\r\n= OverheadRefresh\r\n=\r\n===================\r\n*/\r\n\r\nvoid OverheadRefresh (void)\r\n{\r\n    unsigned        x,y,endx,endy,sx,sy;\r\n    unsigned        tile;\r\n\r\n\r\n    endx = maporgx+VIEWTILEX;\r\n    endy = maporgy+VIEWTILEY;\r\n\r\n    for (y=maporgy;y<endy;y++)\r\n    {\r\n        for (x=maporgx;x<endx;x++)\r\n        {\r\n            sx = (x-maporgx)*16;\r\n            sy = (y-maporgy)*16;\r\n\r\n            switch (viewtype)\r\n            {\r\n#if 0\r\n                case mapview:\r\n                    tile = *(mapsegs[0]+farmapylookup[y]+x);\r\n                    break;\r\n\r\n                case tilemapview:\r\n                    tile = tilemap[x][y];\r\n                    break;\r\n\r\n                case visview:\r\n                    tile = spotvis[x][y];\r\n                    break;\r\n#endif\r\n                case actoratview:\r\n                    tile = (unsigned)actorat[x][y];\r\n                    break;\r\n            }\r\n\r\n            if (tile<MAXWALLTILES)\r\n                LatchDrawTile(sx,sy,tile);\r\n            else\r\n            {\r\n                LatchDrawChar(sx,sy,NUMBERCHARS+((tile&0xf000)>>12));\r\n                LatchDrawChar(sx+8,sy,NUMBERCHARS+((tile&0x0f00)>>8));\r\n                LatchDrawChar(sx,sy+8,NUMBERCHARS+((tile&0x00f0)>>4));\r\n                LatchDrawChar(sx+8,sy+8,NUMBERCHARS+(tile&0x000f));\r\n            }\r\n        }\r\n    }\r\n}\r\n#endif\r\n\r\n#if 0\r\n/*\r\n===================\r\n=\r\n= ViewMap\r\n=\r\n===================\r\n*/\r\n\r\nvoid ViewMap (void)\r\n{\r\n    boolean         button0held;\r\n\r\n    viewtype = actoratview;\r\n    //      button0held = false;\r\n\r\n\r\n    maporgx = player->tilex - VIEWTILEX/2;\r\n    if (maporgx<0)\r\n        maporgx = 0;\r\n    if (maporgx>MAPSIZE-VIEWTILEX)\r\n        maporgx=MAPSIZE-VIEWTILEX;\r\n    maporgy = player->tiley - VIEWTILEY/2;\r\n    if (maporgy<0)\r\n        maporgy = 0;\r\n    if (maporgy>MAPSIZE-VIEWTILEY)\r\n        maporgy=MAPSIZE-VIEWTILEY;\r\n\r\n    do\r\n    {\r\n        //\r\n        // let user pan around\r\n        //\r\n        PollControls ();\r\n        if (controlx < 0 && maporgx>0)\r\n            maporgx--;\r\n        if (controlx > 0 && maporgx<mapwidth-VIEWTILEX)\r\n            maporgx++;\r\n        if (controly < 0 && maporgy>0)\r\n            maporgy--;\r\n        if (controly > 0 && maporgy<mapheight-VIEWTILEY)\r\n            maporgy++;\r\n\r\n#if 0\r\n        if (c.button0 && !button0held)\r\n        {\r\n            button0held = true;\r\n            viewtype++;\r\n            if (viewtype>visview)\r\n                viewtype = mapview;\r\n        }\r\n        if (!c.button0)\r\n            button0held = false;\r\n#endif\r\n\r\n        OverheadRefresh ();\r\n\r\n    } while (!Keyboard[sc_Escape]);\r\n\r\n    IN_ClearKeysDown ();\r\n}\r\n#endif\r\n#endif\r\n","// WL_DRAW.C\r\n\r\n#include \"wl_def.h\"\r\n#include \"id_vl.h\"\r\n#pragma hdrstop\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                               LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n// the door is the last picture before the sprites\r\n#define DOORWALL        (PMSpriteStart-8)\r\n\r\n#define ACTORSIZE       0x4000\r\n\r\n/*\r\n=============================================================================\r\n\r\n                              GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nstatic byte *vbuf = NULL;\r\nunsigned vbufPitch = 0;\r\n\r\nint32_t    lasttimecount;\r\nint32_t    frameon;\r\nboolean fpscounter;\r\n\r\nint fps_frames=0, fps_time=0, fps=0;\r\n\r\nint *wallheight;\r\nint min_wallheight;\r\n\r\n//\r\n// math tables\r\n//\r\nshort *pixelangle;\r\nint32_t finetangent[FINEANGLES/4];\r\nfixed sintable[ANGLES+ANGLES/4];\r\nfixed *costable = sintable+(ANGLES/4);\r\n\r\n//\r\n// refresh variables\r\n//\r\nfixed   viewx,viewy;                    // the focal point\r\nshort   viewangle;\r\nfixed   viewsin,viewcos;\r\n\r\nvoid    TransformActor (objtype *ob);\r\nvoid    BuildTables (void);\r\nvoid    ClearScreen (void);\r\nint     CalcRotate (objtype *ob);\r\nvoid    DrawScaleds (void);\r\nvoid    CalcTics (void);\r\nvoid    ThreeDRefresh (void);\r\n\r\n\r\n\r\n//\r\n// wall optimization variables\r\n//\r\nint     lastside;               // true for vertical\r\nint32_t    lastintercept;\r\nint     lasttilehit;\r\nint     lasttexture;\r\n\r\n//\r\n// ray tracing variables\r\n//\r\nshort    focaltx,focalty,viewtx,viewty;\r\nlongword xpartialup,xpartialdown,ypartialup,ypartialdown;\r\n\r\nshort   midangle,angle;\r\n\r\nword    tilehit;\r\nint     pixx;\r\n\r\nshort   xtile,ytile;\r\nshort   xtilestep,ytilestep;\r\nint32_t    xintercept,yintercept;\r\nword    xstep,ystep;\r\nword    xspot,yspot;\r\nint     texdelta;\r\n\r\nword horizwall[MAXWALLTILES],vertwall[MAXWALLTILES];\r\n\r\n\r\n/*\r\n============================================================================\r\n\r\n                           3 - D  DEFINITIONS\r\n\r\n============================================================================\r\n*/\r\n\r\n/*\r\n========================\r\n=\r\n= TransformActor\r\n=\r\n= Takes paramaters:\r\n=   gx,gy               : globalx/globaly of point\r\n=\r\n= globals:\r\n=   viewx,viewy         : point of view\r\n=   viewcos,viewsin     : sin/cos of viewangle\r\n=   scale               : conversion from global value to screen value\r\n=\r\n= sets:\r\n=   screenx,transx,transy,screenheight: projected edge location and size\r\n=\r\n========================\r\n*/\r\n\r\n\r\n//\r\n// transform actor\r\n//\r\nvoid TransformActor (objtype *ob)\r\n{\r\n    fixed gx,gy,gxt,gyt,nx,ny;\r\n\r\n//\r\n// translate point to view centered coordinates\r\n//\r\n    gx = ob->x-viewx;\r\n    gy = ob->y-viewy;\r\n\r\n//\r\n// calculate newx\r\n//\r\n    gxt = FixedMul(gx,viewcos);\r\n    gyt = FixedMul(gy,viewsin);\r\n    nx = gxt-gyt-ACTORSIZE;         // fudge the shape forward a bit, because\r\n                                    // the midpoint could put parts of the shape\r\n                                    // into an adjacent wall\r\n\r\n//\r\n// calculate newy\r\n//\r\n    gxt = FixedMul(gx,viewsin);\r\n    gyt = FixedMul(gy,viewcos);\r\n    ny = gyt+gxt;\r\n\r\n//\r\n// calculate perspective ratio\r\n//\r\n    ob->transx = nx;\r\n    ob->transy = ny;\r\n\r\n    if (nx<MINDIST)                 // too close, don't overflow the divide\r\n    {\r\n        ob->viewheight = 0;\r\n        return;\r\n    }\r\n\r\n    ob->viewx = (word)(centerx + ny*scale/nx);\r\n\r\n//\r\n// calculate height (heightnumerator/(nx>>8))\r\n//\r\n    ob->viewheight = (word)(heightnumerator/(nx>>8));\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n========================\r\n=\r\n= TransformTile\r\n=\r\n= Takes paramaters:\r\n=   tx,ty               : tile the object is centered in\r\n=\r\n= globals:\r\n=   viewx,viewy         : point of view\r\n=   viewcos,viewsin     : sin/cos of viewangle\r\n=   scale               : conversion from global value to screen value\r\n=\r\n= sets:\r\n=   screenx,transx,transy,screenheight: projected edge location and size\r\n=\r\n= Returns true if the tile is withing getting distance\r\n=\r\n========================\r\n*/\r\n\r\nboolean TransformTile (int tx, int ty, short *dispx, short *dispheight)\r\n{\r\n    fixed gx,gy,gxt,gyt,nx,ny;\r\n\r\n//\r\n// translate point to view centered coordinates\r\n//\r\n    gx = ((int32_t)tx<<TILESHIFT)+0x8000-viewx;\r\n    gy = ((int32_t)ty<<TILESHIFT)+0x8000-viewy;\r\n\r\n//\r\n// calculate newx\r\n//\r\n    gxt = FixedMul(gx,viewcos);\r\n    gyt = FixedMul(gy,viewsin);\r\n    nx = gxt-gyt-0x2000;            // 0x2000 is size of object\r\n\r\n//\r\n// calculate newy\r\n//\r\n    gxt = FixedMul(gx,viewsin);\r\n    gyt = FixedMul(gy,viewcos);\r\n    ny = gyt+gxt;\r\n\r\n\r\n//\r\n// calculate height / perspective ratio\r\n//\r\n    if (nx<MINDIST)                 // too close, don't overflow the divide\r\n        *dispheight = 0;\r\n    else\r\n    {\r\n        *dispx = (short)(centerx + ny*scale/nx);\r\n        *dispheight = (short)(heightnumerator/(nx>>8));\r\n    }\r\n\r\n//\r\n// see if it should be grabbed\r\n//\r\n    if (nx<TILEGLOBAL && ny>-TILEGLOBAL/2 && ny<TILEGLOBAL/2)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n====================\r\n=\r\n= CalcHeight\r\n=\r\n= Calculates the height of xintercept,yintercept from viewx,viewy\r\n=\r\n====================\r\n*/\r\n\r\nint CalcHeight()\r\n{\r\n    fixed z = FixedMul(xintercept - viewx, viewcos) - FixedMul(yintercept - viewy, viewsin);\r\n    \r\n    \r\n    if(z < MINDIST)\r\n        z = MINDIST;\r\n    \r\n    int height = heightnumerator / (z >> 8);\r\n    \r\n    if(height < min_wallheight)\r\n        min_wallheight = height;\r\n    \r\n    return height;\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n===================\r\n=\r\n= ScalePost\r\n=\r\n===================\r\n*/\r\n\r\nbyte *postsource;\r\nint postx;\r\n\r\nvoid ScalePost()\r\n{\r\n\r\n    int ywcount, yoffs, yw, yd, yendoffs;\r\n    byte col;\r\n\r\n\r\n\r\n    ywcount = yd = wallheight[postx] >> 3;\r\n    if(yd <= 0) yd = 100;\r\n\r\n    yoffs = (viewheight / 2 - ywcount) * vbufPitch;\r\n    if(yoffs < 0) yoffs = 0;\r\n    yoffs += postx;\r\n\r\n    yendoffs = viewheight / 2 + ywcount - 1;\r\n    yw=TEXTURESIZE-1;\r\n\r\n    while(yendoffs >= viewheight)\r\n    {\r\n        ywcount -= TEXTURESIZE/2;\r\n        while(ywcount <= 0)\r\n        {\r\n            ywcount += yd;\r\n            yw--;\r\n        }\r\n        yendoffs--;\r\n    }\r\n    if(yw < 0) return;\r\n\r\n    col = postsource[yw];\r\n\r\n    yendoffs = yendoffs * vbufPitch + postx;\r\n    while(yoffs <= yendoffs)\r\n    {\r\n        vbuf[yendoffs] = col;\r\n        ywcount -= TEXTURESIZE/2;\r\n        if(ywcount <= 0)\r\n        {\r\n            do\r\n            {\r\n                ywcount += yd;\r\n                yw--;\r\n            }\r\n            while(ywcount <= 0);\r\n            if(yw < 0) break;\r\n            col = postsource[yw];\r\n        }\r\n        yendoffs -= vbufPitch;\r\n    }\r\n}\r\n\r\nvoid GlobalScalePost(byte *vidbuf, unsigned pitch)\r\n{\r\n    vbuf = vidbuf;\r\n    vbufPitch = pitch;\r\n    ScalePost();\r\n}\r\n\r\n/*\r\n====================\r\n=\r\n= HitVertWall\r\n=\r\n= tilehit bit 7 is 0, because it's not a door tile\r\n= if bit 6 is 1 and the adjacent tile is a door tile, use door side pic\r\n=\r\n====================\r\n*/\r\n\r\nvoid HitVertWall (void)\r\n{\r\n    int wallpic;\r\n    int texture;\r\n\r\n    texture = ((yintercept+texdelta)>>TEXTUREFROMFIXEDSHIFT)&TEXTUREMASK;\r\n    if (xtilestep == -1)\r\n    {\r\n        texture = TEXTUREMASK-texture;\r\n        xintercept += TILEGLOBAL;\r\n    }\r\n\r\n    if(lastside==1 && lastintercept==xtile && lasttilehit==tilehit && !(lasttilehit & 0x40))\r\n    {\r\n        if((pixx&3) && texture == lasttexture)\r\n        {\r\n            ScalePost();\r\n            postx = pixx;\r\n            wallheight[pixx] = wallheight[pixx-1];\r\n            return;\r\n        }\r\n        ScalePost();\r\n        wallheight[pixx] = CalcHeight();\r\n        postsource+=texture-lasttexture;\r\n        postx=pixx;\r\n        lasttexture=texture;\r\n        return;\r\n    }\r\n\r\n    if(lastside!=-1) ScalePost();\r\n\r\n    lastside=1;\r\n    lastintercept=xtile;\r\n    lasttilehit=tilehit;\r\n    lasttexture=texture;\r\n    wallheight[pixx] = CalcHeight();\r\n    postx = pixx;\r\n\r\n    if (tilehit & 0x40)\r\n    {                                                               // check for adjacent doors\r\n        ytile = (short)(yintercept>>TILESHIFT);\r\n        if ( tilemap[xtile-xtilestep][ytile]&0x80 )\r\n            wallpic = DOORWALL+3;\r\n        else\r\n            wallpic = vertwall[tilehit & ~0x40];\r\n    }\r\n    else\r\n        wallpic = vertwall[tilehit];\r\n\r\n    postsource = PM_GetTexture(wallpic) + texture;\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= HitHorizWall\r\n=\r\n= tilehit bit 7 is 0, because it's not a door tile\r\n= if bit 6 is 1 and the adjacent tile is a door tile, use door side pic\r\n=\r\n====================\r\n*/\r\n\r\nvoid HitHorizWall (void)\r\n{\r\n    int wallpic;\r\n    int texture;\r\n\r\n    texture = ((xintercept+texdelta)>>TEXTUREFROMFIXEDSHIFT)&TEXTUREMASK;\r\n    if (ytilestep == -1)\r\n        yintercept += TILEGLOBAL;\r\n    else\r\n        texture = TEXTUREMASK-texture;\r\n\r\n    if(lastside==0 && lastintercept==ytile && lasttilehit==tilehit && !(lasttilehit & 0x40))\r\n    {\r\n        if((pixx&3) && texture == lasttexture)\r\n        {\r\n            ScalePost();\r\n            postx=pixx;\r\n            wallheight[pixx] = wallheight[pixx-1];\r\n            return;\r\n        }\r\n        ScalePost();\r\n        wallheight[pixx] = CalcHeight();\r\n        postsource+=texture-lasttexture;\r\n        postx=pixx;\r\n        lasttexture=texture;\r\n        return;\r\n    }\r\n\r\n    if(lastside!=-1) ScalePost();\r\n\r\n    lastside=0;\r\n    lastintercept=ytile;\r\n    lasttilehit=tilehit;\r\n    lasttexture=texture;\r\n    wallheight[pixx] = CalcHeight();\r\n    postx = pixx;\r\n\r\n    if (tilehit & 0x40)\r\n    {                                                               // check for adjacent doors\r\n        xtile = (short)(xintercept>>TILESHIFT);\r\n        if ( tilemap[xtile][ytile-ytilestep]&0x80)\r\n            wallpic = DOORWALL+2;\r\n        else\r\n            wallpic = horizwall[tilehit & ~0x40];\r\n    }\r\n    else\r\n        wallpic = horizwall[tilehit];\r\n\r\n    postsource = PM_GetTexture(wallpic) + texture;\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n====================\r\n=\r\n= HitHorizDoor\r\n=\r\n====================\r\n*/\r\n\r\nvoid HitHorizDoor (void)\r\n{\r\n    int doorpage;\r\n    int doornum;\r\n    int texture;\r\n\r\n    doornum = tilehit&0x7f;\r\n    texture = ((xintercept-doorposition[doornum])>>TEXTUREFROMFIXEDSHIFT)&TEXTUREMASK;\r\n\r\n    if(lasttilehit==tilehit)\r\n    {\r\n        if((pixx&3) && texture == lasttexture)\r\n        {\r\n            ScalePost();\r\n            postx=pixx;\r\n            wallheight[pixx] = wallheight[pixx-1];\r\n            return;\r\n        }\r\n        ScalePost();\r\n        wallheight[pixx] = CalcHeight();\r\n        postsource+=texture-lasttexture;\r\n        postx=pixx;\r\n        lasttexture=texture;\r\n        return;\r\n    }\r\n\r\n    if(lastside!=-1) ScalePost();\r\n\r\n    lastside=2;\r\n    lasttilehit=tilehit;\r\n    lasttexture=texture;\r\n    wallheight[pixx] = CalcHeight();\r\n    postx = pixx;\r\n\r\n    switch(doorobjlist[doornum].lock)\r\n    {\r\n        case dr_normal:\r\n            doorpage = DOORWALL;\r\n            break;\r\n        case dr_lock1:\r\n        case dr_lock2:\r\n        case dr_lock3:\r\n        case dr_lock4:\r\n            doorpage = DOORWALL+6;\r\n            break;\r\n        case dr_elevator:\r\n            doorpage = DOORWALL+4;\r\n            break;\r\n    }\r\n\r\n    postsource = PM_GetTexture(doorpage) + texture;\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n====================\r\n=\r\n= HitVertDoor\r\n=\r\n====================\r\n*/\r\n\r\nvoid HitVertDoor (void)\r\n{\r\n    int doorpage;\r\n    int doornum;\r\n    int texture;\r\n\r\n    doornum = tilehit&0x7f;\r\n    texture = ((yintercept-doorposition[doornum])>>TEXTUREFROMFIXEDSHIFT)&TEXTUREMASK;\r\n\r\n    if(lasttilehit==tilehit)\r\n    {\r\n        if((pixx&3) && texture == lasttexture)\r\n        {\r\n            ScalePost();\r\n            postx=pixx;\r\n            wallheight[pixx] = wallheight[pixx-1];\r\n            return;\r\n        }\r\n        ScalePost();\r\n        wallheight[pixx] = CalcHeight();\r\n        postsource+=texture-lasttexture;\r\n        postx=pixx;\r\n        lasttexture=texture;\r\n        return;\r\n    }\r\n\r\n    if(lastside!=-1) ScalePost();\r\n\r\n    lastside=2;\r\n    lasttilehit=tilehit;\r\n    lasttexture=texture;\r\n    wallheight[pixx] = CalcHeight();\r\n    postx = pixx;\r\n\r\n    switch(doorobjlist[doornum].lock)\r\n    {\r\n        case dr_normal:\r\n            doorpage = DOORWALL+1;\r\n            break;\r\n        case dr_lock1:\r\n        case dr_lock2:\r\n        case dr_lock3:\r\n        case dr_lock4:\r\n            doorpage = DOORWALL+7;\r\n            break;\r\n        case dr_elevator:\r\n            doorpage = DOORWALL+5;\r\n            break;\r\n    }\r\n\r\n    postsource = PM_GetTexture(doorpage) + texture;\r\n}\r\n\r\n//==========================================================================\r\n\r\n#define HitHorizBorder HitHorizWall\r\n#define HitVertBorder HitVertWall\r\n\r\n//==========================================================================\r\n\r\nbyte vgaCeiling[]=\r\n{\r\n#ifndef SPEAR\r\n 0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0xbf,\r\n 0x4e,0x4e,0x4e,0x1d,0x8d,0x4e,0x1d,0x2d,0x1d,0x8d,\r\n 0x1d,0x1d,0x1d,0x1d,0x1d,0x2d,0xdd,0x1d,0x1d,0x98,\r\n\r\n 0x1d,0x9d,0x2d,0xdd,0xdd,0x9d,0x2d,0x4d,0x1d,0xdd,\r\n 0x7d,0x1d,0x2d,0x2d,0xdd,0xd7,0x1d,0x1d,0x1d,0x2d,\r\n 0x1d,0x1d,0x1d,0x1d,0xdd,0xdd,0x7d,0xdd,0xdd,0xdd\r\n#else\r\n 0x6f,0x4f,0x1d,0xde,0xdf,0x2e,0x7f,0x9e,0xae,0x7f,\r\n 0x1d,0xde,0xdf,0xde,0xdf,0xde,0xe1,0xdc,0x2e,0x1d,0xdc\r\n#endif\r\n};\r\n\r\n/*\r\n=====================\r\n=\r\n= VGAClearScreen\r\n=\r\n=====================\r\n*/\r\n\r\nvoid VGAClearScreen (void)\r\n{\r\n    byte ceiling=vgaCeiling[gamestate.episode*10+mapon];\r\n\r\n    int y;\r\n    byte *ptr = vbuf;\r\n    \r\n    for(y = 0; y < viewheight / 2; y++, ptr += vbufPitch)\r\n        memset(ptr, ceiling, viewwidth);\r\n    \r\n    for(; y < viewheight; y++, ptr += vbufPitch)\r\n        memset(ptr, 0x19, viewwidth);\r\n    \r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= CalcRotate\r\n=\r\n=====================\r\n*/\r\n\r\nint CalcRotate (objtype *ob)\r\n{\r\n    int angle, viewangle;\r\n\r\n    // this isn't exactly correct, as it should vary by a trig value,\r\n    // but it is close enough with only eight rotations\r\n\r\n    viewangle = player->angle + (centerx - ob->viewx)/8;\r\n\r\n    if (ob->obclass == rocketobj || ob->obclass == hrocketobj)\r\n        angle = (viewangle-180) - ob->angle;\r\n    else\r\n        angle = (viewangle-180) - dirangle[ob->dir];\r\n\r\n    angle+=ANGLES/16;\r\n    while (angle>=ANGLES)\r\n        angle-=ANGLES;\r\n    while (angle<0)\r\n        angle+=ANGLES;\r\n\r\n    if (ob->state->rotate == 2)             // 2 rotation pain frame\r\n        return 0;               // pain with shooting frame bugfix\r\n\r\n    return angle/(ANGLES/8);\r\n}\r\n\r\nvoid ScaleShape (int xcenter, int shapenum, unsigned height, uint32_t flags)\r\n{\r\n    t_compshape *shape;\r\n    unsigned scale,pixheight;\r\n    unsigned starty,endy;\r\n    word *cmdptr;\r\n    byte *cline;\r\n    byte *line;\r\n    byte *vmem;\r\n    int actx,i,upperedge;\r\n    short newstart;\r\n    int scrstarty,screndy,lpix,rpix,pixcnt,ycnt;\r\n    unsigned j;\r\n    byte col;\r\n\r\n\r\n\r\n    shape = (t_compshape *) PM_GetSprite(shapenum);\r\n\r\n    scale=height>>3;                 // low three bits are fractional\r\n    if(!scale) return;   // too close or far away\r\n\r\n    pixheight=scale*SPRITESCALEFACTOR;\r\n    actx=xcenter-scale;\r\n    upperedge=viewheight/2-scale;\r\n\r\n    cmdptr=(word *) shape->dataofs;\r\n\r\n    for(i=shape->leftpix,pixcnt=i*pixheight,rpix=(pixcnt>>6)+actx;i<=shape->rightpix;i++,cmdptr++)\r\n    {\r\n        lpix=rpix;\r\n        \r\n        if(lpix>=viewwidth)\r\n            break;\r\n        \r\n        pixcnt+=pixheight;\r\n        rpix=(pixcnt>>6)+actx;\r\n        \r\n        if(lpix!=rpix && rpix>0)\r\n        {\r\n            if(lpix<0)\r\n                lpix=0;\r\n            \r\n            if(rpix>viewwidth)\r\n                rpix=viewwidth,i=shape->rightpix+1;\r\n            \r\n            cline=(byte *)shape + *cmdptr;\r\n            \r\n            while(lpix<rpix)\r\n            {\r\n                if(wallheight[lpix]<=(int)height)\r\n                {\r\n                    line=cline;\r\n                    while((endy = READWORD(line)) != 0)\r\n                    {\r\n                        endy >>= 1;\r\n                        newstart = READWORD(line);\r\n                        starty = READWORD(line) >> 1;\r\n                        j=starty;\r\n                        ycnt=j*pixheight;\r\n                        screndy=(ycnt>>6)+upperedge;\r\n                        \r\n                        if(screndy<0)\r\n                            vmem=vbuf+lpix;\r\n                        else\r\n                            vmem=vbuf+screndy*vbufPitch+lpix;\r\n                        \r\n                        for(;j<endy;j++)\r\n                        {\r\n                            scrstarty=screndy;\r\n                            ycnt+=pixheight;\r\n                            screndy=(ycnt>>6)+upperedge;\r\n                            if(scrstarty!=screndy && screndy>0)\r\n                            {\r\n                                col=((byte *)shape)[newstart+j];\r\n\r\n                                if(scrstarty<0)\r\n                                    scrstarty=0;\r\n                                \r\n                                if(screndy>viewheight)\r\n                                    screndy=viewheight,j=endy;\r\n\r\n                                while(scrstarty<screndy)\r\n                                {\r\n                                    *vmem=col;\r\n                                    vmem+=vbufPitch;\r\n                                    scrstarty++;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                lpix++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid SimpleScaleShape (int xcenter, int shapenum, unsigned height)\r\n{\r\n    t_compshape   *shape;\r\n    unsigned scale,pixheight;\r\n    unsigned starty,endy;\r\n    word *cmdptr;\r\n    byte *cline;\r\n    byte *line;\r\n    int actx,i,upperedge;\r\n    short newstart;\r\n    int scrstarty,screndy,lpix,rpix,pixcnt,ycnt;\r\n    unsigned j;\r\n    byte col;\r\n    byte *vmem;\r\n\r\n    shape = (t_compshape *) PM_GetSprite(shapenum);\r\n\r\n    scale=height>>1;\r\n    pixheight=scale*SPRITESCALEFACTOR;\r\n    actx=xcenter-scale;\r\n    upperedge=viewheight/2-scale;\r\n\r\n    cmdptr=shape->dataofs;\r\n\r\n    for(i=shape->leftpix,pixcnt=i*pixheight,rpix=(pixcnt>>6)+actx;i<=shape->rightpix;i++,cmdptr++)\r\n    {\r\n        lpix=rpix;\r\n        if(lpix>=viewwidth) break;\r\n        pixcnt+=pixheight;\r\n        rpix=(pixcnt>>6)+actx;\r\n        if(lpix!=rpix && rpix>0)\r\n        {\r\n            if(lpix<0) lpix=0;\r\n            if(rpix>viewwidth) rpix=viewwidth,i=shape->rightpix+1;\r\n            cline = (byte *)shape + *cmdptr;\r\n            while(lpix<rpix)\r\n            {\r\n                line=cline;\r\n                while((endy = READWORD(line)) != 0)\r\n                {\r\n                    endy >>= 1;\r\n                    newstart = READWORD(line);\r\n                    starty = READWORD(line) >> 1;\r\n                    j=starty;\r\n                    ycnt=j*pixheight;\r\n                    screndy=(ycnt>>6)+upperedge;\r\n                    if(screndy<0) vmem=vbuf+lpix;\r\n                    else vmem=vbuf+screndy*vbufPitch+lpix;\r\n                    for(;j<endy;j++)\r\n                    {\r\n                        scrstarty=screndy;\r\n                        ycnt+=pixheight;\r\n                        screndy=(ycnt>>6)+upperedge;\r\n                        if(scrstarty!=screndy && screndy>0)\r\n                        {\r\n                            col=((byte *)shape)[newstart+j];\r\n                            if(scrstarty<0) scrstarty=0;\r\n                            if(screndy>viewheight) screndy=viewheight,j=endy;\r\n\r\n                            while(scrstarty<screndy)\r\n                            {\r\n                                *vmem=col;\r\n                                vmem+=vbufPitch;\r\n                                scrstarty++;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                lpix++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/*\r\n=====================\r\n=\r\n= DrawScaleds\r\n=\r\n= Draws all objects that are visable\r\n=\r\n=====================\r\n*/\r\n\r\n#define MAXVISABLE 250\r\n\r\ntypedef struct\r\n{\r\n    short      viewx,\r\n               viewheight,\r\n               shapenum;\r\n    short      flags;          // this must be changed to uint32_t, when you\r\n                               // you need more than 16-flags for drawing\r\n} visobj_t;\r\n\r\nvisobj_t vislist[MAXVISABLE];\r\nvisobj_t *visptr,*visstep,*farthest;\r\n\r\nvoid DrawScaleds (void)\r\n{\r\n    int      i,least,numvisable,height;\r\n    byte     *tilespot,*visspot;\r\n    unsigned spotloc;\r\n\r\n    statobj_t *statptr;\r\n    objtype   *obj;\r\n\r\n    visptr = &vislist[0];\r\n\r\n//\r\n// place static objects\r\n//\r\n    for (statptr = &statobjlist[0] ; statptr !=laststatobj ; statptr++)\r\n    {\r\n        if ((visptr->shapenum = statptr->shapenum) == -1)\r\n            continue;                                               // object has been deleted\r\n\r\n        if (!*statptr->visspot)\r\n            continue;                                               // not visable\r\n\r\n        if (TransformTile (statptr->tilex,statptr->tiley,\r\n            &visptr->viewx,&visptr->viewheight) && statptr->flags & FL_BONUS)\r\n        {\r\n            GetBonus (statptr);\r\n            if(statptr->shapenum == -1)\r\n                continue;                                           // object has been taken\r\n        }\r\n\r\n        if (!visptr->viewheight)\r\n            continue;                                               // to close to the object\r\n\r\n        if (visptr < &vislist[MAXVISABLE-1])    // don't let it overflow\r\n        {\r\n            visptr->flags = (short) statptr->flags;\r\n            visptr++;\r\n        }\r\n    }\r\n\r\n//\r\n// place active objects\r\n//\r\n    for (obj = player->next;obj;obj=obj->next)\r\n    {\r\n        if ((visptr->shapenum = obj->state->shapenum)==0)\r\n            continue;                                               // no shape\r\n\r\n        spotloc = (obj->tilex<<mapshift)+obj->tiley;   // optimize: keep in struct?\r\n        visspot = &spotvis[0][0]+spotloc;\r\n        tilespot = &tilemap[0][0]+spotloc;\r\n\r\n        //\r\n        // could be in any of the nine surrounding tiles\r\n        //\r\n        if (*visspot\r\n            || ( *(visspot-1) && !*(tilespot-1) )\r\n            || ( *(visspot+1) && !*(tilespot+1) )\r\n            || ( *(visspot-65) && !*(tilespot-65) )\r\n            || ( *(visspot-64) && !*(tilespot-64) )\r\n            || ( *(visspot-63) && !*(tilespot-63) )\r\n            || ( *(visspot+65) && !*(tilespot+65) )\r\n            || ( *(visspot+64) && !*(tilespot+64) )\r\n            || ( *(visspot+63) && !*(tilespot+63) ) )\r\n        {\r\n            obj->active = ac_yes;\r\n            TransformActor (obj);\r\n            if (!obj->viewheight)\r\n                continue;                                               // too close or far away\r\n\r\n            visptr->viewx = obj->viewx;\r\n            visptr->viewheight = obj->viewheight;\r\n            if (visptr->shapenum == -1)\r\n                visptr->shapenum = obj->temp1;  // special shape\r\n\r\n            if (obj->state->rotate)\r\n                visptr->shapenum += CalcRotate (obj);\r\n\r\n            if (visptr < &vislist[MAXVISABLE-1])    // don't let it overflow\r\n            {\r\n                visptr->flags = (short) obj->flags;\r\n                \r\n                visptr++;\r\n            }\r\n            obj->flags |= FL_VISABLE;\r\n        }\r\n        else\r\n            obj->flags &= ~FL_VISABLE;\r\n    }\r\n\r\n//\r\n// draw from back to front\r\n//\r\n    \r\n    numvisable = (int) (visptr-&vislist[0]);\r\n\r\n    if (!numvisable)\r\n        return;                                                                 // no visable objects\r\n\r\n    for (i = 0; i<numvisable; i++)\r\n    {\r\n        least = 32000;\r\n        for (visstep=&vislist[0] ; visstep<visptr ; visstep++)\r\n        {\r\n            height = visstep->viewheight;\r\n            if (height < least)\r\n            {\r\n                least = height;\r\n                farthest = visstep;\r\n            }\r\n        }\r\n        //\r\n        // draw farthest\r\n        //\r\n        ScaleShape(farthest->viewx, farthest->shapenum, farthest->viewheight, farthest->flags);\r\n\r\n        farthest->viewheight = 32000;\r\n    }\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n==============\r\n=\r\n= DrawPlayerWeapon\r\n=\r\n= Draw the player's hands\r\n=\r\n==============\r\n*/\r\n\r\nint weaponscale[NUMWEAPONS] = {SPR_KNIFEREADY, SPR_PISTOLREADY,\r\n    SPR_MACHINEGUNREADY, SPR_CHAINREADY};\r\n\r\nvoid DrawPlayerWeapon (void)\r\n{\r\n    int shapenum;\r\n\r\n#ifndef SPEAR\r\n    if (gamestate.victoryflag)\r\n    {\r\n#ifndef APOGEE_1_0\r\n        if (player->state == &s_deathcam && (GetTimeCount()&32) )\r\n            SimpleScaleShape(viewwidth/2,SPR_DEATHCAM,viewheight+1);\r\n#endif\r\n        return;\r\n    }\r\n#endif\r\n\r\n    if (gamestate.weapon != -1)\r\n    {\r\n        shapenum = weaponscale[gamestate.weapon]+gamestate.weaponframe;\r\n        SimpleScaleShape(viewwidth/2,shapenum,viewheight+1);\r\n    }\r\n\r\n    if (demorecord || demoplayback)\r\n        SimpleScaleShape(viewwidth/2,SPR_DEMO,viewheight+1);\r\n}\r\n\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= CalcTics\r\n=\r\n=====================\r\n*/\r\n\r\nvoid CalcTics (void)\r\n{\r\n//\r\n// calculate tics since last refresh for adaptive timing\r\n//\r\n    if (lasttimecount > (int32_t) GetTimeCount())\r\n        lasttimecount = GetTimeCount();    // if the game was paused a LONG time\r\n\r\n    uint32_t curtime = SDL_GetTicks();\r\n    tics = (curtime * 7) / 100 - lasttimecount;\r\n    if(!tics)\r\n    {\r\n        // wait until end of current tic\r\n        SDL_Delay(((lasttimecount + 1) * 100) / 7 - curtime);\r\n        tics = 1;\r\n    }\r\n\r\n    lasttimecount += tics;\r\n\r\n    if (tics>MAXTICS)\r\n        tics = MAXTICS;\r\n}\r\n\r\n\r\n//==========================================================================\r\n\r\nvoid AsmRefresh()\r\n{\r\n    int32_t xstep,ystep;\r\n    longword xpartial,ypartial;\r\n    boolean playerInPushwallBackTile = tilemap[focaltx][focalty] == 64;\r\n\r\n    for(pixx=0;pixx<viewwidth;pixx++)\r\n    {\r\n        short angl=midangle+pixelangle[pixx];\r\n        if(angl<0) angl+=FINEANGLES;\r\n        if(angl>=3600) angl-=FINEANGLES;\r\n        if(angl<900)\r\n        {\r\n            xtilestep=1;\r\n            ytilestep=-1;\r\n            xstep=finetangent[900-1-angl];\r\n            ystep=-finetangent[angl];\r\n            xpartial=xpartialup;\r\n            ypartial=ypartialdown;\r\n        }\r\n        else if(angl<1800)\r\n        {\r\n            xtilestep=-1;\r\n            ytilestep=-1;\r\n            xstep=-finetangent[angl-900];\r\n            ystep=-finetangent[1800-1-angl];\r\n            xpartial=xpartialdown;\r\n            ypartial=ypartialdown;\r\n        }\r\n        else if(angl<2700)\r\n        {\r\n            xtilestep=-1;\r\n            ytilestep=1;\r\n            xstep=-finetangent[2700-1-angl];\r\n            ystep=finetangent[angl-1800];\r\n            xpartial=xpartialdown;\r\n            ypartial=ypartialup;\r\n        }\r\n        else if(angl<3600)\r\n        {\r\n            xtilestep=1;\r\n            ytilestep=1;\r\n            xstep=finetangent[angl-2700];\r\n            ystep=finetangent[3600-1-angl];\r\n            xpartial=xpartialup;\r\n            ypartial=ypartialup;\r\n        }\r\n        yintercept=FixedMul(ystep,xpartial)+viewy;\r\n        xtile=focaltx+xtilestep;\r\n        xspot=(word)((xtile<<mapshift)+((uint32_t)yintercept>>16));\r\n        xintercept=FixedMul(xstep,ypartial)+viewx;\r\n        ytile=focalty+ytilestep;\r\n        yspot=(word)((((uint32_t)xintercept>>16)<<mapshift)+ytile);\r\n        texdelta=0;\r\n\r\n        // Special treatment when player is in back tile of pushwall\r\n        if(playerInPushwallBackTile)\r\n        {\r\n            if(    pwalldir == di_east && xtilestep ==  1\r\n                || pwalldir == di_west && xtilestep == -1)\r\n            {\r\n                int32_t yintbuf = yintercept - ((ystep * (64 - pwallpos)) >> 6);\r\n                if((yintbuf >> 16) == focalty)   // ray hits pushwall back?\r\n                {\r\n                    if(pwalldir == di_east)\r\n                        xintercept = (focaltx << TILESHIFT) + (pwallpos << 10);\r\n                    else\r\n                        xintercept = (focaltx << TILESHIFT) - TILEGLOBAL + ((64 - pwallpos) << 10);\r\n                    yintercept = yintbuf;\r\n                    ytile = (short) (yintercept >> TILESHIFT);\r\n                    tilehit = pwalltile;\r\n                    HitVertWall();\r\n                    continue;\r\n                }\r\n            }\r\n            else if(pwalldir == di_south && ytilestep ==  1\r\n                ||  pwalldir == di_north && ytilestep == -1)\r\n            {\r\n                int32_t xintbuf = xintercept - ((xstep * (64 - pwallpos)) >> 6);\r\n                if((xintbuf >> 16) == focaltx)   // ray hits pushwall back?\r\n                {\r\n                    xintercept = xintbuf;\r\n                    if(pwalldir == di_south)\r\n                        yintercept = (focalty << TILESHIFT) + (pwallpos << 10);\r\n                    else\r\n                        yintercept = (focalty << TILESHIFT) - TILEGLOBAL + ((64 - pwallpos) << 10);\r\n                    xtile = (short) (xintercept >> TILESHIFT);\r\n                    tilehit = pwalltile;\r\n                    HitHorizWall();\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        do\r\n        {\r\n            if(ytilestep==-1 && (yintercept>>16)<=ytile) goto horizentry;\r\n            if(ytilestep==1 && (yintercept>>16)>=ytile) goto horizentry;\r\nvertentry:\r\n            if((uint32_t)yintercept>mapheight*65536-1 || (word)xtile>=mapwidth)\r\n            {\r\n                if(xtile<0) xintercept=0, xtile=0;\r\n                else if(xtile>=mapwidth) xintercept=mapwidth<<TILESHIFT, xtile=mapwidth-1;\r\n                else xtile=(short) (xintercept >> TILESHIFT);\r\n                if(yintercept<0) yintercept=0, ytile=0;\r\n                else if(yintercept>=(mapheight<<TILESHIFT)) yintercept=mapheight<<TILESHIFT, ytile=mapheight-1;\r\n                yspot=0xffff;\r\n                tilehit=0;\r\n                HitHorizBorder();\r\n                break;\r\n            }\r\n            if(xspot>=maparea) break;\r\n            tilehit=((byte *)tilemap)[xspot];\r\n            if(tilehit)\r\n            {\r\n                if(tilehit&0x80)\r\n                {\r\n                    int32_t yintbuf=yintercept+(ystep>>1);\r\n                    if((yintbuf>>16)!=(yintercept>>16))\r\n                        goto passvert;\r\n                    if((word)yintbuf<doorposition[tilehit&0x7f])\r\n                        goto passvert;\r\n                    yintercept=yintbuf;\r\n                    xintercept=(xtile<<TILESHIFT)|0x8000;\r\n                    ytile = (short) (yintercept >> TILESHIFT);\r\n                    HitVertDoor();\r\n                }\r\n                else\r\n                {\r\n                    if(tilehit==64)\r\n                    {\r\n                        if(pwalldir==di_west || pwalldir==di_east)\r\n                        {\r\n                            int32_t yintbuf;\r\n                            int pwallposnorm;\r\n                            int pwallposinv;\r\n                            if(pwalldir==di_west)\r\n                            {\r\n                                pwallposnorm = 64-pwallpos;\r\n                                pwallposinv = pwallpos;\r\n                            }\r\n                            else\r\n                            {\r\n                                pwallposnorm = pwallpos;\r\n                                pwallposinv = 64-pwallpos;\r\n                            }\r\n                            if(pwalldir == di_east && xtile==pwallx && ((uint32_t)yintercept>>16)==pwally\r\n                                || pwalldir == di_west && !(xtile==pwallx && ((uint32_t)yintercept>>16)==pwally))\r\n                            {\r\n                                yintbuf=yintercept+((ystep*pwallposnorm)>>6);\r\n                                if((yintbuf>>16)!=(yintercept>>16))\r\n                                    goto passvert;\r\n\r\n                                xintercept=(xtile<<TILESHIFT)+TILEGLOBAL-(pwallposinv<<10);\r\n                                yintercept=yintbuf;\r\n                                ytile = (short) (yintercept >> TILESHIFT);\r\n                                tilehit=pwalltile;\r\n                                HitVertWall();\r\n                            }\r\n                            else\r\n                            {\r\n                                yintbuf=yintercept+((ystep*pwallposinv)>>6);\r\n                                if((yintbuf>>16)!=(yintercept>>16))\r\n                                    goto passvert;\r\n\r\n                                xintercept=(xtile<<TILESHIFT)-(pwallposinv<<10);\r\n                                yintercept=yintbuf;\r\n                                ytile = (short) (yintercept >> TILESHIFT);\r\n                                tilehit=pwalltile;\r\n                                HitVertWall();\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            int pwallposi = pwallpos;\r\n                            if(pwalldir==di_north) pwallposi = 64-pwallpos;\r\n                            if(pwalldir==di_south && (word)yintercept<(pwallposi<<10)\r\n                                || pwalldir==di_north && (word)yintercept>(pwallposi<<10))\r\n                            {\r\n                                if(((uint32_t)yintercept>>16)==pwally && xtile==pwallx)\r\n                                {\r\n                                    if(pwalldir==di_south && (int32_t)((word)yintercept)+ystep<(pwallposi<<10)\r\n                                            || pwalldir==di_north && (int32_t)((word)yintercept)+ystep>(pwallposi<<10))\r\n                                        goto passvert;\r\n\r\n                                    if(pwalldir==di_south)\r\n                                        yintercept=(yintercept&0xffff0000)+(pwallposi<<10);\r\n                                    else\r\n                                        yintercept=(yintercept&0xffff0000)-TILEGLOBAL+(pwallposi<<10);\r\n                                    xintercept=xintercept-((xstep*(64-pwallpos))>>6);\r\n                                    xtile = (short) (xintercept >> TILESHIFT);\r\n                                    tilehit=pwalltile;\r\n                                    HitHorizWall();\r\n                                }\r\n                                else\r\n                                {\r\n                                    texdelta = -(pwallposi<<10);\r\n                                    xintercept=xtile<<TILESHIFT;\r\n                                    ytile = (short) (yintercept >> TILESHIFT);\r\n                                    tilehit=pwalltile;\r\n                                    HitVertWall();\r\n                                }\r\n                            }\r\n                            else\r\n                            {\r\n                                if(((uint32_t)yintercept>>16)==pwally && xtile==pwallx)\r\n                                {\r\n                                    texdelta = -(pwallposi<<10);\r\n                                    xintercept=xtile<<TILESHIFT;\r\n                                    ytile = (short) (yintercept >> TILESHIFT);\r\n                                    tilehit=pwalltile;\r\n                                    HitVertWall();\r\n                                }\r\n                                else\r\n                                {\r\n                                    if(pwalldir==di_south && (int32_t)((word)yintercept)+ystep>(pwallposi<<10)\r\n                                            || pwalldir==di_north && (int32_t)((word)yintercept)+ystep<(pwallposi<<10))\r\n                                        goto passvert;\r\n\r\n                                    if(pwalldir==di_south)\r\n                                        yintercept=(yintercept&0xffff0000)-((64-pwallpos)<<10);\r\n                                    else\r\n                                        yintercept=(yintercept&0xffff0000)+((64-pwallpos)<<10);\r\n                                    xintercept=xintercept-((xstep*pwallpos)>>6);\r\n                                    xtile = (short) (xintercept >> TILESHIFT);\r\n                                    tilehit=pwalltile;\r\n                                    HitHorizWall();\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        xintercept=xtile<<TILESHIFT;\r\n                        ytile = (short) (yintercept >> TILESHIFT);\r\n                        HitVertWall();\r\n                    }\r\n                }\r\n                break;\r\n            }\r\npassvert:\r\n            *((byte *)spotvis+xspot)=1;\r\n            xtile+=xtilestep;\r\n            yintercept+=ystep;\r\n            xspot=(word)((xtile<<mapshift)+((uint32_t)yintercept>>16));\r\n        }\r\n        while(1);\r\n        continue;\r\n\r\n        do\r\n        {\r\n            if(xtilestep==-1 && (xintercept>>16)<=xtile) goto vertentry;\r\n            if(xtilestep==1 && (xintercept>>16)>=xtile) goto vertentry;\r\nhorizentry:\r\n            if((uint32_t)xintercept>mapwidth*65536-1 || (word)ytile>=mapheight)\r\n            {\r\n                if(ytile<0) yintercept=0, ytile=0;\r\n                else if(ytile>=mapheight) yintercept=mapheight<<TILESHIFT, ytile=mapheight-1;\r\n                else ytile=(short) (yintercept >> TILESHIFT);\r\n                if(xintercept<0) xintercept=0, xtile=0;\r\n                else if(xintercept>=(mapwidth<<TILESHIFT)) xintercept=mapwidth<<TILESHIFT, xtile=mapwidth-1;\r\n                xspot=0xffff;\r\n                tilehit=0;\r\n                HitVertBorder();\r\n                break;\r\n            }\r\n            if(yspot>=maparea) break;\r\n            tilehit=((byte *)tilemap)[yspot];\r\n            if(tilehit)\r\n            {\r\n                if(tilehit&0x80)\r\n                {\r\n                    int32_t xintbuf=xintercept+(xstep>>1);\r\n                    if((xintbuf>>16)!=(xintercept>>16))\r\n                        goto passhoriz;\r\n                    if((word)xintbuf<doorposition[tilehit&0x7f])\r\n                        goto passhoriz;\r\n                    xintercept=xintbuf;\r\n                    yintercept=(ytile<<TILESHIFT)+0x8000;\r\n                    xtile = (short) (xintercept >> TILESHIFT);\r\n                    HitHorizDoor();\r\n                }\r\n                else\r\n                {\r\n                    if(tilehit==64)\r\n                    {\r\n                        if(pwalldir==di_north || pwalldir==di_south)\r\n                        {\r\n                            int32_t xintbuf;\r\n                            int pwallposnorm;\r\n                            int pwallposinv;\r\n                            if(pwalldir==di_north)\r\n                            {\r\n                                pwallposnorm = 64-pwallpos;\r\n                                pwallposinv = pwallpos;\r\n                            }\r\n                            else\r\n                            {\r\n                                pwallposnorm = pwallpos;\r\n                                pwallposinv = 64-pwallpos;\r\n                            }\r\n                            if(pwalldir == di_south && ytile==pwally && ((uint32_t)xintercept>>16)==pwallx\r\n                                || pwalldir == di_north && !(ytile==pwally && ((uint32_t)xintercept>>16)==pwallx))\r\n                            {\r\n                                xintbuf=xintercept+((xstep*pwallposnorm)>>6);\r\n                                if((xintbuf>>16)!=(xintercept>>16))\r\n                                    goto passhoriz;\r\n\r\n                                yintercept=(ytile<<TILESHIFT)+TILEGLOBAL-(pwallposinv<<10);\r\n                                xintercept=xintbuf;\r\n                                xtile = (short) (xintercept >> TILESHIFT);\r\n                                tilehit=pwalltile;\r\n                                HitHorizWall();\r\n                            }\r\n                            else\r\n                            {\r\n                                xintbuf=xintercept+((xstep*pwallposinv)>>6);\r\n                                if((xintbuf>>16)!=(xintercept>>16))\r\n                                    goto passhoriz;\r\n\r\n                                yintercept=(ytile<<TILESHIFT)-(pwallposinv<<10);\r\n                                xintercept=xintbuf;\r\n                                xtile = (short) (xintercept >> TILESHIFT);\r\n                                tilehit=pwalltile;\r\n                                HitHorizWall();\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            int pwallposi = pwallpos;\r\n                            if(pwalldir==di_west) pwallposi = 64-pwallpos;\r\n                            if(pwalldir==di_east && (word)xintercept<(pwallposi<<10)\r\n                                    || pwalldir==di_west && (word)xintercept>(pwallposi<<10))\r\n                            {\r\n                                if(((uint32_t)xintercept>>16)==pwallx && ytile==pwally)\r\n                                {\r\n                                    if(pwalldir==di_east && (int32_t)((word)xintercept)+xstep<(pwallposi<<10)\r\n                                            || pwalldir==di_west && (int32_t)((word)xintercept)+xstep>(pwallposi<<10))\r\n                                        goto passhoriz;\r\n\r\n                                    if(pwalldir==di_east)\r\n                                        xintercept=(xintercept&0xffff0000)+(pwallposi<<10);\r\n                                    else\r\n                                        xintercept=(xintercept&0xffff0000)-TILEGLOBAL+(pwallposi<<10);\r\n                                    yintercept=yintercept-((ystep*(64-pwallpos))>>6);\r\n                                    ytile = (short) (yintercept >> TILESHIFT);\r\n                                    tilehit=pwalltile;\r\n                                    HitVertWall();\r\n                                }\r\n                                else\r\n                                {\r\n                                    texdelta = -(pwallposi<<10);\r\n                                    yintercept=ytile<<TILESHIFT;\r\n                                    xtile = (short) (xintercept >> TILESHIFT);\r\n                                    tilehit=pwalltile;\r\n                                    HitHorizWall();\r\n                                }\r\n                            }\r\n                            else\r\n                            {\r\n                                if(((uint32_t)xintercept>>16)==pwallx && ytile==pwally)\r\n                                {\r\n                                    texdelta = -(pwallposi<<10);\r\n                                    yintercept=ytile<<TILESHIFT;\r\n                                    xtile = (short) (xintercept >> TILESHIFT);\r\n                                    tilehit=pwalltile;\r\n                                    HitHorizWall();\r\n                                }\r\n                                else\r\n                                {\r\n                                    if(pwalldir==di_east && (int32_t)((word)xintercept)+xstep>(pwallposi<<10)\r\n                                            || pwalldir==di_west && (int32_t)((word)xintercept)+xstep<(pwallposi<<10))\r\n                                        goto passhoriz;\r\n\r\n                                    if(pwalldir==di_east)\r\n                                        xintercept=(xintercept&0xffff0000)-((64-pwallpos)<<10);\r\n                                    else\r\n                                        xintercept=(xintercept&0xffff0000)+((64-pwallpos)<<10);\r\n                                    yintercept=yintercept-((ystep*pwallpos)>>6);\r\n                                    ytile = (short) (yintercept >> TILESHIFT);\r\n                                    tilehit=pwalltile;\r\n                                    HitVertWall();\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        yintercept=ytile<<TILESHIFT;\r\n                        xtile = (short) (xintercept >> TILESHIFT);\r\n                        HitHorizWall();\r\n                    }\r\n                }\r\n                break;\r\n            }\r\npasshoriz:\r\n            *((byte *)spotvis+yspot)=1;\r\n            ytile+=ytilestep;\r\n            xintercept+=xstep;\r\n            yspot=(word)((((uint32_t)xintercept>>16)<<mapshift)+ytile);\r\n        }\r\n        while(1);\r\n    }\r\n}\r\n\r\n/*\r\n====================\r\n=\r\n= WallRefresh\r\n=\r\n====================\r\n*/\r\n\r\nvoid WallRefresh (void)\r\n{\r\n    xpartialdown = viewx&(TILEGLOBAL-1);\r\n    xpartialup = TILEGLOBAL-xpartialdown;\r\n    ypartialdown = viewy&(TILEGLOBAL-1);\r\n    ypartialup = TILEGLOBAL-ypartialdown;\r\n\r\n    min_wallheight = viewheight;\r\n    lastside = -1;                  // the first pixel is on a new wall\r\n    AsmRefresh ();\r\n    ScalePost ();                   // no more optimization on last post\r\n}\r\n\r\nvoid CalcViewVariables()\r\n{\r\n    viewangle = player->angle;\r\n    //printf(\"\\nvieangle=%d\\n\",viewangle);\r\n    midangle = viewangle*(FINEANGLES/ANGLES);\r\n    viewsin = sintable[viewangle];\r\n    viewcos = costable[viewangle];\r\n    //printf(\"%d\\n\",viewcos);\r\n    viewx = player->x - FixedMul(focallength,viewcos);\r\n    viewy = player->y + FixedMul(focallength,viewsin);\r\n\r\n    focaltx = (short)(viewx>>TILESHIFT);\r\n    focalty = (short)(viewy>>TILESHIFT);\r\n\r\n    viewtx = (short)(player->x >> TILESHIFT);\r\n    viewty = (short)(player->y >> TILESHIFT);\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n========================\r\n=\r\n= ThreeDRefresh\r\n=\r\n========================\r\n*/\r\n\r\nvoid    ThreeDRefresh (void)\r\n{\r\n    // printf(\"ThreeDRefresh\\n\");\r\n//\r\n// clear out the traced array\r\n//\r\n    memset(spotvis,0,maparea);\r\n    spotvis[player->tilex][player->tiley] = 1;       // Detect all sprites over player fix\r\n\r\n    vbuf = VL_LockSurface(screenBuffer);\r\n    vbuf+=screenofs;\r\n    vbufPitch = bufferPitch;\r\n\r\n    CalcViewVariables();\r\n\r\n//\r\n// follow the walls from there to the right, drawing as we go\r\n//\r\n    VGAClearScreen ();\r\n\r\n    WallRefresh ();\r\n\r\n    \r\n\r\n//\r\n// draw all the scaled images\r\n//\r\n    \r\n    DrawScaleds();                  // draw scaled stuff\r\n\r\n\r\n    DrawPlayerWeapon ();    // draw player's hands\r\n\r\n    if(Keyboard[sc_Tab] && viewsize == 21 && gamestate.weapon != -1)\r\n        ShowActStatus();\r\n\r\n    VL_UnlockSurface(screenBuffer);\r\n    vbuf = NULL;\r\n\r\n//\r\n// show screen and time last cycle\r\n//\r\n\r\n    if (fizzlein)\r\n    {\r\n        FizzleFade(screenBuffer, 0, 0, screenWidth, screenHeight, 20, false);\r\n        fizzlein = false;\r\n\r\n        lasttimecount = GetTimeCount();          // don't make a big tic count\r\n    }\r\n    else\r\n    {\r\n#ifndef REMDEBUG\r\n        if (fpscounter)\r\n        {\r\n            fontnumber = 0;\r\n            SETFONTCOLOR(7,127);\r\n            PrintX=4; PrintY=1;\r\n            VWB_Bar(0,0,50,10,bordercol);\r\n            US_PrintSigned(fps);\r\n            US_Print(\" fps\");\r\n        }\r\n#endif\r\n        \r\n#ifdef __EMSCRIPTEN__\r\n        Em_BlitToScreen();\r\n#else\r\n        SDL_BlitSurface(screenBuffer, NULL, screen, NULL);\r\n#endif  \r\n        SDL_Flip(screen);\r\n    }\r\n\r\n#ifndef REMDEBUG\r\n    if (fpscounter)\r\n    {\r\n        fps_frames++;\r\n        fps_time+=tics;\r\n\r\n        if(fps_time>35)\r\n        {\r\n            fps_time-=35;\r\n            fps=fps_frames<<1;\r\n            fps_frames=0;\r\n        }\r\n    }\r\n#endif\r\n}\r\n","// WL_GAME.C\r\n\r\n#include <math.h>\r\n#include \"wl_def.h\"\r\n// Win32\r\n#ifdef _WIN32\r\n#include \"SDL_mixer.h\"\r\n#elif __linux__\r\n#include <SDL/SDL_mixer.h>\r\n#else\r\n#include <SDL/SDL_mixer.h>\r\n#endif\r\n\r\n#ifdef __EMSCRIPTEN__\r\n#include <emscripten.h>\r\n#endif\r\n\r\n#include \"web.h\"\r\n\r\n#pragma hdrstop\r\n\r\n#ifdef MYPROFILE\r\n#include <TIME.H>\r\n#endif\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                             LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                             GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nboolean         ingame,fizzlein;\r\ngametype        gamestate;\r\nbyte            bordercol=VIEWCOLOR;        // color of the Change View/Ingame border\r\n\r\n#ifdef SPEAR\r\nint32_t         spearx,speary;\r\nunsigned        spearangle;\r\nboolean         spearflag;\r\n#endif\r\n\r\n\r\n//\r\n// ELEVATOR BACK MAPS - REMEMBER (-1)!!\r\n//\r\nint ElevatorBackTo[]={1,1,7,3,5,3};\r\n\r\nvoid SetupGameLevel (void);\r\nvoid DrawPlayScreen (void);\r\nvoid LoadLatchMem (void);\r\nvoid GameLoop (int);\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                             LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n\r\n//===========================================================================\r\n//===========================================================================\r\n\r\n\r\n/*\r\n==========================\r\n=\r\n= SetSoundLoc - Given the location of an object (in terms of global\r\n=       coordinates, held in globalsoundx and globalsoundy), munges the values\r\n=       for an approximate distance from the left and right ear, and puts\r\n=       those values into leftchannel and rightchannel.\r\n=\r\n= JAB\r\n=\r\n==========================\r\n*/\r\n\r\nint leftchannel, rightchannel;\r\n#define ATABLEMAX 15\r\nbyte righttable[ATABLEMAX][ATABLEMAX * 2] = {\r\n{ 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 6, 0, 0, 0, 0, 0, 1, 3, 5, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 6, 4, 0, 0, 0, 0, 0, 2, 4, 6, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 6, 6, 4, 1, 0, 0, 0, 1, 2, 4, 6, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 6, 5, 4, 2, 1, 0, 1, 2, 3, 5, 7, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 6, 5, 4, 3, 2, 2, 3, 3, 5, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 6, 6, 5, 4, 4, 4, 4, 5, 6, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 6, 6, 5, 5, 5, 6, 6, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}\r\n};\r\nbyte lefttable[ATABLEMAX][ATABLEMAX * 2] = {\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 5, 3, 1, 0, 0, 0, 0, 0, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 6, 4, 2, 0, 0, 0, 0, 0, 4, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 6, 4, 2, 1, 0, 0, 0, 1, 4, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 7, 5, 3, 2, 1, 0, 1, 2, 4, 5, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 6, 5, 3, 3, 2, 2, 3, 4, 5, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 6, 5, 4, 4, 4, 4, 5, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 6, 6, 5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},\r\n{ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8}\r\n};\r\n\r\nvoid\r\nSetSoundLoc(fixed gx,fixed gy)\r\n{\r\n    fixed   xt,yt;\r\n    int     x,y;\r\n\r\n//\r\n// translate point to view centered coordinates\r\n//\r\n    gx -= viewx;\r\n    gy -= viewy;\r\n\r\n//\r\n// calculate newx\r\n//\r\n    xt = FixedMul(gx,viewcos);\r\n    yt = FixedMul(gy,viewsin);\r\n    x = (xt - yt) >> TILESHIFT;\r\n\r\n//\r\n// calculate newy\r\n//\r\n    xt = FixedMul(gx,viewsin);\r\n    yt = FixedMul(gy,viewcos);\r\n    y = (yt + xt) >> TILESHIFT;\r\n\r\n    if (y >= ATABLEMAX)\r\n        y = ATABLEMAX - 1;\r\n    else if (y <= -ATABLEMAX)\r\n        y = -ATABLEMAX;\r\n    if (x < 0)\r\n        x = -x;\r\n    if (x >= ATABLEMAX)\r\n        x = ATABLEMAX - 1;\r\n    leftchannel  =  lefttable[x][y + ATABLEMAX];\r\n    rightchannel = righttable[x][y + ATABLEMAX];\r\n\r\n}\r\n\r\n/*\r\n==========================\r\n=\r\n= SetSoundLocGlobal - Sets up globalsoundx & globalsoundy and then calls\r\n=       UpdateSoundLoc() to transform that into relative channel volumes. Those\r\n=       values are then passed to the Sound Manager so that they'll be used for\r\n=       the next sound played (if possible).\r\n=\r\n= JAB\r\n=\r\n==========================\r\n*/\r\nvoid PlaySoundLocGlobal(word s,fixed gx,fixed gy)\r\n{\r\n    SetSoundLoc(gx, gy);\r\n    SD_PositionSound(leftchannel, rightchannel);\r\n\r\n    int channel = SD_PlaySound((soundnames) s);\r\n    if(channel)\r\n    {\r\n        channelSoundPos[channel - 1].globalsoundx = gx;\r\n        channelSoundPos[channel - 1].globalsoundy = gy;\r\n        channelSoundPos[channel - 1].valid = 1;\r\n    }\r\n}\r\n\r\nvoid UpdateSoundLoc(void)\r\n{\r\n/*    if (SoundPositioned)\r\n    {\r\n        SetSoundLoc(globalsoundx,globalsoundy);\r\n        SD_SetPosition(leftchannel,rightchannel);\r\n    }*/\r\n\r\n    for(int i = 0; i < MIX_CHANNELS; i++)\r\n    {\r\n        if(channelSoundPos[i].valid)\r\n        {\r\n            SetSoundLoc(channelSoundPos[i].globalsoundx,\r\n                channelSoundPos[i].globalsoundy);\r\n            SD_SetPosition(i, leftchannel, rightchannel);\r\n        }\r\n    }\r\n}\r\n\r\n/*\r\n**      JAB End\r\n*/\r\n\r\n/*\r\n==========================\r\n=\r\n= ScanInfoPlane\r\n=\r\n= Spawn all actors and mark down special places\r\n=\r\n==========================\r\n*/\r\n\r\nstatic void ScanInfoPlane(void)\r\n{\r\n    unsigned x,y;\r\n    int      tile;\r\n    word     *start;\r\n\r\n    start = mapsegs[1];\r\n    for (y=0;y<mapheight;y++)\r\n    {\r\n        for (x=0;x<mapwidth;x++)\r\n        {\r\n            tile = *start++;\r\n            if (!tile)\r\n                continue;\r\n\r\n            switch (tile)\r\n            {\r\n                case 19:\r\n                case 20:\r\n                case 21:\r\n                case 22:\r\n                    SpawnPlayer(x,y,NORTH+tile-19);\r\n                    break;\r\n\r\n                case 23:\r\n                case 24:\r\n                case 25:\r\n                case 26:\r\n                case 27:\r\n                case 28:\r\n                case 29:\r\n                case 30:\r\n\r\n                case 31:\r\n                case 32:\r\n                case 33:\r\n                case 34:\r\n                case 35:\r\n                case 36:\r\n                case 37:\r\n                case 38:\r\n\r\n                case 39:\r\n                case 40:\r\n                case 41:\r\n                case 42:\r\n                case 43:\r\n                case 44:\r\n                case 45:\r\n                case 46:\r\n\r\n                case 47:\r\n                case 48:\r\n                case 49:\r\n                case 50:\r\n                case 51:\r\n                case 52:\r\n                case 53:\r\n                case 54:\r\n\r\n                case 55:\r\n                case 56:\r\n                case 57:\r\n                case 58:\r\n                case 59:\r\n                case 60:\r\n                case 61:\r\n                case 62:\r\n\r\n                case 63:\r\n                case 64:\r\n                case 65:\r\n                case 66:\r\n                case 67:\r\n                case 68:\r\n                case 69:\r\n                case 70:\r\n                case 71:\r\n                case 72:\r\n#ifdef SPEAR\r\n                case 73:                        // TRUCK AND SPEAR!\r\n                case 74:\r\n#endif\r\n                    SpawnStatic(x,y,tile-23);\r\n                    break;\r\n\r\n//\r\n// P wall\r\n//\r\n                case 98:\r\n                    if (!loadedgame)\r\n                        gamestate.secrettotal++;\r\n                    break;\r\n\r\n//\r\n// guard\r\n//\r\n                case 180:\r\n                case 181:\r\n                case 182:\r\n                case 183:\r\n                    if (gamestate.difficulty<gd_hard)\r\n                        break;\r\n                    tile -= 36;\r\n                case 144:\r\n                case 145:\r\n                case 146:\r\n                case 147:\r\n                    if (gamestate.difficulty<gd_medium)\r\n                        break;\r\n                    tile -= 36;\r\n                case 108:\r\n                case 109:\r\n                case 110:\r\n                case 111:\r\n                    SpawnStand(en_guard,x,y,tile-108);\r\n                    break;\r\n\r\n\r\n                case 184:\r\n                case 185:\r\n                case 186:\r\n                case 187:\r\n                    if (gamestate.difficulty<gd_hard)\r\n                        break;\r\n                    tile -= 36;\r\n                case 148:\r\n                case 149:\r\n                case 150:\r\n                case 151:\r\n                    if (gamestate.difficulty<gd_medium)\r\n                        break;\r\n                    tile -= 36;\r\n                case 112:\r\n                case 113:\r\n                case 114:\r\n                case 115:\r\n                    SpawnPatrol(en_guard,x,y,tile-112);\r\n                    break;\r\n\r\n                case 124:\r\n                    SpawnDeadGuard (x,y);\r\n                    break;\r\n//\r\n// officer\r\n//\r\n                case 188:\r\n                case 189:\r\n                case 190:\r\n                case 191:\r\n                    if (gamestate.difficulty<gd_hard)\r\n                        break;\r\n                    tile -= 36;\r\n                case 152:\r\n                case 153:\r\n                case 154:\r\n                case 155:\r\n                    if (gamestate.difficulty<gd_medium)\r\n                        break;\r\n                    tile -= 36;\r\n                case 116:\r\n                case 117:\r\n                case 118:\r\n                case 119:\r\n                    SpawnStand(en_officer,x,y,tile-116);\r\n                    break;\r\n\r\n\r\n                case 192:\r\n                case 193:\r\n                case 194:\r\n                case 195:\r\n                    if (gamestate.difficulty<gd_hard)\r\n                        break;\r\n                    tile -= 36;\r\n                case 156:\r\n                case 157:\r\n                case 158:\r\n                case 159:\r\n                    if (gamestate.difficulty<gd_medium)\r\n                        break;\r\n                    tile -= 36;\r\n                case 120:\r\n                case 121:\r\n                case 122:\r\n                case 123:\r\n                    SpawnPatrol(en_officer,x,y,tile-120);\r\n                    break;\r\n\r\n\r\n//\r\n// ss\r\n//\r\n                case 198:\r\n                case 199:\r\n                case 200:\r\n                case 201:\r\n                    if (gamestate.difficulty<gd_hard)\r\n                        break;\r\n                    tile -= 36;\r\n                case 162:\r\n                case 163:\r\n                case 164:\r\n                case 165:\r\n                    if (gamestate.difficulty<gd_medium)\r\n                        break;\r\n                    tile -= 36;\r\n                case 126:\r\n                case 127:\r\n                case 128:\r\n                case 129:\r\n                    SpawnStand(en_ss,x,y,tile-126);\r\n                    break;\r\n\r\n\r\n                case 202:\r\n                case 203:\r\n                case 204:\r\n                case 205:\r\n                    if (gamestate.difficulty<gd_hard)\r\n                        break;\r\n                    tile -= 36;\r\n                case 166:\r\n                case 167:\r\n                case 168:\r\n                case 169:\r\n                    if (gamestate.difficulty<gd_medium)\r\n                        break;\r\n                    tile -= 36;\r\n                case 130:\r\n                case 131:\r\n                case 132:\r\n                case 133:\r\n                    SpawnPatrol(en_ss,x,y,tile-130);\r\n                    break;\r\n\r\n//\r\n// dogs\r\n//\r\n                case 206:\r\n                case 207:\r\n                case 208:\r\n                case 209:\r\n                    if (gamestate.difficulty<gd_hard)\r\n                        break;\r\n                    tile -= 36;\r\n                case 170:\r\n                case 171:\r\n                case 172:\r\n                case 173:\r\n                    if (gamestate.difficulty<gd_medium)\r\n                        break;\r\n                    tile -= 36;\r\n                case 134:\r\n                case 135:\r\n                case 136:\r\n                case 137:\r\n                    SpawnStand(en_dog,x,y,tile-134);\r\n                    break;\r\n\r\n\r\n                case 210:\r\n                case 211:\r\n                case 212:\r\n                case 213:\r\n                    if (gamestate.difficulty<gd_hard)\r\n                        break;\r\n                    tile -= 36;\r\n                case 174:\r\n                case 175:\r\n                case 176:\r\n                case 177:\r\n                    if (gamestate.difficulty<gd_medium)\r\n                        break;\r\n                    tile -= 36;\r\n                case 138:\r\n                case 139:\r\n                case 140:\r\n                case 141:\r\n                    SpawnPatrol(en_dog,x,y,tile-138);\r\n                    break;\r\n\r\n//\r\n// boss\r\n//\r\n#ifndef SPEAR\r\n                case 214:\r\n                    SpawnBoss (x,y);\r\n                    break;\r\n                case 197:\r\n                    SpawnGretel (x,y);\r\n                    break;\r\n                case 215:\r\n                    SpawnGift (x,y);\r\n                    break;\r\n                case 179:\r\n                    SpawnFat (x,y);\r\n                    break;\r\n                case 196:\r\n                    SpawnSchabbs (x,y);\r\n                    break;\r\n                case 160:\r\n                    SpawnFakeHitler (x,y);\r\n                    break;\r\n                case 178:\r\n                    SpawnHitler (x,y);\r\n                    break;\r\n#else\r\n                case 106:\r\n                    SpawnSpectre (x,y);\r\n                    break;\r\n                case 107:\r\n                    SpawnAngel (x,y);\r\n                    break;\r\n                case 125:\r\n                    SpawnTrans (x,y);\r\n                    break;\r\n                case 142:\r\n                    SpawnUber (x,y);\r\n                    break;\r\n                case 143:\r\n                    SpawnWill (x,y);\r\n                    break;\r\n                case 161:\r\n                    SpawnDeath (x,y);\r\n                    break;\r\n\r\n#endif\r\n\r\n//\r\n// mutants\r\n//\r\n                case 252:\r\n                case 253:\r\n                case 254:\r\n                case 255:\r\n                    if (gamestate.difficulty<gd_hard)\r\n                        break;\r\n                    tile -= 18;\r\n                case 234:\r\n                case 235:\r\n                case 236:\r\n                case 237:\r\n                    if (gamestate.difficulty<gd_medium)\r\n                        break;\r\n                    tile -= 18;\r\n                case 216:\r\n                case 217:\r\n                case 218:\r\n                case 219:\r\n                    SpawnStand(en_mutant,x,y,tile-216);\r\n                    break;\r\n\r\n                case 256:\r\n                case 257:\r\n                case 258:\r\n                case 259:\r\n                    if (gamestate.difficulty<gd_hard)\r\n                        break;\r\n                    tile -= 18;\r\n                case 238:\r\n                case 239:\r\n                case 240:\r\n                case 241:\r\n                    if (gamestate.difficulty<gd_medium)\r\n                        break;\r\n                    tile -= 18;\r\n                case 220:\r\n                case 221:\r\n                case 222:\r\n                case 223:\r\n                    SpawnPatrol(en_mutant,x,y,tile-220);\r\n                    break;\r\n\r\n//\r\n// ghosts\r\n//\r\n#ifndef SPEAR\r\n                case 224:\r\n                    SpawnGhosts (en_blinky,x,y);\r\n                    break;\r\n                case 225:\r\n                    SpawnGhosts (en_clyde,x,y);\r\n                    break;\r\n                case 226:\r\n                    SpawnGhosts (en_pinky,x,y);\r\n                    break;\r\n                case 227:\r\n                    SpawnGhosts (en_inky,x,y);\r\n                    break;\r\n#endif\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n==================\r\n=\r\n= SetupGameLevel\r\n=\r\n==================\r\n*/\r\n\r\nvoid SetupGameLevel (void)\r\n{\r\n    int  x,y;\r\n    word *map;\r\n    word tile;\r\n\r\n\r\n    if (!loadedgame)\r\n    {\r\n        gamestate.TimeCount\r\n            = gamestate.secrettotal\r\n            = gamestate.killtotal\r\n            = gamestate.treasuretotal\r\n            = gamestate.secretcount\r\n            = gamestate.killcount\r\n            = gamestate.treasurecount\r\n            = pwallstate = pwallpos = facetimes = 0;\r\n        LastAttacker = NULL;\r\n        killerobj = NULL;\r\n    }\r\n\r\n    if (demoplayback || demorecord)\r\n        US_InitRndT (false);\r\n    else\r\n        US_InitRndT (true);\r\n\r\n//\r\n// load the level\r\n//\r\n    CA_CacheMap (gamestate.mapon+10*gamestate.episode);\r\n    mapon-=gamestate.episode*10;\r\n\r\n\r\n//\r\n// copy the wall data to a data segment array\r\n//\r\n    memset (tilemap,0,sizeof(tilemap));\r\n    memset (actorat,0,sizeof(actorat));\r\n    map = mapsegs[0];\r\n    for (y=0;y<mapheight;y++)\r\n    {\r\n        for (x=0;x<mapwidth;x++)\r\n        {\r\n            tile = *map++;\r\n            if (tile<AREATILE)\r\n            {\r\n                // solid wall\r\n                tilemap[x][y] = (byte) tile;\r\n                actorat[x][y] = (objtype *)(uintptr_t) tile;\r\n            }\r\n            else\r\n            {\r\n                // area floor\r\n                tilemap[x][y] = 0;\r\n                actorat[x][y] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n//\r\n// spawn doors\r\n//\r\n    InitActorList ();                       // start spawning things with a clean slate\r\n    InitDoorList ();\r\n    InitStaticList ();\r\n\r\n    map = mapsegs[0];\r\n    for (y=0;y<mapheight;y++)\r\n    {\r\n        for (x=0;x<mapwidth;x++)\r\n        {\r\n            tile = *map++;\r\n            if (tile >= 90 && tile <= 101)\r\n            {\r\n                // door\r\n                switch (tile)\r\n                {\r\n                    case 90:\r\n                    case 92:\r\n                    case 94:\r\n                    case 96:\r\n                    case 98:\r\n                    case 100:\r\n                        SpawnDoor (x,y,1,(tile-90)/2);\r\n                        break;\r\n                    case 91:\r\n                    case 93:\r\n                    case 95:\r\n                    case 97:\r\n                    case 99:\r\n                    case 101:\r\n                        SpawnDoor (x,y,0,(tile-91)/2);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n//\r\n// spawn actors\r\n//\r\n    ScanInfoPlane ();\r\n\r\n\r\n//\r\n// take out the ambush markers\r\n//\r\n    map = mapsegs[0];\r\n    for (y=0;y<mapheight;y++)\r\n    {\r\n        for (x=0;x<mapwidth;x++)\r\n        {\r\n            tile = *map++;\r\n            if (tile == AMBUSHTILE)\r\n            {\r\n                tilemap[x][y] = 0;\r\n                if ( (unsigned)(uintptr_t)actorat[x][y] == AMBUSHTILE)\r\n                    actorat[x][y] = NULL;\r\n\r\n                if (*map >= AREATILE)\r\n                    tile = *map;\r\n                if (*(map-1-mapwidth) >= AREATILE)\r\n                    tile = *(map-1-mapwidth);\r\n                if (*(map-1+mapwidth) >= AREATILE)\r\n                    tile = *(map-1+mapwidth);\r\n                if ( *(map-2) >= AREATILE)\r\n                    tile = *(map-2);\r\n\r\n                *(map-1) = tile;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n//\r\n// have the caching manager load and purge stuff to make sure all marks\r\n// are in memory\r\n//\r\n    CA_LoadAllSounds ();\r\n}\r\n\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n===================\r\n=\r\n= DrawPlayBorderSides\r\n=\r\n= To fix window overwrites\r\n=\r\n===================\r\n*/\r\nvoid DrawPlayBorderSides(void)\r\n{\r\n    if(viewsize == 21) return;\r\n\r\n    const int sw = screenWidth;\r\n    const int sh = screenHeight;\r\n    const int vw = viewwidth;\r\n    const int vh = viewheight;\r\n    const int px = scaleFactor; // size of one \"pixel\"\r\n\r\n    const int h  = sh - px * STATUSLINES;\r\n    const int xl = sw / 2 - vw / 2;\r\n    const int yl = (h - vh) / 2;\r\n\r\n    if(xl != 0)\r\n    {\r\n        VWB_BarScaledCoord(0,            0, xl - px,     h, bordercol);                 // left side\r\n        VWB_BarScaledCoord(xl + vw + px, 0, xl - px * 2, h, bordercol);                 // right side\r\n    }\r\n\r\n    if(yl != 0)\r\n    {\r\n        VWB_BarScaledCoord(0, 0,            sw, yl - px, bordercol);                    // upper side\r\n        VWB_BarScaledCoord(0, yl + vh + px, sw, yl - px, bordercol);                    // lower side\r\n    }\r\n\r\n    if(xl != 0)\r\n    {\r\n        // Paint game view border lines\r\n        VWB_BarScaledCoord(xl - px, yl - px, vw + px, px,          0);                      // upper border\r\n        VWB_BarScaledCoord(xl,      yl + vh, vw + px, px,          bordercol - 2);          // lower border\r\n        VWB_BarScaledCoord(xl - px, yl - px, px,      vh + px,     0);                      // left border\r\n        VWB_BarScaledCoord(xl + vw, yl - px, px,      vh + px * 2, bordercol - 2);          // right border\r\n        VWB_BarScaledCoord(xl - px, yl + vh, px,      px,          bordercol - 3);          // lower left highlight\r\n    }\r\n    else\r\n    {\r\n        // Just paint a lower border line\r\n        VWB_BarScaledCoord(0, yl+vh, vw, px, bordercol-2);       // lower border\r\n    }\r\n}\r\n\r\n\r\n/*\r\n===================\r\n=\r\n= DrawStatusBorder\r\n=\r\n===================\r\n*/\r\n\r\nvoid DrawStatusBorder (byte color)\r\n{\r\n    int statusborderw = (screenWidth-scaleFactor*320)/2;\r\n\r\n    VWB_BarScaledCoord (0,0,screenWidth,screenHeight-scaleFactor*(STATUSLINES-3),color);\r\n    VWB_BarScaledCoord (0,screenHeight-scaleFactor*(STATUSLINES-3),\r\n        statusborderw+scaleFactor*8,scaleFactor*(STATUSLINES-4),color);\r\n    VWB_BarScaledCoord (0,screenHeight-scaleFactor*2,screenWidth,scaleFactor*2,color);\r\n    VWB_BarScaledCoord (screenWidth-statusborderw-scaleFactor*8, screenHeight-scaleFactor*(STATUSLINES-3),\r\n        statusborderw+scaleFactor*8,scaleFactor*(STATUSLINES-4),color);\r\n\r\n    VWB_BarScaledCoord (statusborderw+scaleFactor*9, screenHeight-scaleFactor*3,\r\n        scaleFactor*97, scaleFactor*1, color-1);\r\n    VWB_BarScaledCoord (statusborderw+scaleFactor*106, screenHeight-scaleFactor*3,\r\n        scaleFactor*161, scaleFactor*1, color-2);\r\n    VWB_BarScaledCoord (statusborderw+scaleFactor*267, screenHeight-scaleFactor*3,\r\n        scaleFactor*44, scaleFactor*1, color-3);\r\n    VWB_BarScaledCoord (screenWidth-statusborderw-scaleFactor*9, screenHeight-scaleFactor*(STATUSLINES-4),\r\n        scaleFactor*1, scaleFactor*20, color-2);\r\n    VWB_BarScaledCoord (screenWidth-statusborderw-scaleFactor*9, screenHeight-scaleFactor*(STATUSLINES/2-4),\r\n        scaleFactor*1, scaleFactor*14, color-3);\r\n}\r\n\r\n\r\n/*\r\n===================\r\n=\r\n= DrawPlayBorder\r\n=\r\n===================\r\n*/\r\n\r\nvoid DrawPlayBorder (void)\r\n{\r\n    const int px = scaleFactor; // size of one \"pixel\"\r\n\r\n    if (bordercol != VIEWCOLOR)\r\n        DrawStatusBorder(bordercol);\r\n    else\r\n    {\r\n        const int statusborderw = (screenWidth-px*320)/2;\r\n        VWB_BarScaledCoord (0, screenHeight-px*STATUSLINES,\r\n            statusborderw+px*8, px*STATUSLINES, bordercol);\r\n        VWB_BarScaledCoord (screenWidth-statusborderw-px*8, screenHeight-px*STATUSLINES,\r\n            statusborderw+px*8, px*STATUSLINES, bordercol);\r\n    }\r\n\r\n    if((unsigned) viewheight == screenHeight) return;\r\n\r\n    VWB_BarScaledCoord (0,0,screenWidth,screenHeight-px*STATUSLINES,bordercol);\r\n\r\n    const int xl = screenWidth/2-viewwidth/2;\r\n    const int yl = (screenHeight-px*STATUSLINES-viewheight)/2;\r\n    VWB_BarScaledCoord (xl,yl,viewwidth,viewheight,0);\r\n\r\n    if(xl != 0)\r\n    {\r\n        // Paint game view border lines\r\n        VWB_BarScaledCoord(xl-px, yl-px, viewwidth+px, px, 0);                      // upper border\r\n        VWB_BarScaledCoord(xl, yl+viewheight, viewwidth+px, px, bordercol-2);       // lower border\r\n        VWB_BarScaledCoord(xl-px, yl-px, px, viewheight+px, 0);                     // left border\r\n        VWB_BarScaledCoord(xl+viewwidth, yl-px, px, viewheight+2*px, bordercol-2);  // right border\r\n        VWB_BarScaledCoord(xl-px, yl+viewheight, px, px, bordercol-3);              // lower left highlight\r\n    }\r\n    else\r\n    {\r\n        // Just paint a lower border line\r\n        VWB_BarScaledCoord(0, yl+viewheight, viewwidth, px, bordercol-2);       // lower border\r\n    }\r\n}\r\n\r\n\r\n/*\r\n===================\r\n=\r\n= DrawPlayScreen\r\n=\r\n===================\r\n*/\r\n\r\nvoid DrawPlayScreen (void)\r\n{\r\n    VWB_DrawPicScaledCoord ((screenWidth-scaleFactor*320)/2,screenHeight-scaleFactor*STATUSLINES,STATUSBARPIC);\r\n    DrawPlayBorder ();\r\n\r\n    DrawFace ();\r\n    DrawHealth ();\r\n    DrawLives ();\r\n    DrawLevel ();\r\n    DrawAmmo ();\r\n    DrawKeys ();\r\n    DrawWeapon ();\r\n    DrawScore ();\r\n}\r\n\r\n// Uses LatchDrawPic instead of StatusDrawPic\r\nvoid LatchNumberHERE (int x, int y, unsigned width, int32_t number)\r\n{\r\n    unsigned length,c;\r\n    char str[20];\r\n\r\n    ltoa (number,str,10);\r\n\r\n    length = (unsigned) strlen (str);\r\n\r\n    while (length<width)\r\n    {\r\n        LatchDrawPic (x,y,N_BLANKPIC);\r\n        x++;\r\n        width--;\r\n    }\r\n\r\n    c = length <= width ? 0 : length-width;\r\n\r\n    while (c<length)\r\n    {\r\n        LatchDrawPic (x,y,str[c]-'0'+ N_0PIC);\r\n        x++;\r\n        c++;\r\n    }\r\n}\r\n\r\nvoid ShowActStatus()\r\n{\r\n    // Draw status bar without borders\r\n    byte *source = grsegs[STATUSBARPIC];\r\n    int picnum = STATUSBARPIC - STARTPICS;\r\n    int width = pictable[picnum].width;\r\n    int height = pictable[picnum].height;\r\n    int destx = (screenWidth-scaleFactor*320)/2 + 9 * scaleFactor;\r\n    int desty = screenHeight - (height - 4) * scaleFactor;\r\n    VL_MemToScreenScaledCoord(source, width, height, 9, 4, destx, desty, width - 18, height - 7);\r\n\r\n    ingame = false;\r\n    DrawFace ();\r\n    DrawHealth ();\r\n    DrawLives ();\r\n    DrawLevel ();\r\n    DrawAmmo ();\r\n    DrawKeys ();\r\n    DrawWeapon ();\r\n    DrawScore ();\r\n    ingame = true;\r\n}\r\n\r\n\r\n//==========================================================================\r\n\r\n/*\r\n==================\r\n=\r\n= StartDemoRecord\r\n=\r\n==================\r\n*/\r\n\r\nchar    demoname[13] = \"DEMO?.\";\r\n\r\n#ifndef REMDEBUG\r\n#define MAXDEMOSIZE     8192\r\n\r\nvoid StartDemoRecord (int levelnumber)\r\n{\r\n    demobuffer=malloc(MAXDEMOSIZE);\r\n    CHECKMALLOCRESULT(demobuffer);\r\n    demoptr = (int8_t *) demobuffer;\r\n    lastdemoptr = demoptr+MAXDEMOSIZE;\r\n\r\n    *demoptr = levelnumber;\r\n    demoptr += 4;                           // leave space for length\r\n    demorecord = true;\r\n}\r\n\r\n\r\n/*\r\n==================\r\n=\r\n= FinishDemoRecord\r\n=\r\n==================\r\n*/\r\n\r\nvoid FinishDemoRecord (void)\r\n{\r\n    int32_t    length,level;\r\n\r\n    demorecord = false;\r\n\r\n    length = (int32_t) (demoptr - (int8_t *)demobuffer);\r\n\r\n    demoptr = ((int8_t *)demobuffer)+1;\r\n    demoptr[0] = (int8_t) length;\r\n    demoptr[1] = (int8_t) (length >> 8);\r\n    demoptr[2] = 0;\r\n\r\n    VW_FadeIn();\r\n    CenterWindow(24,3);\r\n    PrintY+=6;\r\n    fontnumber=0;\r\n    SETFONTCOLOR(0,15);\r\n    US_Print(\" Demo number (0-9): \");\r\n    VW_UpdateScreen();\r\n\r\n    if (US_LineInput (px,py,str,NULL,true,1,0))\r\n    {\r\n        level = atoi (str);\r\n        if (level>=0 && level<=9)\r\n        {\r\n            demoname[4] = (char)('0'+level);\r\n            CA_WriteFile (demoname,demobuffer,length);\r\n        }\r\n    }\r\n\r\n    free(demobuffer);\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n==================\r\n=\r\n= RecordDemo\r\n=\r\n= Fades the screen out, then starts a demo.  Exits with the screen faded\r\n=\r\n==================\r\n*/\r\n\r\nvoid RecordDemo (void)\r\n{\r\n    int level,esc,maps;\r\n\r\n    CenterWindow(26,3);\r\n    PrintY+=6;\r\n    CA_CacheGrChunk(STARTFONT);\r\n    fontnumber=0;\r\n    SETFONTCOLOR(0,15);\r\n#ifndef SPEAR\r\n#ifdef UPLOAD\r\n    US_Print(\"  Demo which level(1-10): \"); maps = 10;\r\n#else\r\n    US_Print(\"  Demo which level(1-60): \"); maps = 60;\r\n#endif\r\n#else\r\n    US_Print(\"  Demo which level(1-21): \"); maps = 21;\r\n#endif\r\n    VW_UpdateScreen();\r\n    VW_FadeIn ();\r\n    esc = !US_LineInput (px,py,str,NULL,true,2,0);\r\n    if (esc)\r\n        return;\r\n\r\n    level = atoi (str);\r\n    level--;\r\n\r\n    if (level >= maps || level < 0)\r\n        return;\r\n\r\n    VW_FadeOut ();\r\n\r\n#ifndef SPEAR\r\n    NewGame (gd_hard,level/10);\r\n    gamestate.mapon = level%10;\r\n#else\r\n    NewGame (gd_hard,0);\r\n    gamestate.mapon = level;\r\n#endif\r\n\r\n    StartDemoRecord (level);\r\n\r\n    DrawPlayScreen ();\r\n    VW_FadeIn ();\r\n\r\n    startgame = false;\r\n    demorecord = true;\r\n\r\n    SetupGameLevel ();\r\n    StartMusic ();\r\n\r\n    if(usedoublebuffering) VH_UpdateScreen();\r\n    fizzlein = true;\r\n\r\n    PlayLoop (0);\r\n\r\n    demoplayback = false;\r\n\r\n    StopMusic ();\r\n    VW_FadeOut ();\r\n    ClearMemory ();\r\n\r\n    FinishDemoRecord ();\r\n}\r\n#else\r\nvoid FinishDemoRecord (void) {return;}\r\nvoid RecordDemo (void) {return;}\r\n#endif\r\n\r\n\r\n\r\n//==========================================================================\r\n\r\n/*\r\n==================\r\n=\r\n= PlayDemo\r\n=\r\n= Fades the screen out, then starts a demo.  Exits with the screen unfaded\r\n=\r\n==================\r\n*/\r\n\r\nvoid PlayDemo (int demonumber)\r\n{\r\n    printf(\"play demo\\n\");\r\n    int length;\r\n#ifdef DEMOSEXTERN\r\n// debug: load chunk\r\n#ifndef SPEARDEMO\r\n    int dems[4]={T_DEMO0,T_DEMO1,T_DEMO2,T_DEMO3};\r\n#else\r\n    int dems[1]={T_DEMO0};\r\n#endif\r\n\r\n    CA_CacheGrChunk(dems[demonumber]);\r\n    demoptr = (int8_t *) grsegs[dems[demonumber]];\r\n#else\r\n    demoname[4] = '0'+demonumber;\r\n    CA_LoadFile (demoname,&demobuffer);\r\n    demoptr = (int8_t *)demobuffer;\r\n#endif\r\n\r\n    NewGame (1,0);\r\n    gamestate.mapon = *demoptr++;\r\n    gamestate.difficulty = gd_hard;\r\n    length = READWORD(*(uint8_t **)&demoptr);\r\n    // TODO: Seems like the original demo format supports 16 MB demos\r\n    //       But T_DEM00 and T_DEM01 of Wolf have a 0xd8 as third length size...\r\n    demoptr++;\r\n    lastdemoptr = demoptr-4+length;\r\n\r\n    VW_FadeOut ();\r\n\r\n    SETFONTCOLOR(0,15);\r\n    DrawPlayScreen ();\r\n\r\n    startgame = false;\r\n    demoplayback = true;\r\n\r\n    SetupGameLevel ();\r\n    StartMusic ();\r\n\r\n    PlayLoop (0);\r\n\r\n#ifdef DEMOSEXTERN\r\n    UNCACHEGRCHUNK(dems[demonumber]);\r\n#else\r\n    MM_FreePtr (&demobuffer);\r\n#endif\r\n\r\n    demoplayback = false;\r\n\r\n    StopMusic ();\r\n    ClearMemory ();\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n==================\r\n=\r\n= Died\r\n=\r\n==================\r\n*/\r\n\r\n#define DEATHROTATE 2\r\n\r\nvoid Died (void)\r\n{\r\n    float   fangle;\r\n    int32_t dx,dy;\r\n    int     iangle,curangle,clockwise,counter,change;\r\n\r\n    if (screenfaded)\r\n    {\r\n        ThreeDRefresh ();\r\n        VW_FadeIn ();\r\n    }\r\n\r\n    gamestate.weapon = (weapontype) -1;                     // take away weapon\r\n    SD_PlaySound (PLAYERDEATHSND);\r\n\r\n    //\r\n    // swing around to face attacker\r\n    //\r\n    if(killerobj)\r\n    {\r\n        dx = killerobj->x - player->x;\r\n        dy = player->y - killerobj->y;\r\n\r\n        fangle = (float) atan2((float) dy, (float) dx);     // returns -pi to pi\r\n        if (fangle<0)\r\n            fangle = (float) (M_PI*2+fangle);\r\n\r\n        iangle = (int) (fangle/(M_PI*2)*ANGLES);\r\n    }\r\n    else\r\n    {\r\n        iangle = player->angle + ANGLES / 2;\r\n        if(iangle >= ANGLES) iangle -= ANGLES;\r\n    }\r\n\r\n    if (player->angle > iangle)\r\n    {\r\n        counter = player->angle - iangle;\r\n        clockwise = ANGLES-player->angle + iangle;\r\n    }\r\n    else\r\n    {\r\n        clockwise = iangle - player->angle;\r\n        counter = player->angle + ANGLES-iangle;\r\n    }\r\n\r\n    curangle = player->angle;\r\n\r\n    if (clockwise<counter)\r\n    {\r\n        //\r\n        // rotate clockwise\r\n        //\r\n        if (curangle>iangle)\r\n            curangle -= ANGLES;\r\n        do\r\n        {\r\n            change = tics*DEATHROTATE;\r\n            if (curangle + change > iangle)\r\n                change = iangle-curangle;\r\n\r\n            curangle += change;\r\n            player->angle += change;\r\n            if (player->angle >= ANGLES)\r\n                player->angle -= ANGLES;\r\n\r\n            ThreeDRefresh ();\r\n            CalcTics ();\r\n        } while (curangle != iangle);\r\n    }\r\n    else\r\n    {\r\n        //\r\n        // rotate counterclockwise\r\n        //\r\n        if (curangle<iangle)\r\n            curangle += ANGLES;\r\n        do\r\n        {\r\n            change = -(int)tics*DEATHROTATE;\r\n            if (curangle + change < iangle)\r\n                change = iangle-curangle;\r\n\r\n            curangle += change;\r\n            player->angle += change;\r\n            if (player->angle < 0)\r\n                player->angle += ANGLES;\r\n\r\n            ThreeDRefresh ();\r\n            CalcTics ();\r\n        } while (curangle != iangle);\r\n    }\r\n\r\n    //\r\n    // fade to red\r\n    //\r\n    FinishPaletteShifts ();\r\n\r\n    if(usedoublebuffering) VH_UpdateScreen();\r\n\r\n    VL_BarScaledCoord (viewscreenx,viewscreeny,viewwidth,viewheight,4);\r\n\r\n    IN_ClearKeysDown ();\r\n\r\n    FizzleFade(screenBuffer,viewscreenx,viewscreeny,viewwidth,viewheight,70,false);\r\n\r\n    IN_UserInput(100);\r\n    SD_WaitSoundDone ();\r\n    ClearMemory();\r\n\r\n    gamestate.lives--;\r\n\r\n    if (gamestate.lives > -1)\r\n    {\r\n        gamestate.health = 100;\r\n        gamestate.weapon = gamestate.bestweapon\r\n            = gamestate.chosenweapon = wp_pistol;\r\n        gamestate.ammo = STARTAMMO;\r\n        gamestate.keys = 0;\r\n        pwallstate = pwallpos = 0;\r\n        gamestate.attackframe = gamestate.attackcount =\r\n            gamestate.weaponframe = 0;\r\n\r\n        if(viewsize != 21)\r\n        {\r\n            DrawKeys ();\r\n            DrawWeapon ();\r\n            DrawAmmo ();\r\n            DrawHealth ();\r\n            DrawFace ();\r\n            DrawLives ();\r\n        }\r\n    }\r\n}\r\n\r\n//==========================================================================\r\n\r\n// void my_async_call (void*, int);\r\n\r\n// EM_JS(void, my_async_call, (void* fn, int jumpto), {\r\n//     function wrapper() {\r\n//         getFuncWrapper(fn, 'vi')(jumpto);\r\n//     }\r\n//     requestAnimationFrame(wrapper);\r\n// });\r\n\r\n/*\r\n===================\r\n=\r\n= GameLoop\r\n=\r\n===================\r\n*/\r\nboolean died = false;\r\nvoid GameLoop1 (int)\r\n{\r\n    GameLoop(1);\r\n}\r\n\r\nvoid GameLoop2 (int)\r\n{\r\n    GameLoop(2);\r\n}\r\n\r\nint gameloopiters = 0;\r\nvoid GameLoop (int jumpto)\r\n{\r\n    printf(\"GameLoop %d\\n\", gameloopiters++);\r\n    assert(DigiMap[18] == 3);\r\n    assert(jumpto >= 0 && jumpto <= 1);\r\n// #ifdef MYPROFILE\r\n//     clock_t start,end;\r\n// #endif\r\n\r\nswitch (jumpto) { // re-entry state machine\r\ncase 0:\r\nrestartgame:\r\n    ClearMemory ();\r\n    assert(DigiMap[18] == 3);\r\n\r\n    SETFONTCOLOR(0,15);\r\n    VW_FadeOut();\r\n    DrawPlayScreen ();\r\n    died = false;\r\n    assert(DigiMap[18] == 3);\r\n\r\ncase 1:\r\n#ifndef __EMSCRIPTEN__\r\n    do\r\n    {\r\n#endif\r\n        if (!loadedgame)\r\n            gamestate.score = gamestate.oldscore;\r\n        if(!died || viewsize != 21) DrawScore();\r\n\r\n        startgame = false;\r\n        if (!loadedgame)\r\n            SetupGameLevel ();\r\n\r\n// #ifdef SPEAR\r\n//         if (gamestate.mapon == 20)      // give them the key allways\r\n//         {\r\n//             gamestate.keys |= 1;\r\n//             DrawKeys ();\r\n//         }\r\n// #endif\r\n\r\n        ingame = true;\r\n        if(loadedgame)\r\n        {\r\n            ContinueMusic(lastgamemusicoffset);\r\n            loadedgame = false;\r\n        }\r\n        else StartMusic ();\r\n\r\n        if (!died)\r\n            PreloadGraphics ();             // TODO: Let this do something useful!\r\n        else\r\n        {\r\n            died = false;\r\n            fizzlein = true;\r\n        }\r\n\r\n        DrawLevel ();\r\n\r\n// #ifdef SPEAR\r\n// startplayloop:\r\n// #endif\r\n\r\n        assert(DigiMap[18] == 3);\r\n        #ifdef __EMSCRIPTEN__\r\n        em_continuation_push(GameLoop2/* return here */);\r\n        PlayLoop (0);\r\n        return;\r\n        #else\r\n        PlayLoop (0);\r\n        #endif\r\ncase 2:\r\n\r\n// #ifdef SPEAR\r\n//         if (spearflag)\r\n//         {\r\n//             SD_StopSound();\r\n//             SD_PlaySound(GETSPEARSND);\r\n//             if (DigiMode != sds_Off)\r\n//             {\r\n//                 Delay(150);\r\n//             }\r\n//             else\r\n//                 SD_WaitSoundDone();\r\n\r\n//             ClearMemory ();\r\n//             gamestate.oldscore = gamestate.score;\r\n//             gamestate.mapon = 20;\r\n//             SetupGameLevel ();\r\n//             StartMusic ();\r\n//             player->x = spearx;\r\n//             player->y = speary;\r\n//             player->angle = (short)spearangle;\r\n//             spearflag = false;\r\n//             Thrust (0,0);\r\n//             goto startplayloop;\r\n//         }\r\n// #endif\r\n\r\n        StopMusic ();\r\n        ingame = false;\r\n\r\n        if (demorecord && playstate != ex_warped)\r\n            FinishDemoRecord ();\r\n\r\n        if (startgame || loadedgame)\r\n            goto restartgame;\r\n\r\n        switch (playstate)\r\n        {\r\n            case ex_completed:\r\n            case ex_secretlevel:\r\n                if(viewsize == 21) DrawPlayScreen();\r\n                gamestate.keys = 0;\r\n                DrawKeys ();\r\n                VW_FadeOut ();\r\n\r\n                ClearMemory ();\r\n\r\n                LevelCompleted ();              // do the intermission\r\n                if(viewsize == 21) DrawPlayScreen();\r\n\r\n// #ifdef SPEARDEMO\r\n//                 if (gamestate.mapon == 1)\r\n//                 {\r\n//                     died = true;                    // don't \"get psyched!\"\r\n\r\n//                     VW_FadeOut ();\r\n\r\n//                     ClearMemory ();\r\n\r\n//                     CheckHighScore (gamestate.score,gamestate.mapon+1);\r\n// #ifndef JAPAN\r\n//                     strcpy(MainMenu[viewscores].string,STR_VS);\r\n// #endif\r\n//                     MainMenu[viewscores].routine = CP_ViewScores;\r\n//                     return;\r\n//                 }\r\n// #endif\r\n\r\n// #ifdef JAPDEMO\r\n//                 if (gamestate.mapon == 3)\r\n//                 {\r\n//                     died = true;                    // don't \"get psyched!\"\r\n\r\n//                     VW_FadeOut ();\r\n\r\n//                     ClearMemory ();\r\n\r\n//                     CheckHighScore (gamestate.score,gamestate.mapon+1);\r\n// #ifndef JAPAN\r\n//                     strcpy(MainMenu[viewscores].string,STR_VS);\r\n// #endif\r\n//                     MainMenu[viewscores].routine = CP_ViewScores;\r\n//                     return;\r\n//                 }\r\n// #endif\r\n\r\n                gamestate.oldscore = gamestate.score;\r\n\r\n#ifndef SPEAR\r\n                //\r\n                // COMING BACK FROM SECRET LEVEL\r\n                //\r\n                if (gamestate.mapon == 9)\r\n                    gamestate.mapon = ElevatorBackTo[gamestate.episode];    // back from secret\r\n                else\r\n                    //\r\n                    // GOING TO SECRET LEVEL\r\n                    //\r\n                    if (playstate == ex_secretlevel)\r\n                        gamestate.mapon = 9;\r\n#else\r\n\r\n#define FROMSECRET1             3\r\n#define FROMSECRET2             11\r\n\r\n                //\r\n                // GOING TO SECRET LEVEL\r\n                //\r\n                if (playstate == ex_secretlevel)\r\n                    switch(gamestate.mapon)\r\n                {\r\n                    case FROMSECRET1: gamestate.mapon = 18; break;\r\n                    case FROMSECRET2: gamestate.mapon = 19; break;\r\n                }\r\n                else\r\n                    //\r\n                    // COMING BACK FROM SECRET LEVEL\r\n                    //\r\n                    if (gamestate.mapon == 18 || gamestate.mapon == 19)\r\n                        switch(gamestate.mapon)\r\n                    {\r\n                        case 18: gamestate.mapon = FROMSECRET1+1; break;\r\n                        case 19: gamestate.mapon = FROMSECRET2+1; break;\r\n                    }\r\n#endif\r\n                    else\r\n                        //\r\n                        // GOING TO NEXT LEVEL\r\n                        //\r\n                        gamestate.mapon++;\r\n                break;\r\n\r\n            case ex_died:\r\n                Died ();\r\n                died = true;                    // don't \"get psyched!\"\r\n\r\n                if (gamestate.lives > -1)\r\n                    break;                          // more lives left\r\n\r\n                VW_FadeOut ();\r\n                if(screenHeight % 200 != 0)\r\n                    VL_ClearScreen(0);\r\n\r\n                ClearMemory ();\r\n\r\n                CheckHighScore (gamestate.score,gamestate.mapon+1);\r\n#ifndef JAPAN\r\n                strcpy(MainMenu[viewscores].string,STR_VS);\r\n#endif\r\n                MainMenu[viewscores].routine = CP_ViewScores;\r\n                return;\r\n\r\n            case ex_victorious:\r\n                if(viewsize == 21) DrawPlayScreen();\r\n#ifndef SPEAR\r\n                VW_FadeOut ();\r\n#else\r\n                VL_FadeOut (0,255,0,17,17,300);\r\n#endif\r\n                ClearMemory ();\r\n\r\n                Victory ();\r\n\r\n                ClearMemory ();\r\n\r\n                CheckHighScore (gamestate.score,gamestate.mapon+1);\r\n#ifndef JAPAN\r\n                strcpy(MainMenu[viewscores].string,STR_VS);\r\n#endif\r\n                MainMenu[viewscores].routine = CP_ViewScores;\r\n                return;\r\n\r\n            default:\r\n                if(viewsize == 21) DrawPlayScreen();\r\n                ClearMemory ();\r\n                break;\r\n        }\r\n#ifndef __EMSCRIPTEN__\r\n    } while (1);\r\n#else\r\n    emscripten_async_call((void (*)(void *))GameLoop1, (void *)1, -1);\r\n#endif\r\n} // end jumpto switch\r\n}\r\n","// WL_INTER.C\r\n\r\n#include \"wl_def.h\"\r\n#pragma hdrstop\r\n\r\nLRstruct LevelRatios[LRpack];\r\nint32_t lastBreathTime = 0;\r\n\r\nvoid Write (int x, int y, const char *string);\r\n\r\n//==========================================================================\r\n\r\n/*\r\n==================\r\n=\r\n= CLearSplitVWB\r\n=\r\n==================\r\n*/\r\n\r\nvoid\r\nClearSplitVWB (void)\r\n{\r\n    WindowX = 0;\r\n    WindowY = 0;\r\n    WindowW = 320;\r\n    WindowH = 160;\r\n}\r\n\r\n\r\n//==========================================================================\r\n\r\n#ifdef SPEAR\r\n#ifndef SPEARDEMO\r\n////////////////////////////////////////////////////////\r\n//\r\n// End of Spear of Destiny\r\n//\r\n////////////////////////////////////////////////////////\r\n\r\nvoid\r\nEndScreen (int palette, int screen)\r\n{\r\n    SDL_Color pal[256];\r\n    CA_CacheScreen (screen);\r\n    VW_UpdateScreen ();\r\n    CA_CacheGrChunk (palette);\r\n    VL_ConvertPalette(grsegs[palette], pal, 256);\r\n    VL_FadeIn (0, 255, pal, 30);\r\n    UNCACHEGRCHUNK (palette);\r\n    IN_ClearKeysDown ();\r\n    IN_Ack ();\r\n    VW_FadeOut ();\r\n}\r\n\r\n\r\nvoid\r\nEndSpear (void)\r\n{\r\n    SDL_Color pal[256];\r\n\r\n    EndScreen (END1PALETTE, ENDSCREEN11PIC);\r\n\r\n    CA_CacheScreen (ENDSCREEN3PIC);\r\n    VW_UpdateScreen ();\r\n    CA_CacheGrChunk (END3PALETTE);\r\n    VL_ConvertPalette(grsegs[END3PALETTE], pal, 256);\r\n    VL_FadeIn (0, 255, pal, 30);\r\n    UNCACHEGRCHUNK (END3PALETTE);\r\n    fontnumber = 0;\r\n    fontcolor = 0xd0;\r\n    WindowX = 0;\r\n    WindowW = 320;\r\n    PrintX = 0;\r\n    PrintY = 180;\r\n    US_CPrint (STR_ENDGAME1 \"\\n\");\r\n    US_CPrint (STR_ENDGAME2);\r\n    VW_UpdateScreen ();\r\n    IN_UserInput(700);\r\n\r\n    PrintX = 0;\r\n    PrintY = 180;\r\n    VWB_Bar (0, 180, 320, 20, 0);\r\n    US_CPrint (STR_ENDGAME3 \"\\n\");\r\n    US_CPrint (STR_ENDGAME4);\r\n    VW_UpdateScreen ();\r\n    IN_UserInput(700);\r\n\r\n    VW_FadeOut ();\r\n\r\n    EndScreen (END4PALETTE, ENDSCREEN4PIC);\r\n    EndScreen (END5PALETTE, ENDSCREEN5PIC);\r\n    EndScreen (END6PALETTE, ENDSCREEN6PIC);\r\n    EndScreen (END7PALETTE, ENDSCREEN7PIC);\r\n    EndScreen (END8PALETTE, ENDSCREEN8PIC);\r\n    EndScreen (END9PALETTE, ENDSCREEN9PIC);\r\n\r\n    EndScreen (END2PALETTE, ENDSCREEN12PIC);\r\n\r\n    MainMenu[savegame].active = 0;\r\n}\r\n#endif\r\n#endif\r\n\r\n//==========================================================================\r\n\r\n/*\r\n==================\r\n=\r\n= Victory\r\n=\r\n==================\r\n*/\r\n\r\nvoid\r\nVictory (void)\r\n{\r\n#ifndef SPEARDEMO\r\n    int32_t sec;\r\n    int i, min, kr, sr, tr, x;\r\n    char tempstr[8];\r\n\r\n#define RATIOX  6\r\n#define RATIOY  14\r\n#define TIMEX   14\r\n#define TIMEY   8\r\n\r\n\r\n#ifdef SPEAR\r\n    StartCPMusic (XTHEEND_MUS);\r\n\r\n    CA_CacheGrChunk (BJCOLLAPSE1PIC);\r\n    CA_CacheGrChunk (BJCOLLAPSE2PIC);\r\n    CA_CacheGrChunk (BJCOLLAPSE3PIC);\r\n    CA_CacheGrChunk (BJCOLLAPSE4PIC);\r\n\r\n    VWB_Bar (0, 0, 320, 200, VIEWCOLOR);\r\n    VWB_DrawPic (124, 44, BJCOLLAPSE1PIC);\r\n    VW_UpdateScreen ();\r\n    VW_FadeIn ();\r\n    VW_WaitVBL (2 * 70);\r\n    VWB_DrawPic (124, 44, BJCOLLAPSE2PIC);\r\n    VW_UpdateScreen ();\r\n    VW_WaitVBL (105);\r\n    VWB_DrawPic (124, 44, BJCOLLAPSE3PIC);\r\n    VW_UpdateScreen ();\r\n    VW_WaitVBL (105);\r\n    VWB_DrawPic (124, 44, BJCOLLAPSE4PIC);\r\n    VW_UpdateScreen ();\r\n    VW_WaitVBL (3 * 70);\r\n\r\n    UNCACHEGRCHUNK (BJCOLLAPSE1PIC);\r\n    UNCACHEGRCHUNK (BJCOLLAPSE2PIC);\r\n    UNCACHEGRCHUNK (BJCOLLAPSE3PIC);\r\n    UNCACHEGRCHUNK (BJCOLLAPSE4PIC);\r\n    VL_FadeOut (0, 255, 0, 17, 17, 5);\r\n#endif\r\n\r\n    StartCPMusic (URAHERO_MUS);\r\n    ClearSplitVWB ();\r\n    CacheLump (LEVELEND_LUMP_START, LEVELEND_LUMP_END);\r\n    CA_CacheGrChunk (STARTFONT);\r\n\r\n#ifndef SPEAR\r\n    CA_CacheGrChunk (C_TIMECODEPIC);\r\n#endif\r\n\r\n    VWB_Bar (0, 0, 320, screenHeight / scaleFactor - STATUSLINES + 1, VIEWCOLOR);\r\n    if (bordercol != VIEWCOLOR)\r\n        DrawStatusBorder (VIEWCOLOR);\r\n\r\n#ifdef JAPAN\r\n#ifndef JAPDEMO\r\n    CA_CacheGrChunk (C_ENDRATIOSPIC);\r\n    VWB_DrawPic (0, 0, C_ENDRATIOSPIC);\r\n    UNCACHEGRCHUNK (C_ENDRATIOSPIC);\r\n#endif\r\n#else\r\n    Write (18, 2, STR_YOUWIN);\r\n\r\n    Write (TIMEX, TIMEY - 2, STR_TOTALTIME);\r\n\r\n    Write (12, RATIOY - 2, \"averages\");\r\n\r\n#ifdef SPANISH\r\n    Write (RATIOX + 2, RATIOY, STR_RATKILL);\r\n    Write (RATIOX + 2, RATIOY + 2, STR_RATSECRET);\r\n    Write (RATIOX + 2, RATIOY + 4, STR_RATTREASURE);\r\n#else\r\n    Write (RATIOX + 8, RATIOY, STR_RATKILL);\r\n    Write (RATIOX + 4, RATIOY + 2, STR_RATSECRET);\r\n    Write (RATIOX, RATIOY + 4, STR_RATTREASURE);\r\n#endif\r\n\r\n#endif\r\n\r\n#ifndef JAPDEMO\r\n    VWB_DrawPic (8, 4, L_BJWINSPIC);\r\n#endif\r\n\r\n\r\n    for (kr = sr = tr = sec = i = 0; i < LRpack; i++)\r\n    {\r\n        sec += LevelRatios[i].time;\r\n        kr += LevelRatios[i].kill;\r\n        sr += LevelRatios[i].secret;\r\n        tr += LevelRatios[i].treasure;\r\n    }\r\n\r\n#ifndef SPEAR\r\n    kr /= LRpack;\r\n    sr /= LRpack;\r\n    tr /= LRpack;\r\n#else\r\n    kr /= 14;\r\n    sr /= 14;\r\n    tr /= 14;\r\n#endif\r\n\r\n    min = sec / 60;\r\n    sec %= 60;\r\n\r\n    if (min > 99)\r\n        min = sec = 99;\r\n\r\n    i = TIMEX * 8 + 1;\r\n    VWB_DrawPic (i, TIMEY * 8, L_NUM0PIC + (min / 10));\r\n    i += 2 * 8;\r\n    VWB_DrawPic (i, TIMEY * 8, L_NUM0PIC + (min % 10));\r\n    i += 2 * 8;\r\n    Write (i / 8, TIMEY, \":\");\r\n    i += 1 * 8;\r\n    VWB_DrawPic (i, TIMEY * 8, L_NUM0PIC + (sec / 10));\r\n    i += 2 * 8;\r\n    VWB_DrawPic (i, TIMEY * 8, L_NUM0PIC + (sec % 10));\r\n    VW_UpdateScreen ();\r\n\r\n    itoa (kr, tempstr, 10);\r\n    x = RATIOX + 24 - (int) strlen(tempstr) * 2;\r\n    Write (x, RATIOY, tempstr);\r\n\r\n    itoa (sr, tempstr, 10);\r\n    x = RATIOX + 24 - (int) strlen(tempstr) * 2;\r\n    Write (x, RATIOY + 2, tempstr);\r\n\r\n    itoa (tr, tempstr, 10);\r\n    x = RATIOX + 24 - (int) strlen(tempstr) * 2;\r\n    Write (x, RATIOY + 4, tempstr);\r\n\r\n#ifndef SPANISH\r\n#ifndef UPLOAD\r\n#ifndef SPEAR\r\n    //\r\n    // TOTAL TIME VERIFICATION CODE\r\n    //\r\n    if (gamestate.difficulty >= gd_medium)\r\n    {\r\n        VWB_DrawPic (30 * 8, TIMEY * 8, C_TIMECODEPIC);\r\n        fontnumber = 0;\r\n        fontcolor = READHCOLOR;\r\n        PrintX = 30 * 8 - 3;\r\n        PrintY = TIMEY * 8 + 8;\r\n        PrintX += 4;\r\n        tempstr[0] = (((min / 10) ^ (min % 10)) ^ 0xa) + 'A';\r\n        tempstr[1] = (int) ((((sec / 10) ^ (sec % 10)) ^ 0xa) + 'A');\r\n        tempstr[2] = (tempstr[0] ^ tempstr[1]) + 'A';\r\n        tempstr[3] = 0;\r\n        US_Print (tempstr);\r\n    }\r\n#endif\r\n#endif\r\n#endif\r\n\r\n    fontnumber = 1;\r\n\r\n    VW_UpdateScreen ();\r\n    VW_FadeIn ();\r\n\r\n    IN_Ack ();\r\n\r\n    VW_FadeOut ();\r\n    if(screenHeight % 200 != 0)\r\n        VL_ClearScreen(0);\r\n\r\n#ifndef SPEAR\r\n    UNCACHEGRCHUNK (C_TIMECODEPIC);\r\n#endif\r\n    UnCacheLump (LEVELEND_LUMP_START, LEVELEND_LUMP_END);\r\n\r\n#ifndef SPEAR\r\n    EndText ();\r\n#else\r\n    EndSpear ();\r\n#endif\r\n\r\n#endif // SPEARDEMO\r\n}\r\n\r\n\r\n//==========================================================================\r\n\r\n#ifndef JAPAN\r\n/*\r\n==================\r\n=\r\n= PG13\r\n=\r\n==================\r\n*/\r\n\r\nvoid\r\nPG13 (void)\r\n{\r\n    VW_FadeOut ();\r\n    VWB_Bar (0, 0, 320, 200, 0x82);     // background\r\n\r\n    CA_CacheGrChunk (PG13PIC);\r\n    VWB_DrawPic (216, 110, PG13PIC);\r\n    VW_UpdateScreen ();\r\n\r\n    UNCACHEGRCHUNK (PG13PIC);\r\n\r\n    VW_FadeIn ();\r\n    IN_UserInput (TickBase * 7);\r\n\r\n    VW_FadeOut ();\r\n}\r\n#endif\r\n\r\n\r\n//==========================================================================\r\n\r\nvoid\r\nWrite (int x, int y, const char *string)\r\n{\r\n    static const int alpha[] = { L_NUM0PIC, L_NUM1PIC, L_NUM2PIC, L_NUM3PIC, L_NUM4PIC, L_NUM5PIC,\r\n        L_NUM6PIC, L_NUM7PIC, L_NUM8PIC, L_NUM9PIC, L_COLONPIC, 0, 0, 0, 0, 0, 0, L_APIC, L_BPIC,\r\n        L_CPIC, L_DPIC, L_EPIC, L_FPIC, L_GPIC, L_HPIC, L_IPIC, L_JPIC, L_KPIC,\r\n        L_LPIC, L_MPIC, L_NPIC, L_OPIC, L_PPIC, L_QPIC, L_RPIC, L_SPIC, L_TPIC,\r\n        L_UPIC, L_VPIC, L_WPIC, L_XPIC, L_YPIC, L_ZPIC\r\n    };\r\n\r\n    int i, ox, nx, ny, len = (int) strlen(string);\r\n    char ch;\r\n\r\n    ox = nx = x * 8;\r\n    ny = y * 8;\r\n    for (i = 0; i < len; i++)\r\n    {\r\n        if (string[i] == '\\n')\r\n        {\r\n            nx = ox;\r\n            ny += 16;\r\n        }\r\n        else\r\n        {\r\n            ch = string[i];\r\n            if (ch >= 'a')\r\n                ch -= ('a' - 'A');\r\n            ch -= '0';\r\n\r\n            switch (string[i])\r\n            {\r\n                case '!':\r\n                    VWB_DrawPic (nx, ny, L_EXPOINTPIC);\r\n                    nx += 8;\r\n                    continue;\r\n\r\n#ifndef APOGEE_1_0\r\n                case '\\'':\r\n                    VWB_DrawPic (nx, ny, L_APOSTROPHEPIC);\r\n                    nx += 8;\r\n                    continue;\r\n#endif\r\n\r\n                case ' ':\r\n                    break;\r\n\r\n                case 0x3a:     // ':'\r\n                    VWB_DrawPic (nx, ny, L_COLONPIC);\r\n                    nx += 8;\r\n                    continue;\r\n\r\n                case '%':\r\n                    VWB_DrawPic (nx, ny, L_PERCENTPIC);\r\n                    break;\r\n\r\n                default:\r\n                    VWB_DrawPic (nx, ny, alpha[ch]);\r\n            }\r\n            nx += 16;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//\r\n// Breathe Mr. BJ!!!\r\n//\r\nvoid\r\nBJ_Breathe (void)\r\n{\r\n    static int which = 0, max = 10;\r\n    int pics[2] = { L_GUYPIC, L_GUY2PIC };\r\n\r\n    SDL_Delay(5);\r\n\r\n    if ((int32_t) GetTimeCount () - lastBreathTime > max)\r\n    {\r\n        which ^= 1;\r\n        VWB_DrawPic (0, 16, pics[which]);\r\n        VW_UpdateScreen ();\r\n        lastBreathTime = GetTimeCount();\r\n        max = 35;\r\n    }\r\n}\r\n\r\n\r\n\r\n/*\r\n==================\r\n=\r\n= LevelCompleted\r\n=\r\n= Entered with the screen faded out\r\n= Still in split screen mode with the status bar\r\n=\r\n= Exit with the screen faded out\r\n=\r\n==================\r\n*/\r\n\r\nvoid\r\nLevelCompleted (void)\r\n{\r\n#define VBLWAIT 30\r\n#define PAR_AMOUNT      500\r\n#define PERCENT100AMT   10000\r\n    typedef struct\r\n    {\r\n        float time;\r\n        char timestr[6];\r\n    } times;\r\n\r\n    int x, i, min, sec, ratio, kr, sr, tr;\r\n    char tempstr[10];\r\n    int32_t bonus, timeleft = 0;\r\n    times parTimes[] = {\r\n#ifndef SPEAR\r\n        //\r\n        // Episode One Par Times\r\n        //\r\n        {1.5, \"01:30\"},\r\n        {2, \"02:00\"},\r\n        {2, \"02:00\"},\r\n        {3.5, \"03:30\"},\r\n        {3, \"03:00\"},\r\n        {3, \"03:00\"},\r\n        {2.5, \"02:30\"},\r\n        {2.5, \"02:30\"},\r\n        {0, \"??:??\"},           // Boss level\r\n        {0, \"??:??\"},           // Secret level\r\n\r\n        //\r\n        // Episode Two Par Times\r\n        //\r\n        {1.5, \"01:30\"},\r\n        {3.5, \"03:30\"},\r\n        {3, \"03:00\"},\r\n        {2, \"02:00\"},\r\n        {4, \"04:00\"},\r\n        {6, \"06:00\"},\r\n        {1, \"01:00\"},\r\n        {3, \"03:00\"},\r\n        {0, \"??:??\"},\r\n        {0, \"??:??\"},\r\n\r\n        //\r\n        // Episode Three Par Times\r\n        //\r\n        {1.5, \"01:30\"},\r\n        {1.5, \"01:30\"},\r\n        {2.5, \"02:30\"},\r\n        {2.5, \"02:30\"},\r\n        {3.5, \"03:30\"},\r\n        {2.5, \"02:30\"},\r\n        {2, \"02:00\"},\r\n        {6, \"06:00\"},\r\n        {0, \"??:??\"},\r\n        {0, \"??:??\"},\r\n\r\n        //\r\n        // Episode Four Par Times\r\n        //\r\n        {2, \"02:00\"},\r\n        {2, \"02:00\"},\r\n        {1.5, \"01:30\"},\r\n        {1, \"01:00\"},\r\n        {4.5, \"04:30\"},\r\n        {3.5, \"03:30\"},\r\n        {2, \"02:00\"},\r\n        {4.5, \"04:30\"},\r\n        {0, \"??:??\"},\r\n        {0, \"??:??\"},\r\n\r\n        //\r\n        // Episode Five Par Times\r\n        //\r\n        {2.5, \"02:30\"},\r\n        {1.5, \"01:30\"},\r\n        {2.5, \"02:30\"},\r\n        {2.5, \"02:30\"},\r\n        {4, \"04:00\"},\r\n        {3, \"03:00\"},\r\n        {4.5, \"04:30\"},\r\n        {3.5, \"03:30\"},\r\n        {0, \"??:??\"},\r\n        {0, \"??:??\"},\r\n\r\n        //\r\n        // Episode Six Par Times\r\n        //\r\n        {6.5, \"06:30\"},\r\n        {4, \"04:00\"},\r\n        {4.5, \"04:30\"},\r\n        {6, \"06:00\"},\r\n        {5, \"05:00\"},\r\n        {5.5, \"05:30\"},\r\n        {5.5, \"05:30\"},\r\n        {8.5, \"08:30\"},\r\n        {0, \"??:??\"},\r\n        {0, \"??:??\"}\r\n#else\r\n        //\r\n        // SPEAR OF DESTINY TIMES\r\n        //\r\n        {1.5, \"01:30\"},\r\n        {3.5, \"03:30\"},\r\n        {2.75, \"02:45\"},\r\n        {3.5, \"03:30\"},\r\n        {0, \"??:??\"},           // Boss 1\r\n        {4.5, \"04:30\"},\r\n        {3.25, \"03:15\"},\r\n        {2.75, \"02:45\"},\r\n        {4.75, \"04:45\"},\r\n        {0, \"??:??\"},           // Boss 2\r\n        {6.5, \"06:30\"},\r\n        {4.5, \"04:30\"},\r\n        {2.75, \"02:45\"},\r\n        {4.5, \"04:30\"},\r\n        {6, \"06:00\"},\r\n        {0, \"??:??\"},           // Boss 3\r\n        {6, \"06:00\"},\r\n        {0, \"??:??\"},           // Boss 4\r\n        {0, \"??:??\"},           // Secret level 1\r\n        {0, \"??:??\"},           // Secret level 2\r\n#endif\r\n    };\r\n\r\n    CacheLump (LEVELEND_LUMP_START, LEVELEND_LUMP_END);\r\n    ClearSplitVWB ();           // set up for double buffering in split screen\r\n    VWB_Bar (0, 0, 320, screenHeight / scaleFactor - STATUSLINES + 1, VIEWCOLOR);\r\n\r\n    if (bordercol != VIEWCOLOR)\r\n        DrawStatusBorder (VIEWCOLOR);\r\n\r\n    StartCPMusic (ENDLEVEL_MUS);\r\n\r\n//\r\n// do the intermission\r\n//\r\n    IN_ClearKeysDown ();\r\n    IN_StartAck ();\r\n\r\n#ifdef JAPAN\r\n    CA_CacheGrChunk (C_INTERMISSIONPIC);\r\n    VWB_DrawPic (0, 0, C_INTERMISSIONPIC);\r\n    UNCACHEGRCHUNK (C_INTERMISSIONPIC);\r\n#endif\r\n    VWB_DrawPic (0, 16, L_GUYPIC);\r\n\r\n#ifndef SPEAR\r\n    if (mapon < 8)\r\n#else\r\n    if (mapon != 4 && mapon != 9 && mapon != 15 && mapon < 17)\r\n#endif\r\n    {\r\n#ifndef JAPAN\r\n#ifdef SPANISH\r\n        Write (14, 2, \"piso\\ncompletado\");\r\n#else\r\n        Write (14, 2, \"floor\\ncompleted\");\r\n#endif\r\n\r\n        Write (14, 7, STR_BONUS \"     0\");\r\n        Write (16, 10, STR_TIME);\r\n        Write (16, 12, STR_PAR);\r\n\r\n#ifdef SPANISH\r\n        Write (11, 14, STR_RAT2KILL);\r\n        Write (11, 16, STR_RAT2SECRET);\r\n        Write (11, 18, STR_RAT2TREASURE);\r\n#else\r\n        Write (9, 14, STR_RAT2KILL);\r\n        Write (5, 16, STR_RAT2SECRET);\r\n        Write (1, 18, STR_RAT2TREASURE);\r\n#endif\r\n\r\n        Write (26, 2, itoa (gamestate.mapon + 1, tempstr, 10));\r\n#endif\r\n\r\n#ifdef SPANISH\r\n        Write (30, 12, parTimes[gamestate.episode * 10 + mapon].timestr);\r\n#else\r\n        Write (26, 12, parTimes[gamestate.episode * 10 + mapon].timestr);\r\n#endif\r\n\r\n        //\r\n        // PRINT TIME\r\n        //\r\n        sec = gamestate.TimeCount / 70;\r\n\r\n        if (sec > 99 * 60)      // 99 minutes max\r\n            sec = 99 * 60;\r\n\r\n        if (gamestate.TimeCount < parTimes[gamestate.episode * 10 + mapon].time * 4200)\r\n            timeleft = (int32_t) ((parTimes[gamestate.episode * 10 + mapon].time * 4200) / 70 - sec);\r\n\r\n        min = sec / 60;\r\n        sec %= 60;\r\n\r\n#ifdef SPANISH\r\n        i = 30 * 8;\r\n#else\r\n        i = 26 * 8;\r\n#endif\r\n        VWB_DrawPic (i, 10 * 8, L_NUM0PIC + (min / 10));\r\n        i += 2 * 8;\r\n        VWB_DrawPic (i, 10 * 8, L_NUM0PIC + (min % 10));\r\n        i += 2 * 8;\r\n        Write (i / 8, 10, \":\");\r\n        i += 1 * 8;\r\n        VWB_DrawPic (i, 10 * 8, L_NUM0PIC + (sec / 10));\r\n        i += 2 * 8;\r\n        VWB_DrawPic (i, 10 * 8, L_NUM0PIC + (sec % 10));\r\n\r\n        VW_UpdateScreen ();\r\n        VW_FadeIn ();\r\n\r\n\r\n        //\r\n        // FIGURE RATIOS OUT BEFOREHAND\r\n        //\r\n        kr = sr = tr = 0;\r\n        if (gamestate.killtotal)\r\n            kr = (gamestate.killcount * 100) / gamestate.killtotal;\r\n        if (gamestate.secrettotal)\r\n            sr = (gamestate.secretcount * 100) / gamestate.secrettotal;\r\n        if (gamestate.treasuretotal)\r\n            tr = (gamestate.treasurecount * 100) / gamestate.treasuretotal;\r\n\r\n\r\n        //\r\n        // PRINT TIME BONUS\r\n        //\r\n        bonus = timeleft * PAR_AMOUNT;\r\n        if (bonus)\r\n        {\r\n            for (i = 0; i <= timeleft; i++)\r\n            {\r\n                ltoa ((int32_t) i * PAR_AMOUNT, tempstr, 10);\r\n                x = 36 - (int) strlen(tempstr) * 2;\r\n                Write (x, 7, tempstr);\r\n                if (!(i % (PAR_AMOUNT / 10)))\r\n                    SD_PlaySound (ENDBONUS1SND);\r\n                if(!usedoublebuffering || !(i % (PAR_AMOUNT / 50))) VW_UpdateScreen ();\r\n                while(SD_SoundPlaying ())\r\n                    BJ_Breathe ();\r\n                if (IN_CheckAck ())\r\n                    goto done;\r\n            }\r\n\r\n            VW_UpdateScreen ();\r\n\r\n            SD_PlaySound (ENDBONUS2SND);\r\n            while (SD_SoundPlaying ())\r\n                BJ_Breathe ();\r\n        }\r\n\r\n\r\n#ifdef SPANISH\r\n#define RATIOXX                33\r\n#else\r\n#define RATIOXX                37\r\n#endif\r\n        //\r\n        // KILL RATIO\r\n        //\r\n        ratio = kr;\r\n        for (i = 0; i <= ratio; i++)\r\n        {\r\n            itoa (i, tempstr, 10);\r\n            x = RATIOXX - (int) strlen(tempstr) * 2;\r\n            Write (x, 14, tempstr);\r\n            if (!(i % 10))\r\n                SD_PlaySound (ENDBONUS1SND);\r\n            if(!usedoublebuffering || !(i & 1)) VW_UpdateScreen ();\r\n            while (SD_SoundPlaying ())\r\n                BJ_Breathe ();\r\n\r\n            if (IN_CheckAck ())\r\n                goto done;\r\n        }\r\n        if (ratio >= 100)\r\n        {\r\n            VW_WaitVBL (VBLWAIT);\r\n            SD_StopSound ();\r\n            bonus += PERCENT100AMT;\r\n            ltoa (bonus, tempstr, 10);\r\n            x = (RATIOXX - 1) - (int) strlen(tempstr) * 2;\r\n            Write (x, 7, tempstr);\r\n            VW_UpdateScreen ();\r\n            SD_PlaySound (PERCENT100SND);\r\n        }\r\n        else if (!ratio)\r\n        {\r\n            VW_WaitVBL (VBLWAIT);\r\n            SD_StopSound ();\r\n            SD_PlaySound (NOBONUSSND);\r\n        }\r\n        else\r\n            SD_PlaySound (ENDBONUS2SND);\r\n\r\n        VW_UpdateScreen ();\r\n        while (SD_SoundPlaying ())\r\n            BJ_Breathe ();\r\n\r\n        //\r\n        // SECRET RATIO\r\n        //\r\n        ratio = sr;\r\n        for (i = 0; i <= ratio; i++)\r\n        {\r\n            itoa (i, tempstr, 10);\r\n            x = RATIOXX - (int) strlen(tempstr) * 2;\r\n            Write (x, 16, tempstr);\r\n            if (!(i % 10))\r\n                SD_PlaySound (ENDBONUS1SND);\r\n            if(!usedoublebuffering || !(i & 1)) VW_UpdateScreen ();\r\n            while (SD_SoundPlaying ())\r\n                BJ_Breathe ();\r\n\r\n            if (IN_CheckAck ())\r\n                goto done;\r\n        }\r\n        if (ratio >= 100)\r\n        {\r\n            VW_WaitVBL (VBLWAIT);\r\n            SD_StopSound ();\r\n            bonus += PERCENT100AMT;\r\n            ltoa (bonus, tempstr, 10);\r\n            x = (RATIOXX - 1) - (int) strlen(tempstr) * 2;\r\n            Write (x, 7, tempstr);\r\n            VW_UpdateScreen ();\r\n            SD_PlaySound (PERCENT100SND);\r\n        }\r\n        else if (!ratio)\r\n        {\r\n            VW_WaitVBL (VBLWAIT);\r\n            SD_StopSound ();\r\n            SD_PlaySound (NOBONUSSND);\r\n        }\r\n        else\r\n            SD_PlaySound (ENDBONUS2SND);\r\n        VW_UpdateScreen ();\r\n        while (SD_SoundPlaying ())\r\n            BJ_Breathe ();\r\n\r\n        //\r\n        // TREASURE RATIO\r\n        //\r\n        ratio = tr;\r\n        for (i = 0; i <= ratio; i++)\r\n        {\r\n            itoa (i, tempstr, 10);\r\n            x = RATIOXX - (int) strlen(tempstr) * 2;\r\n            Write (x, 18, tempstr);\r\n            if (!(i % 10))\r\n                SD_PlaySound (ENDBONUS1SND);\r\n            if(!usedoublebuffering || !(i & 1)) VW_UpdateScreen ();\r\n            while (SD_SoundPlaying ())\r\n                BJ_Breathe ();\r\n            if (IN_CheckAck ())\r\n                goto done;\r\n        }\r\n        if (ratio >= 100)\r\n        {\r\n            VW_WaitVBL (VBLWAIT);\r\n            SD_StopSound ();\r\n            bonus += PERCENT100AMT;\r\n            ltoa (bonus, tempstr, 10);\r\n            x = (RATIOXX - 1) - (int) strlen(tempstr) * 2;\r\n            Write (x, 7, tempstr);\r\n            VW_UpdateScreen ();\r\n            SD_PlaySound (PERCENT100SND);\r\n        }\r\n        else if (!ratio)\r\n        {\r\n            VW_WaitVBL (VBLWAIT);\r\n            SD_StopSound ();\r\n            SD_PlaySound (NOBONUSSND);\r\n        }\r\n        else\r\n            SD_PlaySound (ENDBONUS2SND);\r\n        VW_UpdateScreen ();\r\n        while (SD_SoundPlaying ())\r\n            BJ_Breathe ();\r\n\r\n\r\n        //\r\n        // JUMP STRAIGHT HERE IF KEY PRESSED\r\n        //\r\ndone:   itoa (kr, tempstr, 10);\r\n        x = RATIOXX - (int) strlen(tempstr) * 2;\r\n        Write (x, 14, tempstr);\r\n\r\n        itoa (sr, tempstr, 10);\r\n        x = RATIOXX - (int) strlen(tempstr) * 2;\r\n        Write (x, 16, tempstr);\r\n\r\n        itoa (tr, tempstr, 10);\r\n        x = RATIOXX - (int) strlen(tempstr) * 2;\r\n        Write (x, 18, tempstr);\r\n\r\n        bonus = (int32_t) timeleft *PAR_AMOUNT +\r\n            (PERCENT100AMT * (kr >= 100)) +\r\n            (PERCENT100AMT * (sr >= 100)) + (PERCENT100AMT * (tr >= 100));\r\n\r\n        GivePoints (bonus);\r\n        ltoa (bonus, tempstr, 10);\r\n        x = 36 - (int) strlen(tempstr) * 2;\r\n        Write (x, 7, tempstr);\r\n\r\n        //\r\n        // SAVE RATIO INFORMATION FOR ENDGAME\r\n        //\r\n        LevelRatios[mapon].kill = kr;\r\n        LevelRatios[mapon].secret = sr;\r\n        LevelRatios[mapon].treasure = tr;\r\n        LevelRatios[mapon].time = min * 60 + sec;\r\n    }\r\n    else\r\n    {\r\n#ifdef SPEAR\r\n#ifndef SPEARDEMO\r\n        switch (mapon)\r\n        {\r\n            case 4:\r\n                Write (14, 4, \" trans\\n\" \" grosse\\n\" STR_DEFEATED);\r\n                break;\r\n            case 9:\r\n                Write (14, 4, \"barnacle\\n\" \"wilhelm\\n\" STR_DEFEATED);\r\n                break;\r\n            case 15:\r\n                Write (14, 4, \"ubermutant\\n\" STR_DEFEATED);\r\n                break;\r\n            case 17:\r\n                Write (14, 4, \" death\\n\" \" knight\\n\" STR_DEFEATED);\r\n                break;\r\n            case 18:\r\n                Write (13, 4, \"secret tunnel\\n\" \"    area\\n\" \"  completed!\");\r\n                break;\r\n            case 19:\r\n                Write (13, 4, \"secret castle\\n\" \"    area\\n\" \"  completed!\");\r\n                break;\r\n        }\r\n#endif\r\n#else\r\n        Write (14, 4, \"secret floor\\n completed!\");\r\n#endif\r\n\r\n        Write (10, 16, \"15000 bonus!\");\r\n\r\n        VW_UpdateScreen ();\r\n        VW_FadeIn ();\r\n\r\n        GivePoints (15000);\r\n    }\r\n\r\n\r\n    DrawScore ();\r\n    VW_UpdateScreen ();\r\n\r\n    lastBreathTime = GetTimeCount();\r\n    IN_StartAck ();\r\n    while (!IN_CheckAck ())\r\n        BJ_Breathe ();\r\n\r\n//\r\n// done\r\n//\r\n#ifdef SPEARDEMO\r\n    if (gamestate.mapon == 1)\r\n    {\r\n        SD_PlaySound (BONUS1UPSND);\r\n\r\n        CA_CacheGrChunk (STARTFONT + 1);\r\n        Message (\"This concludes your demo\\n\"\r\n                 \"of Spear of Destiny! Now,\\n\" \"go to your local software\\n\" \"store and buy it!\");\r\n        UNCACHEGRCHUNK (STARTFONT + 1);\r\n\r\n        IN_ClearKeysDown ();\r\n        IN_Ack ();\r\n    }\r\n#endif\r\n\r\n#ifdef JAPDEMO\r\n    if (gamestate.mapon == 3)\r\n    {\r\n        SD_PlaySound (BONUS1UPSND);\r\n\r\n        CA_CacheGrChunk (STARTFONT + 1);\r\n        Message (\"This concludes your demo\\n\"\r\n                 \"of Wolfenstein 3-D! Now,\\n\" \"go to your local software\\n\" \"store and buy it!\");\r\n        UNCACHEGRCHUNK (STARTFONT + 1);\r\n\r\n        IN_ClearKeysDown ();\r\n        IN_Ack ();\r\n    }\r\n#endif\r\n\r\n    VW_FadeOut ();\r\n    DrawPlayBorder();\r\n\r\n    UnCacheLump (LEVELEND_LUMP_START, LEVELEND_LUMP_END);\r\n}\r\n\r\n\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= PreloadGraphics\r\n=\r\n= Fill the cache up\r\n=\r\n=================\r\n*/\r\n\r\nboolean\r\nPreloadUpdate (unsigned current, unsigned total)\r\n{\r\n    unsigned w = WindowW - scaleFactor * 10;\r\n\r\n    VWB_BarScaledCoord (WindowX + scaleFactor * 5, WindowY + WindowH - scaleFactor * 3,\r\n        w, scaleFactor * 2, BLACK);\r\n    w = ((int32_t) w * current) / total;\r\n    if (w)\r\n    {\r\n        VWB_BarScaledCoord (WindowX + scaleFactor * 5, WindowY + WindowH - scaleFactor * 3,\r\n            w, scaleFactor * 2, 0x37);       //SECONDCOLOR);\r\n        VWB_BarScaledCoord (WindowX + scaleFactor * 5, WindowY + WindowH - scaleFactor * 3,\r\n            w - scaleFactor * 1, scaleFactor * 1, 0x32);\r\n\r\n    }\r\n    VW_UpdateScreen ();\r\n//      if (LastScan == sc_Escape)\r\n//      {\r\n//              IN_ClearKeysDown();\r\n//              return(true);\r\n//      }\r\n//      else\r\n    return (false);\r\n}\r\n\r\nvoid\r\nPreloadGraphics (void)\r\n{\r\n    DrawLevel ();\r\n    ClearSplitVWB ();           // set up for double buffering in split screen\r\n\r\n    VWB_BarScaledCoord (0, 0, screenWidth, screenHeight - scaleFactor * (STATUSLINES - 1), bordercol);\r\n    LatchDrawPicScaledCoord ((screenWidth-scaleFactor*224)/16,\r\n        (screenHeight-scaleFactor*(STATUSLINES+48))/2, GETPSYCHEDPIC);\r\n\r\n    WindowX = (screenWidth - scaleFactor*224)/2;\r\n    WindowY = (screenHeight - scaleFactor*(STATUSLINES+48))/2;\r\n    WindowW = scaleFactor * 28 * 8;\r\n    WindowH = scaleFactor * 48;\r\n\r\n    VW_UpdateScreen ();\r\n    VW_FadeIn ();\r\n\r\n//      PM_Preload (PreloadUpdate);\r\n    PreloadUpdate (10, 10);\r\n    IN_UserInput (70);\r\n    VW_FadeOut ();\r\n\r\n    DrawPlayBorder ();\r\n    VW_UpdateScreen ();\r\n}\r\n\r\n\r\n//==========================================================================\r\n\r\n/*\r\n==================\r\n=\r\n= DrawHighScores\r\n=\r\n==================\r\n*/\r\n\r\nvoid\r\nDrawHighScores (void)\r\n{\r\n    char buffer[16];\r\n#ifndef SPEAR\r\n    char *str;\r\n#ifndef UPLOAD\r\n    char buffer1[5];\r\n#endif\r\n#endif\r\n    word i, w, h;\r\n    HighScore *s;\r\n\r\n#ifndef SPEAR\r\n    CA_CacheGrChunk (HIGHSCORESPIC);\r\n    CA_CacheGrChunk (STARTFONT);\r\n#ifndef APOGEE_1_0\r\n    CA_CacheGrChunk (C_LEVELPIC);\r\n    CA_CacheGrChunk (C_SCOREPIC);\r\n    CA_CacheGrChunk (C_NAMEPIC);\r\n#else\r\n    CA_CacheGrChunk (C_CODEPIC);\r\n#endif\r\n\r\n    ClearMScreen ();\r\n    DrawStripes (10);\r\n\r\n    VWB_DrawPic (48, 0, HIGHSCORESPIC);\r\n    UNCACHEGRCHUNK (HIGHSCORESPIC);\r\n\r\n#ifndef APOGEE_1_0\r\n    VWB_DrawPic (4 * 8, 68, C_NAMEPIC);\r\n    VWB_DrawPic (20 * 8, 68, C_LEVELPIC);\r\n    VWB_DrawPic (28 * 8, 68, C_SCOREPIC);\r\n#else\r\n    VWB_DrawPic(35*8,68,C_CODEPIC);\r\n#endif\r\n    fontnumber = 0;\r\n\r\n#else\r\n    CacheLump (BACKDROP_LUMP_START, BACKDROP_LUMP_END);\r\n    ClearMScreen ();\r\n    DrawStripes (10);\r\n    UnCacheLump (BACKDROP_LUMP_START, BACKDROP_LUMP_END);\r\n\r\n    CacheLump (HIGHSCORES_LUMP_START, HIGHSCORES_LUMP_END);\r\n    CA_CacheGrChunk (STARTFONT + 1);\r\n    VWB_DrawPic (0, 0, HIGHSCORESPIC);\r\n\r\n    fontnumber = 1;\r\n#endif\r\n\r\n\r\n#ifndef SPEAR\r\n    SETFONTCOLOR (15, 0x29);\r\n#else\r\n    SETFONTCOLOR (HIGHLIGHT, 0x29);\r\n#endif\r\n\r\n    for (i = 0, s = Scores; i < MaxScores; i++, s++)\r\n    {\r\n        PrintY = 76 + (16 * i);\r\n\r\n        //\r\n        // name\r\n        //\r\n#ifndef SPEAR\r\n        PrintX = 4 * 8;\r\n#else\r\n        PrintX = 16;\r\n#endif\r\n        US_Print (s->name);\r\n\r\n        //\r\n        // level\r\n        //\r\n        itoa (s->completed, buffer, 10);\r\n#ifndef SPEAR\r\n        for (str = buffer; *str; str++)\r\n            *str = *str + (129 - '0');  // Used fixed-width numbers (129...)\r\n        USL_MeasureString (buffer, &w, &h);\r\n        PrintX = (22 * 8) - w;\r\n#else\r\n        USL_MeasureString (buffer, &w, &h);\r\n        PrintX = 194 - w;\r\n#endif\r\n\r\n#ifndef UPLOAD\r\n#ifndef SPEAR\r\n        PrintX -= 6;\r\n        itoa (s->episode + 1, buffer1, 10);\r\n        US_Print (\"E\");\r\n        US_Print (buffer1);\r\n        US_Print (\"/L\");\r\n#endif\r\n#endif\r\n\r\n#ifdef SPEAR\r\n        if (s->completed == 21)\r\n            VWB_DrawPic (PrintX + 8, PrintY - 1, C_WONSPEARPIC);\r\n        else\r\n#endif\r\n            US_Print (buffer);\r\n\r\n        //\r\n        // score\r\n        //\r\n        itoa (s->score, buffer, 10);\r\n#ifndef SPEAR\r\n        for (str = buffer; *str; str++)\r\n            *str = *str + (129 - '0');  // Used fixed-width numbers (129...)\r\n        USL_MeasureString (buffer, &w, &h);\r\n        PrintX = (34 * 8) - 8 - w;\r\n#else\r\n        USL_MeasureString (buffer, &w, &h);\r\n        PrintX = 292 - w;\r\n#endif\r\n        US_Print (buffer);\r\n\r\n#ifdef APOGEE_1_0\r\n//#ifndef UPLOAD\r\n#ifndef SPEAR\r\n        //\r\n        // verification #\r\n        //\r\n        if (!i)\r\n        {\r\n            char temp = (((s->score >> 28) & 0xf) ^ ((s->score >> 24) & 0xf)) + 'A';\r\n            char temp1 = (((s->score >> 20) & 0xf) ^ ((s->score >> 16) & 0xf)) + 'A';\r\n            char temp2 = (((s->score >> 12) & 0xf) ^ ((s->score >> 8) & 0xf)) + 'A';\r\n            char temp3 = (((s->score >> 4) & 0xf) ^ ((s->score >> 0) & 0xf)) + 'A';\r\n\r\n            SETFONTCOLOR (0x49, 0x29);\r\n            PrintX = 35 * 8;\r\n            buffer[0] = temp;\r\n            buffer[1] = temp1;\r\n            buffer[2] = temp2;\r\n            buffer[3] = temp3;\r\n            buffer[4] = 0;\r\n            US_Print (buffer);\r\n            SETFONTCOLOR (15, 0x29);\r\n        }\r\n#endif\r\n//#endif\r\n#endif\r\n    }\r\n\r\n    VW_UpdateScreen ();\r\n\r\n#ifdef SPEAR\r\n    UnCacheLump (HIGHSCORES_LUMP_START, HIGHSCORES_LUMP_END);\r\n    fontnumber = 0;\r\n#endif\r\n}\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n=======================\r\n=\r\n= CheckHighScore\r\n=\r\n=======================\r\n*/\r\n\r\nvoid\r\nCheckHighScore (int32_t score, word other)\r\n{\r\n    word i, j;\r\n    int n;\r\n    HighScore myscore;\r\n\r\n    strcpy (myscore.name, \"\");\r\n    myscore.score = score;\r\n    myscore.episode = gamestate.episode;\r\n    myscore.completed = other;\r\n\r\n    for (i = 0, n = -1; i < MaxScores; i++)\r\n    {\r\n        if ((myscore.score > Scores[i].score)\r\n            || ((myscore.score == Scores[i].score) && (myscore.completed > Scores[i].completed)))\r\n        {\r\n            for (j = MaxScores; --j > i;)\r\n                Scores[j] = Scores[j - 1];\r\n            Scores[i] = myscore;\r\n            n = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n#ifdef SPEAR\r\n    StartCPMusic (XAWARD_MUS);\r\n#else\r\n    StartCPMusic (ROSTER_MUS);\r\n#endif\r\n    DrawHighScores ();\r\n\r\n    VW_FadeIn ();\r\n\r\n    if (n != -1)\r\n    {\r\n        //\r\n        // got a high score\r\n        //\r\n        PrintY = 76 + (16 * n);\r\n#ifndef SPEAR\r\n        PrintX = 4 * 8;\r\n        backcolor = BORDCOLOR;\r\n        fontcolor = 15;\r\n        US_LineInput (PrintX, PrintY, Scores[n].name, 0, true, MaxHighName, 100);\r\n#else\r\n        PrintX = 16;\r\n        fontnumber = 1;\r\n        VWB_Bar (PrintX - 2, PrintY - 2, 145, 15, 0x9c);\r\n        VW_UpdateScreen ();\r\n        backcolor = 0x9c;\r\n        fontcolor = 15;\r\n        US_LineInput (PrintX, PrintY, Scores[n].name, 0, true, MaxHighName, 130);\r\n#endif\r\n    }\r\n    else\r\n    {\r\n        IN_ClearKeysDown ();\r\n        IN_UserInput (500);\r\n    }\r\n\r\n}\r\n\r\n\r\n#ifndef UPLOAD\r\n#ifndef SPEAR\r\n#ifndef JAPAN\r\n////////////////////////////////////////////////////////\r\n//\r\n// NON-SHAREWARE NOTICE\r\n//\r\n////////////////////////////////////////////////////////\r\nvoid\r\nNonShareware (void)\r\n{\r\n    VW_FadeOut ();\r\n\r\n    ClearMScreen ();\r\n    DrawStripes (10);\r\n\r\n    CA_CacheGrChunk (STARTFONT + 1);\r\n    fontnumber = 1;\r\n\r\n    SETFONTCOLOR (READHCOLOR, BKGDCOLOR);\r\n    PrintX = 110;\r\n    PrintY = 15;\r\n\r\n#ifdef SPANISH\r\n    US_Print (\"Atencion\");\r\n#else\r\n    US_Print (\"Attention\");\r\n#endif\r\n\r\n    SETFONTCOLOR (HIGHLIGHT, BKGDCOLOR);\r\n    WindowX = PrintX = 40;\r\n    PrintY = 60;\r\n#ifdef SPANISH\r\n    US_Print (\"Este juego NO es gratis y\\n\");\r\n    US_Print (\"NO es Shareware; favor de\\n\");\r\n    US_Print (\"no distribuirlo.\\n\\n\");\r\n#else\r\n    US_Print (\"This game is NOT shareware.\\n\");\r\n    US_Print (\"Please do not distribute it.\\n\");\r\n    US_Print (\"Thanks.\\n\\n\");\r\n#endif\r\n    US_Print (\"        Id Software\\n\");\r\n\r\n    VW_UpdateScreen ();\r\n    VW_FadeIn ();\r\n    IN_Ack ();\r\n}\r\n#endif\r\n#endif\r\n#endif\r\n\r\n#ifdef SPEAR\r\n#ifndef GOODTIMES\r\n#ifndef SPEARDEMO\r\n////////////////////////////////////////////////////////\r\n//\r\n// COPY PROTECTION FOR FormGen\r\n//\r\n////////////////////////////////////////////////////////\r\nchar CopyProFailedStrs[][100] = {\r\n    STR_COPY1,\r\n    STR_COPY2,\r\n\r\n    STR_COPY3,\r\n    STR_COPY4,\r\n\r\n    STR_COPY5,\r\n    STR_COPY6,\r\n\r\n    STR_COPY7,\r\n    STR_COPY8,\r\n\r\n    STR_COPY9,\r\n    \"\",\r\n\r\n    STR_COPY10,\r\n    STR_COPY11,\r\n\r\n    STR_COPY12,\r\n    \"\",\r\n\r\n    STR_COPY13,\r\n    \"\",\r\n\r\n    STR_COPY14,\r\n    \"\"\r\n};\r\n\r\nchar BackDoorStrs[5][16] = {\r\n    \"a spoon?\",\r\n    \"bite me!\",\r\n    \"joshua\",\r\n    \"pelt\",\r\n    \"snoops\"\r\n};\r\n\r\nchar GoodBoyStrs[10][40] = {\r\n    \"...is the CORRECT ANSWER!\",\r\n    \"\",\r\n\r\n    \"Consider yourself bitten, sir.\",\r\n    \"\",\r\n\r\n    \"Greetings Professor Falken, would you\",\r\n    \"like to play Spear of Destiny?\",\r\n\r\n    \"Do you have any gold spray paint?\",\r\n    \"\",\r\n\r\n    \"I wish I had a 21\\\" monitor...\",\r\n    \"\"\r\n};\r\n\r\nchar bossstrs[4][24] = {\r\n    \"DEATH KNIGHT\",\r\n    \"BARNACLE WILHELM\",\r\n    \"UBERMUTANTUBER MUTANT\",\r\n    \"TRANS GROSSE\"\r\n};\r\n\r\nchar WordStr[5][20] = {\r\n    \"New Game\",\r\n    \"Sound...F4\",\r\n    \"Control...F6\",\r\n    \"Change View...F5\",\r\n    \"Quit...F10\"\r\n};\r\n\r\nchar WordCorrect[5][2] = { \"3\", \"4\", \"4\", \"5\", \"5\" };\r\n\r\nchar MemberStr[10][40] = {\r\n    STR_COPY15,\r\n    \"\",\r\n\r\n    STR_COPY16,\r\n    \"\",\r\n\r\n    STR_COPY17,\r\n    STR_COPY18,\r\n\r\n    STR_COPY19,\r\n    STR_COPY20,\r\n\r\n    STR_COPY21,\r\n    STR_COPY22\r\n};\r\n\r\nchar MemberCorrect[5][24] = {\r\n    \"adrian carmack\",\r\n    \"john carmackjohn romero\",\r\n    \"tom hall\",\r\n    \"jay wilbur\",\r\n    \"kevin cloud\"\r\n};\r\n\r\nchar DosMessages[9][80] = {\r\n    STR_NOPE1,\r\n    STR_NOPE2,\r\n    STR_NOPE3,\r\n    STR_NOPE4,\r\n    STR_NOPE5,\r\n    STR_NOPE6,\r\n    STR_NOPE7,\r\n    STR_NOPE8,\r\n    STR_NOPE9\r\n};\r\n\r\nchar MiscTitle[4][20] = {\r\n    \"BLOOD TEST\",\r\n    \"STRAIGHT-LACED\",\r\n    \"QUITE SHAPELY\",\r\n    \"I AM WHAT I AMMO\"\r\n};\r\n\r\nchar MiscStr[12][40] = {\r\n    STR_MISC1,\r\n    STR_MISC2,\r\n    \"\",\r\n\r\n    STR_MISC3,\r\n    STR_MISC4,\r\n    \"\",\r\n\r\n    STR_MISC5,\r\n    STR_MISC6,\r\n    \"\",\r\n\r\n    STR_MISC7,\r\n    STR_MISC8,\r\n    STR_MISC9\r\n};\r\n\r\nchar MiscCorrect[4][5] = { \"ss\", \"8\", STR_STAR, \"45\" };\r\n\r\n\r\nint\r\nBackDoor (char *s)\r\n{\r\n    for (int i = 0; i < 5; i++)\r\n    {\r\n        if (!strcasecmp (s, BackDoorStrs[i]))\r\n        {\r\n            SETFONTCOLOR (14, 15);\r\n            fontnumber = 0;\r\n            PrintY = 175;\r\n            VWB_DrawPic (0, 20 * 8, COPYPROTBOXPIC);\r\n            US_CPrint (GoodBoyStrs[i * 2]);\r\n            US_CPrint (GoodBoyStrs[i * 2 + 1]);\r\n            VW_UpdateScreen ();\r\n            return 1;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n\r\nvoid\r\nCopyProtection (void)\r\n{\r\n#define TYPEBOX_Y       177\r\n#define TYPEBOX_BKGD    0x9c\r\n#define PRINTCOLOR      HIGHLIGHT\r\n\r\n    unsigned i;\r\n    int match, whichboss, bossnum, attempt, whichline;\r\n    int enemypicked[4] = { 0, 0, 0, 0 };\r\n    int bosses[4] = { BOSSPIC1PIC, BOSSPIC2PIC, BOSSPIC3PIC, BOSSPIC4PIC };\r\n    int whichpicked[4] = { 0, 0, 0, 0 };\r\n    int whichone, quiztype, whichmem, whichword;\r\n    int memberpicked[5] = { 0, 0, 0, 0, 0 };\r\n    int wordpicked[5] = { 0, 0, 0, 0, 0 };\r\n\r\n    char inputbuffer[20];\r\n    char message[80];\r\n\r\n    enum\r\n    {\r\n        debriefing,\r\n        checkmanual,\r\n        staffquiz,\r\n        miscquiz,\r\n\r\n        totaltypes\r\n    };\r\n\r\n\r\n\r\n    attempt = 0;\r\n    VW_FadeOut ();\r\n    CA_CacheGrChunk (C_BACKDROPPIC);\r\n    CacheLump (COPYPROT_LUMP_START, COPYPROT_LUMP_END);\r\n    CA_CacheGrChunk (STARTFONT + 1);\r\n    CA_LoadAllSounds ();\r\n    StartCPMusic (COPYPRO_MUS);\r\n    US_InitRndT (true);\r\n\r\n    while (attempt < 3)\r\n    {\r\n        fontnumber = 1;\r\n        SETFONTCOLOR (PRINTCOLOR - 2, 15);\r\n        VWB_DrawPic (0, 0, C_BACKDROPPIC);\r\n        VWB_DrawPic (0, 0, COPYPROTTOPPIC);\r\n        VWB_DrawPic (0, 20 * 8, COPYPROTBOXPIC);\r\n        WindowX = WindowY = 0;\r\n        WindowW = 320;\r\n        WindowH = 200;\r\n        PrintY = 65;\r\n\r\n        quiztype = US_RndT () % totaltypes;\r\n        switch (quiztype)\r\n        {\r\n            //\r\n            // BOSSES QUIZ\r\n            //\r\n            case debriefing:\r\n            {\r\n                PrintX = 0;\r\n                US_Print (STR_DEBRIEF);\r\n                SETFONTCOLOR (PRINTCOLOR, 15);\r\n\r\n                while (enemypicked[whichboss = US_RndT () & 3]);\r\n                enemypicked[whichboss] = 1;\r\n                bossnum = bosses[whichboss];\r\n                VWB_DrawPic (128, 60, bossnum);\r\n                fontnumber = 0;\r\n                PrintY = 130;\r\n                US_CPrint (STR_ENEMY1 \"\\n\");\r\n                US_CPrint (STR_ENEMY2 \"\\n\\n\");\r\n\r\n                VW_UpdateScreen ();\r\n                VW_FadeIn ();\r\n\r\n                PrintX = 100;\r\n                fontcolor = 15;\r\n                backcolor = TYPEBOX_BKGD;\r\n                inputbuffer[0] = 0;\r\n                PrintY = TYPEBOX_Y;\r\n                fontnumber = 1;\r\n                US_LineInput (PrintX, PrintY, inputbuffer, 0, true, 20, 100);\r\n\r\n                match = 0;\r\n                size_t inputlen = strlen(inputbuffer);\r\n                if(inputlen > 3)\r\n                {\r\n                    size_t bosslen = strlen(bossstrs[whichboss]);\r\n                    for (i = 0; i < bosslen; i++)\r\n                    {\r\n                        if (!strncasecmp (inputbuffer, bossstrs[whichboss] + i, inputlen))\r\n                        {\r\n                            match = 1;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                match += BackDoor (inputbuffer);\r\n                break;\r\n            }\r\n\r\n            //\r\n            // MANUAL CHECK\r\n            //\r\n            case checkmanual:\r\n            {\r\n                while (wordpicked[whichword = US_RndT () % 5]);\r\n                wordpicked[whichword] = 1;\r\n                US_CPrint (STR_CHECKMAN);\r\n                SETFONTCOLOR (PRINTCOLOR, 15);\r\n                PrintY += 25;\r\n                US_CPrint (STR_MAN1);\r\n                US_CPrint (STR_MAN2);\r\n                sprintf(message, STR_MAN3 \" \\\"%s\\\" \" STR_MAN4, WordStr[whichword]);\r\n                US_CPrint (message);\r\n                VW_UpdateScreen ();\r\n                VW_FadeIn ();\r\n\r\n                PrintX = 146;\r\n                fontcolor = 15;\r\n                backcolor = TYPEBOX_BKGD;\r\n                inputbuffer[0] = 0;\r\n                PrintY = TYPEBOX_Y;\r\n                US_LineInput (PrintX, PrintY, inputbuffer, 0, true, 6, 100);\r\n\r\n                match = 1 - (strcasecmp (inputbuffer, WordCorrect[whichword]) != 0);\r\n                match += BackDoor (inputbuffer);\r\n                break;\r\n            }\r\n\r\n            //\r\n            // STAFF QUIZ\r\n            //\r\n            case staffquiz:\r\n            {\r\n                while (memberpicked[whichmem = US_RndT () % 5]);\r\n                memberpicked[whichmem] = 1;\r\n                US_CPrint (STR_ID1);\r\n                SETFONTCOLOR (PRINTCOLOR, 15);\r\n                PrintY += 25;\r\n                US_CPrint (MemberStr[whichmem * 2]);\r\n                US_CPrint (MemberStr[whichmem * 2 + 1]);\r\n                VW_UpdateScreen ();\r\n                VW_FadeIn ();\r\n\r\n                PrintX = 100;\r\n                fontcolor = 15;\r\n                backcolor = TYPEBOX_BKGD;\r\n                inputbuffer[0] = 0;\r\n                PrintY = TYPEBOX_Y;\r\n                US_LineInput (PrintX, PrintY, inputbuffer, 0, true, 20, 120);\r\n\r\n                match = 0;\r\n                size_t inputlen = strlen(inputbuffer);\r\n                if(inputlen > 2)\r\n                {\r\n                    size_t memberlen = strlen(MemberCorrect[whichmem]);\r\n                    for (i = 0; i < memberlen; i++)\r\n                    {\r\n                        if (!strncasecmp (inputbuffer, MemberCorrect[whichmem] + i, inputlen))\r\n                        {\r\n                            match = 1;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                match += BackDoor (inputbuffer);\r\n                break;\r\n            }\r\n\r\n            //\r\n            // MISCELLANEOUS QUESTIONS\r\n            //\r\n            case miscquiz:\r\n            {\r\n                while (whichpicked[whichone = US_RndT () & 3]);\r\n                whichpicked[whichone] = 1;\r\n                US_CPrint (MiscTitle[whichone]);\r\n                SETFONTCOLOR (PRINTCOLOR, 15);\r\n                PrintY += 25;\r\n                US_CPrint (MiscStr[whichone * 3]);\r\n                US_CPrint (MiscStr[whichone * 3 + 1]);\r\n                US_CPrint (MiscStr[whichone * 3 + 2]);\r\n                VW_UpdateScreen ();\r\n                VW_FadeIn ();\r\n\r\n                PrintX = 146;\r\n                fontcolor = 15;\r\n                backcolor = TYPEBOX_BKGD;\r\n                inputbuffer[0] = 0;\r\n                PrintY = TYPEBOX_Y;\r\n                US_LineInput (PrintX, PrintY, inputbuffer, 0, true, 6, 100);\r\n\r\n                match = 1 - (strcasecmp (inputbuffer, MiscCorrect[whichone]) != 0);\r\n                match += BackDoor (inputbuffer);\r\n                break;\r\n            }\r\n        }\r\n\r\n        //\r\n        // IF NO MATCH, WE'VE GOT A (MINOR) PROBLEM!\r\n        //\r\n\r\n        if (!match)\r\n        {\r\n            whichline = 2 * (US_RndT () % 9);\r\n            SETFONTCOLOR (14, 15);\r\n            fontnumber = 0;\r\n            PrintY = 175;\r\n            VWB_DrawPic (0, 20 * 8, COPYPROTBOXPIC);\r\n            US_CPrint (CopyProFailedStrs[whichline]);\r\n            US_CPrint (CopyProFailedStrs[whichline + 1]);\r\n\r\n            VW_UpdateScreen ();\r\n            SD_PlaySound (NOWAYSND);\r\n            IN_UserInput (TickBase * 6);\r\n            VW_FadeOut ();\r\n            attempt++;\r\n        }\r\n        else\r\n        {\r\n            int start;\r\n\r\n            SD_PlaySound (BONUS1UPSND);\r\n            SD_WaitSoundDone ();\r\n            UNCACHEGRCHUNK (STARTFONT + 1);\r\n            UNCACHEGRCHUNK (C_BACKDROPPIC);\r\n            UnCacheLump (COPYPROT_LUMP_START, COPYPROT_LUMP_END);\r\n\r\n            switch (SoundMode)\r\n            {\r\n                case sdm_Off:\r\n                    return;\r\n                case sdm_PC:\r\n                    start = STARTPCSOUNDS;\r\n                    break;\r\n                case sdm_AdLib:\r\n                    start = STARTADLIBSOUNDS;\r\n            }\r\n\r\n/*                        for (i=0;i<NUMSOUNDS;i++,start++)\r\n                                MM_FreePtr ((memptr *)&audiosegs[start]); */\r\n            return;\r\n        }\r\n    }\r\n\r\n    ClearMemory ();\r\n    ShutdownId ();\r\n\r\n    printf (\"%s\\n\", DosMessages[US_RndT () % 9]);\r\n    exit (1);\r\n}\r\n\r\n#endif // SPEARDEMO\r\n#endif // GOODTIMES\r\n#endif // SPEAR\r\n//===========================================================================\r\n","// WL_MAIN.C\r\n\r\n#ifdef _WIN32\r\n    #include <io.h>\r\n#else\r\n    #include <unistd.h>\r\n#endif\r\n\r\n#include \"wl_def.h\"\r\n#pragma hdrstop\r\n\r\n#ifdef __EMSCRIPTEN__\r\n#include <emscripten.h>\r\n#endif\r\n\r\n\r\nvoid em_noop_main_loop() {\r\n\r\n}\r\n\r\n/*\r\n=============================================================================\r\n\r\n                             WOLFENSTEIN 3-D\r\n\r\n                        An Id Software production\r\n\r\n                             by John Carmack\r\n\r\n=============================================================================\r\n*/\r\n\r\nextern byte signon[];\r\n\r\n/*\r\n=============================================================================\r\n\r\n                             LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n#define FOCALLENGTH     (0x5700l)               // in global coordinates\r\n//#define FOCALLENGTH     (0x0200l)               // in global coordinates\r\n#define VIEWGLOBAL      0x10000                 // globals visable flush to wall\r\n\r\n#define VIEWWIDTH       256                     // size of view window\r\n#define VIEWHEIGHT      144\r\n\r\n/*\r\n=============================================================================\r\n\r\n                            GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nchar    str[80];\r\nint     dirangle[9] = {0,ANGLES/8,2*ANGLES/8,3*ANGLES/8,4*ANGLES/8,\r\n                       5*ANGLES/8,6*ANGLES/8,7*ANGLES/8,ANGLES};\r\n\r\n//\r\n// proejection variables\r\n//\r\nfixed    focallength;\r\nunsigned screenofs;\r\nint      viewscreenx, viewscreeny;\r\nint      viewwidth;\r\nint      viewheight;\r\nshort    centerx;\r\nint      shootdelta;           // pixels away from centerx a target can be\r\nfixed    scale;\r\nint32_t  heightnumerator;\r\n\r\n\r\nvoid    Quit (const char *error,...);\r\n\r\nboolean startgame;\r\nboolean loadedgame;\r\nint     mouseadjustment;\r\n\r\nchar    configdir[256] = \"\";\r\nchar    configname[13] = \"config.\";\r\n\r\n//\r\n// Command line parameter variables\r\n//\r\nboolean param_debugmode = false;\r\nboolean param_nowait = false;\r\nint     param_difficulty = 1;           // default is \"normal\"\r\nint     param_tedlevel = -1;            // default is not to start a level\r\nint     param_joystickindex = 0;\r\n\r\n\r\nint     param_joystickhat = -1;\r\nint     param_samplerate = 44100;\r\nint     param_audiobuffer = 2048 / (44100 / param_samplerate);\r\n\r\nint     param_mission = 0;\r\nboolean param_goodtimes = false;\r\nboolean param_ignorenumchunks = false;\r\n\r\n/*\r\n=============================================================================\r\n\r\n                            LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= ReadConfig\r\n=\r\n====================\r\n*/\r\n\r\nvoid ReadConfig(void)\r\n{\r\n    SDMode  sd;\r\n    SMMode  sm;\r\n    SDSMode sds;\r\n\r\n    char configpath[300];\r\n\r\n\r\n    if(configdir[0])\r\n        snprintf(configpath, sizeof(configpath), \"%s/%s\", configdir, configname);\r\n    else\r\n        strcpy(configpath, configname);\r\n\r\n    const int file = open(configpath, O_RDONLY | O_BINARY);\r\n    if (file != -1)\r\n    {\r\n        //\r\n        // valid config file\r\n        //\r\n        word tmp;\r\n        read(file,&tmp,sizeof(tmp));\r\n        if(tmp!=0xfefa)\r\n        {\r\n            close(file);\r\n            goto noconfig;\r\n        }\r\n        read(file,Scores,sizeof(HighScore) * MaxScores);\r\n\r\n        read(file,&sd,sizeof(sd));\r\n        read(file,&sm,sizeof(sm));\r\n        read(file,&sds,sizeof(sds));\r\n\r\n        read(file,&mouseenabled,sizeof(mouseenabled));\r\n        read(file,&joystickenabled,sizeof(joystickenabled));\r\n        boolean dummyJoypadEnabled;\r\n        read(file,&dummyJoypadEnabled,sizeof(dummyJoypadEnabled));\r\n        boolean dummyJoystickProgressive;\r\n        read(file,&dummyJoystickProgressive,sizeof(dummyJoystickProgressive));\r\n        int dummyJoystickPort = 0;\r\n        read(file,&dummyJoystickPort,sizeof(dummyJoystickPort));\r\n\r\n        read(file,dirscan,sizeof(dirscan));\r\n        read(file,buttonscan,sizeof(buttonscan));\r\n        read(file,buttonmouse,sizeof(buttonmouse));\r\n        read(file,buttonjoy,sizeof(buttonjoy));\r\n\r\n        read(file,&viewsize,sizeof(viewsize));\r\n        read(file,&mouseadjustment,sizeof(mouseadjustment));\r\n\r\n        close(file);\r\n\r\n        if ((sd == sdm_AdLib || sm == smm_AdLib) && !AdLibPresent\r\n                && !SoundBlasterPresent)\r\n        {\r\n            sd = sdm_PC;\r\n            sm = smm_Off;\r\n        }\r\n\r\n        if ((sds == sds_SoundBlaster && !SoundBlasterPresent))\r\n            sds = sds_Off;\r\n\r\n        // make sure values are correct\r\n\r\n        if(mouseenabled) mouseenabled=true;\r\n        if(joystickenabled) joystickenabled=true;\r\n\r\n        if (!MousePresent)\r\n            mouseenabled = false;\r\n        if (!IN_JoyPresent())\r\n            joystickenabled = false;\r\n\r\n        if(mouseadjustment<0) mouseadjustment=0;\r\n        else if(mouseadjustment>9) mouseadjustment=9;\r\n\r\n        if(viewsize<4) viewsize=4;\r\n        else if(viewsize>21) viewsize=21;\r\n\r\n        MainMenu[6].active=1;\r\n        MainItems.curpos=0;\r\n    }\r\n    else\r\n    {\r\n        //\r\n        // no config file, so select by hardware\r\n        //\r\nnoconfig:\r\n        if (SoundBlasterPresent || AdLibPresent)\r\n        {\r\n            sd = sdm_AdLib;\r\n            sm = smm_AdLib;\r\n        }\r\n        else\r\n        {\r\n            sd = sdm_PC;\r\n            sm = smm_Off;\r\n        }\r\n\r\n        if (SoundBlasterPresent)\r\n            sds = sds_SoundBlaster;\r\n        else\r\n            sds = sds_Off;\r\n\r\n        if (MousePresent)\r\n            mouseenabled = true;\r\n\r\n        if (IN_JoyPresent())\r\n            joystickenabled = true;\r\n\r\n        viewsize = 19;                          // start with a good size\r\n        mouseadjustment=5;\r\n    }\r\n\r\n    printf(\"init sound sm=%d sd=%d sds=%d\\n\", sm,sd,sds);\r\n\r\n    SD_SetMusicMode (sm);\r\n    SD_SetSoundMode (sd);\r\n    SD_SetDigiDevice (sds);\r\n}\r\n\r\n/*\r\n====================\r\n=\r\n= WriteConfig\r\n=\r\n====================\r\n*/\r\n\r\nvoid WriteConfig(void)\r\n{\r\n    char configpath[300];\r\n\r\n    if(configdir[0])\r\n        snprintf(configpath, sizeof(configpath), \"%s/%s\", configdir, configname);\r\n    else\r\n        strcpy(configpath, configname);\r\n\r\n    const int file = open(configpath, O_CREAT | O_WRONLY | O_BINARY, 0644);\r\n    if (file != -1)\r\n    {\r\n        word tmp=0xfefa;\r\n        write(file,&tmp,sizeof(tmp));\r\n        write(file,Scores,sizeof(HighScore) * MaxScores);\r\n\r\n        write(file,&SoundMode,sizeof(SoundMode));\r\n        write(file,&MusicMode,sizeof(MusicMode));\r\n        write(file,&DigiMode,sizeof(DigiMode));\r\n\r\n        write(file,&mouseenabled,sizeof(mouseenabled));\r\n        write(file,&joystickenabled,sizeof(joystickenabled));\r\n        boolean dummyJoypadEnabled = false;\r\n        write(file,&dummyJoypadEnabled,sizeof(dummyJoypadEnabled));\r\n        boolean dummyJoystickProgressive = false;\r\n        write(file,&dummyJoystickProgressive,sizeof(dummyJoystickProgressive));\r\n        int dummyJoystickPort = 0;\r\n        write(file,&dummyJoystickPort,sizeof(dummyJoystickPort));\r\n\r\n        write(file,dirscan,sizeof(dirscan));\r\n        write(file,buttonscan,sizeof(buttonscan));\r\n        write(file,buttonmouse,sizeof(buttonmouse));\r\n        write(file,buttonjoy,sizeof(buttonjoy));\r\n\r\n        write(file,&viewsize,sizeof(viewsize));\r\n        write(file,&mouseadjustment,sizeof(mouseadjustment));\r\n\r\n        close(file);\r\n    }\r\n\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= NewGame\r\n=\r\n= Set up new game to start from the beginning\r\n=\r\n=====================\r\n*/\r\n\r\nvoid NewGame (int difficulty,int episode)\r\n{\r\n    memset (&gamestate,0,sizeof(gamestate));\r\n    gamestate.difficulty = difficulty;\r\n    gamestate.weapon = gamestate.bestweapon\r\n            = gamestate.chosenweapon = wp_pistol;\r\n    gamestate.health = 100;\r\n    gamestate.ammo = STARTAMMO;\r\n    gamestate.lives = 3;\r\n    gamestate.nextextra = EXTRAPOINTS;\r\n    gamestate.episode=episode;\r\n\r\n    startgame = true;\r\n}\r\n\r\n//===========================================================================\r\n\r\nvoid DiskFlopAnim(int x,int y)\r\n{\r\n    static int8_t which=0;\r\n    if (!x && !y)\r\n        return;\r\n    VWB_DrawPic(x,y,C_DISKLOADING1PIC+which);\r\n    VW_UpdateScreen();\r\n    which^=1;\r\n}\r\n\r\n\r\nint32_t DoChecksum(byte *source,unsigned size,int32_t checksum)\r\n{\r\n    unsigned i;\r\n\r\n    for (i=0;i<size-1;i++)\r\n    checksum += source[i]^source[i+1];\r\n\r\n    return checksum;\r\n}\r\n\r\n\r\n/*\r\n==================\r\n=\r\n= SaveTheGame\r\n=\r\n==================\r\n*/\r\n\r\nextern statetype s_grdstand;\r\nextern statetype s_player;\r\n\r\nboolean SaveTheGame(FILE *file,int x,int y)\r\n{\r\n//    struct diskfree_t dfree;\r\n//    int32_t avail,size,checksum;\r\n    int checksum;\r\n    objtype *ob;\r\n    objtype nullobj;\r\n    statobj_t nullstat;\r\n\r\n/*    if (_dos_getdiskfree(0,&dfree))\r\n        Quit(\"Error in _dos_getdiskfree call\");\r\n\r\n    avail = (int32_t)dfree.avail_clusters *\r\n                  dfree.bytes_per_sector *\r\n                  dfree.sectors_per_cluster;\r\n\r\n    size = 0;\r\n    for (ob = player; ob ; ob=ob->next)\r\n        size += sizeof(*ob);\r\n    size += sizeof(nullobj);\r\n\r\n    size += sizeof(gamestate) +\r\n            sizeof(LRstruct)*LRpack +\r\n            sizeof(tilemap) +\r\n            sizeof(actorat) +\r\n            sizeof(laststatobj) +\r\n            sizeof(statobjlist) +\r\n            sizeof(doorposition) +\r\n            sizeof(pwallstate) +\r\n            sizeof(pwalltile) +\r\n            sizeof(pwallx) +\r\n            sizeof(pwally) +\r\n            sizeof(pwalldir) +\r\n            sizeof(pwallpos);\r\n\r\n    if (avail < size)\r\n    {\r\n        Message(STR_NOSPACE1\"\\n\"STR_NOSPACE2);\r\n        return false;\r\n    }*/\r\n\r\n    checksum = 0;\r\n\r\n    DiskFlopAnim(x,y);\r\n    fwrite(&gamestate,sizeof(gamestate),1,file);\r\n    checksum = DoChecksum((byte *)&gamestate,sizeof(gamestate),checksum);\r\n\r\n    DiskFlopAnim(x,y);\r\n    fwrite(&LevelRatios[0],sizeof(LRstruct)*LRpack,1,file);\r\n    checksum = DoChecksum((byte *)&LevelRatios[0],sizeof(LRstruct)*LRpack,checksum);\r\n\r\n    DiskFlopAnim(x,y);\r\n    fwrite(tilemap,sizeof(tilemap),1,file);\r\n    checksum = DoChecksum((byte *)tilemap,sizeof(tilemap),checksum);\r\n    DiskFlopAnim(x,y);\r\n\r\n    int i;\r\n    for(i=0;i<MAPSIZE;i++)\r\n    {\r\n        for(int j=0;j<MAPSIZE;j++)\r\n        {\r\n            word actnum;\r\n            objtype *objptr=actorat[i][j];\r\n            if(ISPOINTER(objptr))\r\n                actnum=0x8000 | (word)(objptr-objlist);\r\n            else\r\n                actnum=(word)(uintptr_t)objptr;\r\n            fwrite(&actnum,sizeof(actnum),1,file);\r\n            checksum = DoChecksum((byte *)&actnum,sizeof(actnum),checksum);\r\n        }\r\n    }\r\n\r\n    fwrite (areaconnect,sizeof(areaconnect),1,file);\r\n    fwrite (areabyplayer,sizeof(areabyplayer),1,file);\r\n\r\n    // player object needs special treatment as it's in WL_AGENT.CPP and not in\r\n    // WL_ACT2.CPP which could cause problems for the relative addressing\r\n\r\n    ob = player;\r\n    DiskFlopAnim(x,y);\r\n    memcpy(&nullobj,ob,sizeof(nullobj));\r\n    nullobj.state=(statetype *) ((uintptr_t)nullobj.state-(uintptr_t)&s_player);\r\n    fwrite(&nullobj,sizeof(nullobj),1,file);\r\n    ob = ob->next;\r\n\r\n    DiskFlopAnim(x,y);\r\n    for (; ob ; ob=ob->next)\r\n    {\r\n        memcpy(&nullobj,ob,sizeof(nullobj));\r\n        nullobj.state=(statetype *) ((uintptr_t)nullobj.state-(uintptr_t)&s_grdstand);\r\n        fwrite(&nullobj,sizeof(nullobj),1,file);\r\n    }\r\n    nullobj.active = ac_badobject;          // end of file marker\r\n    DiskFlopAnim(x,y);\r\n    fwrite(&nullobj,sizeof(nullobj),1,file);\r\n\r\n    DiskFlopAnim(x,y);\r\n    word laststatobjnum=(word) (laststatobj-statobjlist);\r\n    fwrite(&laststatobjnum,sizeof(laststatobjnum),1,file);\r\n    checksum = DoChecksum((byte *)&laststatobjnum,sizeof(laststatobjnum),checksum);\r\n\r\n    DiskFlopAnim(x,y);\r\n    for(i=0;i<MAXSTATS;i++)\r\n    {\r\n        memcpy(&nullstat,statobjlist+i,sizeof(nullstat));\r\n        nullstat.visspot=(byte *) ((uintptr_t) nullstat.visspot-(uintptr_t)spotvis);\r\n        fwrite(&nullstat,sizeof(nullstat),1,file);\r\n        checksum = DoChecksum((byte *)&nullstat,sizeof(nullstat),checksum);\r\n    }\r\n\r\n    DiskFlopAnim(x,y);\r\n    fwrite (doorposition,sizeof(doorposition),1,file);\r\n    checksum = DoChecksum((byte *)doorposition,sizeof(doorposition),checksum);\r\n    DiskFlopAnim(x,y);\r\n    fwrite (doorobjlist,sizeof(doorobjlist),1,file);\r\n    checksum = DoChecksum((byte *)doorobjlist,sizeof(doorobjlist),checksum);\r\n\r\n    DiskFlopAnim(x,y);\r\n    fwrite (&pwallstate,sizeof(pwallstate),1,file);\r\n    checksum = DoChecksum((byte *)&pwallstate,sizeof(pwallstate),checksum);\r\n    fwrite (&pwalltile,sizeof(pwalltile),1,file);\r\n    checksum = DoChecksum((byte *)&pwalltile,sizeof(pwalltile),checksum);\r\n    fwrite (&pwallx,sizeof(pwallx),1,file);\r\n    checksum = DoChecksum((byte *)&pwallx,sizeof(pwallx),checksum);\r\n    fwrite (&pwally,sizeof(pwally),1,file);\r\n    checksum = DoChecksum((byte *)&pwally,sizeof(pwally),checksum);\r\n    fwrite (&pwalldir,sizeof(pwalldir),1,file);\r\n    checksum = DoChecksum((byte *)&pwalldir,sizeof(pwalldir),checksum);\r\n    fwrite (&pwallpos,sizeof(pwallpos),1,file);\r\n    checksum = DoChecksum((byte *)&pwallpos,sizeof(pwallpos),checksum);\r\n\r\n    //\r\n    // WRITE OUT CHECKSUM\r\n    //\r\n    fwrite (&checksum,sizeof(checksum),1,file);\r\n\r\n    fwrite (&lastgamemusicoffset,sizeof(lastgamemusicoffset),1,file);\r\n\r\n    return(true);\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n==================\r\n=\r\n= LoadTheGame\r\n=\r\n==================\r\n*/\r\n\r\nboolean LoadTheGame(FILE *file,int x,int y)\r\n{\r\n    int32_t checksum,oldchecksum;\r\n    objtype nullobj;\r\n    statobj_t nullstat;\r\n\r\n    checksum = 0;\r\n\r\n    DiskFlopAnim(x,y);\r\n    fread (&gamestate,sizeof(gamestate),1,file);\r\n    checksum = DoChecksum((byte *)&gamestate,sizeof(gamestate),checksum);\r\n\r\n    DiskFlopAnim(x,y);\r\n    fread (&LevelRatios[0],sizeof(LRstruct)*LRpack,1,file);\r\n    checksum = DoChecksum((byte *)&LevelRatios[0],sizeof(LRstruct)*LRpack,checksum);\r\n\r\n    DiskFlopAnim(x,y);\r\n    SetupGameLevel ();\r\n\r\n    DiskFlopAnim(x,y);\r\n    fread (tilemap,sizeof(tilemap),1,file);\r\n    checksum = DoChecksum((byte *)tilemap,sizeof(tilemap),checksum);\r\n\r\n    DiskFlopAnim(x,y);\r\n\r\n    int actnum=0, i;\r\n    for(i=0;i<MAPSIZE;i++)\r\n    {\r\n        for(int j=0;j<MAPSIZE;j++)\r\n        {\r\n            fread (&actnum,sizeof(word),1,file);\r\n            checksum = DoChecksum((byte *) &actnum,sizeof(word),checksum);\r\n            if(actnum&0x8000)\r\n                actorat[i][j]=objlist+(actnum&0x7fff);\r\n            else\r\n                actorat[i][j]=(objtype *)(uintptr_t) actnum;\r\n        }\r\n    }\r\n\r\n    fread (areaconnect,sizeof(areaconnect),1,file);\r\n    fread (areabyplayer,sizeof(areabyplayer),1,file);\r\n\r\n    InitActorList ();\r\n    DiskFlopAnim(x,y);\r\n    fread (player,sizeof(*player),1,file);\r\n    player->state=(statetype *) ((uintptr_t)player->state+(uintptr_t)&s_player);\r\n\r\n    //Load all actors ?\r\n    while (1)\r\n    {\r\n        DiskFlopAnim(x,y);\r\n        fread (&nullobj,sizeof(nullobj),1,file);\r\n        if (nullobj.active == ac_badobject)\r\n            break;\r\n        GetNewActor ();\r\n        nullobj.state=(statetype *) ((uintptr_t)nullobj.state+(uintptr_t)&s_grdstand);\r\n        // don't copy over the links\r\n        memcpy (newobj,&nullobj,sizeof(nullobj)-8);\r\n    }\r\n\r\n    DiskFlopAnim(x,y);\r\n    word laststatobjnum;\r\n    fread (&laststatobjnum,sizeof(laststatobjnum),1,file);\r\n    laststatobj=statobjlist+laststatobjnum;\r\n    checksum = DoChecksum((byte *)&laststatobjnum,sizeof(laststatobjnum),checksum);\r\n\r\n    DiskFlopAnim(x,y);\r\n    for(i=0;i<MAXSTATS;i++)\r\n    {\r\n        fread(&nullstat,sizeof(nullstat),1,file);\r\n        checksum = DoChecksum((byte *)&nullstat,sizeof(nullstat),checksum);\r\n        nullstat.visspot=(byte *) ((uintptr_t)nullstat.visspot+(uintptr_t)spotvis);\r\n        memcpy(statobjlist+i,&nullstat,sizeof(nullstat));\r\n    }\r\n\r\n    DiskFlopAnim(x,y);\r\n    fread (doorposition,sizeof(doorposition),1,file);\r\n    checksum = DoChecksum((byte *)doorposition,sizeof(doorposition),checksum);\r\n    DiskFlopAnim(x,y);\r\n    fread (doorobjlist,sizeof(doorobjlist),1,file);\r\n    checksum = DoChecksum((byte *)doorobjlist,sizeof(doorobjlist),checksum);\r\n\r\n    DiskFlopAnim(x,y);\r\n    fread (&pwallstate,sizeof(pwallstate),1,file);\r\n    checksum = DoChecksum((byte *)&pwallstate,sizeof(pwallstate),checksum);\r\n    fread (&pwalltile,sizeof(pwalltile),1,file);\r\n    checksum = DoChecksum((byte *)&pwalltile,sizeof(pwalltile),checksum);\r\n    fread (&pwallx,sizeof(pwallx),1,file);\r\n    checksum = DoChecksum((byte *)&pwallx,sizeof(pwallx),checksum);\r\n    fread (&pwally,sizeof(pwally),1,file);\r\n    checksum = DoChecksum((byte *)&pwally,sizeof(pwally),checksum);\r\n    fread (&pwalldir,sizeof(pwalldir),1,file);\r\n    checksum = DoChecksum((byte *)&pwalldir,sizeof(pwalldir),checksum);\r\n    fread (&pwallpos,sizeof(pwallpos),1,file);\r\n    checksum = DoChecksum((byte *)&pwallpos,sizeof(pwallpos),checksum);\r\n\r\n    if (gamestate.secretcount)      // assign valid floorcodes under moved pushwalls\r\n    {\r\n        word *map, *obj; word tile, sprite;\r\n        map = mapsegs[0]; obj = mapsegs[1];\r\n        for (y=0;y<mapheight;y++)\r\n            for (x=0;x<mapwidth;x++)\r\n            {\r\n                tile = *map++; sprite = *obj++;\r\n                if (sprite == PUSHABLETILE && !tilemap[x][y]\r\n                    && (tile < AREATILE || tile >= (AREATILE+NUMMAPS)))\r\n                {\r\n                    if (*map >= AREATILE)\r\n                        tile = *map;\r\n                    if (*(map-1-mapwidth) >= AREATILE)\r\n                        tile = *(map-1-mapwidth);\r\n                    if (*(map-1+mapwidth) >= AREATILE)\r\n                        tile = *(map-1+mapwidth);\r\n                    if ( *(map-2) >= AREATILE)\r\n                        tile = *(map-2);\r\n\r\n                    *(map-1) = tile; *(obj-1) = 0;\r\n                }\r\n            }\r\n    }\r\n\r\n    Thrust(0,0);    // set player->areanumber to the floortile you're standing on\r\n\r\n    fread (&oldchecksum,sizeof(oldchecksum),1,file);\r\n\r\n    fread (&lastgamemusicoffset,sizeof(lastgamemusicoffset),1,file);\r\n    if(lastgamemusicoffset<0) lastgamemusicoffset=0;\r\n\r\n\r\n    if (oldchecksum != checksum)\r\n    {\r\n        Message(STR_SAVECHT1\"\\n\"\r\n                STR_SAVECHT2\"\\n\"\r\n                STR_SAVECHT3\"\\n\"\r\n                STR_SAVECHT4);\r\n\r\n        IN_ClearKeysDown();\r\n        IN_Ack();\r\n\r\n        gamestate.oldscore = gamestate.score = 0;\r\n        gamestate.lives = 1;\r\n        gamestate.weapon =\r\n            gamestate.chosenweapon =\r\n            gamestate.bestweapon = wp_pistol;\r\n        gamestate.ammo = 8;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n==========================\r\n=\r\n= ShutdownId\r\n=\r\n= Shuts down all ID_?? managers\r\n=\r\n==========================\r\n*/\r\n\r\nvoid ShutdownId (void)\r\n{\r\n    US_Shutdown ();         // This line is completely useless...\r\n    SD_Shutdown ();\r\n    PM_Shutdown ();\r\n    IN_Shutdown ();\r\n    VW_Shutdown ();\r\n    CA_Shutdown ();\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n==================\r\n=\r\n= BuildTables\r\n=\r\n= Calculates:\r\n=\r\n= scale                 projection constant\r\n= sintable/costable     overlapping fractional tables\r\n=\r\n==================\r\n*/\r\n\r\nconst float radtoint = (float)(FINEANGLES/2/PI);\r\n\r\nvoid BuildTables (void)\r\n{\r\n    //\r\n    // calculate fine tangents\r\n    //\r\n\r\n    int i;\r\n    for(i=0;i<FINEANGLES/8;i++)\r\n    {\r\n        double tang=tan((i+0.5)/radtoint);\r\n        finetangent[i]=(int32_t)(tang*GLOBAL1);\r\n        finetangent[FINEANGLES/4-1-i]=(int32_t)((1/tang)*GLOBAL1);\r\n    }\r\n\r\n    //\r\n    // costable overlays sintable with a quarter phase shift\r\n    // ANGLES is assumed to be divisable by four\r\n    //\r\n\r\n    float angle=0;\r\n    float anglestep=(float)(PI/2/ANGLEQUAD);\r\n    for(i=0; i<ANGLEQUAD; i++)\r\n    {\r\n        fixed value=(int32_t)(GLOBAL1*sin(angle));\r\n        sintable[i]=sintable[i+ANGLES]=sintable[ANGLES/2-i]=value;\r\n        sintable[ANGLES-i]=sintable[ANGLES/2+i]=-value;\r\n        angle+=anglestep;\r\n    }\r\n    sintable[ANGLEQUAD] = 65536;\r\n    sintable[3*ANGLEQUAD] = -65536;\r\n\r\n}\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= CalcProjection\r\n=\r\n= Uses focallength\r\n=\r\n====================\r\n*/\r\n\r\nvoid CalcProjection (int32_t focal)\r\n{\r\n    int     i;\r\n    int    intang;\r\n    float   angle;\r\n    double  tang;\r\n    int     halfview;\r\n    double  facedist;\r\n\r\n    focallength = focal;\r\n    facedist = focal+MINDIST;\r\n    halfview = viewwidth/2;                                 // half view in pixels\r\n\r\n    //\r\n    // calculate scale value for vertical height calculations\r\n    // and sprite x calculations\r\n    //\r\n    scale = (fixed) (halfview*facedist/(VIEWGLOBAL/2));\r\n\r\n    //\r\n    // divide heightnumerator by a posts distance to get the posts height for\r\n    // the heightbuffer.  The pixel height is height>>2\r\n    //\r\n    heightnumerator = (TILEGLOBAL*scale)>>6;\r\n\r\n    //\r\n    // calculate the angle offset from view angle of each pixel's ray\r\n    //\r\n\r\n    for (i=0;i<halfview;i++)\r\n    {\r\n        // start 1/2 pixel over, so viewangle bisects two middle pixels\r\n        tang = (int32_t)i*VIEWGLOBAL/viewwidth/facedist;\r\n        angle = (float) atan(tang);\r\n        intang = (int) (angle*radtoint);\r\n        pixelangle[halfview-1-i] = intang;\r\n        pixelangle[halfview+i] = -intang;\r\n    }\r\n}\r\n\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n===================\r\n=\r\n= SetupWalls\r\n=\r\n= Map tile values to scaled pics\r\n=\r\n===================\r\n*/\r\n\r\nvoid SetupWalls (void)\r\n{\r\n    int     i;\r\n\r\n    horizwall[0]=0;\r\n    vertwall[0]=0;\r\n\r\n    for (i=1;i<MAXWALLTILES;i++)\r\n    {\r\n        horizwall[i]=(i-1)*2;\r\n        vertwall[i]=(i-1)*2+1;\r\n    }\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n==========================\r\n=\r\n= SignonScreen\r\n=\r\n==========================\r\n*/\r\n\r\nvoid SignonScreen (void)                        // VGA version\r\n{\r\n    printf(\"VL_SetVGAPlaneMode\\n\");\r\n    VL_SetVGAPlaneMode ();\r\n    printf(\"end VL_SetVGAPlaneMode\\n\");\r\n\r\n    VL_MungePic (signon,320,200);\r\n    VL_MemToScreen (signon,320,200,0,0);\r\n}\r\n\r\n\r\n/*\r\n==========================\r\n=\r\n= FinishSignon\r\n=\r\n==========================\r\n*/\r\n\r\nvoid FinishSignon (void)\r\n{\r\n#ifndef SPEAR\r\n    VW_Bar (0,189,300,11,VL_GetPixel(0,0));\r\n    WindowX = 0;\r\n    WindowW = 320;\r\n    PrintY = 190;\r\n\r\n    #ifndef JAPAN\r\n    SETFONTCOLOR(14,4);\r\n\r\n    #ifdef SPANISH\r\n    US_CPrint (\"Oprima una tecla\");\r\n    #else\r\n    US_CPrint (\"Press a key\");\r\n    #endif\r\n\r\n    #endif\r\n\r\n    VH_UpdateScreen();\r\n\r\n\r\n    if (!param_nowait)\r\n        IN_Ack ();\r\n\r\n    #ifndef JAPAN\r\n    VW_Bar (0,189,300,11,VL_GetPixel(0,0));\r\n\r\n    PrintY = 190;\r\n    SETFONTCOLOR(10,4);\r\n\r\n    #ifdef SPANISH\r\n    US_CPrint (\"pensando...\");\r\n    #else\r\n    US_CPrint (\"Working...\");\r\n    #endif\r\n\r\n    VH_UpdateScreen();\r\n    #endif\r\n\r\n    SETFONTCOLOR(0,15);\r\n#else\r\n    VH_UpdateScreen();\r\n\r\n    if (!param_nowait)\r\n        VW_WaitVBL(3*70);\r\n#endif\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= InitDigiMap\r\n=\r\n=====================\r\n*/\r\n\r\n// channel mapping:\r\n//  -1: any non reserved channel\r\n//   0: player weapons\r\n//   1: boss weapons\r\n\r\nstatic int wolfdigimap[] =\r\n    {\r\n        // These first sounds are in the upload version\r\n#ifndef SPEAR\r\n        HALTSND,                0,  -1,\r\n        DOGBARKSND,             1,  -1,\r\n        CLOSEDOORSND,           2,  -1,\r\n        OPENDOORSND,            3,  -1,\r\n        ATKMACHINEGUNSND,       4,   0,\r\n        ATKPISTOLSND,           5,   0,\r\n        ATKGATLINGSND,          6,   0,\r\n        SCHUTZADSND,            7,  -1,\r\n        GUTENTAGSND,            8,  -1,\r\n        MUTTISND,               9,  -1,\r\n        BOSSFIRESND,            10,  1,\r\n        SSFIRESND,              11, -1,\r\n        DEATHSCREAM1SND,        12, -1,\r\n        DEATHSCREAM2SND,        13, -1,\r\n        DEATHSCREAM3SND,        13, -1,\r\n        TAKEDAMAGESND,          14, -1,\r\n        PUSHWALLSND,            15, -1,\r\n\r\n        LEBENSND,               20, -1,\r\n        NAZIFIRESND,            21, -1,\r\n        SLURPIESND,             22, -1,\r\n\r\n        YEAHSND,                32, -1,\r\n\r\n#ifndef UPLOAD\r\n        // These are in all other episodes\r\n        DOGDEATHSND,            16, -1,\r\n        AHHHGSND,               17, -1,\r\n        DIESND,                 18, -1,\r\n        EVASND,                 19, -1,\r\n\r\n        TOT_HUNDSND,            23, -1,\r\n        MEINGOTTSND,            24, -1,\r\n        SCHABBSHASND,           25, -1,\r\n        HITLERHASND,            26, -1,\r\n        SPIONSND,               27, -1,\r\n        NEINSOVASSND,           28, -1,\r\n        DOGATTACKSND,           29, -1,\r\n        LEVELDONESND,           30, -1,\r\n        MECHSTEPSND,            31, -1,\r\n\r\n        SCHEISTSND,             33, -1,\r\n        DEATHSCREAM4SND,        34, -1,         // AIIEEE\r\n        DEATHSCREAM5SND,        35, -1,         // DEE-DEE\r\n        DONNERSND,              36, -1,         // EPISODE 4 BOSS DIE\r\n        EINESND,                37, -1,         // EPISODE 4 BOSS SIGHTING\r\n        ERLAUBENSND,            38, -1,         // EPISODE 6 BOSS SIGHTING\r\n        DEATHSCREAM6SND,        39, -1,         // FART\r\n        DEATHSCREAM7SND,        40, -1,         // GASP\r\n        DEATHSCREAM8SND,        41, -1,         // GUH-BOY!\r\n        DEATHSCREAM9SND,        42, -1,         // AH GEEZ!\r\n        KEINSND,                43, -1,         // EPISODE 5 BOSS SIGHTING\r\n        MEINSND,                44, -1,         // EPISODE 6 BOSS DIE\r\n        ROSESND,                45, -1,         // EPISODE 5 BOSS DIE\r\n\r\n#endif\r\n#else\r\n//\r\n// SPEAR OF DESTINY DIGISOUNDS\r\n//\r\n        HALTSND,                0,  -1,\r\n        CLOSEDOORSND,           2,  -1,\r\n        OPENDOORSND,            3,  -1,\r\n        ATKMACHINEGUNSND,       4,   0,\r\n        ATKPISTOLSND,           5,   0,\r\n        ATKGATLINGSND,          6,   0,\r\n        SCHUTZADSND,            7,  -1,\r\n        BOSSFIRESND,            8,   1,\r\n        SSFIRESND,              9,  -1,\r\n        DEATHSCREAM1SND,        10, -1,\r\n        DEATHSCREAM2SND,        11, -1,\r\n        TAKEDAMAGESND,          12, -1,\r\n        PUSHWALLSND,            13, -1,\r\n        AHHHGSND,               15, -1,\r\n        LEBENSND,               16, -1,\r\n        NAZIFIRESND,            17, -1,\r\n        SLURPIESND,             18, -1,\r\n        LEVELDONESND,           22, -1,\r\n        DEATHSCREAM4SND,        23, -1,         // AIIEEE\r\n        DEATHSCREAM3SND,        23, -1,         // DOUBLY-MAPPED!!!\r\n        DEATHSCREAM5SND,        24, -1,         // DEE-DEE\r\n        DEATHSCREAM6SND,        25, -1,         // FART\r\n        DEATHSCREAM7SND,        26, -1,         // GASP\r\n        DEATHSCREAM8SND,        27, -1,         // GUH-BOY!\r\n        DEATHSCREAM9SND,        28, -1,         // AH GEEZ!\r\n        GETGATLINGSND,          38, -1,         // Got Gat replacement\r\n\r\n#ifndef SPEARDEMO\r\n        DOGBARKSND,             1,  -1,\r\n        DOGDEATHSND,            14, -1,\r\n        SPIONSND,               19, -1,\r\n        NEINSOVASSND,           20, -1,\r\n        DOGATTACKSND,           21, -1,\r\n        TRANSSIGHTSND,          29, -1,         // Trans Sight\r\n        TRANSDEATHSND,          30, -1,         // Trans Death\r\n        WILHELMSIGHTSND,        31, -1,         // Wilhelm Sight\r\n        WILHELMDEATHSND,        32, -1,         // Wilhelm Death\r\n        UBERDEATHSND,           33, -1,         // Uber Death\r\n        KNIGHTSIGHTSND,         34, -1,         // Death Knight Sight\r\n        KNIGHTDEATHSND,         35, -1,         // Death Knight Death\r\n        ANGELSIGHTSND,          36, -1,         // Angel Sight\r\n        ANGELDEATHSND,          37, -1,         // Angel Death\r\n        GETSPEARSND,            39, -1,         // Got Spear replacement\r\n#endif\r\n#endif\r\n        LASTSOUND\r\n    };\r\n\r\n\r\nvoid InitDigiMap (void)\r\n{\r\n    int *map;\r\n\r\n    int i = 0;\r\n\r\n    for (map = wolfdigimap; *map != LASTSOUND; map += 3)\r\n    {\r\n        printf(\"prepare sound i=%d sound=%d digi=%d\\n\", i, map[0], map[1]);\r\n        DigiMap[map[0]] = map[1];\r\n        DigiChannel[map[1]] = map[2];\r\n        SD_PrepareSound(map[1]);\r\n        i++;\r\n    }\r\n    // printf(\"prepared DigiMap\\n\");\r\n    // i=0;\r\n    // while(i < LASTSOUND) {\r\n    //     printf(\"DigiMap[%d]=%d\\n\", i, DigiMap[i]);\r\n    //     i++;\r\n    // }\r\n}\r\n\r\n#ifndef SPEAR\r\nCP_iteminfo MusicItems={CTL_X,CTL_Y,6,0,32};\r\nCP_itemtype MusicMenu[]=\r\n    {\r\n        {1,\"Get Them!\",0},\r\n        {1,\"Searching\",0},\r\n        {1,\"P.O.W.\",0},\r\n        {1,\"Suspense\",0},\r\n        {1,\"War March\",0},\r\n        {1,\"Around The Corner!\",0},\r\n\r\n        {1,\"Nazi Anthem\",0},\r\n        {1,\"Lurking...\",0},\r\n        {1,\"Going After Hitler\",0},\r\n        {1,\"Pounding Headache\",0},\r\n        {1,\"Into the Dungeons\",0},\r\n        {1,\"Ultimate Conquest\",0},\r\n\r\n        {1,\"Kill the S.O.B.\",0},\r\n        {1,\"The Nazi Rap\",0},\r\n        {1,\"Twelfth Hour\",0},\r\n        {1,\"Zero Hour\",0},\r\n        {1,\"Ultimate Conquest\",0},\r\n        {1,\"Wolfpack\",0}\r\n    };\r\n#else\r\nCP_iteminfo MusicItems={CTL_X,CTL_Y-20,9,0,32};\r\nCP_itemtype MusicMenu[]=\r\n    {\r\n        {1,\"Funky Colonel Bill\",0},\r\n        {1,\"Death To The Nazis\",0},\r\n        {1,\"Tiptoeing Around\",0},\r\n        {1,\"Is This THE END?\",0},\r\n        {1,\"Evil Incarnate\",0},\r\n        {1,\"Jazzin' Them Nazis\",0},\r\n        {1,\"Puttin' It To The Enemy\",0},\r\n        {1,\"The SS Gonna Get You\",0},\r\n        {1,\"Towering Above\",0}\r\n    };\r\n#endif\r\n\r\n#ifndef SPEARDEMO\r\nvoid DoJukebox(void)\r\n{\r\n    int which,lastsong=-1;\r\n    unsigned start;\r\n    unsigned songs[]=\r\n        {\r\n#ifndef SPEAR\r\n            GETTHEM_MUS,\r\n            SEARCHN_MUS,\r\n            POW_MUS,\r\n            SUSPENSE_MUS,\r\n            WARMARCH_MUS,\r\n            CORNER_MUS,\r\n\r\n            NAZI_OMI_MUS,\r\n            PREGNANT_MUS,\r\n            GOINGAFT_MUS,\r\n            HEADACHE_MUS,\r\n            DUNGEON_MUS,\r\n            ULTIMATE_MUS,\r\n\r\n            INTROCW3_MUS,\r\n            NAZI_RAP_MUS,\r\n            TWELFTH_MUS,\r\n            ZEROHOUR_MUS,\r\n            ULTIMATE_MUS,\r\n            PACMAN_MUS\r\n#else\r\n            XFUNKIE_MUS,             // 0\r\n            XDEATH_MUS,              // 2\r\n            XTIPTOE_MUS,             // 4\r\n            XTHEEND_MUS,             // 7\r\n            XEVIL_MUS,               // 17\r\n            XJAZNAZI_MUS,            // 18\r\n            XPUTIT_MUS,              // 21\r\n            XGETYOU_MUS,             // 22\r\n            XTOWER2_MUS              // 23\r\n#endif\r\n        };\r\n\r\n    IN_ClearKeysDown();\r\n    if (!AdLibPresent && !SoundBlasterPresent)\r\n        return;\r\n\r\n    MenuFadeOut();\r\n\r\n#ifndef SPEAR\r\n#ifndef UPLOAD\r\n    start = ((SDL_GetTicks()/10)%3)*6;\r\n#else\r\n    start = 0;\r\n#endif\r\n#else\r\n    start = 0;\r\n#endif\r\n\r\n    CA_CacheGrChunk (STARTFONT+1);\r\n#ifdef SPEAR\r\n    CacheLump (BACKDROP_LUMP_START,BACKDROP_LUMP_END);\r\n#else\r\n    CacheLump (CONTROLS_LUMP_START,CONTROLS_LUMP_END);\r\n#endif\r\n    CA_LoadAllSounds ();\r\n\r\n    fontnumber=1;\r\n    ClearMScreen ();\r\n    VWB_DrawPic(112,184,C_MOUSELBACKPIC);\r\n    DrawStripes (10);\r\n    SETFONTCOLOR (TEXTCOLOR,BKGDCOLOR);\r\n\r\n#ifndef SPEAR\r\n    DrawWindow (CTL_X-2,CTL_Y-6,280,13*7,BKGDCOLOR);\r\n#else\r\n    DrawWindow (CTL_X-2,CTL_Y-26,280,13*10,BKGDCOLOR);\r\n#endif\r\n\r\n    DrawMenu (&MusicItems,&MusicMenu[start]);\r\n\r\n    SETFONTCOLOR (READHCOLOR,BKGDCOLOR);\r\n    PrintY=15;\r\n    WindowX = 0;\r\n    WindowY = 320;\r\n    US_CPrint (\"Robert's Jukebox\");\r\n\r\n    SETFONTCOLOR (TEXTCOLOR,BKGDCOLOR);\r\n    VW_UpdateScreen();\r\n    MenuFadeIn();\r\n\r\n    do\r\n    {\r\n        which = HandleMenu(&MusicItems,&MusicMenu[start],NULL);\r\n        if (which>=0)\r\n        {\r\n            if (lastsong >= 0)\r\n                MusicMenu[start+lastsong].active = 1;\r\n\r\n            StartCPMusic(songs[start + which]);\r\n            MusicMenu[start+which].active = 2;\r\n            DrawMenu (&MusicItems,&MusicMenu[start]);\r\n            VW_UpdateScreen();\r\n            lastsong = which;\r\n        }\r\n    } while(which>=0);\r\n\r\n    MenuFadeOut();\r\n    IN_ClearKeysDown();\r\n#ifdef SPEAR\r\n    UnCacheLump (BACKDROP_LUMP_START,BACKDROP_LUMP_END);\r\n#else\r\n    UnCacheLump (CONTROLS_LUMP_START,CONTROLS_LUMP_END);\r\n#endif\r\n}\r\n#endif\r\n\r\n/*\r\n==========================\r\n=\r\n= InitGame\r\n=\r\n= Load a few things right away\r\n=\r\n==========================\r\n*/\r\n\r\nstatic void InitGame()\r\n{\r\n#ifndef SPEARDEMO\r\n    boolean didjukebox=false;\r\n#endif\r\n\r\n    // initialize SDL\r\n#if defined _WIN32\r\n    putenv(\"SDL_VIDEODRIVER=directx\");\r\n#endif\r\n    if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_JOYSTICK) < 0)\r\n    {\r\n        printf(\"Unable to init SDL: %s\\n\", SDL_GetError());\r\n        exit(1);\r\n    }\r\n    atexit(SDL_Quit);\r\n\r\n    int numJoysticks = SDL_NumJoysticks();\r\n    if(param_joystickindex && (param_joystickindex < -1 || param_joystickindex >= numJoysticks))\r\n    {\r\n        if(!numJoysticks)\r\n            printf(\"No joysticks are available to SDL!\\n\");\r\n        else\r\n            printf(\"The joystick index must be between -1 and %i!\\n\", numJoysticks - 1);\r\n        exit(1);\r\n    }\r\n    printf(\"SignonScreen\\n\");\r\n    SignonScreen ();\r\n    printf(\"end SignonScreen\\n\");\r\n\r\n\r\n#if defined _WIN32\r\n    if(!fullscreen)\r\n    {\r\n        struct SDL_SysWMinfo wmInfo;\r\n        SDL_VERSION(&wmInfo.version);\r\n\r\n        if(SDL_GetWMInfo(&wmInfo) != -1)\r\n        {\r\n            HWND hwndSDL = wmInfo.window;\r\n            DWORD style = GetWindowLong(hwndSDL, GWL_STYLE) & ~WS_SYSMENU;\r\n            SetWindowLong(hwndSDL, GWL_STYLE, style);\r\n            SetWindowPos(hwndSDL, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);\r\n        }\r\n    }\r\n#endif\r\n\r\n    printf(\"starting systems\\n\");\r\n\r\n    printf(\"VH_Startup\\n\");VH_Startup ();\r\n\r\n    printf(\"IN_Startup\\n\");IN_Startup ();\r\n    printf(\"PM_Startup\\n\");PM_Startup ();\r\n    printf(\"SD_Startup\\n\");SD_Startup ();\r\n    printf(\"CA_Startup\\n\");CA_Startup ();\r\n    printf(\"US_Startup\\n\");US_Startup ();\r\n\r\n    \r\n\r\n    printf(\"done starting systems\\n\");\r\n\r\n    // TODO: Will any memory checking be needed someday??\r\n#ifdef NOTYET\r\n#ifndef SPEAR\r\n    if (mminfo.mainmem < 235000L)\r\n#else\r\n    if (mminfo.mainmem < 257000L && !MS_CheckParm(\"debugmode\"))\r\n#endif\r\n    {\r\n        byte *screen;\r\n\r\n        CA_CacheGrChunk (ERRORSCREEN);\r\n        screen = grsegs[ERRORSCREEN];\r\n        ShutdownId();\r\n/*        memcpy((byte *)0xb8000,screen+7+7*160,17*160);\r\n        gotoxy (1,23);*/\r\n        exit(1);\r\n    }\r\n#endif\r\n\r\n\r\n//\r\n// build some tables\r\n//\r\n    InitDigiMap ();\r\n\r\n            assert(DigiMap[18] == 3);\r\n    ReadConfig ();\r\n\r\n            assert(DigiMap[18] == 3);\r\n\r\n    SetupSaveGames();\r\n\r\n//\r\n// HOLDING DOWN 'M' KEY?\r\n//\r\n#ifndef SPEARDEMO\r\n    if (Keyboard[sc_M])\r\n    {\r\n        DoJukebox();\r\n        didjukebox=true;\r\n    }\r\n    else\r\n#endif\r\n\r\n//\r\n// draw intro screen stuff\r\n//\r\n    IntroScreen ();\r\n            assert(DigiMap[18] == 3);\r\n\r\n//\r\n// load in and lock down some basic chunks\r\n//\r\n\r\n    CA_CacheGrChunk(STARTFONT);\r\n    CA_CacheGrChunk(STATUSBARPIC);\r\n\r\n            assert(DigiMap[18] == 3);\r\n    LoadLatchMem ();\r\n\r\n            assert(DigiMap[18] == 3);\r\n    BuildTables ();          // trig tables\r\n    SetupWalls ();\r\n\r\n            assert(DigiMap[18] == 3);\r\n    NewViewSize (viewsize);\r\n\r\n//\r\n// initialize variables\r\n//\r\n    InitRedShifts ();\r\n#ifndef SPEARDEMO\r\n    if(!didjukebox)\r\n#endif\r\n\r\n            assert(DigiMap[18] == 3);\r\n        FinishSignon();\r\n\r\n            assert(DigiMap[18] == 3);\r\n\r\n#ifdef NOTYET\r\n    vdisp = (byte *) (0xa0000+PAGE1START);\r\n    vbuf = (byte *) (0xa0000+PAGE2START);\r\n#endif\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n==========================\r\n=\r\n= SetViewSize\r\n=\r\n==========================\r\n*/\r\n\r\nboolean SetViewSize (unsigned width, unsigned height)\r\n{\r\n    viewwidth = width&~15;                  // must be divisable by 16\r\n    viewheight = height&~1;                 // must be even\r\n    centerx = viewwidth/2-1;\r\n    shootdelta = viewwidth/10;\r\n    if((unsigned) viewheight == screenHeight)\r\n        viewscreenx = viewscreeny = screenofs = 0;\r\n    else\r\n    {\r\n        viewscreenx = (screenWidth-viewwidth) / 2;\r\n        viewscreeny = (screenHeight-scaleFactor*STATUSLINES-viewheight)/2;\r\n        screenofs = viewscreeny*screenWidth+viewscreenx;\r\n    }\r\n\r\n//\r\n// calculate trace angles and projection constants\r\n//\r\n    CalcProjection (FOCALLENGTH);\r\n\r\n    return true;\r\n}\r\n\r\n\r\nvoid ShowViewSize (int width)\r\n{\r\n    int oldwidth,oldheight;\r\n\r\n    oldwidth = viewwidth;\r\n    oldheight = viewheight;\r\n\r\n    if(width == 21)\r\n    {\r\n        viewwidth = screenWidth;\r\n        viewheight = screenHeight;\r\n        VWB_BarScaledCoord (0, 0, screenWidth, screenHeight, 0);\r\n    }\r\n    else if(width == 20)\r\n    {\r\n        viewwidth = screenWidth;\r\n        viewheight = screenHeight - scaleFactor*STATUSLINES;\r\n        DrawPlayBorder ();\r\n    }\r\n    else\r\n    {\r\n        viewwidth = width*16*screenWidth/320;\r\n        viewheight = (int) (width*16*HEIGHTRATIO*screenHeight/200);\r\n        DrawPlayBorder ();\r\n    }\r\n\r\n    viewwidth = oldwidth;\r\n    viewheight = oldheight;\r\n}\r\n\r\n\r\nvoid NewViewSize (int width)\r\n{\r\n    viewsize = width;\r\n    if(viewsize == 21)\r\n        SetViewSize(screenWidth, screenHeight);\r\n    else if(viewsize == 20)\r\n        SetViewSize(screenWidth, screenHeight - scaleFactor * STATUSLINES);\r\n    else\r\n        SetViewSize(width*16*screenWidth/320, (unsigned) (width*16*HEIGHTRATIO*screenHeight/200));\r\n}\r\n\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n==========================\r\n=\r\n= Quit\r\n=\r\n==========================\r\n*/\r\n\r\nvoid Quit (const char *errorStr, ...)\r\n{\r\n#ifdef NOTYET\r\n    byte *screen;\r\n#endif\r\n    char error[256];\r\n    if(errorStr != NULL)\r\n    {\r\n        va_list vlist;\r\n        va_start(vlist, errorStr);\r\n        vsprintf(error, errorStr, vlist);\r\n        va_end(vlist);\r\n    }\r\n    else error[0] = 0;\r\n\r\n    if (!pictable)  // don't try to display the red box before it's loaded\r\n    {\r\n        ShutdownId();\r\n        if (error && *error)\r\n        {\r\n#ifdef NOTYET\r\n            SetTextCursor(0,0);\r\n#endif\r\n            puts(error);\r\n#ifdef NOTYET\r\n            SetTextCursor(0,2);\r\n#endif\r\n            VW_WaitVBL(100);\r\n        }\r\n        exit(1);\r\n    }\r\n\r\n    if (!error || !*error)\r\n    {\r\n#ifdef NOTYET\r\n        #ifndef JAPAN\r\n        CA_CacheGrChunk (ORDERSCREEN);\r\n        screen = grsegs[ORDERSCREEN];\r\n        #endif\r\n#endif\r\n        WriteConfig ();\r\n    }\r\n#ifdef NOTYET\r\n    else\r\n    {\r\n        CA_CacheGrChunk (ERRORSCREEN);\r\n        screen = grsegs[ERRORSCREEN];\r\n    }\r\n#endif\r\n\r\n    ShutdownId ();\r\n\r\n    if (error && *error)\r\n    {\r\n#ifdef NOTYET\r\n        memcpy((byte *)0xb8000,screen+7,7*160);\r\n        SetTextCursor(9,3);\r\n#endif\r\n        puts(error);\r\n#ifdef NOTYET\r\n        SetTextCursor(0,7);\r\n#endif\r\n        VW_WaitVBL(200);\r\n        exit(1);\r\n    }\r\n    else\r\n    if (!error || !(*error))\r\n    {\r\n#ifdef NOTYET\r\n        #ifndef JAPAN\r\n        memcpy((byte *)0xb8000,screen+7,24*160); // 24 for SPEAR/UPLOAD compatibility\r\n        #endif\r\n        SetTextCursor(0,23);\r\n#endif\r\n    }\r\n\r\n    exit(0);\r\n}\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= DemoLoop\r\n=\r\n=====================\r\n*/\r\n\r\nvoid HighScoreScreenTest(int);\r\n\r\nvoid HighScoreScreenTest(int x) {\r\n#ifndef __EMSCRIPTEN__\r\n    do {\r\n#endif\r\n\r\n    #ifdef __EMSCRIPTEN__\r\n    EM_ASM(\r\n        debugger;\r\n    );\r\n    #endif\r\n    DrawHighScores ();\r\n    VW_UpdateScreen ();\r\n#ifndef __EMSCRIPTEN__\r\n    } while (1);\r\n#else\r\n    emscripten_async_call((void (*)(void *))HighScoreScreenTest, 0, -1);\r\n#endif\r\n}\r\n\r\nvoid ControlPanelLoop(int);\r\n\r\nstatic void DemoLoop()\r\n{\r\n    int LastDemo = 0;\r\n\r\n//\r\n// check for launch from ted\r\n//\r\n    if (param_tedlevel != -1)\r\n    {\r\n        param_nowait = true;\r\n        EnableEndGameMenuItem();\r\n        NewGame(param_difficulty,0);\r\n\r\n#ifndef SPEAR\r\n        gamestate.episode = param_tedlevel/10;\r\n        gamestate.mapon = param_tedlevel%10;\r\n#else\r\n        gamestate.episode = 0;\r\n        gamestate.mapon = param_tedlevel;\r\n#endif\r\n        printf(\"before GameLoop\\n\");\r\n        GameLoop(0);\r\n        Quit (NULL);\r\n    }\r\n\r\n\r\n//\r\n// main game cycle\r\n//\r\n\r\n#ifndef DEMOTEST\r\n\r\n    #ifndef UPLOAD\r\n\r\n        #ifndef GOODTIMES\r\n        #ifndef SPEAR\r\n        #ifndef JAPAN\r\n        if (!param_nowait)\r\n            NonShareware();\r\n        #endif\r\n        #else\r\n            #ifndef GOODTIMES\r\n            #ifndef SPEARDEMO\r\n            extern void CopyProtection(void);\r\n            if(!param_goodtimes)\r\n                CopyProtection();\r\n            #endif\r\n            #endif\r\n        #endif\r\n        #endif\r\n    #endif\r\n\r\n    StartCPMusic(INTROSONG);\r\n\r\n#ifndef JAPAN\r\n    if (!param_nowait)\r\n        PG13 ();\r\n#endif\r\n\r\n#endif\r\n    // VW_FadeIn ();\r\n\r\n    // printf(\"HighScoreScreenTest\\n\");\r\n    // HighScoreScreenTest(0);\r\n\r\n\r\n\r\n#ifndef __EMSCRIPTEN__\r\n    while (1)\r\n    {\r\n#endif\r\n        while (!(param_nowait || true))\r\n        {\r\n//\r\n// title page\r\n//\r\n#ifndef DEMOTEST\r\n\r\n#ifdef SPEAR\r\n            SDL_Color pal[256];\r\n            CA_CacheGrChunk (TITLEPALETTE);\r\n            VL_ConvertPalette(grsegs[TITLEPALETTE], pal, 256);\r\n\r\n            CA_CacheGrChunk (TITLE1PIC);\r\n            VWB_DrawPic (0,0,TITLE1PIC);\r\n            UNCACHEGRCHUNK (TITLE1PIC);\r\n\r\n            CA_CacheGrChunk (TITLE2PIC);\r\n            VWB_DrawPic (0,80,TITLE2PIC);\r\n            UNCACHEGRCHUNK (TITLE2PIC);\r\n            VW_UpdateScreen ();\r\n            VL_FadeIn(0,255,pal,30);\r\n\r\n            UNCACHEGRCHUNK (TITLEPALETTE);\r\n#else\r\n            CA_CacheScreen (TITLEPIC);\r\n            VW_UpdateScreen ();\r\n            VW_FadeIn();\r\n#endif\r\n            if (IN_UserInput(TickBase*15))\r\n                break;\r\n            VW_FadeOut();\r\n//\r\n// credits page\r\n//\r\n            CA_CacheScreen (CREDITSPIC);\r\n            VW_UpdateScreen();\r\n            VW_FadeIn ();\r\n            if (IN_UserInput(TickBase*10))\r\n                break;\r\n            VW_FadeOut ();\r\n//\r\n// high scores\r\n//\r\n            DrawHighScores ();\r\n            VW_UpdateScreen ();\r\n            VW_FadeIn ();\r\n\r\n            if (IN_UserInput(TickBase*10))\r\n                break;\r\n#endif\r\n//\r\n// demo\r\n//\r\n\r\n            #ifndef SPEARDEMO\r\n            PlayDemo (LastDemo++%4);\r\n            #else\r\n            PlayDemo (0);\r\n            #endif\r\n\r\n            if (playstate == ex_abort)\r\n                break;\r\n            VW_FadeOut();\r\n            if(screenHeight % 200 != 0)\r\n                VL_ClearScreen(0);\r\n            StartCPMusic(INTROSONG);\r\n        }// end demo loop\r\n\r\n        VW_FadeOut ();\r\n\r\n#ifdef __EMSCRIPTEN__\r\n        ControlPanelLoop(0);\r\n        printf(\"going to noop main loop\\n\");\r\n        printf (\"from line %d of file \\\"%s\\\".\\n\", __LINE__, __FILE__);\r\n        emscripten_set_main_loop(em_noop_main_loop, 0, 1);\r\n#endif\r\n\r\n#ifdef DEBUGKEYS\r\n        if (Keyboard[sc_Tab] && param_debugmode)\r\n            RecordDemo ();\r\n        else\r\n            US_ControlPanel (0);\r\n#else\r\n        US_ControlPanel (0);\r\n#endif\r\n\r\n        if (startgame || loadedgame)\r\n        {\r\n            GameLoop (0);\r\n            if(!param_nowait)\r\n            {\r\n                VW_FadeOut();\r\n                StartCPMusic(INTROSONG);\r\n            }\r\n        }\r\n#ifndef __EMSCRIPTEN__\r\n    }\r\n#endif\r\n}\r\n\r\nvoid ControlPanelLoop(int jumpto) {\r\n\r\n            assert(DigiMap[18] == 3);\r\n        // TODO(jsdf)\r\n        // US_ControlPanel (0);\r\n        startgame = true;\r\n        if (startgame || loadedgame)\r\n        {\r\n            NewGame(3, 0);\r\n            assert(DigiMap[18] == 3);\r\n            GameLoop (0);\r\n            return;\r\n        }\r\n\r\n    #ifdef __EMSCRIPTEN__\r\n        emscripten_async_call((void (*)(void *))ControlPanelLoop, 0, -1);\r\n    #endif\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n#define IFARG(str) if(!strcmp(arg, (str)))\r\n\r\nvoid CheckParameters(int argc, char *argv[])\r\n{\r\n    bool hasError = false, showHelp = false;\r\n    bool sampleRateGiven = false, audioBufferGiven = false;\r\n    int defaultSampleRate = param_samplerate;\r\n\r\n    for(int i = 1; i < argc; i++)\r\n    {\r\n        char *arg = argv[i];\r\n#ifndef SPEAR\r\n        IFARG(\"--goobers\")\r\n#else\r\n        IFARG(\"--debugmode\")\r\n#endif\r\n            param_debugmode = true;\r\n        else IFARG(\"--baby\")\r\n            param_difficulty = 0;\r\n        else IFARG(\"--easy\")\r\n            param_difficulty = 1;\r\n        else IFARG(\"--normal\")\r\n            param_difficulty = 2;\r\n        else IFARG(\"--hard\")\r\n            param_difficulty = 3;\r\n        else IFARG(\"--nowait\")\r\n            param_nowait = true;\r\n        else IFARG(\"--tedlevel\")\r\n        {\r\n            if(++i >= argc)\r\n            {\r\n                printf(\"The tedlevel option is missing the level argument!\\n\");\r\n                hasError = true;\r\n            }\r\n            else param_tedlevel = atoi(argv[i]);\r\n        }\r\n        else IFARG(\"--windowed\")\r\n            fullscreen = false;\r\n        else IFARG(\"--windowed-mouse\")\r\n        {\r\n            fullscreen = false;\r\n            forcegrabmouse = true;\r\n        }\r\n        else IFARG(\"--res\")\r\n        {\r\n            if(i + 2 >= argc)\r\n            {\r\n                printf(\"The res option needs the width and/or the height argument!\\n\");\r\n                hasError = true;\r\n            }\r\n            else\r\n            {\r\n                screenWidth = atoi(argv[++i]);\r\n                screenHeight = atoi(argv[++i]);\r\n                unsigned factor = screenWidth / 320;\r\n                if(screenWidth % 320 || screenHeight != 200 * factor && screenHeight != 240 * factor)\r\n                    printf(\"Screen size must be a multiple of 320x200 or 320x240!\\n\"), hasError = true;\r\n            }\r\n        }\r\n        else IFARG(\"--resf\")\r\n        {\r\n            if(i + 2 >= argc)\r\n            {\r\n                printf(\"The resf option needs the width and/or the height argument!\\n\");\r\n                hasError = true;\r\n            }\r\n            else\r\n            {\r\n                screenWidth = atoi(argv[++i]);\r\n                screenHeight = atoi(argv[++i]);\r\n                if(screenWidth < 320)\r\n                    printf(\"Screen width must be at least 320!\\n\"), hasError = true;\r\n                if(screenHeight < 200)\r\n                    printf(\"Screen height must be at least 200!\\n\"), hasError = true;\r\n            }\r\n        }\r\n        else IFARG(\"--bits\")\r\n        {\r\n            if(++i >= argc)\r\n            {\r\n                printf(\"The bits option is missing the color depth argument!\\n\");\r\n                hasError = true;\r\n            }\r\n            else\r\n            {\r\n                screenBits = atoi(argv[i]);\r\n                switch(screenBits)\r\n                {\r\n                    case 8:\r\n                    case 16:\r\n                    case 24:\r\n                    case 32:\r\n                        break;\r\n\r\n                    default:\r\n                        printf(\"Screen color depth must be 8, 16, 24, or 32!\\n\");\r\n                        hasError = true;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        else IFARG(\"--nodblbuf\")\r\n            usedoublebuffering = false;\r\n        else IFARG(\"--extravbls\")\r\n        {\r\n            if(++i >= argc)\r\n            {\r\n                printf(\"The extravbls option is missing the vbls argument!\\n\");\r\n                hasError = true;\r\n            }\r\n            else\r\n            {\r\n                extravbls = atoi(argv[i]);\r\n                if(extravbls < 0)\r\n                {\r\n                    printf(\"Extravbls must be positive!\\n\");\r\n                    hasError = true;\r\n                }\r\n            }\r\n        }\r\n        else IFARG(\"--joystick\")\r\n        {\r\n            if(++i >= argc)\r\n            {\r\n                printf(\"The joystick option is missing the index argument!\\n\");\r\n                hasError = true;\r\n            }\r\n            else param_joystickindex = atoi(argv[i]);   // index is checked in InitGame\r\n        }\r\n        else IFARG(\"--joystickhat\")\r\n        {\r\n            if(++i >= argc)\r\n            {\r\n                printf(\"The joystickhat option is missing the index argument!\\n\");\r\n                hasError = true;\r\n            }\r\n            else param_joystickhat = atoi(argv[i]);\r\n        }\r\n        else IFARG(\"--samplerate\")\r\n        {\r\n            if(++i >= argc)\r\n            {\r\n                printf(\"The samplerate option is missing the rate argument!\\n\");\r\n                hasError = true;\r\n            }\r\n            else param_samplerate = atoi(argv[i]);\r\n            sampleRateGiven = true;\r\n        }\r\n        else IFARG(\"--audiobuffer\")\r\n        {\r\n            if(++i >= argc)\r\n            {\r\n                printf(\"The audiobuffer option is missing the size argument!\\n\");\r\n                hasError = true;\r\n            }\r\n            else param_audiobuffer = atoi(argv[i]);\r\n            audioBufferGiven = true;\r\n        }\r\n        else IFARG(\"--mission\")\r\n        {\r\n            if(++i >= argc)\r\n            {\r\n                printf(\"The mission option is missing the mission argument!\\n\");\r\n                hasError = true;\r\n            }\r\n            else\r\n            {\r\n                param_mission = atoi(argv[i]);\r\n                if(param_mission < 0 || param_mission > 3)\r\n                {\r\n                    printf(\"The mission option must be between 0 and 3!\\n\");\r\n                    hasError = true;\r\n                }\r\n            }\r\n        }\r\n        else IFARG(\"--configdir\")\r\n        {\r\n            if(++i >= argc)\r\n            {\r\n                printf(\"The configdir option is missing the dir argument!\\n\");\r\n                hasError = true;\r\n            }\r\n            else\r\n            {\r\n                size_t len = strlen(argv[i]);\r\n                if(len + 2 > sizeof(configdir))\r\n                {\r\n                    printf(\"The config directory is too long!\\n\");\r\n                    hasError = true;\r\n                }\r\n                else\r\n                {\r\n                    strcpy(configdir, argv[i]);\r\n                    if(argv[i][len] != '/' && argv[i][len] != '\\\\')\r\n                        strcat(configdir, \"/\");\r\n                }\r\n            }\r\n        }\r\n        else IFARG(\"--goodtimes\")\r\n            param_goodtimes = true;\r\n        else IFARG(\"--ignorenumchunks\")\r\n            param_ignorenumchunks = true;\r\n        else IFARG(\"--help\")\r\n            showHelp = true;\r\n        else {\r\n            printf(\"Unrecognized parameter: %s\\n\", arg);\r\n        }\r\n    }\r\n    if(showHelp || hasError)\r\n    {\r\n        printf(\r\n            \"Chocolate Wolfenstein 3D\\n\" //TODO: add version #? author credit? site link?\r\n            \"Based on Wolf4SDL, by Moritz \\\"Ripper\\\" Kroll (http://www.chaos-software.de.vu)\\n\"\r\n            \"Original Wolfenstein 3D by id Software\\n\\n\"\r\n            \"Options:\\n\"\r\n            \" --help                 This help page\\n\"\r\n            \" --tedlevel <level>     Starts the game in the given level\\n\"\r\n            \" --baby                 Sets the difficulty to baby for tedlevel\\n\"\r\n            \" --easy                 Sets the difficulty to easy for tedlevel\\n\"\r\n            \" --normal               Sets the difficulty to normal for tedlevel\\n\"\r\n            \" --hard                 Sets the difficulty to hard for tedlevel\\n\"\r\n            \" --nowait               Skips intro screens\\n\"\r\n            \" --windowed[-mouse]     Starts the game in a window [and grabs mouse]\\n\"\r\n            \" --res <width> <height> Sets the screen resolution\\n\"\r\n            \"                        (must be multiple of 320x200 or 320x240)\\n\"\r\n            \" --resf <w> <h>         Sets any screen resolution >= 320x200\\n\"\r\n            \"                        (which may result in graphic errors)\\n\"\r\n            \" --bits <b>             Sets the screen color depth\\n\"\r\n            \"                        (use this when you have palette/fading problems\\n\"\r\n            \"                        allowed: 8, 16, 24, 32, default: \\\"best\\\" depth)\\n\"\r\n            \" --nodblbuf             Don't use SDL's double buffering\\n\"\r\n            \" --extravbls <vbls>     Sets a delay after each frame, which may help to\\n\"\r\n            \"                        reduce flickering (unit is currently 8 ms, default: 0)\\n\"\r\n            \" --joystick <index>     Use the index-th joystick if available\\n\"\r\n            \"                        (-1 to disable joystick, default: 0)\\n\"\r\n            \" --joystickhat <index>  Enables movement with the given coolie hat\\n\"\r\n            \" --samplerate <rate>    Sets the sound sample rate (given in Hz, default: %i)\\n\"\r\n            \" --audiobuffer <size>   Sets the size of the audio buffer (-> sound latency)\\n\"\r\n            \"                        (given in bytes, default: 2048 / (44100 / samplerate))\\n\"\r\n            \" --ignorenumchunks      Ignores the number of chunks in VGAHEAD.*\\n\"\r\n            \"                        (may be useful for some broken mods)\\n\"\r\n            \" --configdir <dir>      Directory where config file and save games are stored\\n\"\r\n#if defined(_WIN32)\r\n            \"                        (default: current directory)\\n\"\r\n#else\r\n            \"                        (default: $HOME/.chocolate_wolfenstein_3d)\\n\"\r\n#endif\r\n#if defined(SPEAR) && !defined(SPEARDEMO)\r\n            \" --mission <mission>    Mission number to play (0-3)\\n\"\r\n            \"                        (default: 0 -> .sod, 1-3 -> .sd*)\\n\"\r\n            \" --goodtimes            Disable copy protection quiz\\n\"\r\n#endif\r\n            , defaultSampleRate\r\n        );\r\n    }\r\n    if (hasError) {\r\n        exit(1);\r\n    }\r\n\r\n    if(sampleRateGiven && !audioBufferGiven)\r\n        param_audiobuffer = 2048 / (44100 / param_samplerate);\r\n}\r\n\r\n/*\r\n==========================\r\n=\r\n= main\r\n=\r\n==========================\r\n*/\r\n\r\nint main (int argc, char *argv[])\r\n{\r\n\r\n    printf(\"main started\\n\");\r\n\r\n    CheckParameters(argc, argv);\r\n\r\n    CheckForEpisodes();\r\n\r\n    printf(\"InitGame\\n\");\r\n    InitGame();\r\n\r\n    // printf(\"after InitGame\\n\"); exit(123);\r\n\r\n    printf(\"about to start demoloop\\n\");\r\n    DemoLoop();\r\n\r\n    // Quit(\"Demo loop exited???\");\r\n    return 1;\r\n}\r\n","////////////////////////////////////////////////////////////////////\r\n//\r\n// WL_MENU.C\r\n// by John Romero (C) 1992 Id Software, Inc.\r\n//\r\n////////////////////////////////////////////////////////////////////\r\n\r\n#include <sys/stat.h>\r\n#include <sys/types.h>\r\n#ifdef _WIN32\r\n    #include <io.h>\r\n    #include <direct.h>\r\n#else\r\n    #include <unistd.h>\r\n#endif\r\n\r\n#include \"wl_def.h\"\r\n#pragma hdrstop\r\n\r\n#ifdef __EMSCRIPTEN__\r\n#include <emscripten.h>\r\n#endif\r\n\r\nextern int lastgamemusicoffset;\r\nextern int numEpisodesMissing;\r\n\r\n//\r\n// PRIVATE PROTOTYPES\r\n//\r\nint CP_ReadThis (int);\r\n\r\n#ifdef SPEAR\r\n#define STARTITEM       newgame\r\n\r\n#else\r\n#ifdef GOODTIMES\r\n#define STARTITEM       newgame\r\n\r\n#else\r\n#define STARTITEM       readthis\r\n#endif\r\n#endif\r\n\r\n// ENDSTRx constants are defined in foreign.h\r\nchar endStrings[9][80] = {\r\n    ENDSTR1,\r\n    ENDSTR2,\r\n    ENDSTR3,\r\n    ENDSTR4,\r\n    ENDSTR5,\r\n    ENDSTR6,\r\n    ENDSTR7,\r\n    ENDSTR8,\r\n    ENDSTR9\r\n};\r\n\r\nCP_itemtype MainMenu[] = {\r\n#ifdef JAPAN\r\n    {1, \"\", CP_NewGame},\r\n    {1, \"\", CP_Sound},\r\n    {1, \"\", CP_Control},\r\n    {1, \"\", CP_LoadGame},\r\n    {0, \"\", CP_SaveGame},\r\n    {1, \"\", CP_ChangeView},\r\n    {2, \"\", CP_ReadThis},\r\n    {1, \"\", CP_ViewScores},\r\n    {1, \"\", 0},\r\n    {1, \"\", 0}\r\n#else\r\n\r\n    {1, STR_NG, CP_NewGame},\r\n    {1, STR_SD, CP_Sound},\r\n    {1, STR_CL, CP_Control},\r\n    {1, STR_LG, CP_LoadGame},\r\n    {0, STR_SG, CP_SaveGame},\r\n    {1, STR_CV, CP_ChangeView},\r\n\r\n#ifndef GOODTIMES\r\n#ifndef SPEAR\r\n\r\n#ifdef SPANISH\r\n    {2, \"Ve esto!\", CP_ReadThis},\r\n#else\r\n    {2, \"Read This!\", CP_ReadThis},\r\n#endif\r\n\r\n#endif\r\n#endif\r\n\r\n    {1, STR_VS, CP_ViewScores},\r\n    {1, STR_BD, 0},\r\n    {1, STR_QT, 0}\r\n#endif\r\n};\r\n\r\nCP_itemtype SndMenu[] = {\r\n#ifdef JAPAN\r\n    {1, \"\", 0},\r\n    {1, \"\", 0},\r\n    {1, \"\", 0},\r\n    {0, \"\", 0},\r\n    {0, \"\", 0},\r\n    {1, \"\", 0},\r\n    {1, \"\", 0},\r\n    {1, \"\", 0},\r\n    {0, \"\", 0},\r\n    {0, \"\", 0},\r\n    {1, \"\", 0},\r\n    {1, \"\", 0},\r\n#else\r\n    {1, STR_NONE, 0},\r\n    {0, STR_PC, 0},\r\n    {1, STR_ALSB, 0},\r\n    {0, \"\", 0},\r\n    {0, \"\", 0},\r\n    {1, STR_NONE, 0},\r\n    {0, STR_DISNEY, 0},\r\n    {1, STR_SB, 0},\r\n    {0, \"\", 0},\r\n    {0, \"\", 0},\r\n    {1, STR_NONE, 0},\r\n    {1, STR_ALSB, 0}\r\n#endif\r\n};\r\n\r\nenum { CTL_MOUSEENABLE, CTL_MOUSESENS, CTL_JOYENABLE, CTL_CUSTOMIZE };\r\n\r\nCP_itemtype CtlMenu[] = {\r\n#ifdef JAPAN\r\n    {0, \"\", 0},\r\n    {0, \"\", MouseSensitivity},\r\n    {0, \"\", 0},\r\n    {1, \"\", CustomControls}\r\n#else\r\n    {0, STR_MOUSEEN, 0},\r\n    {0, STR_SENS, MouseSensitivity},\r\n    {0, STR_JOYEN, 0},\r\n    {1, STR_CUSTOM, CustomControls}\r\n#endif\r\n};\r\n\r\n#ifndef SPEAR\r\nCP_itemtype NewEmenu[] = {\r\n#ifdef JAPAN\r\n#ifdef JAPDEMO\r\n    {1, \"\", 0},\r\n    {0, \"\", 0},\r\n    {0, \"\", 0},\r\n    {0, \"\", 0},\r\n    {0, \"\", 0},\r\n    {0, \"\", 0},\r\n    {0, \"\", 0},\r\n    {0, \"\", 0},\r\n    {0, \"\", 0},\r\n    {0, \"\", 0},\r\n    {0, \"\", 0},\r\n    {0, \"\", 0},\r\n#else\r\n    {1, \"\", 0},\r\n    {0, \"\", 0},\r\n    {1, \"\", 0},\r\n    {0, \"\", 0},\r\n    {1, \"\", 0},\r\n    {0, \"\", 0},\r\n    {1, \"\", 0},\r\n    {0, \"\", 0},\r\n    {1, \"\", 0},\r\n    {0, \"\", 0},\r\n    {1, \"\", 0},\r\n    {0, \"\", 0}\r\n#endif\r\n#else\r\n#ifdef SPANISH\r\n    {1, \"Episodio 1\\n\" \"Fuga desde Wolfenstein\", 0},\r\n    {0, \"\", 0},\r\n    {3, \"Episodio 2\\n\" \"Operacion Eisenfaust\", 0},\r\n    {0, \"\", 0},\r\n    {3, \"Episodio 3\\n\" \"Muere, Fuhrer, Muere!\", 0},\r\n    {0, \"\", 0},\r\n    {3, \"Episodio 4\\n\" \"Un Negro Secreto\", 0},\r\n    {0, \"\", 0},\r\n    {3, \"Episodio 5\\n\" \"Huellas del Loco\", 0},\r\n    {0, \"\", 0},\r\n    {3, \"Episodio 6\\n\" \"Confrontacion\", 0}\r\n#else\r\n    {1, \"Episode 1\\n\" \"Escape from Wolfenstein\", 0},\r\n    {0, \"\", 0},\r\n    {3, \"Episode 2\\n\" \"Operation: Eisenfaust\", 0},\r\n    {0, \"\", 0},\r\n    {3, \"Episode 3\\n\" \"Die, Fuhrer, Die!\", 0},\r\n    {0, \"\", 0},\r\n    {3, \"Episode 4\\n\" \"A Dark Secret\", 0},\r\n    {0, \"\", 0},\r\n    {3, \"Episode 5\\n\" \"Trail of the Madman\", 0},\r\n    {0, \"\", 0},\r\n    {3, \"Episode 6\\n\" \"Confrontation\", 0}\r\n#endif\r\n#endif\r\n};\r\n#endif\r\n\r\n\r\nCP_itemtype NewMenu[] = {\r\n#ifdef JAPAN\r\n    {1, \"\", 0},\r\n    {1, \"\", 0},\r\n    {1, \"\", 0},\r\n    {1, \"\", 0}\r\n#else\r\n    {1, STR_DADDY, 0},\r\n    {1, STR_HURTME, 0},\r\n    {1, STR_BRINGEM, 0},\r\n    {1, STR_DEATH, 0}\r\n#endif\r\n};\r\n\r\nCP_itemtype LSMenu[] = {\r\n    {1, \"\", 0},\r\n    {1, \"\", 0},\r\n    {1, \"\", 0},\r\n    {1, \"\", 0},\r\n    {1, \"\", 0},\r\n    {1, \"\", 0},\r\n    {1, \"\", 0},\r\n    {1, \"\", 0},\r\n    {1, \"\", 0},\r\n    {1, \"\", 0}\r\n};\r\n\r\nCP_itemtype CusMenu[] = {\r\n    {1, \"\", 0},\r\n    {0, \"\", 0},\r\n    {0, \"\", 0},\r\n    {1, \"\", 0},\r\n    {0, \"\", 0},\r\n    {0, \"\", 0},\r\n    {1, \"\", 0},\r\n    {0, \"\", 0},\r\n    {1, \"\", 0}\r\n};\r\n\r\n// CP_iteminfo struct format: short x, y, amount, curpos, indent;\r\nCP_iteminfo MainItems = { MENU_X, MENU_Y, lengthof(MainMenu), STARTITEM, 24 },\r\n            SndItems  = { SM_X, SM_Y1, lengthof(SndMenu), 0, 52 },\r\n            LSItems   = { LSM_X, LSM_Y, lengthof(LSMenu), 0, 24 },\r\n            CtlItems  = { CTL_X, CTL_Y, lengthof(CtlMenu), -1, 56 },\r\n            CusItems  = { 8, CST_Y + 13 * 2, lengthof(CusMenu), -1, 0},\r\n#ifndef SPEAR\r\n            NewEitems = { NE_X, NE_Y, lengthof(NewEmenu), 0, 88 },\r\n#endif\r\n            NewItems  = { NM_X, NM_Y, lengthof(NewMenu), 2, 24 };\r\n\r\nint color_hlite[] = {\r\n    DEACTIVE,\r\n    HIGHLIGHT,\r\n    READHCOLOR,\r\n    0x67\r\n};\r\n\r\nint color_norml[] = {\r\n    DEACTIVE,\r\n    TEXTCOLOR,\r\n    READCOLOR,\r\n    0x6b\r\n};\r\n\r\nint EpisodeSelect[6] = { 1 };\r\n\r\n\r\nstatic int SaveGamesAvail[10];\r\nstatic int StartGame;\r\nstatic int SoundStatus = 1;\r\nstatic int pickquick;\r\nstatic char SaveGameNames[10][32];\r\nstatic char SaveName[13] = \"savegam?.\";\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// INPUT MANAGER SCANCODE TABLES\r\n//\r\n////////////////////////////////////////////////////////////////////\r\n\r\n#if 0\r\nstatic const char *ScanNames[] =      // Scan code names with single chars\r\n{\r\n    \"?\", \"?\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"0\", \"-\", \"+\", \"?\", \"?\",\r\n    \"Q\", \"W\", \"E\", \"R\", \"T\", \"Y\", \"U\", \"I\", \"O\", \"P\", \"[\", \"]\", \"|\", \"?\", \"A\", \"S\",\r\n    \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \";\", \"\\\"\", \"?\", \"?\", \"?\", \"Z\", \"X\", \"C\", \"V\",\r\n    \"B\", \"N\", \"M\", \",\", \".\", \"/\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\",\r\n    \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"\\xf\", \"?\", \"-\", \"\\x15\", \"5\", \"\\x11\", \"+\", \"?\",\r\n    \"\\x13\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\",\r\n    \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\",\r\n    \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\", \"?\"\r\n};                              // DEBUG - consolidate these\r\nstatic ScanCode ExtScanCodes[] =        // Scan codes with >1 char names\r\n{\r\n    1, 0xe, 0xf, 0x1d, 0x2a, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e,\r\n    0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x57, 0x59, 0x46, 0x1c, 0x36,\r\n    0x37, 0x38, 0x47, 0x49, 0x4f, 0x51, 0x52, 0x53, 0x45, 0x48,\r\n    0x50, 0x4b, 0x4d, 0x00\r\n};\r\nstatic const char *ExtScanNames[] =   // Names corresponding to ExtScanCodes\r\n{\r\n    \"Esc\", \"BkSp\", \"Tab\", \"Ctrl\", \"LShft\", \"Space\", \"CapsLk\", \"F1\", \"F2\", \"F3\", \"F4\",\r\n    \"F5\", \"F6\", \"F7\", \"F8\", \"F9\", \"F10\", \"F11\", \"F12\", \"ScrlLk\", \"Enter\", \"RShft\",\r\n    \"PrtSc\", \"Alt\", \"Home\", \"PgUp\", \"End\", \"PgDn\", \"Ins\", \"Del\", \"NumLk\", \"Up\",\r\n    \"Down\", \"Left\", \"Right\", \"\"\r\n};\r\n\r\n/*#pragma warning 737 9\r\nstatic byte\r\n                                        *ScanNames[] =          // Scan code names with single chars\r\n                                        {\r\n        \"?\",\"?\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"0\",\"-\",\"+\",\"?\",\"?\",\r\n        \"Q\",\"W\",\"E\",\"R\",\"T\",\"Y\",\"U\",\"I\",\"O\",\"P\",\"[\",\"]\",\"|\",\"?\",\"A\",\"S\",\r\n        \"D\",\"F\",\"G\",\"H\",\"J\",\"K\",\"L\",\";\",\"\\\"\",\"?\",\"?\",\"?\",\"Z\",\"X\",\"C\",\"V\",\r\n        \"B\",\"N\",\"M\",\",\",\".\",\"/\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"\\xf\",\"?\",\"-\",\"\\x15\",\"5\",\"\\x11\",\"+\",\"?\",\r\n        \"\\x13\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\"\r\n                                        };      // DEBUG - consolidate these\r\nstatic byte ExtScanCodes[] =    // Scan codes with >1 char names\r\n                                        {\r\n        1,0xe,0xf,0x1d,0x2a,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,\r\n        0x3f,0x40,0x41,0x42,0x43,0x44,0x57,0x59,0x46,0x1c,0x36,\r\n        0x37,0x38,0x47,0x49,0x4f,0x51,0x52,0x53,0x45,0x48,\r\n        0x50,0x4b,0x4d,0x00\r\n                                        };\r\nstatic byte *ExtScanNames[] =   // Names corresponding to ExtScanCodes\r\n                                        {\r\n        \"Esc\",\"BkSp\",\"Tab\",\"Ctrl\",\"LShft\",\"Space\",\"CapsLk\",\"F1\",\"F2\",\"F3\",\"F4\",\r\n        \"F5\",\"F6\",\"F7\",\"F8\",\"F9\",\"F10\",\"F11\",\"F12\",\"ScrlLk\",\"Enter\",\"RShft\",\r\n        \"PrtSc\",\"Alt\",\"Home\",\"PgUp\",\"End\",\"PgDn\",\"Ins\",\"Del\",\"NumLk\",\"Up\",\r\n        \"Down\",\"Left\",\"Right\",\"\"\r\n                                        };*/\r\n\r\n#else\r\nstatic const char* const ScanNames[SDLK_LAST] =\r\n    {\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",                                //   0\r\n        \"BkSp\",\"Tab\",\"?\",\"?\",\"?\",\"Return\",\"?\",\"?\",                      //   8\r\n        \"?\",\"?\",\"?\",\"Pause\",\"?\",\"?\",\"?\",\"?\",                            //  16\r\n        \"?\",\"?\",\"?\",\"Esc\",\"?\",\"?\",\"?\",\"?\",                              //  24\r\n        \"Space\",\"!\",\"\\\"\",\"#\",\"$\",\"?\",\"&\",\"'\",                           //  32\r\n        \"(\",\")\",\"*\",\"+\",\",\",\"-\",\".\",\"/\",                                //  40\r\n        \"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",                                //  48\r\n        \"8\",\"9\",\":\",\";\",\"<\",\"=\",\">\",\"?\",                                //  56\r\n        \"@\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",                                //  64\r\n        \"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",                                //  72\r\n        \"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",                                //  80\r\n        \"X\",\"Y\",\"Z\",\"[\",\"\\\\\",\"]\",\"^\",\"_\",                               //  88\r\n        \"`\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"h\",                                //  96\r\n        \"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",                                // 104\r\n        \"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",                                // 112\r\n        \"x\",\"y\",\"z\",\"{\",\"|\",\"}\",\"~\",\"?\",                                // 120\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",                                // 128\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",                                // 136\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",                                // 144\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",                                // 152\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",                                // 160\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",                                // 168\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",                                // 176\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",                                // 184\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",                                // 192\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",                                // 200\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",                                // 208\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",                                // 216\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",                                // 224\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",                                // 232\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",                                // 240\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",                                // 248\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",                                // 256\r\n        \"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"Enter\",                            // 264\r\n        \"?\",\"Up\",\"Down\",\"Right\",\"Left\",\"Ins\",\"Home\",\"End\",              // 272\r\n        \"PgUp\",\"PgDn\",\"F1\",\"F2\",\"F3\",\"F4\",\"F5\",\"F6\",                    // 280\r\n        \"F7\",\"F8\",\"F9\",\"F10\",\"F11\",\"F12\",\"?\",\"?\",                       // 288\r\n        \"?\",\"?\",\"?\",\"?\",\"NumLk\",\"CapsLk\",\"ScrlLk\",\"RShft\",              // 296\r\n        \"Shift\",\"RCtrl\",\"Ctrl\",\"RAlt\",\"Alt\",\"?\",\"?\",\"?\",                // 304\r\n        \"?\",\"?\",\"?\",\"?\",\"PrtSc\",\"?\",\"?\",\"?\",                            // 312\r\n        \"?\",\"?\"                                                         // 320\r\n    };\r\n\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// Wolfenstein Control Panel!  Ta Da!\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_ControlPanel (ScanCode scancode)\r\n{\r\n    int which;\r\n\r\n    if (ingame)\r\n    {\r\n        if (CP_CheckQuick (scancode))\r\n            return;\r\n        lastgamemusicoffset = StartCPMusic (MENUSONG);\r\n    }\r\n    else\r\n        StartCPMusic (MENUSONG);\r\n    SetupControlPanel ();\r\n\r\n    //\r\n    // F-KEYS FROM WITHIN GAME\r\n    //\r\n    switch (scancode)\r\n    {\r\n        case sc_F1:\r\n#ifdef SPEAR\r\n            BossKey ();\r\n#else\r\n#ifdef GOODTIMES\r\n            BossKey ();\r\n#else\r\n            HelpScreens ();\r\n#endif\r\n#endif\r\n            goto finishup;\r\n\r\n        case sc_F2:\r\n            CP_SaveGame (0);\r\n            goto finishup;\r\n\r\n        case sc_F3:\r\n            CP_LoadGame (0);\r\n            goto finishup;\r\n\r\n        case sc_F4:\r\n            CP_Sound (0);\r\n            goto finishup;\r\n\r\n        case sc_F5:\r\n            CP_ChangeView (0);\r\n            goto finishup;\r\n\r\n        case sc_F6:\r\n            CP_Control (0);\r\n            goto finishup;\r\n\r\n        finishup:\r\n            CleanupControlPanel ();\r\n#ifdef SPEAR\r\n            UnCacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n#endif\r\n            return;\r\n    }\r\n\r\n#ifdef SPEAR\r\n    CacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n#endif\r\n\r\n    DrawMainMenu ();\r\n    MenuFadeIn ();\r\n    StartGame = 0;\r\n\r\n    //\r\n    // MAIN MENU LOOP\r\n    //\r\n    do\r\n    {\r\n        which = HandleMenu (&MainItems, &MainMenu[0], NULL);\r\n\r\n#ifdef SPEAR\r\n#ifndef SPEARDEMO\r\n        IN_ProcessEvents();\r\n\r\n        //\r\n        // EASTER EGG FOR SPEAR OF DESTINY!\r\n        //\r\n        if (Keyboard[sc_I] && Keyboard[sc_D])\r\n        {\r\n            VW_FadeOut ();\r\n            StartCPMusic (XJAZNAZI_MUS);\r\n            UnCacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n            UnCacheLump (BACKDROP_LUMP_START, BACKDROP_LUMP_END);\r\n            ClearMemory ();\r\n\r\n\r\n            CA_CacheGrChunk (IDGUYS1PIC);\r\n            VWB_DrawPic (0, 0, IDGUYS1PIC);\r\n            UNCACHEGRCHUNK (IDGUYS1PIC);\r\n\r\n            CA_CacheGrChunk (IDGUYS2PIC);\r\n            VWB_DrawPic (0, 80, IDGUYS2PIC);\r\n            UNCACHEGRCHUNK (IDGUYS2PIC);\r\n\r\n            VW_UpdateScreen ();\r\n\r\n            SDL_Color pal[256];\r\n            CA_CacheGrChunk (IDGUYSPALETTE);\r\n            VL_ConvertPalette(grsegs[IDGUYSPALETTE], pal, 256);\r\n            VL_FadeIn (0, 255, pal, 30);\r\n            UNCACHEGRCHUNK (IDGUYSPALETTE);\r\n\r\n            while (Keyboard[sc_I] || Keyboard[sc_D])\r\n                IN_WaitAndProcessEvents();\r\n            IN_ClearKeysDown ();\r\n            IN_Ack ();\r\n\r\n            VW_FadeOut ();\r\n\r\n            CacheLump (BACKDROP_LUMP_START, BACKDROP_LUMP_END);\r\n            CacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n            DrawMainMenu ();\r\n            StartCPMusic (MENUSONG);\r\n            MenuFadeIn ();\r\n        }\r\n#endif\r\n#endif\r\n\r\n        switch (which)\r\n        {\r\n            case viewscores:\r\n                if (MainMenu[viewscores].routine == NULL)\r\n                {\r\n                    if (CP_EndGame (0))\r\n                        StartGame = 1;\r\n                }\r\n                else\r\n                {\r\n                    DrawMainMenu();\r\n                    MenuFadeIn ();\r\n                }\r\n                break;\r\n\r\n            case backtodemo:\r\n                StartGame = 1;\r\n                if (!ingame)\r\n                    StartCPMusic (INTROSONG);\r\n                VL_FadeOut (0, 255, 0, 0, 0, 10);\r\n                break;\r\n\r\n            case -1:\r\n            case quit:\r\n                CP_Quit (0);\r\n                break;\r\n\r\n            default:\r\n                if (!StartGame)\r\n                {\r\n                    DrawMainMenu ();\r\n                    MenuFadeIn ();\r\n                }\r\n        }\r\n\r\n        //\r\n        // \"EXIT OPTIONS\" OR \"NEW GAME\" EXITS\r\n        //\r\n    }\r\n    while (!StartGame);\r\n\r\n    //\r\n    // DEALLOCATE EVERYTHING\r\n    //\r\n    CleanupControlPanel ();\r\n\r\n    //\r\n    // CHANGE MAINMENU ITEM\r\n    //\r\n    if (startgame || loadedgame)\r\n        EnableEndGameMenuItem();\r\n\r\n    // RETURN/START GAME EXECUTION\r\n\r\n#ifdef SPEAR\r\n    UnCacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n#endif\r\n}\r\n\r\nvoid EnableEndGameMenuItem()\r\n{\r\n    MainMenu[viewscores].routine = NULL;\r\n#ifndef JAPAN\r\n    strcpy (MainMenu[viewscores].string, STR_EG);\r\n#endif\r\n}\r\n\r\n////////////////////////\r\n//\r\n// DRAW MAIN MENU SCREEN\r\n//\r\nvoid\r\nDrawMainMenu (void)\r\n{\r\n#ifdef JAPAN\r\n    CA_CacheScreen (S_OPTIONSPIC);\r\n#else\r\n    ClearMScreen ();\r\n\r\n    VWB_DrawPic (112, 184, C_MOUSELBACKPIC);\r\n    DrawStripes (10);\r\n    VWB_DrawPic (84, 0, C_OPTIONSPIC);\r\n\r\n#ifdef SPANISH\r\n    DrawWindow (MENU_X - 8, MENU_Y - 3, MENU_W + 8, MENU_H, BKGDCOLOR);\r\n#else\r\n    DrawWindow (MENU_X - 8, MENU_Y - 3, MENU_W, MENU_H, BKGDCOLOR);\r\n#endif\r\n#endif\r\n\r\n    //\r\n    // CHANGE \"GAME\" AND \"DEMO\"\r\n    //\r\n    if (ingame)\r\n    {\r\n#ifndef JAPAN\r\n\r\n#ifdef SPANISH\r\n        strcpy (&MainMenu[backtodemo].string, STR_GAME);\r\n#else\r\n        strcpy (&MainMenu[backtodemo].string[8], STR_GAME);\r\n#endif\r\n\r\n#else\r\n        CA_CacheGrChunk (C_MRETGAMEPIC);\r\n        VWB_DrawPic (12 * 8, 20 * 8, C_MRETGAMEPIC);\r\n        UNCACHEGRCHUNK (C_MRETGAMEPIC);\r\n        CA_CacheGrChunk (C_MENDGAMEPIC);\r\n        VWB_DrawPic (12 * 8, 18 * 8, C_MENDGAMEPIC);\r\n        UNCACHEGRCHUNK (C_MENDGAMEPIC);\r\n#endif\r\n        MainMenu[backtodemo].active = 2;\r\n    }\r\n    else\r\n    {\r\n#ifndef JAPAN\r\n#ifdef SPANISH\r\n        strcpy (&MainMenu[backtodemo].string, STR_BD);\r\n#else\r\n        strcpy (&MainMenu[backtodemo].string[8], STR_DEMO);\r\n#endif\r\n#else\r\n        CA_CacheGrChunk (C_MRETDEMOPIC);\r\n        VWB_DrawPic (12 * 8, 20 * 8, C_MRETDEMOPIC);\r\n        UNCACHEGRCHUNK (C_MRETDEMOPIC);\r\n        CA_CacheGrChunk (C_MSCORESPIC);\r\n        VWB_DrawPic (12 * 8, 18 * 8, C_MSCORESPIC);\r\n        UNCACHEGRCHUNK (C_MSCORESPIC);\r\n#endif\r\n        MainMenu[backtodemo].active = 1;\r\n    }\r\n\r\n    DrawMenu (&MainItems, &MainMenu[0]);\r\n    VW_UpdateScreen ();\r\n}\r\n\r\n#ifndef GOODTIMES\r\n#ifndef SPEAR\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// READ THIS!\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nint\r\nCP_ReadThis (int)\r\n{\r\n    StartCPMusic (CORNER_MUS);\r\n    HelpScreens ();\r\n    StartCPMusic (MENUSONG);\r\n    return true;\r\n}\r\n#endif\r\n#endif\r\n\r\n\r\n#ifdef GOODTIMES\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// BOSS KEY\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nvoid\r\nBossKey (void)\r\n{\r\n#ifdef NOTYET\r\n    byte palette1[256][3];\r\n    SD_MusicOff ();\r\n/*       _AX = 3;\r\n        geninterrupt(0x10); */\r\n    _asm\r\n    {\r\n    mov eax, 3 int 0x10}\r\n    puts (\"C>\");\r\n    SetTextCursor (2, 0);\r\n//      while (!Keyboard[sc_Escape])\r\n    IN_Ack ();\r\n    IN_ClearKeysDown ();\r\n\r\n    SD_MusicOn ();\r\n    VL_SetVGAPlaneMode ();\r\n    for (int i = 0; i < 768; i++)\r\n        palette1[0][i] = 0;\r\n\r\n    VL_SetPalette (&palette1[0][0]);\r\n    LoadLatchMem ();\r\n#endif\r\n}\r\n#else\r\n#ifdef SPEAR\r\nvoid\r\nBossKey (void)\r\n{\r\n#ifdef NOTYET\r\n    byte palette1[256][3];\r\n    SD_MusicOff ();\r\n/*       _AX = 3;\r\n        geninterrupt(0x10); */\r\n    _asm\r\n    {\r\n    mov eax, 3 int 0x10}\r\n    puts (\"C>\");\r\n    SetTextCursor (2, 0);\r\n//      while (!Keyboard[sc_Escape])\r\n    IN_Ack ();\r\n    IN_ClearKeysDown ();\r\n\r\n    SD_MusicOn ();\r\n    VL_SetVGAPlaneMode ();\r\n    for (int i = 0; i < 768; i++)\r\n        palette1[0][i] = 0;\r\n\r\n    VL_SetPalette (&palette1[0][0]);\r\n    LoadLatchMem ();\r\n#endif\r\n}\r\n#endif\r\n#endif\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// CHECK QUICK-KEYS & QUIT (WHILE IN A GAME)\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nint\r\nCP_CheckQuick (ScanCode scancode)\r\n{\r\n    switch (scancode)\r\n    {\r\n        //\r\n        // END GAME\r\n        //\r\n        case sc_F7:\r\n            CA_CacheGrChunk (STARTFONT + 1);\r\n\r\n            WindowH = 160;\r\n#ifdef JAPAN\r\n            if (GetYorN (7, 8, C_JAPQUITPIC))\r\n#else\r\n            if (Confirm (ENDGAMESTR))\r\n#endif\r\n            {\r\n                playstate = ex_died;\r\n                killerobj = NULL;\r\n                pickquick = gamestate.lives = 0;\r\n            }\r\n\r\n            WindowH = 200;\r\n            fontnumber = 0;\r\n            MainMenu[savegame].active = 0;\r\n            return 1;\r\n\r\n        //\r\n        // QUICKSAVE\r\n        //\r\n        case sc_F8:\r\n            if (SaveGamesAvail[LSItems.curpos] && pickquick)\r\n            {\r\n                CA_CacheGrChunk (STARTFONT + 1);\r\n                fontnumber = 1;\r\n                Message (STR_SAVING \"...\");\r\n                CP_SaveGame (1);\r\n                fontnumber = 0;\r\n            }\r\n            else\r\n            {\r\n#ifndef SPEAR\r\n                CA_CacheGrChunk (STARTFONT + 1);\r\n                CA_CacheGrChunk (C_CURSOR1PIC);\r\n                CA_CacheGrChunk (C_CURSOR2PIC);\r\n                CA_CacheGrChunk (C_DISKLOADING1PIC);\r\n                CA_CacheGrChunk (C_DISKLOADING2PIC);\r\n                CA_CacheGrChunk (C_SAVEGAMEPIC);\r\n                CA_CacheGrChunk (C_MOUSELBACKPIC);\r\n#else\r\n                CacheLump (BACKDROP_LUMP_START, BACKDROP_LUMP_END);\r\n                CA_CacheGrChunk (C_CURSOR1PIC);\r\n#endif\r\n\r\n                VW_FadeOut ();\r\n                if(screenHeight % 200 != 0)\r\n                    VL_ClearScreen(0);\r\n\r\n                lastgamemusicoffset = StartCPMusic (MENUSONG);\r\n                pickquick = CP_SaveGame (0);\r\n\r\n                SETFONTCOLOR (0, 15);\r\n                IN_ClearKeysDown ();\r\n                VW_FadeOut();\r\n                if(viewsize != 21)\r\n                    DrawPlayScreen ();\r\n\r\n                if (!startgame && !loadedgame)\r\n                    ContinueMusic (lastgamemusicoffset);\r\n\r\n                if (loadedgame)\r\n                    playstate = ex_abort;\r\n                lasttimecount = GetTimeCount ();\r\n\r\n                if (MousePresent && IN_IsInputGrabbed())\r\n                    IN_CenterMouse();     // Clear accumulated mouse movement\r\n\r\n#ifndef SPEAR\r\n                UNCACHEGRCHUNK (C_CURSOR1PIC);\r\n                UNCACHEGRCHUNK (C_CURSOR2PIC);\r\n                UNCACHEGRCHUNK (C_DISKLOADING1PIC);\r\n                UNCACHEGRCHUNK (C_DISKLOADING2PIC);\r\n                UNCACHEGRCHUNK (C_SAVEGAMEPIC);\r\n                UNCACHEGRCHUNK (C_MOUSELBACKPIC);\r\n#else\r\n                UnCacheLump (BACKDROP_LUMP_START, BACKDROP_LUMP_END);\r\n#endif\r\n            }\r\n            return 1;\r\n\r\n        //\r\n        // QUICKLOAD\r\n        //\r\n        case sc_F9:\r\n            if (SaveGamesAvail[LSItems.curpos] && pickquick)\r\n            {\r\n                char string[100] = STR_LGC;\r\n\r\n\r\n                CA_CacheGrChunk (STARTFONT + 1);\r\n                fontnumber = 1;\r\n\r\n                strcat (string, SaveGameNames[LSItems.curpos]);\r\n                strcat (string, \"\\\"?\");\r\n\r\n                if (Confirm (string))\r\n                    CP_LoadGame (1);\r\n\r\n                fontnumber = 0;\r\n            }\r\n            else\r\n            {\r\n#ifndef SPEAR\r\n                CA_CacheGrChunk (STARTFONT + 1);\r\n                CA_CacheGrChunk (C_CURSOR1PIC);\r\n                CA_CacheGrChunk (C_CURSOR2PIC);\r\n                CA_CacheGrChunk (C_DISKLOADING1PIC);\r\n                CA_CacheGrChunk (C_DISKLOADING2PIC);\r\n                CA_CacheGrChunk (C_LOADGAMEPIC);\r\n                CA_CacheGrChunk (C_MOUSELBACKPIC);\r\n#else\r\n                CA_CacheGrChunk (C_CURSOR1PIC);\r\n                CacheLump (BACKDROP_LUMP_START, BACKDROP_LUMP_END);\r\n#endif\r\n\r\n                VW_FadeOut ();\r\n                if(screenHeight % 200 != 0)\r\n                    VL_ClearScreen(0);\r\n\r\n                lastgamemusicoffset = StartCPMusic (MENUSONG);\r\n                pickquick = CP_LoadGame (0);    // loads lastgamemusicoffs\r\n\r\n                SETFONTCOLOR (0, 15);\r\n                IN_ClearKeysDown ();\r\n                VW_FadeOut();\r\n                if(viewsize != 21)\r\n                    DrawPlayScreen ();\r\n\r\n                if (!startgame && !loadedgame)\r\n                    ContinueMusic (lastgamemusicoffset);\r\n\r\n                if (loadedgame)\r\n                    playstate = ex_abort;\r\n\r\n                lasttimecount = GetTimeCount ();\r\n\r\n                if (MousePresent && IN_IsInputGrabbed())\r\n                    IN_CenterMouse();     // Clear accumulated mouse movement\r\n\r\n#ifndef SPEAR\r\n                UNCACHEGRCHUNK (C_CURSOR1PIC);\r\n                UNCACHEGRCHUNK (C_CURSOR2PIC);\r\n                UNCACHEGRCHUNK (C_DISKLOADING1PIC);\r\n                UNCACHEGRCHUNK (C_DISKLOADING2PIC);\r\n                UNCACHEGRCHUNK (C_LOADGAMEPIC);\r\n                UNCACHEGRCHUNK (C_MOUSELBACKPIC);\r\n#else\r\n                UnCacheLump (BACKDROP_LUMP_START, BACKDROP_LUMP_END);\r\n#endif\r\n            }\r\n            return 1;\r\n\r\n        //\r\n        // QUIT\r\n        //\r\n        case sc_F10:\r\n            CA_CacheGrChunk (STARTFONT + 1);\r\n\r\n            WindowX = WindowY = 0;\r\n            WindowW = 320;\r\n            WindowH = 160;\r\n#ifdef JAPAN\r\n            if (GetYorN (7, 8, C_QUITMSGPIC))\r\n#else\r\n#ifdef SPANISH\r\n            if (Confirm (ENDGAMESTR))\r\n#else\r\n            if (Confirm (endStrings[US_RndT () & 0x7 + (US_RndT () & 1)]))\r\n#endif\r\n#endif\r\n            {\r\n                VW_UpdateScreen ();\r\n                SD_MusicOff ();\r\n                SD_StopSound ();\r\n                MenuFadeOut ();\r\n\r\n                Quit (NULL);\r\n            }\r\n\r\n            DrawPlayBorder ();\r\n            WindowH = 200;\r\n            fontnumber = 0;\r\n            return 1;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// END THE CURRENT GAME\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nint\r\nCP_EndGame (int)\r\n{\r\n    int res;\r\n#ifdef JAPAN\r\n    res = GetYorN (7, 8, C_JAPQUITPIC);\r\n#else\r\n    res = Confirm (ENDGAMESTR);\r\n#endif\r\n    DrawMainMenu();\r\n    if(!res) return 0;\r\n\r\n    pickquick = gamestate.lives = 0;\r\n    playstate = ex_died;\r\n    killerobj = NULL;\r\n\r\n    MainMenu[savegame].active = 0;\r\n    MainMenu[viewscores].routine = CP_ViewScores;\r\n#ifndef JAPAN\r\n    strcpy (MainMenu[viewscores].string, STR_VS);\r\n#endif\r\n\r\n    return 1;\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// VIEW THE HIGH SCORES\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nint\r\nCP_ViewScores (int)\r\n{\r\n    fontnumber = 0;\r\n\r\n#ifdef SPEAR\r\n    UnCacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n    StartCPMusic (XAWARD_MUS);\r\n#else\r\n    StartCPMusic (ROSTER_MUS);\r\n#endif\r\n\r\n    DrawHighScores ();\r\n    VW_UpdateScreen ();\r\n    MenuFadeIn ();\r\n    fontnumber = 1;\r\n\r\n    IN_Ack ();\r\n\r\n    StartCPMusic (MENUSONG);\r\n    MenuFadeOut ();\r\n\r\n#ifdef SPEAR\r\n    CacheLump (BACKDROP_LUMP_START, BACKDROP_LUMP_END);\r\n    CacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n#endif\r\n    return 0;\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// START A NEW GAME\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nint\r\nCP_NewGame (int)\r\n{\r\n    int which, episode;\r\n\r\n#ifdef SPEAR\r\n    UnCacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n#endif\r\n\r\n\r\n#ifndef SPEAR\r\n  firstpart:\r\n\r\n    DrawNewEpisode ();\r\n    do\r\n    {\r\n        which = HandleMenu (&NewEitems, &NewEmenu[0], NULL);\r\n        switch (which)\r\n        {\r\n            case -1:\r\n                MenuFadeOut ();\r\n                return 0;\r\n\r\n            default:\r\n                if (!EpisodeSelect[which / 2])\r\n                {\r\n                    SD_PlaySound (NOWAYSND);\r\n                    Message (\"Please select \\\"Read This!\\\"\\n\"\r\n                             \"from the Options menu to\\n\"\r\n                             \"find out how to order this\\n\" \"episode from Apogee.\");\r\n                    IN_ClearKeysDown ();\r\n                    IN_Ack ();\r\n                    DrawNewEpisode ();\r\n                    which = 0;\r\n                }\r\n                else\r\n                {\r\n                    episode = which / 2;\r\n                    which = 1;\r\n                }\r\n                break;\r\n        }\r\n\r\n    }\r\n    while (!which);\r\n\r\n    ShootSnd ();\r\n\r\n    //\r\n    // ALREADY IN A GAME?\r\n    //\r\n    if (ingame)\r\n#ifdef JAPAN\r\n        if (!GetYorN (7, 8, C_JAPNEWGAMEPIC))\r\n#else\r\n        if (!Confirm (CURGAME))\r\n#endif\r\n        {\r\n            MenuFadeOut ();\r\n            return 0;\r\n        }\r\n\r\n    MenuFadeOut ();\r\n\r\n#else\r\n    episode = 0;\r\n\r\n    //\r\n    // ALREADY IN A GAME?\r\n    //\r\n    CacheLump (NEWGAME_LUMP_START, NEWGAME_LUMP_END);\r\n    DrawNewGame ();\r\n    if (ingame)\r\n        if (!Confirm (CURGAME))\r\n        {\r\n            MenuFadeOut ();\r\n            UnCacheLump (NEWGAME_LUMP_START, NEWGAME_LUMP_END);\r\n            CacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n            return 0;\r\n        }\r\n\r\n#endif\r\n\r\n    DrawNewGame ();\r\n    which = HandleMenu (&NewItems, &NewMenu[0], DrawNewGameDiff);\r\n    if (which < 0)\r\n    {\r\n        MenuFadeOut ();\r\n#ifndef SPEAR\r\n        goto firstpart;\r\n#else\r\n        UnCacheLump (NEWGAME_LUMP_START, NEWGAME_LUMP_END);\r\n        CacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n        return 0;\r\n#endif\r\n    }\r\n\r\n    ShootSnd ();\r\n    NewGame (which, episode);\r\n    StartGame = 1;\r\n    MenuFadeOut ();\r\n\r\n    //\r\n    // CHANGE \"READ THIS!\" TO NORMAL COLOR\r\n    //\r\n#ifndef SPEAR\r\n#ifndef GOODTIMES\r\n    MainMenu[readthis].active = 1;\r\n#endif\r\n#endif\r\n\r\n    pickquick = 0;\r\n\r\n#ifdef SPEAR\r\n    UnCacheLump (NEWGAME_LUMP_START, NEWGAME_LUMP_END);\r\n    CacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n#endif\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n#ifndef SPEAR\r\n/////////////////////\r\n//\r\n// DRAW NEW EPISODE MENU\r\n//\r\nvoid\r\nDrawNewEpisode (void)\r\n{\r\n    int i;\r\n\r\n#ifdef JAPAN\r\n    CA_CacheScreen (S_EPISODEPIC);\r\n#else\r\n    ClearMScreen ();\r\n    VWB_DrawPic (112, 184, C_MOUSELBACKPIC);\r\n\r\n    DrawWindow (NE_X - 4, NE_Y - 4, NE_W + 8, NE_H + 8, BKGDCOLOR);\r\n    SETFONTCOLOR (READHCOLOR, BKGDCOLOR);\r\n    PrintY = 2;\r\n    WindowX = 0;\r\n#ifdef SPANISH\r\n    US_CPrint (\"Cual episodio jugar?\");\r\n#else\r\n    US_CPrint (\"Which episode to play?\");\r\n#endif\r\n#endif\r\n\r\n    SETFONTCOLOR (TEXTCOLOR, BKGDCOLOR);\r\n    DrawMenu (&NewEitems, &NewEmenu[0]);\r\n\r\n    for (i = 0; i < 6; i++)\r\n        VWB_DrawPic (NE_X + 32, NE_Y + i * 26, C_EPISODE1PIC + i);\r\n\r\n    VW_UpdateScreen ();\r\n    MenuFadeIn ();\r\n    WaitKeyUp ();\r\n}\r\n#endif\r\n\r\n/////////////////////\r\n//\r\n// DRAW NEW GAME MENU\r\n//\r\nvoid\r\nDrawNewGame (void)\r\n{\r\n#ifdef JAPAN\r\n    CA_CacheScreen (S_SKILLPIC);\r\n#else\r\n    ClearMScreen ();\r\n    VWB_DrawPic (112, 184, C_MOUSELBACKPIC);\r\n\r\n    SETFONTCOLOR (READHCOLOR, BKGDCOLOR);\r\n    PrintX = NM_X + 20;\r\n    PrintY = NM_Y - 32;\r\n\r\n#ifndef SPEAR\r\n#ifdef SPANISH\r\n    US_Print (\"Eres macho?\");\r\n#else\r\n    US_Print (\"How tough are you?\");\r\n#endif\r\n#else\r\n    VWB_DrawPic (PrintX, PrintY, C_HOWTOUGHPIC);\r\n#endif\r\n\r\n    DrawWindow (NM_X - 5, NM_Y - 10, NM_W, NM_H, BKGDCOLOR);\r\n#endif\r\n\r\n    DrawMenu (&NewItems, &NewMenu[0]);\r\n    DrawNewGameDiff (NewItems.curpos);\r\n    VW_UpdateScreen ();\r\n    MenuFadeIn ();\r\n    WaitKeyUp ();\r\n}\r\n\r\n\r\n////////////////////////\r\n//\r\n// DRAW NEW GAME GRAPHIC\r\n//\r\nvoid\r\nDrawNewGameDiff (int w)\r\n{\r\n    VWB_DrawPic (NM_X + 185, NM_Y + 7, w + C_BABYMODEPIC);\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// HANDLE SOUND MENU\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nint\r\nCP_Sound (int)\r\n{\r\n    int which;\r\n\r\n\r\n#ifdef SPEAR\r\n    UnCacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n    CacheLump (SOUND_LUMP_START, SOUND_LUMP_END);\r\n#endif\r\n\r\n    DrawSoundMenu ();\r\n    MenuFadeIn ();\r\n    WaitKeyUp ();\r\n\r\n    do\r\n    {\r\n        which = HandleMenu (&SndItems, &SndMenu[0], NULL);\r\n        //\r\n        // HANDLE MENU CHOICES\r\n        //\r\n        switch (which)\r\n        {\r\n                //\r\n                // SOUND EFFECTS\r\n                //\r\n            case 0:\r\n                if (SoundMode != sdm_Off)\r\n                {\r\n                    SD_WaitSoundDone ();\r\n                    SD_SetSoundMode (sdm_Off);\r\n                    DrawSoundMenu ();\r\n                }\r\n                break;\r\n            case 1:\r\n                if (SoundMode != sdm_PC)\r\n                {\r\n                    SD_WaitSoundDone ();\r\n                    SD_SetSoundMode (sdm_PC);\r\n                    CA_LoadAllSounds ();\r\n                    DrawSoundMenu ();\r\n                    ShootSnd ();\r\n                }\r\n                break;\r\n            case 2:\r\n                if (SoundMode != sdm_AdLib)\r\n                {\r\n                    SD_WaitSoundDone ();\r\n                    SD_SetSoundMode (sdm_AdLib);\r\n                    CA_LoadAllSounds ();\r\n                    DrawSoundMenu ();\r\n                    ShootSnd ();\r\n                }\r\n                break;\r\n\r\n                //\r\n                // DIGITIZED SOUND\r\n                //\r\n            case 5:\r\n                if (DigiMode != sds_Off)\r\n                {\r\n                    SD_SetDigiDevice (sds_Off);\r\n                    DrawSoundMenu ();\r\n                }\r\n                break;\r\n            case 6:\r\n/*                if (DigiMode != sds_SoundSource)\r\n                {\r\n                    SD_SetDigiDevice (sds_SoundSource);\r\n                    DrawSoundMenu ();\r\n                    ShootSnd ();\r\n                }*/\r\n                break;\r\n            case 7:\r\n                if (DigiMode != sds_SoundBlaster)\r\n                {\r\n                    SD_SetDigiDevice (sds_SoundBlaster);\r\n                    DrawSoundMenu ();\r\n                    ShootSnd ();\r\n                }\r\n                break;\r\n\r\n                //\r\n                // MUSIC\r\n                //\r\n            case 10:\r\n                if (MusicMode != smm_Off)\r\n                {\r\n                    SD_SetMusicMode (smm_Off);\r\n                    DrawSoundMenu ();\r\n                    ShootSnd ();\r\n                }\r\n                break;\r\n            case 11:\r\n                if (MusicMode != smm_AdLib)\r\n                {\r\n                    SD_SetMusicMode (smm_AdLib);\r\n                    DrawSoundMenu ();\r\n                    ShootSnd ();\r\n                    StartCPMusic (MENUSONG);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    while (which >= 0);\r\n\r\n    MenuFadeOut ();\r\n\r\n#ifdef SPEAR\r\n    UnCacheLump (SOUND_LUMP_START, SOUND_LUMP_END);\r\n    CacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n#endif\r\n    return 0;\r\n}\r\n\r\n\r\n//////////////////////\r\n//\r\n// DRAW THE SOUND MENU\r\n//\r\nvoid\r\nDrawSoundMenu (void)\r\n{\r\n    int i, on;\r\n\r\n\r\n#ifdef JAPAN\r\n    CA_CacheScreen (S_SOUNDPIC);\r\n#else\r\n    //\r\n    // DRAW SOUND MENU\r\n    //\r\n    ClearMScreen ();\r\n    VWB_DrawPic (112, 184, C_MOUSELBACKPIC);\r\n\r\n    DrawWindow (SM_X - 8, SM_Y1 - 3, SM_W, SM_H1, BKGDCOLOR);\r\n    DrawWindow (SM_X - 8, SM_Y2 - 3, SM_W, SM_H2, BKGDCOLOR);\r\n    DrawWindow (SM_X - 8, SM_Y3 - 3, SM_W, SM_H3, BKGDCOLOR);\r\n#endif\r\n\r\n    //\r\n    // IF NO ADLIB, NON-CHOOSENESS!\r\n    //\r\n    if (!AdLibPresent && !SoundBlasterPresent)\r\n    {\r\n        SndMenu[2].active = SndMenu[10].active = SndMenu[11].active = 0;\r\n    }\r\n\r\n    if (!SoundBlasterPresent)\r\n        SndMenu[7].active = 0;\r\n\r\n    if (!SoundBlasterPresent)\r\n        SndMenu[5].active = 0;\r\n\r\n    DrawMenu (&SndItems, &SndMenu[0]);\r\n#ifndef JAPAN\r\n    VWB_DrawPic (100, SM_Y1 - 20, C_FXTITLEPIC);\r\n    VWB_DrawPic (100, SM_Y2 - 20, C_DIGITITLEPIC);\r\n    VWB_DrawPic (100, SM_Y3 - 20, C_MUSICTITLEPIC);\r\n#endif\r\n\r\n    for (i = 0; i < SndItems.amount; i++)\r\n#ifdef JAPAN\r\n        if (i != 3 && i != 4 && i != 8 && i != 9)\r\n#else\r\n        if (SndMenu[i].string[0])\r\n#endif\r\n        {\r\n            //\r\n            // DRAW SELECTED/NOT SELECTED GRAPHIC BUTTONS\r\n            //\r\n            on = 0;\r\n            switch (i)\r\n            {\r\n                    //\r\n                    // SOUND EFFECTS\r\n                    //\r\n                case 0:\r\n                    if (SoundMode == sdm_Off)\r\n                        on = 1;\r\n                    break;\r\n                case 1:\r\n                    if (SoundMode == sdm_PC)\r\n                        on = 1;\r\n                    break;\r\n                case 2:\r\n                    if (SoundMode == sdm_AdLib)\r\n                        on = 1;\r\n                    break;\r\n\r\n                    //\r\n                    // DIGITIZED SOUND\r\n                    //\r\n                case 5:\r\n                    if (DigiMode == sds_Off)\r\n                        on = 1;\r\n                    break;\r\n                case 6:\r\n//                    if (DigiMode == sds_SoundSource)\r\n//                        on = 1;\r\n                    break;\r\n                case 7:\r\n                    if (DigiMode == sds_SoundBlaster)\r\n                        on = 1;\r\n                    break;\r\n\r\n                    //\r\n                    // MUSIC\r\n                    //\r\n                case 10:\r\n                    if (MusicMode == smm_Off)\r\n                        on = 1;\r\n                    break;\r\n                case 11:\r\n                    if (MusicMode == smm_AdLib)\r\n                        on = 1;\r\n                    break;\r\n            }\r\n\r\n            if (on)\r\n                VWB_DrawPic (SM_X + 24, SM_Y1 + i * 13 + 2, C_SELECTEDPIC);\r\n            else\r\n                VWB_DrawPic (SM_X + 24, SM_Y1 + i * 13 + 2, C_NOTSELECTEDPIC);\r\n        }\r\n\r\n    DrawMenuGun (&SndItems);\r\n    VW_UpdateScreen ();\r\n}\r\n\r\n\r\n//\r\n// DRAW LOAD/SAVE IN PROGRESS\r\n//\r\nvoid\r\nDrawLSAction (int which)\r\n{\r\n#define LSA_X   96\r\n#define LSA_Y   80\r\n#define LSA_W   130\r\n#define LSA_H   42\r\n\r\n    DrawWindow (LSA_X, LSA_Y, LSA_W, LSA_H, TEXTCOLOR);\r\n    DrawOutline (LSA_X, LSA_Y, LSA_W, LSA_H, 0, HIGHLIGHT);\r\n    VWB_DrawPic (LSA_X + 8, LSA_Y + 5, C_DISKLOADING1PIC);\r\n\r\n    fontnumber = 1;\r\n    SETFONTCOLOR (0, TEXTCOLOR);\r\n    PrintX = LSA_X + 46;\r\n    PrintY = LSA_Y + 13;\r\n\r\n    if (!which)\r\n        US_Print (STR_LOADING \"...\");\r\n    else\r\n        US_Print (STR_SAVING \"...\");\r\n\r\n    VW_UpdateScreen ();\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// LOAD SAVED GAMES\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nint\r\nCP_LoadGame (int quick)\r\n{\r\n    FILE *file;\r\n    int which, exit = 0;\r\n    char name[13];\r\n    char loadpath[300];\r\n\r\n    strcpy (name, SaveName);\r\n\r\n    //\r\n    // QUICKLOAD?\r\n    //\r\n    if (quick)\r\n    {\r\n        which = LSItems.curpos;\r\n\r\n        if (SaveGamesAvail[which])\r\n        {\r\n            name[7] = which + '0';\r\n\r\n            if(configdir[0])\r\n                snprintf(loadpath, sizeof(loadpath), \"%s/%s\", configdir, name);\r\n            else\r\n                strcpy(loadpath, name);\r\n\r\n            file = fopen (loadpath, \"rb\");\r\n            fseek (file, 32, SEEK_SET);\r\n            loadedgame = true;\r\n            LoadTheGame (file, 0, 0);\r\n            loadedgame = false;\r\n            fclose (file);\r\n\r\n            DrawFace ();\r\n            DrawHealth ();\r\n            DrawLives ();\r\n            DrawLevel ();\r\n            DrawAmmo ();\r\n            DrawKeys ();\r\n            DrawWeapon ();\r\n            DrawScore ();\r\n            ContinueMusic (lastgamemusicoffset);\r\n            return 1;\r\n        }\r\n    }\r\n\r\n\r\n#ifdef SPEAR\r\n    UnCacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n    CacheLump (LOADSAVE_LUMP_START, LOADSAVE_LUMP_END);\r\n#endif\r\n\r\n    DrawLoadSaveScreen (0);\r\n\r\n    do\r\n    {\r\n        which = HandleMenu (&LSItems, &LSMenu[0], TrackWhichGame);\r\n        if (which >= 0 && SaveGamesAvail[which])\r\n        {\r\n            ShootSnd ();\r\n            name[7] = which + '0';\r\n\r\n            if(configdir[0])\r\n                snprintf(loadpath, sizeof(loadpath), \"%s/%s\", configdir, name);\r\n            else\r\n                strcpy(loadpath, name);\r\n\r\n            file = fopen (loadpath, \"rb\");\r\n            fseek (file, 32, SEEK_SET);\r\n\r\n            DrawLSAction (0);\r\n            loadedgame = true;\r\n\r\n            LoadTheGame (file, LSA_X + 8, LSA_Y + 5);\r\n            fclose (file);\r\n\r\n            StartGame = 1;\r\n            ShootSnd ();\r\n            //\r\n            // CHANGE \"READ THIS!\" TO NORMAL COLOR\r\n            //\r\n\r\n#ifndef SPEAR\r\n#ifndef GOODTIMES\r\n            MainMenu[readthis].active = 1;\r\n#endif\r\n#endif\r\n\r\n            exit = 1;\r\n            break;\r\n        }\r\n\r\n    }\r\n    while (which >= 0);\r\n\r\n    MenuFadeOut ();\r\n\r\n#ifdef SPEAR\r\n    UnCacheLump (LOADSAVE_LUMP_START, LOADSAVE_LUMP_END);\r\n    CacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n#endif\r\n\r\n    return exit;\r\n}\r\n\r\n\r\n///////////////////////////////////\r\n//\r\n// HIGHLIGHT CURRENT SELECTED ENTRY\r\n//\r\nvoid\r\nTrackWhichGame (int w)\r\n{\r\n    static int lastgameon = 0;\r\n\r\n    PrintLSEntry (lastgameon, TEXTCOLOR);\r\n    PrintLSEntry (w, HIGHLIGHT);\r\n\r\n    lastgameon = w;\r\n}\r\n\r\n\r\n////////////////////////////\r\n//\r\n// DRAW THE LOAD/SAVE SCREEN\r\n//\r\nvoid\r\nDrawLoadSaveScreen (int loadsave)\r\n{\r\n#define DISKX   100\r\n#define DISKY   0\r\n\r\n    int i;\r\n\r\n\r\n    ClearMScreen ();\r\n    fontnumber = 1;\r\n    VWB_DrawPic (112, 184, C_MOUSELBACKPIC);\r\n    DrawWindow (LSM_X - 10, LSM_Y - 5, LSM_W, LSM_H, BKGDCOLOR);\r\n    DrawStripes (10);\r\n\r\n    if (!loadsave)\r\n        VWB_DrawPic (60, 0, C_LOADGAMEPIC);\r\n    else\r\n        VWB_DrawPic (60, 0, C_SAVEGAMEPIC);\r\n\r\n    for (i = 0; i < 10; i++)\r\n        PrintLSEntry (i, TEXTCOLOR);\r\n\r\n    DrawMenu (&LSItems, &LSMenu[0]);\r\n    VW_UpdateScreen ();\r\n    MenuFadeIn ();\r\n    WaitKeyUp ();\r\n}\r\n\r\n\r\n///////////////////////////////////////////\r\n//\r\n// PRINT LOAD/SAVE GAME ENTRY W/BOX OUTLINE\r\n//\r\nvoid\r\nPrintLSEntry (int w, int color)\r\n{\r\n    SETFONTCOLOR (color, BKGDCOLOR);\r\n    DrawOutline (LSM_X + LSItems.indent, LSM_Y + w * 13, LSM_W - LSItems.indent - 15, 11, color,\r\n                 color);\r\n    PrintX = LSM_X + LSItems.indent + 2;\r\n    PrintY = LSM_Y + w * 13 + 1;\r\n    fontnumber = 0;\r\n\r\n    if (SaveGamesAvail[w])\r\n        US_Print (SaveGameNames[w]);\r\n    else\r\n        US_Print (\"      - \" STR_EMPTY \" -\");\r\n\r\n    fontnumber = 1;\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// SAVE CURRENT GAME\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nint\r\nCP_SaveGame (int quick)\r\n{\r\n    int which, exit = 0;\r\n    FILE *file;\r\n    char name[13];\r\n    char savepath[300];\r\n    char input[32];\r\n\r\n    strcpy (name, SaveName);\r\n\r\n    //\r\n    // QUICKSAVE?\r\n    //\r\n    if (quick)\r\n    {\r\n        which = LSItems.curpos;\r\n\r\n        if (SaveGamesAvail[which])\r\n        {\r\n            name[7] = which + '0';\r\n\r\n            if(configdir[0])\r\n                snprintf(savepath, sizeof(savepath), \"%s/%s\", configdir, name);\r\n            else\r\n                strcpy(savepath, name);\r\n\r\n            unlink (savepath);\r\n            file = fopen (savepath, \"wb\");\r\n\r\n            strcpy (input, &SaveGameNames[which][0]);\r\n\r\n            fwrite (input, 1, 32, file);\r\n            fseek (file, 32, SEEK_SET);\r\n            SaveTheGame (file, 0, 0);\r\n            fclose (file);\r\n\r\n            return 1;\r\n        }\r\n    }\r\n\r\n\r\n#ifdef SPEAR\r\n    UnCacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n    CacheLump (LOADSAVE_LUMP_START, LOADSAVE_LUMP_END);\r\n#endif\r\n\r\n    DrawLoadSaveScreen (1);\r\n\r\n    do\r\n    {\r\n        which = HandleMenu (&LSItems, &LSMenu[0], TrackWhichGame);\r\n        if (which >= 0)\r\n        {\r\n            //\r\n            // OVERWRITE EXISTING SAVEGAME?\r\n            //\r\n            if (SaveGamesAvail[which])\r\n            {\r\n#ifdef JAPAN\r\n                if (!GetYorN (7, 8, C_JAPSAVEOVERPIC))\r\n#else\r\n                if (!Confirm (GAMESVD))\r\n#endif\r\n                {\r\n                    DrawLoadSaveScreen (1);\r\n                    continue;\r\n                }\r\n                else\r\n                {\r\n                    DrawLoadSaveScreen (1);\r\n                    PrintLSEntry (which, HIGHLIGHT);\r\n                    VW_UpdateScreen ();\r\n                }\r\n            }\r\n\r\n            ShootSnd ();\r\n\r\n            strcpy (input, &SaveGameNames[which][0]);\r\n            name[7] = which + '0';\r\n\r\n            fontnumber = 0;\r\n            if (!SaveGamesAvail[which])\r\n                VWB_Bar (LSM_X + LSItems.indent + 1, LSM_Y + which * 13 + 1,\r\n                         LSM_W - LSItems.indent - 16, 10, BKGDCOLOR);\r\n            VW_UpdateScreen ();\r\n\r\n            if (US_LineInput\r\n                (LSM_X + LSItems.indent + 2, LSM_Y + which * 13 + 1, input, input, true, 31,\r\n                 LSM_W - LSItems.indent - 30))\r\n            {\r\n                SaveGamesAvail[which] = 1;\r\n                strcpy (&SaveGameNames[which][0], input);\r\n\r\n                if(configdir[0])\r\n                    snprintf(savepath, sizeof(savepath), \"%s/%s\", configdir, name);\r\n                else\r\n                    strcpy(savepath, name);\r\n\r\n                unlink (savepath);\r\n                file = fopen (savepath, \"wb\");\r\n                fwrite (input, 32, 1, file);\r\n                fseek (file, 32, SEEK_SET);\r\n\r\n                DrawLSAction (1);\r\n                SaveTheGame (file, LSA_X + 8, LSA_Y + 5);\r\n\r\n                fclose (file);\r\n\r\n                ShootSnd ();\r\n                exit = 1;\r\n            }\r\n            else\r\n            {\r\n                VWB_Bar (LSM_X + LSItems.indent + 1, LSM_Y + which * 13 + 1,\r\n                         LSM_W - LSItems.indent - 16, 10, BKGDCOLOR);\r\n                PrintLSEntry (which, HIGHLIGHT);\r\n                VW_UpdateScreen ();\r\n                SD_PlaySound (ESCPRESSEDSND);\r\n                continue;\r\n            }\r\n\r\n            fontnumber = 1;\r\n            break;\r\n        }\r\n\r\n    }\r\n    while (which >= 0);\r\n\r\n    MenuFadeOut ();\r\n\r\n#ifdef SPEAR\r\n    UnCacheLump (LOADSAVE_LUMP_START, LOADSAVE_LUMP_END);\r\n    CacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n#endif\r\n\r\n    return exit;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// DEFINE CONTROLS\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nint\r\nCP_Control (int)\r\n{\r\n    int which;\r\n\r\n#ifdef SPEAR\r\n    UnCacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n    CacheLump (CONTROL_LUMP_START, CONTROL_LUMP_END);\r\n#endif\r\n\r\n    DrawCtlScreen ();\r\n    MenuFadeIn ();\r\n    WaitKeyUp ();\r\n\r\n    do\r\n    {\r\n        which = HandleMenu (&CtlItems, CtlMenu, NULL);\r\n        switch (which)\r\n        {\r\n            case CTL_MOUSEENABLE:\r\n                mouseenabled ^= 1;\r\n                if(IN_IsInputGrabbed())\r\n                    IN_CenterMouse();\r\n                DrawCtlScreen ();\r\n                CusItems.curpos = -1;\r\n                ShootSnd ();\r\n                break;\r\n\r\n            case CTL_JOYENABLE:\r\n                joystickenabled ^= 1;\r\n                DrawCtlScreen ();\r\n                CusItems.curpos = -1;\r\n                ShootSnd ();\r\n                break;\r\n\r\n            case CTL_MOUSESENS:\r\n            case CTL_CUSTOMIZE:\r\n                DrawCtlScreen ();\r\n                MenuFadeIn ();\r\n                WaitKeyUp ();\r\n                break;\r\n        }\r\n    }\r\n    while (which >= 0);\r\n\r\n    MenuFadeOut ();\r\n\r\n#ifdef SPEAR\r\n    UnCacheLump (CONTROL_LUMP_START, CONTROL_LUMP_END);\r\n    CacheLump (OPTIONS_LUMP_START, OPTIONS_LUMP_END);\r\n#endif\r\n    return 0;\r\n}\r\n\r\n\r\n////////////////////////////////\r\n//\r\n// DRAW MOUSE SENSITIVITY SCREEN\r\n//\r\nvoid\r\nDrawMouseSens (void)\r\n{\r\n#ifdef JAPAN\r\n    CA_CacheScreen (S_MOUSESENSPIC);\r\n#else\r\n    ClearMScreen ();\r\n    VWB_DrawPic (112, 184, C_MOUSELBACKPIC);\r\n#ifdef SPANISH\r\n    DrawWindow (10, 80, 300, 43, BKGDCOLOR);\r\n#else\r\n    DrawWindow (10, 80, 300, 30, BKGDCOLOR);\r\n#endif\r\n\r\n    WindowX = 0;\r\n    WindowW = 320;\r\n    PrintY = 82;\r\n    SETFONTCOLOR (READCOLOR, BKGDCOLOR);\r\n    US_CPrint (STR_MOUSEADJ);\r\n\r\n    SETFONTCOLOR (TEXTCOLOR, BKGDCOLOR);\r\n#ifdef SPANISH\r\n    PrintX = 14;\r\n    PrintY = 95 + 13;\r\n    US_Print (STR_SLOW);\r\n    PrintX = 252;\r\n    US_Print (STR_FAST);\r\n#else\r\n    PrintX = 14;\r\n    PrintY = 95;\r\n    US_Print (STR_SLOW);\r\n    PrintX = 269;\r\n    US_Print (STR_FAST);\r\n#endif\r\n#endif\r\n\r\n    VWB_Bar (60, 97, 200, 10, TEXTCOLOR);\r\n    DrawOutline (60, 97, 200, 10, 0, HIGHLIGHT);\r\n    DrawOutline (60 + 20 * mouseadjustment, 97, 20, 10, 0, READCOLOR);\r\n    VWB_Bar (61 + 20 * mouseadjustment, 98, 19, 9, READHCOLOR);\r\n\r\n    VW_UpdateScreen ();\r\n    MenuFadeIn ();\r\n}\r\n\r\n\r\n///////////////////////////\r\n//\r\n// ADJUST MOUSE SENSITIVITY\r\n//\r\nint\r\nMouseSensitivity (int)\r\n{\r\n    ControlInfo ci;\r\n    int exit = 0, oldMA;\r\n\r\n\r\n    oldMA = mouseadjustment;\r\n    DrawMouseSens ();\r\n    do\r\n    {\r\n        SDL_Delay(5);\r\n        ReadAnyControl (&ci);\r\n        switch (ci.dir)\r\n        {\r\n            case dir_North:\r\n            case dir_West:\r\n                if (mouseadjustment)\r\n                {\r\n                    mouseadjustment--;\r\n                    VWB_Bar (60, 97, 200, 10, TEXTCOLOR);\r\n                    DrawOutline (60, 97, 200, 10, 0, HIGHLIGHT);\r\n                    DrawOutline (60 + 20 * mouseadjustment, 97, 20, 10, 0, READCOLOR);\r\n                    VWB_Bar (61 + 20 * mouseadjustment, 98, 19, 9, READHCOLOR);\r\n                    VW_UpdateScreen ();\r\n                    SD_PlaySound (MOVEGUN1SND);\r\n                    TicDelay(20);\r\n                }\r\n                break;\r\n\r\n            case dir_South:\r\n            case dir_East:\r\n                if (mouseadjustment < 9)\r\n                {\r\n                    mouseadjustment++;\r\n                    VWB_Bar (60, 97, 200, 10, TEXTCOLOR);\r\n                    DrawOutline (60, 97, 200, 10, 0, HIGHLIGHT);\r\n                    DrawOutline (60 + 20 * mouseadjustment, 97, 20, 10, 0, READCOLOR);\r\n                    VWB_Bar (61 + 20 * mouseadjustment, 98, 19, 9, READHCOLOR);\r\n                    VW_UpdateScreen ();\r\n                    SD_PlaySound (MOVEGUN1SND);\r\n                    TicDelay(20);\r\n                }\r\n                break;\r\n        }\r\n\r\n        if (ci.button0 || Keyboard[sc_Space] || Keyboard[sc_Enter])\r\n            exit = 1;\r\n        else if (ci.button1 || Keyboard[sc_Escape])\r\n            exit = 2;\r\n\r\n    }\r\n    while (!exit);\r\n\r\n    if (exit == 2)\r\n    {\r\n        mouseadjustment = oldMA;\r\n        SD_PlaySound (ESCPRESSEDSND);\r\n    }\r\n    else\r\n        SD_PlaySound (SHOOTSND);\r\n\r\n    WaitKeyUp ();\r\n    MenuFadeOut ();\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n///////////////////////////\r\n//\r\n// DRAW CONTROL MENU SCREEN\r\n//\r\nvoid\r\nDrawCtlScreen (void)\r\n{\r\n    int i, x, y;\r\n\r\n#ifdef JAPAN\r\n    CA_CacheScreen (S_CONTROLPIC);\r\n#else\r\n    ClearMScreen ();\r\n    DrawStripes (10);\r\n    VWB_DrawPic (80, 0, C_CONTROLPIC);\r\n    VWB_DrawPic (112, 184, C_MOUSELBACKPIC);\r\n    DrawWindow (CTL_X - 8, CTL_Y - 5, CTL_W, CTL_H, BKGDCOLOR);\r\n#endif\r\n    WindowX = 0;\r\n    WindowW = 320;\r\n    SETFONTCOLOR (TEXTCOLOR, BKGDCOLOR);\r\n\r\n    if (IN_JoyPresent())\r\n        CtlMenu[CTL_JOYENABLE].active = 1;\r\n\r\n    if (MousePresent)\r\n    {\r\n        CtlMenu[CTL_MOUSESENS].active = CtlMenu[CTL_MOUSEENABLE].active = 1;\r\n    }\r\n\r\n    CtlMenu[CTL_MOUSESENS].active = mouseenabled;\r\n\r\n\r\n    DrawMenu (&CtlItems, CtlMenu);\r\n\r\n\r\n    x = CTL_X + CtlItems.indent - 24;\r\n    y = CTL_Y + 3;\r\n    if (mouseenabled)\r\n        VWB_DrawPic (x, y, C_SELECTEDPIC);\r\n    else\r\n        VWB_DrawPic (x, y, C_NOTSELECTEDPIC);\r\n\r\n    y = CTL_Y + 29;\r\n    if (joystickenabled)\r\n        VWB_DrawPic (x, y, C_SELECTEDPIC);\r\n    else\r\n        VWB_DrawPic (x, y, C_NOTSELECTEDPIC);\r\n\r\n    //\r\n    // PICK FIRST AVAILABLE SPOT\r\n    //\r\n    if (CtlItems.curpos < 0 || !CtlMenu[CtlItems.curpos].active)\r\n    {\r\n        for (i = 0; i < CtlItems.amount; i++)\r\n        {\r\n            if (CtlMenu[i].active)\r\n            {\r\n                CtlItems.curpos = i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    DrawMenuGun (&CtlItems);\r\n    VW_UpdateScreen ();\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// CUSTOMIZE CONTROLS\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nenum\r\n{ FIRE, STRAFE, RUN, OPEN };\r\nchar mbarray[4][3] = { \"b0\", \"b1\", \"b2\", \"b3\" };\r\nint8_t order[4] = { RUN, OPEN, FIRE, STRAFE };\r\n\r\n\r\nint\r\nCustomControls (int)\r\n{\r\n    int which;\r\n\r\n    DrawCustomScreen ();\r\n    do\r\n    {\r\n        which = HandleMenu (&CusItems, &CusMenu[0], FixupCustom);\r\n        switch (which)\r\n        {\r\n            case 0:\r\n                DefineMouseBtns ();\r\n                DrawCustMouse (1);\r\n                break;\r\n            case 3:\r\n                DefineJoyBtns ();\r\n                DrawCustJoy (0);\r\n                break;\r\n            case 6:\r\n                DefineKeyBtns ();\r\n                DrawCustKeybd (0);\r\n                break;\r\n            case 8:\r\n                DefineKeyMove ();\r\n                DrawCustKeys (0);\r\n        }\r\n    }\r\n    while (which >= 0);\r\n\r\n    MenuFadeOut ();\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n////////////////////////\r\n//\r\n// DEFINE THE MOUSE BUTTONS\r\n//\r\nvoid\r\nDefineMouseBtns (void)\r\n{\r\n    CustomCtrls mouseallowed = { 0, 1, 1, 1 };\r\n    EnterCtrlData (2, &mouseallowed, DrawCustMouse, PrintCustMouse, MOUSE);\r\n}\r\n\r\n\r\n////////////////////////\r\n//\r\n// DEFINE THE JOYSTICK BUTTONS\r\n//\r\nvoid\r\nDefineJoyBtns (void)\r\n{\r\n    CustomCtrls joyallowed = { 1, 1, 1, 1 };\r\n    EnterCtrlData (5, &joyallowed, DrawCustJoy, PrintCustJoy, JOYSTICK);\r\n}\r\n\r\n\r\n////////////////////////\r\n//\r\n// DEFINE THE KEYBOARD BUTTONS\r\n//\r\nvoid\r\nDefineKeyBtns (void)\r\n{\r\n    CustomCtrls keyallowed = { 1, 1, 1, 1 };\r\n    EnterCtrlData (8, &keyallowed, DrawCustKeybd, PrintCustKeybd, KEYBOARDBTNS);\r\n}\r\n\r\n\r\n////////////////////////\r\n//\r\n// DEFINE THE KEYBOARD BUTTONS\r\n//\r\nvoid\r\nDefineKeyMove (void)\r\n{\r\n    CustomCtrls keyallowed = { 1, 1, 1, 1 };\r\n    EnterCtrlData (10, &keyallowed, DrawCustKeys, PrintCustKeys, KEYBOARDMOVE);\r\n}\r\n\r\n\r\n////////////////////////\r\n//\r\n// ENTER CONTROL DATA FOR ANY TYPE OF CONTROL\r\n//\r\nenum\r\n{ FWRD, RIGHT, BKWD, LEFT };\r\nint moveorder[4] = { LEFT, RIGHT, FWRD, BKWD };\r\n\r\nvoid\r\nEnterCtrlData (int index, CustomCtrls * cust, void (*DrawRtn) (int), void (*PrintRtn) (int),\r\n               int type)\r\n{\r\n    int j, exit, tick, redraw, which, x, picked, lastFlashTime;\r\n    ControlInfo ci;\r\n\r\n\r\n    ShootSnd ();\r\n    PrintY = CST_Y + 13 * index;\r\n    IN_ClearKeysDown ();\r\n    exit = 0;\r\n    redraw = 1;\r\n    //\r\n    // FIND FIRST SPOT IN ALLOWED ARRAY\r\n    //\r\n    for (j = 0; j < 4; j++)\r\n        if (cust->allowed[j])\r\n        {\r\n            which = j;\r\n            break;\r\n        }\r\n\r\n    do\r\n    {\r\n        if (redraw)\r\n        {\r\n            x = CST_START + CST_SPC * which;\r\n            DrawWindow (5, PrintY - 1, 310, 13, BKGDCOLOR);\r\n\r\n            DrawRtn (1);\r\n            DrawWindow (x - 2, PrintY, CST_SPC, 11, TEXTCOLOR);\r\n            DrawOutline (x - 2, PrintY, CST_SPC, 11, 0, HIGHLIGHT);\r\n            SETFONTCOLOR (0, TEXTCOLOR);\r\n            PrintRtn (which);\r\n            PrintX = x;\r\n            SETFONTCOLOR (TEXTCOLOR, BKGDCOLOR);\r\n            VW_UpdateScreen ();\r\n            WaitKeyUp ();\r\n            redraw = 0;\r\n        }\r\n\r\n        SDL_Delay(5);\r\n        ReadAnyControl (&ci);\r\n\r\n        if (type == MOUSE || type == JOYSTICK)\r\n            if (IN_KeyDown (sc_Enter) || IN_KeyDown (sc_Control) || IN_KeyDown (sc_Alt))\r\n            {\r\n                IN_ClearKeysDown ();\r\n                ci.button0 = ci.button1 = false;\r\n            }\r\n\r\n        //\r\n        // CHANGE BUTTON VALUE?\r\n        //\r\n        if ((type != KEYBOARDBTNS && type != KEYBOARDMOVE) && (ci.button0 | ci.button1 | ci.button2 | ci.button3) ||\r\n            ((type == KEYBOARDBTNS || type == KEYBOARDMOVE) && LastScan == sc_Enter))\r\n        {\r\n            lastFlashTime = GetTimeCount();\r\n            tick = picked = 0;\r\n            SETFONTCOLOR (0, TEXTCOLOR);\r\n\r\n            if (type == KEYBOARDBTNS || type == KEYBOARDMOVE)\r\n                IN_ClearKeysDown ();\r\n\r\n            while(1)\r\n            {\r\n                int button, result = 0;\r\n\r\n                //\r\n                // FLASH CURSOR\r\n                //\r\n                if (GetTimeCount() - lastFlashTime > 10)\r\n                {\r\n                    switch (tick)\r\n                    {\r\n                        case 0:\r\n                            VWB_Bar (x, PrintY + 1, CST_SPC - 2, 10, TEXTCOLOR);\r\n                            break;\r\n                        case 1:\r\n                            PrintX = x;\r\n                            US_Print (\"?\");\r\n                            SD_PlaySound (HITWALLSND);\r\n                    }\r\n                    tick ^= 1;\r\n                    lastFlashTime = GetTimeCount();\r\n                    VW_UpdateScreen ();\r\n                }\r\n                else SDL_Delay(5);\r\n\r\n                //\r\n                // WHICH TYPE OF INPUT DO WE PROCESS?\r\n                //\r\n                switch (type)\r\n                {\r\n                    case MOUSE:\r\n                        button = IN_MouseButtons();\r\n                        switch (button)\r\n                        {\r\n                            case 1:\r\n                                result = 1;\r\n                                break;\r\n                            case 2:\r\n                                result = 2;\r\n                                break;\r\n                            case 4:\r\n                                result = 3;\r\n                                break;\r\n                        }\r\n\r\n                        if (result)\r\n                        {\r\n                            for (int z = 0; z < 4; z++)\r\n                                if (order[which] == buttonmouse[z])\r\n                                {\r\n                                    buttonmouse[z] = bt_nobutton;\r\n                                    break;\r\n                                }\r\n\r\n                            buttonmouse[result - 1] = order[which];\r\n                            picked = 1;\r\n                            SD_PlaySound (SHOOTDOORSND);\r\n                        }\r\n                        break;\r\n\r\n                    case JOYSTICK:\r\n                        if (ci.button0)\r\n                            result = 1;\r\n                        else if (ci.button1)\r\n                            result = 2;\r\n                        else if (ci.button2)\r\n                            result = 3;\r\n                        else if (ci.button3)\r\n                            result = 4;\r\n\r\n                        if (result)\r\n                        {\r\n                            for (int z = 0; z < 4; z++)\r\n                            {\r\n                                if (order[which] == buttonjoy[z])\r\n                                {\r\n                                    buttonjoy[z] = bt_nobutton;\r\n                                    break;\r\n                                }\r\n                            }\r\n\r\n                            buttonjoy[result - 1] = order[which];\r\n                            picked = 1;\r\n                            SD_PlaySound (SHOOTDOORSND);\r\n                        }\r\n                        break;\r\n\r\n                    case KEYBOARDBTNS:\r\n                        if (LastScan && LastScan != sc_Escape)\r\n                        {\r\n                            buttonscan[order[which]] = LastScan;\r\n                            picked = 1;\r\n                            ShootSnd ();\r\n                            IN_ClearKeysDown ();\r\n                        }\r\n                        break;\r\n\r\n                    case KEYBOARDMOVE:\r\n                        if (LastScan && LastScan != sc_Escape)\r\n                        {\r\n                            dirscan[moveorder[which]] = LastScan;\r\n                            picked = 1;\r\n                            ShootSnd ();\r\n                            IN_ClearKeysDown ();\r\n                        }\r\n                        break;\r\n                }\r\n\r\n                //\r\n                // EXIT INPUT?\r\n                //\r\n                if (IN_KeyDown (sc_Escape) || type != JOYSTICK && ci.button1)\r\n                {\r\n                    picked = 1;\r\n                    SD_PlaySound (ESCPRESSEDSND);\r\n                }\r\n\r\n                if(picked) break;\r\n\r\n                ReadAnyControl (&ci);\r\n            }\r\n\r\n            SETFONTCOLOR (TEXTCOLOR, BKGDCOLOR);\r\n            redraw = 1;\r\n            WaitKeyUp ();\r\n            continue;\r\n        }\r\n\r\n        if (ci.button1 || IN_KeyDown (sc_Escape))\r\n            exit = 1;\r\n\r\n        //\r\n        // MOVE TO ANOTHER SPOT?\r\n        //\r\n        switch (ci.dir)\r\n        {\r\n            case dir_West:\r\n                do\r\n                {\r\n                    which--;\r\n                    if (which < 0)\r\n                        which = 3;\r\n                }\r\n                while (!cust->allowed[which]);\r\n                redraw = 1;\r\n                SD_PlaySound (MOVEGUN1SND);\r\n                while (ReadAnyControl (&ci), ci.dir != dir_None) SDL_Delay(5);\r\n                IN_ClearKeysDown ();\r\n                break;\r\n\r\n            case dir_East:\r\n                do\r\n                {\r\n                    which++;\r\n                    if (which > 3)\r\n                        which = 0;\r\n                }\r\n                while (!cust->allowed[which]);\r\n                redraw = 1;\r\n                SD_PlaySound (MOVEGUN1SND);\r\n                while (ReadAnyControl (&ci), ci.dir != dir_None) SDL_Delay(5);\r\n                IN_ClearKeysDown ();\r\n                break;\r\n            case dir_North:\r\n            case dir_South:\r\n                exit = 1;\r\n        }\r\n    }\r\n    while (!exit);\r\n\r\n    SD_PlaySound (ESCPRESSEDSND);\r\n    WaitKeyUp ();\r\n    DrawWindow (5, PrintY - 1, 310, 13, BKGDCOLOR);\r\n}\r\n\r\n\r\n////////////////////////\r\n//\r\n// FIXUP GUN CURSOR OVERDRAW SHIT\r\n//\r\nvoid\r\nFixupCustom (int w)\r\n{\r\n    static int lastwhich = -1;\r\n    int y = CST_Y + 26 + w * 13;\r\n\r\n\r\n    VWB_Hlin (7, 32, y - 1, DEACTIVE);\r\n    VWB_Hlin (7, 32, y + 12, BORD2COLOR);\r\n#ifndef SPEAR\r\n    VWB_Hlin (7, 32, y - 2, BORDCOLOR);\r\n    VWB_Hlin (7, 32, y + 13, BORDCOLOR);\r\n#else\r\n    VWB_Hlin (7, 32, y - 2, BORD2COLOR);\r\n    VWB_Hlin (7, 32, y + 13, BORD2COLOR);\r\n#endif\r\n\r\n    switch (w)\r\n    {\r\n        case 0:\r\n            DrawCustMouse (1);\r\n            break;\r\n        case 3:\r\n            DrawCustJoy (1);\r\n            break;\r\n        case 6:\r\n            DrawCustKeybd (1);\r\n            break;\r\n        case 8:\r\n            DrawCustKeys (1);\r\n    }\r\n\r\n\r\n    if (lastwhich >= 0)\r\n    {\r\n        y = CST_Y + 26 + lastwhich * 13;\r\n        VWB_Hlin (7, 32, y - 1, DEACTIVE);\r\n        VWB_Hlin (7, 32, y + 12, BORD2COLOR);\r\n#ifndef SPEAR\r\n        VWB_Hlin (7, 32, y - 2, BORDCOLOR);\r\n        VWB_Hlin (7, 32, y + 13, BORDCOLOR);\r\n#else\r\n        VWB_Hlin (7, 32, y - 2, BORD2COLOR);\r\n        VWB_Hlin (7, 32, y + 13, BORD2COLOR);\r\n#endif\r\n\r\n        if (lastwhich != w)\r\n            switch (lastwhich)\r\n            {\r\n                case 0:\r\n                    DrawCustMouse (0);\r\n                    break;\r\n                case 3:\r\n                    DrawCustJoy (0);\r\n                    break;\r\n                case 6:\r\n                    DrawCustKeybd (0);\r\n                    break;\r\n                case 8:\r\n                    DrawCustKeys (0);\r\n            }\r\n    }\r\n\r\n    lastwhich = w;\r\n}\r\n\r\n\r\n////////////////////////\r\n//\r\n// DRAW CUSTOMIZE SCREEN\r\n//\r\nvoid\r\nDrawCustomScreen (void)\r\n{\r\n    int i;\r\n\r\n\r\n#ifdef JAPAN\r\n    CA_CacheScreen (S_CUSTOMPIC);\r\n    fontnumber = 1;\r\n\r\n    PrintX = CST_START;\r\n    PrintY = CST_Y + 26;\r\n    DrawCustMouse (0);\r\n\r\n    PrintX = CST_START;\r\n    US_Print (\"\\n\\n\\n\");\r\n    DrawCustJoy (0);\r\n\r\n    PrintX = CST_START;\r\n    US_Print (\"\\n\\n\\n\");\r\n    DrawCustKeybd (0);\r\n\r\n    PrintX = CST_START;\r\n    US_Print (\"\\n\\n\\n\");\r\n    DrawCustKeys (0);\r\n#else\r\n    ClearMScreen ();\r\n    WindowX = 0;\r\n    WindowW = 320;\r\n    VWB_DrawPic (112, 184, C_MOUSELBACKPIC);\r\n    DrawStripes (10);\r\n    VWB_DrawPic (80, 0, C_CUSTOMIZEPIC);\r\n\r\n    //\r\n    // MOUSE\r\n    //\r\n    SETFONTCOLOR (READCOLOR, BKGDCOLOR);\r\n    WindowX = 0;\r\n    WindowW = 320;\r\n\r\n#ifndef SPEAR\r\n    PrintY = CST_Y;\r\n    US_CPrint (\"Mouse\\n\");\r\n#else\r\n    PrintY = CST_Y + 13;\r\n    VWB_DrawPic (128, 48, C_MOUSEPIC);\r\n#endif\r\n\r\n    SETFONTCOLOR (TEXTCOLOR, BKGDCOLOR);\r\n#ifdef SPANISH\r\n    PrintX = CST_START - 16;\r\n    US_Print (STR_CRUN);\r\n    PrintX = CST_START - 16 + CST_SPC * 1;\r\n    US_Print (STR_COPEN);\r\n    PrintX = CST_START - 16 + CST_SPC * 2;\r\n    US_Print (STR_CFIRE);\r\n    PrintX = CST_START - 16 + CST_SPC * 3;\r\n    US_Print (STR_CSTRAFE \"\\n\");\r\n#else\r\n    PrintX = CST_START;\r\n    US_Print (STR_CRUN);\r\n    PrintX = CST_START + CST_SPC * 1;\r\n    US_Print (STR_COPEN);\r\n    PrintX = CST_START + CST_SPC * 2;\r\n    US_Print (STR_CFIRE);\r\n    PrintX = CST_START + CST_SPC * 3;\r\n    US_Print (STR_CSTRAFE \"\\n\");\r\n#endif\r\n\r\n    DrawWindow (5, PrintY - 1, 310, 13, BKGDCOLOR);\r\n    DrawCustMouse (0);\r\n    US_Print (\"\\n\");\r\n\r\n\r\n    //\r\n    // JOYSTICK/PAD\r\n    //\r\n#ifndef SPEAR\r\n    SETFONTCOLOR (READCOLOR, BKGDCOLOR);\r\n    US_CPrint (\"Joystick/Gravis GamePad\\n\");\r\n#else\r\n    PrintY += 13;\r\n    VWB_DrawPic (40, 88, C_JOYSTICKPIC);\r\n#endif\r\n\r\n#ifdef SPEAR\r\n    VWB_DrawPic (112, 120, C_KEYBOARDPIC);\r\n#endif\r\n\r\n    SETFONTCOLOR (TEXTCOLOR, BKGDCOLOR);\r\n#ifdef SPANISH\r\n    PrintX = CST_START - 16;\r\n    US_Print (STR_CRUN);\r\n    PrintX = CST_START - 16 + CST_SPC * 1;\r\n    US_Print (STR_COPEN);\r\n    PrintX = CST_START - 16 + CST_SPC * 2;\r\n    US_Print (STR_CFIRE);\r\n    PrintX = CST_START - 16 + CST_SPC * 3;\r\n    US_Print (STR_CSTRAFE \"\\n\");\r\n#else\r\n    PrintX = CST_START;\r\n    US_Print (STR_CRUN);\r\n    PrintX = CST_START + CST_SPC * 1;\r\n    US_Print (STR_COPEN);\r\n    PrintX = CST_START + CST_SPC * 2;\r\n    US_Print (STR_CFIRE);\r\n    PrintX = CST_START + CST_SPC * 3;\r\n    US_Print (STR_CSTRAFE \"\\n\");\r\n#endif\r\n    DrawWindow (5, PrintY - 1, 310, 13, BKGDCOLOR);\r\n    DrawCustJoy (0);\r\n    US_Print (\"\\n\");\r\n\r\n\r\n    //\r\n    // KEYBOARD\r\n    //\r\n#ifndef SPEAR\r\n    SETFONTCOLOR (READCOLOR, BKGDCOLOR);\r\n    US_CPrint (\"Keyboard\\n\");\r\n#else\r\n    PrintY += 13;\r\n#endif\r\n    SETFONTCOLOR (TEXTCOLOR, BKGDCOLOR);\r\n#ifdef SPANISH\r\n    PrintX = CST_START - 16;\r\n    US_Print (STR_CRUN);\r\n    PrintX = CST_START - 16 + CST_SPC * 1;\r\n    US_Print (STR_COPEN);\r\n    PrintX = CST_START - 16 + CST_SPC * 2;\r\n    US_Print (STR_CFIRE);\r\n    PrintX = CST_START - 16 + CST_SPC * 3;\r\n    US_Print (STR_CSTRAFE \"\\n\");\r\n#else\r\n    PrintX = CST_START;\r\n    US_Print (STR_CRUN);\r\n    PrintX = CST_START + CST_SPC * 1;\r\n    US_Print (STR_COPEN);\r\n    PrintX = CST_START + CST_SPC * 2;\r\n    US_Print (STR_CFIRE);\r\n    PrintX = CST_START + CST_SPC * 3;\r\n    US_Print (STR_CSTRAFE \"\\n\");\r\n#endif\r\n    DrawWindow (5, PrintY - 1, 310, 13, BKGDCOLOR);\r\n    DrawCustKeybd (0);\r\n    US_Print (\"\\n\");\r\n\r\n\r\n    //\r\n    // KEYBOARD MOVE KEYS\r\n    //\r\n    SETFONTCOLOR (TEXTCOLOR, BKGDCOLOR);\r\n#ifdef SPANISH\r\n    PrintX = 4;\r\n    US_Print (STR_LEFT);\r\n    US_Print (\"/\");\r\n    US_Print (STR_RIGHT);\r\n    US_Print (\"/\");\r\n    US_Print (STR_FRWD);\r\n    US_Print (\"/\");\r\n    US_Print (STR_BKWD \"\\n\");\r\n#else\r\n    PrintX = CST_START;\r\n    US_Print (STR_LEFT);\r\n    PrintX = CST_START + CST_SPC * 1;\r\n    US_Print (STR_RIGHT);\r\n    PrintX = CST_START + CST_SPC * 2;\r\n    US_Print (STR_FRWD);\r\n    PrintX = CST_START + CST_SPC * 3;\r\n    US_Print (STR_BKWD \"\\n\");\r\n#endif\r\n    DrawWindow (5, PrintY - 1, 310, 13, BKGDCOLOR);\r\n    DrawCustKeys (0);\r\n#endif\r\n    //\r\n    // PICK STARTING POINT IN MENU\r\n    //\r\n    if (CusItems.curpos < 0)\r\n        for (i = 0; i < CusItems.amount; i++)\r\n            if (CusMenu[i].active)\r\n            {\r\n                CusItems.curpos = i;\r\n                break;\r\n            }\r\n\r\n\r\n    VW_UpdateScreen ();\r\n    MenuFadeIn ();\r\n}\r\n\r\n\r\nvoid\r\nPrintCustMouse (int i)\r\n{\r\n    int j;\r\n\r\n    for (j = 0; j < 4; j++)\r\n        if (order[i] == buttonmouse[j])\r\n        {\r\n            PrintX = CST_START + CST_SPC * i;\r\n            US_Print (mbarray[j]);\r\n            break;\r\n        }\r\n}\r\n\r\nvoid\r\nDrawCustMouse (int hilight)\r\n{\r\n    int i, color;\r\n\r\n\r\n    color = TEXTCOLOR;\r\n    if (hilight)\r\n        color = HIGHLIGHT;\r\n    SETFONTCOLOR (color, BKGDCOLOR);\r\n\r\n    if (!mouseenabled)\r\n    {\r\n        SETFONTCOLOR (DEACTIVE, BKGDCOLOR);\r\n        CusMenu[0].active = 0;\r\n    }\r\n    else\r\n        CusMenu[0].active = 1;\r\n\r\n    PrintY = CST_Y + 13 * 2;\r\n    for (i = 0; i < 4; i++)\r\n        PrintCustMouse (i);\r\n}\r\n\r\nvoid\r\nPrintCustJoy (int i)\r\n{\r\n    for (int j = 0; j < 4; j++)\r\n    {\r\n        if (order[i] == buttonjoy[j])\r\n        {\r\n            PrintX = CST_START + CST_SPC * i;\r\n            US_Print (mbarray[j]);\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nvoid\r\nDrawCustJoy (int hilight)\r\n{\r\n    int i, color;\r\n\r\n    color = TEXTCOLOR;\r\n    if (hilight)\r\n        color = HIGHLIGHT;\r\n    SETFONTCOLOR (color, BKGDCOLOR);\r\n\r\n    if (!joystickenabled)\r\n    {\r\n        SETFONTCOLOR (DEACTIVE, BKGDCOLOR);\r\n        CusMenu[3].active = 0;\r\n    }\r\n    else\r\n        CusMenu[3].active = 1;\r\n\r\n    PrintY = CST_Y + 13 * 5;\r\n    for (i = 0; i < 4; i++)\r\n        PrintCustJoy (i);\r\n}\r\n\r\n\r\nvoid\r\nPrintCustKeybd (int i)\r\n{\r\n    PrintX = CST_START + CST_SPC * i;\r\n    US_Print ((const char *) IN_GetScanName (buttonscan[order[i]]));\r\n}\r\n\r\nvoid\r\nDrawCustKeybd (int hilight)\r\n{\r\n    int i, color;\r\n\r\n\r\n    color = TEXTCOLOR;\r\n    if (hilight)\r\n        color = HIGHLIGHT;\r\n    SETFONTCOLOR (color, BKGDCOLOR);\r\n\r\n    PrintY = CST_Y + 13 * 8;\r\n    for (i = 0; i < 4; i++)\r\n        PrintCustKeybd (i);\r\n}\r\n\r\nvoid\r\nPrintCustKeys (int i)\r\n{\r\n    PrintX = CST_START + CST_SPC * i;\r\n    US_Print ((const char *) IN_GetScanName (dirscan[moveorder[i]]));\r\n}\r\n\r\nvoid\r\nDrawCustKeys (int hilight)\r\n{\r\n    int i, color;\r\n\r\n\r\n    color = TEXTCOLOR;\r\n    if (hilight)\r\n        color = HIGHLIGHT;\r\n    SETFONTCOLOR (color, BKGDCOLOR);\r\n\r\n    PrintY = CST_Y + 13 * 10;\r\n    for (i = 0; i < 4; i++)\r\n        PrintCustKeys (i);\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// CHANGE SCREEN VIEWING SIZE\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nint\r\nCP_ChangeView (int)\r\n{\r\n    int exit = 0, oldview, newview;\r\n    ControlInfo ci;\r\n\r\n    WindowX = WindowY = 0;\r\n    WindowW = 320;\r\n    WindowH = 200;\r\n    newview = oldview = viewsize;\r\n    DrawChangeView (oldview);\r\n    MenuFadeIn ();\r\n\r\n    do\r\n    {\r\n        CheckPause ();\r\n        SDL_Delay(5);\r\n        ReadAnyControl (&ci);\r\n        switch (ci.dir)\r\n        {\r\n            case dir_South:\r\n            case dir_West:\r\n                newview--;\r\n                if (newview < 4)\r\n                    newview = 4;\r\n                if(newview >= 19) DrawChangeView(newview);\r\n                else ShowViewSize (newview);\r\n                VW_UpdateScreen ();\r\n                SD_PlaySound (HITWALLSND);\r\n                TicDelay (10);\r\n                break;\r\n\r\n            case dir_North:\r\n            case dir_East:\r\n                newview++;\r\n                if (newview >= 21)\r\n                {\r\n                    newview = 21;\r\n                    DrawChangeView(newview);\r\n                }\r\n                else ShowViewSize (newview);\r\n                VW_UpdateScreen ();\r\n                SD_PlaySound (HITWALLSND);\r\n                TicDelay (10);\r\n                break;\r\n        }\r\n\r\n        if (ci.button0 || Keyboard[sc_Enter])\r\n            exit = 1;\r\n        else if (ci.button1 || Keyboard[sc_Escape])\r\n        {\r\n            SD_PlaySound (ESCPRESSEDSND);\r\n            MenuFadeOut ();\r\n            if(screenHeight % 200 != 0)\r\n                VL_ClearScreen(0);\r\n            return 0;\r\n        }\r\n    }\r\n    while (!exit);\r\n\r\n    if (oldview != newview)\r\n    {\r\n        SD_PlaySound (SHOOTSND);\r\n        Message (STR_THINK \"...\");\r\n        NewViewSize (newview);\r\n    }\r\n\r\n    ShootSnd ();\r\n    MenuFadeOut ();\r\n    if(screenHeight % 200 != 0)\r\n        VL_ClearScreen(0);\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n/////////////////////////////\r\n//\r\n// DRAW THE CHANGEVIEW SCREEN\r\n//\r\nvoid\r\nDrawChangeView (int view)\r\n{\r\n    int rescaledHeight = screenHeight / scaleFactor;\r\n    if(view != 21) VWB_Bar (0, rescaledHeight - 40, 320, 40, bordercol);\r\n\r\n#ifdef JAPAN\r\n    CA_CacheScreen (S_CHANGEPIC);\r\n\r\n    ShowViewSize (view);\r\n#else\r\n    ShowViewSize (view);\r\n\r\n    PrintY = (screenHeight / scaleFactor) - 39;\r\n    WindowX = 0;\r\n    WindowY = 320;                                  // TODO: Check this!\r\n    SETFONTCOLOR (HIGHLIGHT, BKGDCOLOR);\r\n\r\n    US_CPrint (STR_SIZE1 \"\\n\");\r\n    US_CPrint (STR_SIZE2 \"\\n\");\r\n    US_CPrint (STR_SIZE3);\r\n#endif\r\n    VW_UpdateScreen ();\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// QUIT THIS INFERNAL GAME!\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nint\r\nCP_Quit (int)\r\n{\r\n#ifdef JAPAN\r\n    if (GetYorN (7, 11, C_QUITMSGPIC))\r\n#else\r\n\r\n#ifdef SPANISH\r\n    if (Confirm (ENDGAMESTR))\r\n#else\r\n    if (Confirm (endStrings[US_RndT () & 0x7 + (US_RndT () & 1)]))\r\n#endif\r\n\r\n#endif\r\n    {\r\n        VW_UpdateScreen ();\r\n        SD_MusicOff ();\r\n        SD_StopSound ();\r\n        MenuFadeOut ();\r\n        Quit (NULL);\r\n    }\r\n\r\n    DrawMainMenu ();\r\n    return 0;\r\n}\r\n\r\nvoid em_menu_noop_main_loop() {\r\n\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// HANDLE INTRO SCREEN (SYSTEM CONFIG)\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nvoid\r\nIntroScreen (void)\r\n{\r\n#ifdef SPEAR\r\n\r\n#define MAINCOLOR       0x4f\r\n#define EMSCOLOR        0x4f\r\n#define XMSCOLOR        0x4f\r\n\r\n#else\r\n\r\n#define MAINCOLOR       0x6c\r\n#define EMSCOLOR        0x6c    // 0x4f\r\n#define XMSCOLOR        0x6c    // 0x7f\r\n\r\n#endif\r\n#define FILLCOLOR       14\r\n\r\n//      long memory;\r\n//      long emshere,xmshere;\r\n    int i;\r\n/*      int ems[10]={100,200,300,400,500,600,700,800,900,1000},\r\n                xms[10]={100,200,300,400,500,600,700,800,900,1000};\r\n        int main[10]={32,64,96,128,160,192,224,256,288,320};*/\r\n\r\n\r\n    //\r\n    // DRAW MAIN MEMORY\r\n    //\r\n#ifdef ABCAUS\r\n    memory = (1023l + mminfo.nearheap + mminfo.farheap) / 1024l;\r\n    for (i = 0; i < 10; i++)\r\n        if (memory >= main[i])\r\n            VWB_Bar (49, 163 - 8 * i, 6, 5, MAINCOLOR - i);\r\n\r\n    //\r\n    // DRAW EMS MEMORY\r\n    //\r\n    if (EMSPresent)\r\n    {\r\n        emshere = 4l * EMSPagesAvail;\r\n        for (i = 0; i < 10; i++)\r\n            if (emshere >= ems[i])\r\n                VWB_Bar (89, 163 - 8 * i, 6, 5, EMSCOLOR - i);\r\n    }\r\n\r\n    //\r\n    // DRAW XMS MEMORY\r\n    //\r\n    if (XMSPresent)\r\n    {\r\n        xmshere = 4l * XMSPagesAvail;\r\n        for (i = 0; i < 10; i++)\r\n            if (xmshere >= xms[i])\r\n                VWB_Bar (129, 163 - 8 * i, 6, 5, XMSCOLOR - i);\r\n    }\r\n#else\r\n    for (i = 0; i < 10; i++)\r\n        VWB_Bar (49, 163 - 8 * i, 6, 5, MAINCOLOR - i);\r\n    for (i = 0; i < 10; i++)\r\n        VWB_Bar (89, 163 - 8 * i, 6, 5, EMSCOLOR - i);\r\n    for (i = 0; i < 10; i++)\r\n        VWB_Bar (129, 163 - 8 * i, 6, 5, XMSCOLOR - i);\r\n#endif\r\n\r\n\r\n    //\r\n    // FILL BOXES\r\n    //\r\n    if (MousePresent)\r\n        VWB_Bar (164, 82, 12, 2, FILLCOLOR);\r\n\r\n    if (IN_JoyPresent())\r\n        VWB_Bar (164, 105, 12, 2, FILLCOLOR);\r\n\r\n    if (AdLibPresent && !SoundBlasterPresent)\r\n        VWB_Bar (164, 128, 12, 2, FILLCOLOR);\r\n\r\n    if (SoundBlasterPresent)\r\n        VWB_Bar (164, 151, 12, 2, FILLCOLOR);\r\n\r\n//    if (SoundSourcePresent)\r\n//        VWB_Bar (164, 174, 12, 2, FILLCOLOR);\r\n       \r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// SUPPORT ROUTINES\r\n//\r\n////////////////////////////////////////////////////////////////////\r\n////////////////////////////////////////////////////////////////////\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// Clear Menu screens to dark red\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nvoid\r\nClearMScreen (void)\r\n{\r\n#ifndef SPEAR\r\n    VWB_Bar (0, 0, 320, 200, BORDCOLOR);\r\n#else\r\n    VWB_DrawPic (0, 0, C_BACKDROPPIC);\r\n#endif\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// Un/Cache a LUMP of graphics\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nvoid\r\nCacheLump (int lumpstart, int lumpend)\r\n{\r\n    int i;\r\n\r\n    for (i = lumpstart; i <= lumpend; i++)\r\n        CA_CacheGrChunk (i);\r\n}\r\n\r\n\r\nvoid\r\nUnCacheLump (int lumpstart, int lumpend)\r\n{\r\n    int i;\r\n\r\n    for (i = lumpstart; i <= lumpend; i++)\r\n        if (grsegs[i])\r\n            UNCACHEGRCHUNK (i);\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// Draw a window for a menu\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nvoid\r\nDrawWindow (int x, int y, int w, int h, int wcolor)\r\n{\r\n    VWB_Bar (x, y, w, h, wcolor);\r\n    DrawOutline (x, y, w, h, BORD2COLOR, DEACTIVE);\r\n}\r\n\r\n\r\nvoid\r\nDrawOutline (int x, int y, int w, int h, int color1, int color2)\r\n{\r\n    VWB_Hlin (x, x + w, y, color2);\r\n    VWB_Vlin (y, y + h, x, color2);\r\n    VWB_Hlin (x, x + w, y + h, color1);\r\n    VWB_Vlin (y, y + h, x + w, color1);\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// Setup Control Panel stuff - graphics, etc.\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nvoid\r\nSetupControlPanel (void)\r\n{\r\n    //\r\n    // CACHE GRAPHICS & SOUNDS\r\n    //\r\n    CA_CacheGrChunk (STARTFONT + 1);\r\n#ifndef SPEAR\r\n    CacheLump (CONTROLS_LUMP_START, CONTROLS_LUMP_END);\r\n#else\r\n    CacheLump (BACKDROP_LUMP_START, BACKDROP_LUMP_END);\r\n#endif\r\n\r\n    SETFONTCOLOR (TEXTCOLOR, BKGDCOLOR);\r\n    fontnumber = 1;\r\n    WindowH = 200;\r\n    if(screenHeight % 200 != 0)\r\n        VL_ClearScreen(0);\r\n\r\n    if (!ingame)\r\n        CA_LoadAllSounds ();\r\n    else\r\n        MainMenu[savegame].active = 1;\r\n\r\n    //\r\n    // CENTER MOUSE\r\n    //\r\n    if(IN_IsInputGrabbed())\r\n        IN_CenterMouse();\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// SEE WHICH SAVE GAME FILES ARE AVAILABLE & READ STRING IN\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nvoid SetupSaveGames()\r\n{\r\n    char name[13];\r\n    char savepath[300];\r\n\r\n    strcpy(name, SaveName);\r\n    for(int i = 0; i < 10; i++)\r\n    {\r\n        name[7] = '0' + i;\r\n\r\n            if(configdir[0])\r\n                snprintf(savepath, sizeof(savepath), \"%s/%s\", configdir, name);\r\n            else\r\n                strcpy(savepath, name);\r\n\r\n            const int handle = open(savepath, O_RDONLY | O_BINARY);\r\n            if(handle >= 0)\r\n            {\r\n                char temp[32];\r\n\r\n                SaveGamesAvail[i] = 1;\r\n                read(handle, temp, 32);\r\n                close(handle);\r\n                strcpy(&SaveGameNames[i][0], temp);\r\n            }\r\n\r\n    }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// Clean up all the Control Panel stuff\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nvoid\r\nCleanupControlPanel (void)\r\n{\r\n#ifndef SPEAR\r\n    UnCacheLump (CONTROLS_LUMP_START, CONTROLS_LUMP_END);\r\n#else\r\n    UnCacheLump (BACKDROP_LUMP_START, BACKDROP_LUMP_END);\r\n#endif\r\n\r\n    fontnumber = 0;\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// Handle moving gun around a menu\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nint\r\nHandleMenu (CP_iteminfo * item_i, CP_itemtype * items, void (*routine) (int w))\r\n{\r\n    char key;\r\n    static int redrawitem = 1, lastitem = -1;\r\n    int i, x, y, basey, exit, which, shape;\r\n    int32_t lastBlinkTime, timer;\r\n    ControlInfo ci;\r\n\r\n\r\n    which = item_i->curpos;\r\n    x = item_i->x & -8;\r\n    basey = item_i->y - 2;\r\n    y = basey + which * 13;\r\n\r\n    VWB_DrawPic (x, y, C_CURSOR1PIC);\r\n    SetTextColor (items + which, 1);\r\n    if (redrawitem)\r\n    {\r\n        PrintX = item_i->x + item_i->indent;\r\n        PrintY = item_i->y + which * 13;\r\n        US_Print ((items + which)->string);\r\n    }\r\n    //\r\n    // CALL CUSTOM ROUTINE IF IT IS NEEDED\r\n    //\r\n    if (routine)\r\n        routine (which);\r\n    VW_UpdateScreen ();\r\n\r\n    shape = C_CURSOR1PIC;\r\n    timer = 8;\r\n    exit = 0;\r\n    lastBlinkTime = GetTimeCount ();\r\n    IN_ClearKeysDown ();\r\n\r\n\r\n    do\r\n    {\r\n        //\r\n        // CHANGE GUN SHAPE\r\n        //\r\n        if ((int32_t)GetTimeCount () - lastBlinkTime > timer)\r\n        {\r\n            lastBlinkTime = GetTimeCount ();\r\n            if (shape == C_CURSOR1PIC)\r\n            {\r\n                shape = C_CURSOR2PIC;\r\n                timer = 8;\r\n            }\r\n            else\r\n            {\r\n                shape = C_CURSOR1PIC;\r\n                timer = 70;\r\n            }\r\n            VWB_DrawPic (x, y, shape);\r\n            if (routine)\r\n                routine (which);\r\n            VW_UpdateScreen ();\r\n        }\r\n        else SDL_Delay(5);\r\n\r\n        CheckPause ();\r\n\r\n        //\r\n        // SEE IF ANY KEYS ARE PRESSED FOR INITIAL CHAR FINDING\r\n        //\r\n        key = LastASCII;\r\n        if (key)\r\n        {\r\n            int ok = 0;\r\n\r\n            if (key >= 'a')\r\n                key -= 'a' - 'A';\r\n\r\n            for (i = which + 1; i < item_i->amount; i++)\r\n                if ((items + i)->active && (items + i)->string[0] == key)\r\n                {\r\n                    EraseGun (item_i, items, x, y, which);\r\n                    which = i;\r\n                    DrawGun (item_i, items, x, &y, which, basey, routine);\r\n                    ok = 1;\r\n                    IN_ClearKeysDown ();\r\n                    break;\r\n                }\r\n\r\n            //\r\n            // DIDN'T FIND A MATCH FIRST TIME THRU. CHECK AGAIN.\r\n            //\r\n            if (!ok)\r\n            {\r\n                for (i = 0; i < which; i++)\r\n                    if ((items + i)->active && (items + i)->string[0] == key)\r\n                    {\r\n                        EraseGun (item_i, items, x, y, which);\r\n                        which = i;\r\n                        DrawGun (item_i, items, x, &y, which, basey, routine);\r\n                        IN_ClearKeysDown ();\r\n                        break;\r\n                    }\r\n            }\r\n        }\r\n\r\n        //\r\n        // GET INPUT\r\n        //\r\n        ReadAnyControl (&ci);\r\n        switch (ci.dir)\r\n        {\r\n                ////////////////////////////////////////////////\r\n                //\r\n                // MOVE UP\r\n                //\r\n            case dir_North:\r\n\r\n                EraseGun (item_i, items, x, y, which);\r\n\r\n                //\r\n                // ANIMATE HALF-STEP\r\n                //\r\n                if (which && (items + which - 1)->active)\r\n                {\r\n                    y -= 6;\r\n                    DrawHalfStep (x, y);\r\n                }\r\n\r\n                //\r\n                // MOVE TO NEXT AVAILABLE SPOT\r\n                //\r\n                do\r\n                {\r\n                    if (!which)\r\n                        which = item_i->amount - 1;\r\n                    else\r\n                        which--;\r\n                }\r\n                while (!(items + which)->active);\r\n\r\n                DrawGun (item_i, items, x, &y, which, basey, routine);\r\n                //\r\n                // WAIT FOR BUTTON-UP OR DELAY NEXT MOVE\r\n                //\r\n                TicDelay (20);\r\n                break;\r\n\r\n                ////////////////////////////////////////////////\r\n                //\r\n                // MOVE DOWN\r\n                //\r\n            case dir_South:\r\n\r\n                EraseGun (item_i, items, x, y, which);\r\n                //\r\n                // ANIMATE HALF-STEP\r\n                //\r\n                if (which != item_i->amount - 1 && (items + which + 1)->active)\r\n                {\r\n                    y += 6;\r\n                    DrawHalfStep (x, y);\r\n                }\r\n\r\n                do\r\n                {\r\n                    if (which == item_i->amount - 1)\r\n                        which = 0;\r\n                    else\r\n                        which++;\r\n                }\r\n                while (!(items + which)->active);\r\n\r\n                DrawGun (item_i, items, x, &y, which, basey, routine);\r\n\r\n                //\r\n                // WAIT FOR BUTTON-UP OR DELAY NEXT MOVE\r\n                //\r\n                TicDelay (20);\r\n                break;\r\n        }\r\n\r\n        if (ci.button0 || Keyboard[sc_Space] || Keyboard[sc_Enter])\r\n            exit = 1;\r\n\r\n        if (ci.button1 && !Keyboard[sc_Alt] || Keyboard[sc_Escape])\r\n            exit = 2;\r\n\r\n    }\r\n    while (!exit);\r\n\r\n\r\n    IN_ClearKeysDown ();\r\n\r\n    //\r\n    // ERASE EVERYTHING\r\n    //\r\n    if (lastitem != which)\r\n    {\r\n        VWB_Bar (x - 1, y, 25, 16, BKGDCOLOR);\r\n        PrintX = item_i->x + item_i->indent;\r\n        PrintY = item_i->y + which * 13;\r\n        US_Print ((items + which)->string);\r\n        redrawitem = 1;\r\n    }\r\n    else\r\n        redrawitem = 0;\r\n\r\n    if (routine)\r\n        routine (which);\r\n    VW_UpdateScreen ();\r\n\r\n    item_i->curpos = which;\r\n\r\n    lastitem = which;\r\n    switch (exit)\r\n    {\r\n        case 1:\r\n            //\r\n            // CALL THE ROUTINE\r\n            //\r\n            if ((items + which)->routine != NULL)\r\n            {\r\n                ShootSnd ();\r\n                MenuFadeOut ();\r\n                (items + which)->routine (0);\r\n            }\r\n            return which;\r\n\r\n        case 2:\r\n            SD_PlaySound (ESCPRESSEDSND);\r\n            return -1;\r\n    }\r\n\r\n    return 0;                   // JUST TO SHUT UP THE ERROR MESSAGES!\r\n}\r\n\r\n\r\n//\r\n// ERASE GUN & DE-HIGHLIGHT STRING\r\n//\r\nvoid\r\nEraseGun (CP_iteminfo * item_i, CP_itemtype * items, int x, int y, int which)\r\n{\r\n    VWB_Bar (x - 1, y, 25, 16, BKGDCOLOR);\r\n    SetTextColor (items + which, 0);\r\n\r\n    PrintX = item_i->x + item_i->indent;\r\n    PrintY = item_i->y + which * 13;\r\n    US_Print ((items + which)->string);\r\n    VW_UpdateScreen ();\r\n}\r\n\r\n\r\n//\r\n// DRAW HALF STEP OF GUN TO NEXT POSITION\r\n//\r\nvoid\r\nDrawHalfStep (int x, int y)\r\n{\r\n    VWB_DrawPic (x, y, C_CURSOR1PIC);\r\n    VW_UpdateScreen ();\r\n    SD_PlaySound (MOVEGUN1SND);\r\n    SDL_Delay (8 * 100 / 7);\r\n}\r\n\r\n\r\n//\r\n// DRAW GUN AT NEW POSITION\r\n//\r\nvoid\r\nDrawGun (CP_iteminfo * item_i, CP_itemtype * items, int x, int *y, int which, int basey,\r\n         void (*routine) (int w))\r\n{\r\n    VWB_Bar (x - 1, *y, 25, 16, BKGDCOLOR);\r\n    *y = basey + which * 13;\r\n    VWB_DrawPic (x, *y, C_CURSOR1PIC);\r\n    SetTextColor (items + which, 1);\r\n\r\n    PrintX = item_i->x + item_i->indent;\r\n    PrintY = item_i->y + which * 13;\r\n    US_Print ((items + which)->string);\r\n\r\n    //\r\n    // CALL CUSTOM ROUTINE IF IT IS NEEDED\r\n    //\r\n    if (routine)\r\n        routine (which);\r\n    VW_UpdateScreen ();\r\n    SD_PlaySound (MOVEGUN2SND);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// DELAY FOR AN AMOUNT OF TICS OR UNTIL CONTROLS ARE INACTIVE\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nvoid\r\nTicDelay (int count)\r\n{\r\n    ControlInfo ci;\r\n\r\n    int32_t startTime = GetTimeCount ();\r\n    do\r\n    {\r\n        SDL_Delay(5);\r\n        ReadAnyControl (&ci);\r\n    }\r\n    while ((int32_t) GetTimeCount () - startTime < count && ci.dir != dir_None);\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// Draw a menu\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nvoid\r\nDrawMenu (CP_iteminfo * item_i, CP_itemtype * items)\r\n{\r\n    int i, which = item_i->curpos;\r\n\r\n\r\n    WindowX = PrintX = item_i->x + item_i->indent;\r\n    WindowY = PrintY = item_i->y;\r\n    WindowW = 320;\r\n    WindowH = 200;\r\n\r\n    for (i = 0; i < item_i->amount; i++)\r\n    {\r\n        SetTextColor (items + i, which == i);\r\n\r\n        PrintY = item_i->y + i * 13;\r\n        if ((items + i)->active)\r\n            US_Print ((items + i)->string);\r\n        else\r\n        {\r\n            SETFONTCOLOR (DEACTIVE, BKGDCOLOR);\r\n            US_Print ((items + i)->string);\r\n            SETFONTCOLOR (TEXTCOLOR, BKGDCOLOR);\r\n        }\r\n\r\n        US_Print (\"\\n\");\r\n    }\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// SET TEXT COLOR (HIGHLIGHT OR NO)\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nvoid\r\nSetTextColor (CP_itemtype * items, int hlight)\r\n{\r\n    if (hlight)\r\n    {\r\n        SETFONTCOLOR (color_hlite[items->active], BKGDCOLOR);\r\n    }\r\n    else\r\n    {\r\n        SETFONTCOLOR (color_norml[items->active], BKGDCOLOR);\r\n    }\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// WAIT FOR CTRLKEY-UP OR BUTTON-UP\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nvoid\r\nWaitKeyUp (void)\r\n{\r\n    ControlInfo ci;\r\n    while (ReadAnyControl (&ci), ci.button0 |\r\n           ci.button1 |\r\n           ci.button2 | ci.button3 | Keyboard[sc_Space] | Keyboard[sc_Enter] | Keyboard[sc_Escape])\r\n    {\r\n        IN_WaitAndProcessEvents();\r\n    }\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// READ KEYBOARD, JOYSTICK AND MOUSE FOR INPUT\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nvoid\r\nReadAnyControl (ControlInfo * ci)\r\n{\r\n    int mouseactive = 0;\r\n\r\n    IN_ReadControl (0, ci);\r\n\r\n    if (mouseenabled && IN_IsInputGrabbed())\r\n    {\r\n        int mousex, mousey, buttons;\r\n        buttons = SDL_GetMouseState(&mousex, &mousey);\r\n        int middlePressed = buttons & SDL_BUTTON(SDL_BUTTON_MIDDLE);\r\n        int rightPressed = buttons & SDL_BUTTON(SDL_BUTTON_RIGHT);\r\n        buttons &= ~(SDL_BUTTON(SDL_BUTTON_MIDDLE) | SDL_BUTTON(SDL_BUTTON_RIGHT));\r\n        if(middlePressed) buttons |= 1 << 2;\r\n        if(rightPressed) buttons |= 1 << 1;\r\n\r\n        if(mousey - CENTERY < -SENSITIVE)\r\n        {\r\n            ci->dir = dir_North;\r\n            mouseactive = 1;\r\n        }\r\n        else if(mousey - CENTERY > SENSITIVE)\r\n        {\r\n            ci->dir = dir_South;\r\n            mouseactive = 1;\r\n        }\r\n\r\n        if(mousex - CENTERX < -SENSITIVE)\r\n        {\r\n            ci->dir = dir_West;\r\n            mouseactive = 1;\r\n        }\r\n        else if(mousex - CENTERX > SENSITIVE)\r\n        {\r\n            ci->dir = dir_East;\r\n            mouseactive = 1;\r\n        }\r\n\r\n        if(mouseactive)\r\n            IN_CenterMouse();\r\n\r\n        if (buttons)\r\n        {\r\n            ci->button0 = buttons & 1;\r\n            ci->button1 = buttons & 2;\r\n            ci->button2 = buttons & 4;\r\n            ci->button3 = false;\r\n            mouseactive = 1;\r\n        }\r\n    }\r\n\r\n    if (joystickenabled && !mouseactive)\r\n    {\r\n        int jx, jy, jb;\r\n\r\n        IN_GetJoyDelta (&jx, &jy);\r\n        if (jy < -SENSITIVE)\r\n            ci->dir = dir_North;\r\n        else if (jy > SENSITIVE)\r\n            ci->dir = dir_South;\r\n\r\n        if (jx < -SENSITIVE)\r\n            ci->dir = dir_West;\r\n        else if (jx > SENSITIVE)\r\n            ci->dir = dir_East;\r\n\r\n        jb = IN_JoyButtons ();\r\n        if (jb)\r\n        {\r\n            ci->button0 = jb & 1;\r\n            ci->button1 = jb & 2;\r\n            ci->button2 = jb & 4;\r\n            ci->button3 = jb & 8;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// DRAW DIALOG AND CONFIRM YES OR NO TO QUESTION\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nint\r\nConfirm (const char *string)\r\n{\r\n    int xit = 0, x, y, tick = 0, lastBlinkTime;\r\n    int whichsnd[2] = { ESCPRESSEDSND, SHOOTSND };\r\n    ControlInfo ci;\r\n\r\n    Message (string);\r\n    IN_ClearKeysDown ();\r\n    WaitKeyUp ();\r\n\r\n    //\r\n    // BLINK CURSOR\r\n    //\r\n    x = PrintX;\r\n    y = PrintY;\r\n    lastBlinkTime = GetTimeCount();\r\n\r\n    do\r\n    {\r\n        ReadAnyControl(&ci);\r\n\r\n        if (GetTimeCount() - lastBlinkTime >= 10)\r\n        {\r\n            switch (tick)\r\n            {\r\n                case 0:\r\n                    VWB_Bar (x, y, 8, 13, TEXTCOLOR);\r\n                    break;\r\n                case 1:\r\n                    PrintX = x;\r\n                    PrintY = y;\r\n                    US_Print (\"_\");\r\n            }\r\n            VW_UpdateScreen ();\r\n            tick ^= 1;\r\n            lastBlinkTime = GetTimeCount();\r\n        }\r\n        else SDL_Delay(5);\r\n\r\n#ifdef SPANISH\r\n    }\r\n    while (!Keyboard[sc_S] && !Keyboard[sc_N] && !Keyboard[sc_Escape]);\r\n#else\r\n    }\r\n    while (!Keyboard[sc_Y] && !Keyboard[sc_N] && !Keyboard[sc_Escape] && !ci.button0 && !ci.button1);\r\n#endif\r\n\r\n#ifdef SPANISH\r\n    if (Keyboard[sc_S] || ci.button0)\r\n    {\r\n        xit = 1;\r\n        ShootSnd ();\r\n    }\r\n#else\r\n    if (Keyboard[sc_Y] || ci.button0)\r\n    {\r\n        xit = 1;\r\n        ShootSnd ();\r\n    }\r\n#endif\r\n\r\n    IN_ClearKeysDown ();\r\n    WaitKeyUp ();\r\n\r\n    SD_PlaySound ((soundnames) whichsnd[xit]);\r\n\r\n    return xit;\r\n}\r\n\r\n#ifdef JAPAN\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// DRAW MESSAGE & GET Y OR N\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nint\r\nGetYorN (int x, int y, int pic)\r\n{\r\n    int xit = 0, whichsnd[2] = { ESCPRESSEDSND, SHOOTSND };\r\n\r\n\r\n    CA_CacheGrChunk (pic);\r\n    VWB_DrawPic (x * 8, y * 8, pic);\r\n    UNCACHEGRCHUNK (pic);\r\n    VW_UpdateScreen ();\r\n    IN_ClearKeysDown ();\r\n\r\n    do\r\n    {\r\n        IN_WaitAndProcessEvents();\r\n#ifndef SPEAR\r\n        if (Keyboard[sc_Tab] && Keyboard[sc_P] && param_debugmode)\r\n            PicturePause ();\r\n#endif\r\n\r\n#ifdef SPANISH\r\n    }\r\n    while (!Keyboard[sc_S] && !Keyboard[sc_N] && !Keyboard[sc_Escape]);\r\n#else\r\n    }\r\n    while (!Keyboard[sc_Y] && !Keyboard[sc_N] && !Keyboard[sc_Escape]);\r\n#endif\r\n\r\n#ifdef SPANISH\r\n    if (Keyboard[sc_S])\r\n    {\r\n        xit = 1;\r\n        ShootSnd ();\r\n    }\r\n\r\n    while (Keyboard[sc_S] || Keyboard[sc_N] || Keyboard[sc_Escape])\r\n        IN_WaitAndProcessEvents();\r\n\r\n#else\r\n\r\n    if (Keyboard[sc_Y])\r\n    {\r\n        xit = 1;\r\n        ShootSnd ();\r\n    }\r\n\r\n    while (Keyboard[sc_Y] || Keyboard[sc_N] || Keyboard[sc_Escape])\r\n        IN_WaitAndProcessEvents();\r\n#endif\r\n\r\n    IN_ClearKeysDown ();\r\n    SD_PlaySound (whichsnd[xit]);\r\n    return xit;\r\n}\r\n#endif\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// PRINT A MESSAGE IN A WINDOW\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nvoid\r\nMessage (const char *string)\r\n{\r\n    int h = 0, w = 0, mw = 0, i, len = (int) strlen(string);\r\n    fontstruct *font;\r\n\r\n\r\n    CA_CacheGrChunk (STARTFONT + 1);\r\n    fontnumber = 1;\r\n    font = (fontstruct *) grsegs[STARTFONT + fontnumber];\r\n    h = font->height;\r\n    for (i = 0; i < len; i++)\r\n    {\r\n        if (string[i] == '\\n')\r\n        {\r\n            if (w > mw)\r\n                mw = w;\r\n            w = 0;\r\n            h += font->height;\r\n        }\r\n        else\r\n            w += font->width[string[i]];\r\n    }\r\n\r\n    if (w + 10 > mw)\r\n        mw = w + 10;\r\n\r\n    PrintY = (WindowH / 2) - h / 2;\r\n    PrintX = WindowX = 160 - mw / 2;\r\n\r\n    DrawWindow (WindowX - 5, PrintY - 5, mw + 10, h + 10, TEXTCOLOR);\r\n    DrawOutline (WindowX - 5, PrintY - 5, mw + 10, h + 10, 0, HIGHLIGHT);\r\n    SETFONTCOLOR (0, TEXTCOLOR);\r\n    US_Print (string);\r\n    VW_UpdateScreen ();\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////\r\n//\r\n// THIS MAY BE FIXED A LITTLE LATER...\r\n//\r\n////////////////////////////////////////////////////////////////////\r\nstatic int lastmusic;\r\n\r\nint\r\nStartCPMusic (int song)\r\n{\r\n    int lastoffs;\r\n\r\n    lastmusic = song;\r\n    lastoffs = SD_MusicOff ();\r\n    UNCACHEAUDIOCHUNK (STARTMUSIC + lastmusic);\r\n\r\n    SD_StartMusic(STARTMUSIC + song);\r\n    return lastoffs;\r\n}\r\n\r\nvoid\r\nFreeMusic (void)\r\n{\r\n    UNCACHEAUDIOCHUNK (STARTMUSIC + lastmusic);\r\n}\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      IN_GetScanName() - Returns a string containing the name of the\r\n//              specified scan code\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nconst char *\r\nIN_GetScanName (ScanCode scan)\r\n{\r\n/*    const char **p;\r\n    ScanCode *s;\r\n\r\n    for (s = ExtScanCodes, p = ExtScanNames; *s; p++, s++)\r\n        if (*s == scan)\r\n            return (*p);*/\r\n\r\n    return (ScanNames[scan]);\r\n}\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n// CHECK FOR PAUSE KEY (FOR MUSIC ONLY)\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nCheckPause (void)\r\n{\r\n    if (Paused)\r\n    {\r\n        switch (SoundStatus)\r\n        {\r\n            case 0:\r\n                SD_MusicOn ();\r\n                break;\r\n            case 1:\r\n                SD_MusicOff ();\r\n                break;\r\n        }\r\n\r\n        SoundStatus ^= 1;\r\n        VW_WaitVBL (3);\r\n        IN_ClearKeysDown ();\r\n        Paused = false;\r\n    }\r\n}\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n// DRAW GUN CURSOR AT CORRECT POSITION IN MENU\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nDrawMenuGun (CP_iteminfo * iteminfo)\r\n{\r\n    int x, y;\r\n\r\n\r\n    x = iteminfo->x;\r\n    y = iteminfo->y + iteminfo->curpos * 13 - 2;\r\n    VWB_DrawPic (x, y, C_CURSOR1PIC);\r\n}\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n// DRAW SCREEN TITLE STRIPES\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nDrawStripes (int y)\r\n{\r\n#ifndef SPEAR\r\n    VWB_Bar (0, y, 320, 24, 0);\r\n    VWB_Hlin (0, 319, y + 22, STRIPE);\r\n#else\r\n    VWB_Bar (0, y, 320, 22, 0);\r\n    VWB_Hlin (0, 319, y + 23, 0);\r\n#endif\r\n}\r\n\r\nvoid\r\nShootSnd (void)\r\n{\r\n    SD_PlaySound (SHOOTSND);\r\n}\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n// CHECK FOR EPISODES\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nCheckForEpisodes (void)\r\n{\r\n    struct stat statbuf;\r\n\r\n    // On Linux like systems, the configdir defaults to $HOME/.chocolate_wolfenstein_3d\r\n#if !defined(_WIN32)\r\n    if(configdir[0] == 0)\r\n    {\r\n        // Set config location to home directory for multi-user support\r\n        char *homedir = getenv(\"HOME\");\r\n        if(homedir == NULL)\r\n        {\r\n            Quit(\"Your $HOME directory is not defined. You must set this before playing.\");\r\n        }\r\n        #define WOLFDIR \"/.chocolate_wolfenstein_3d\"\r\n        if(strlen(homedir) + sizeof(WOLFDIR) > sizeof(configdir))\r\n        {\r\n            Quit(\"Your $HOME directory path is too long. It cannot be used for saving games.\");\r\n        }\r\n        snprintf(configdir, sizeof(configdir), \"%s\" WOLFDIR, homedir);\r\n    }\r\n#endif\r\n\r\n    if(configdir[0] != 0)\r\n    {\r\n        // Ensure config directory exists and create if necessary\r\n        if(stat(configdir, &statbuf) != 0)\r\n        {\r\n#ifdef _WIN32\r\n            if(_mkdir(configdir) != 0)\r\n#else\r\n            if(mkdir(configdir, 0755) != 0)\r\n#endif\r\n            {\r\n                Quit(\"The configuration directory \\\"%s\\\" could not be created.\", configdir);\r\n            }\r\n        }\r\n    }\r\n\r\n//\r\n// JAPANESE VERSION\r\n//\r\n#ifdef JAPAN\r\n#ifdef JAPDEMO\r\n    if(!stat(\"vswap.wj1\", &statbuf))\r\n    {\r\n        strcpy (extension, \"wj1\");\r\n        numEpisodesMissing = 5;\r\n#else\r\n    if(!stat(\"vswap.wj6\", &statbuf))\r\n    {\r\n        strcpy (extension, \"wj6\");\r\n#endif\r\n        strcat (configname, extension);\r\n        strcat (SaveName, extension);\r\n        strcat (demoname, extension);\r\n        EpisodeSelect[1] =\r\n            EpisodeSelect[2] = EpisodeSelect[3] = EpisodeSelect[4] = EpisodeSelect[5] = 1;\r\n    }\r\n    else\r\n        Quit (\"NO JAPANESE WOLFENSTEIN 3-D DATA FILES to be found!\");\r\n#else\r\n\r\n//\r\n// ENGLISH\r\n//\r\n#ifdef UPLOAD\r\n    if(!stat(\"vswap.wl1\", &statbuf))\r\n    {\r\n        strcpy (extension, \"wl1\");\r\n        numEpisodesMissing = 5;\r\n    }\r\n    else\r\n        Quit (\"NO WOLFENSTEIN 3-D DATA FILES to be found!\");\r\n#else\r\n#ifndef SPEAR\r\n    if(!stat(\"vswap.wl6\", &statbuf))\r\n    {\r\n        strcpy (extension, \"wl6\");\r\n        NewEmenu[2].active =\r\n            NewEmenu[4].active =\r\n            NewEmenu[6].active =\r\n            NewEmenu[8].active =\r\n            NewEmenu[10].active =\r\n            EpisodeSelect[1] =\r\n            EpisodeSelect[2] = EpisodeSelect[3] = EpisodeSelect[4] = EpisodeSelect[5] = 1;\r\n    }\r\n    else\r\n    {\r\n        if(!stat(\"vswap.wl3\", &statbuf))\r\n        {\r\n            strcpy (extension, \"wl3\");\r\n            numEpisodesMissing = 3;\r\n            NewEmenu[2].active = NewEmenu[4].active = EpisodeSelect[1] = EpisodeSelect[2] = 1;\r\n        }\r\n        else\r\n        {\r\n            if(!stat(\"vswap.wl1\", &statbuf))\r\n            {\r\n                strcpy (extension, \"wl1\");\r\n                numEpisodesMissing = 5;\r\n            }\r\n            else\r\n                Quit (\"NO WOLFENSTEIN 3-D DATA FILES to be found!\");\r\n        }\r\n    }\r\n#endif\r\n#endif\r\n\r\n\r\n#ifdef SPEAR\r\n#ifndef SPEARDEMO\r\n    if(param_mission == 0)\r\n    {\r\n        if(!stat(\"vswap.sod\", &statbuf))\r\n            strcpy (extension, \"sod\");\r\n        else\r\n            Quit (\"NO SPEAR OF DESTINY DATA FILES TO BE FOUND!\");\r\n    }\r\n    else if(param_mission == 1)\r\n    {\r\n        if(!stat(\"vswap.sd1\", &statbuf))\r\n            strcpy (extension, \"sd1\");\r\n        else\r\n            Quit (\"NO SPEAR OF DESTINY DATA FILES TO BE FOUND!\");\r\n    }\r\n    else if(param_mission == 2)\r\n    {\r\n        if(!stat(\"vswap.sd2\", &statbuf))\r\n            strcpy (extension, \"sd2\");\r\n        else\r\n            Quit (\"NO SPEAR OF DESTINY DATA FILES TO BE FOUND!\");\r\n    }\r\n    else if(param_mission == 3)\r\n    {\r\n        if(!stat(\"vswap.sd3\", &statbuf))\r\n            strcpy (extension, \"sd3\");\r\n        else\r\n            Quit (\"NO SPEAR OF DESTINY DATA FILES TO BE FOUND!\");\r\n    }\r\n    else\r\n        Quit (\"UNSUPPORTED MISSION!\");\r\n    strcpy (graphext, \"sod\");\r\n    strcpy (audioext, \"sod\");\r\n#else\r\n    if(!stat(\"vswap.sdm\", &statbuf))\r\n    {\r\n        strcpy (extension, \"sdm\");\r\n    }\r\n    else\r\n        Quit (\"NO SPEAR OF DESTINY DEMO DATA FILES TO BE FOUND!\");\r\n    strcpy (graphext, \"sdm\");\r\n    strcpy (audioext, \"sdm\");\r\n#endif\r\n#else\r\n    strcpy (graphext, extension);\r\n    strcpy (audioext, extension);\r\n#endif\r\n\r\n    strcat (configname, extension);\r\n    strcat (SaveName, extension);\r\n    strcat (demoname, extension);\r\n\r\n#ifndef SPEAR\r\n#ifndef GOODTIMES\r\n    strcat (helpfilename, extension);\r\n#endif\r\n    strcat (endfilename, extension);\r\n#endif\r\n#endif\r\n}\r\n","// WL_PLAY.C\r\n\r\n#include \"wl_def.h\"\r\n#pragma hdrstop\r\n\r\n\r\n#ifdef __EMSCRIPTEN__\r\n#include <emscripten.h>\r\n#endif\r\n\r\n#include \"web.h\"\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                                 LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define sc_Question     0x35\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                                 GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nboolean madenoise;              // true when shooting or screaming\r\n\r\nexit_t playstate;\r\n\r\nstatic musicnames lastmusicchunk = (musicnames) 0;\r\n\r\nstatic int DebugOk;\r\n\r\nobjtype objlist[MAXACTORS];\r\nobjtype *newobj, *obj, *player, *lastobj, *objfreelist, *killerobj;\r\n\r\nboolean noclip, ammocheat;\r\nint godmode, singlestep, extravbls = 0;\r\n\r\nbyte tilemap[MAPSIZE][MAPSIZE]; // wall values only\r\nbyte spotvis[MAPSIZE][MAPSIZE];\r\nobjtype *actorat[MAPSIZE][MAPSIZE];\r\n\r\n//\r\n// replacing refresh manager\r\n//\r\nunsigned tics;\r\n\r\n//\r\n// control info\r\n//\r\nboolean mouseenabled, joystickenabled;\r\nint dirscan[4] = { sc_UpArrow, sc_RightArrow, sc_DownArrow, sc_LeftArrow };\r\nint buttonscan[NUMBUTTONS] = { sc_Control, sc_Alt, sc_LShift, sc_Space, sc_1, sc_2, sc_3, sc_4 };\r\nint buttonmouse[4] = { bt_attack, bt_strafe, bt_use, bt_nobutton };\r\nint buttonjoy[32] = {\r\n\r\n    bt_attack, bt_strafe, bt_use, bt_run, bt_strafeleft, bt_straferight, bt_esc, bt_pause,\r\n    bt_prevweapon, bt_nextweapon, bt_nobutton, bt_nobutton, bt_nobutton, bt_nobutton, bt_nobutton, bt_nobutton,\r\n\r\n    bt_nobutton, bt_nobutton, bt_nobutton, bt_nobutton, bt_nobutton, bt_nobutton, bt_nobutton, bt_nobutton,\r\n    bt_nobutton, bt_nobutton, bt_nobutton, bt_nobutton, bt_nobutton, bt_nobutton, bt_nobutton, bt_nobutton\r\n};\r\n\r\nint viewsize;\r\n\r\nboolean buttonheld[NUMBUTTONS];\r\n\r\nboolean demorecord, demoplayback;\r\nint8_t *demoptr, *lastdemoptr;\r\nmemptr demobuffer;\r\n\r\n//\r\n// current user input\r\n//\r\nint controlx, controly;         // range from -100 to 100 per tic\r\nboolean buttonstate[NUMBUTTONS];\r\n\r\nint lastgamemusicoffset = 0;\r\n\r\n\r\n//===========================================================================\r\n\r\n\r\nvoid CenterWindow (word w, word h);\r\nvoid InitObjList (void);\r\nvoid RemoveObj (objtype * gone);\r\nvoid PollControls (void);\r\nint StopMusic (void);\r\nvoid StartMusic (void);\r\nvoid ContinueMusic (int offs);\r\nvoid PlayLoop (int);\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                                 LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\nobjtype dummyobj;\r\n\r\n//\r\n// LIST OF SONGS FOR EACH VERSION\r\n//\r\nint songs[] = {\r\n#ifndef SPEAR\r\n    //\r\n    // Episode One\r\n    //\r\n    GETTHEM_MUS,\r\n    SEARCHN_MUS,\r\n    POW_MUS,\r\n    SUSPENSE_MUS,\r\n    GETTHEM_MUS,\r\n    SEARCHN_MUS,\r\n    POW_MUS,\r\n    SUSPENSE_MUS,\r\n\r\n    WARMARCH_MUS,               // Boss level\r\n    CORNER_MUS,                 // Secret level\r\n\r\n    //\r\n    // Episode Two\r\n    //\r\n    NAZI_OMI_MUS,\r\n    PREGNANT_MUS,\r\n    GOINGAFT_MUS,\r\n    HEADACHE_MUS,\r\n    NAZI_OMI_MUS,\r\n    PREGNANT_MUS,\r\n    HEADACHE_MUS,\r\n    GOINGAFT_MUS,\r\n\r\n    WARMARCH_MUS,               // Boss level\r\n    DUNGEON_MUS,                // Secret level\r\n\r\n    //\r\n    // Episode Three\r\n    //\r\n    INTROCW3_MUS,\r\n    NAZI_RAP_MUS,\r\n    TWELFTH_MUS,\r\n    ZEROHOUR_MUS,\r\n    INTROCW3_MUS,\r\n    NAZI_RAP_MUS,\r\n    TWELFTH_MUS,\r\n    ZEROHOUR_MUS,\r\n\r\n    ULTIMATE_MUS,               // Boss level\r\n    PACMAN_MUS,                 // Secret level\r\n\r\n    //\r\n    // Episode Four\r\n    //\r\n    GETTHEM_MUS,\r\n    SEARCHN_MUS,\r\n    POW_MUS,\r\n    SUSPENSE_MUS,\r\n    GETTHEM_MUS,\r\n    SEARCHN_MUS,\r\n    POW_MUS,\r\n    SUSPENSE_MUS,\r\n\r\n    WARMARCH_MUS,               // Boss level\r\n    CORNER_MUS,                 // Secret level\r\n\r\n    //\r\n    // Episode Five\r\n    //\r\n    NAZI_OMI_MUS,\r\n    PREGNANT_MUS,\r\n    GOINGAFT_MUS,\r\n    HEADACHE_MUS,\r\n    NAZI_OMI_MUS,\r\n    PREGNANT_MUS,\r\n    HEADACHE_MUS,\r\n    GOINGAFT_MUS,\r\n\r\n    WARMARCH_MUS,               // Boss level\r\n    DUNGEON_MUS,                // Secret level\r\n\r\n    //\r\n    // Episode Six\r\n    //\r\n    INTROCW3_MUS,\r\n    NAZI_RAP_MUS,\r\n    TWELFTH_MUS,\r\n    ZEROHOUR_MUS,\r\n    INTROCW3_MUS,\r\n    NAZI_RAP_MUS,\r\n    TWELFTH_MUS,\r\n    ZEROHOUR_MUS,\r\n\r\n    ULTIMATE_MUS,               // Boss level\r\n    FUNKYOU_MUS                 // Secret level\r\n#else\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    //\r\n    // SPEAR OF DESTINY TRACKS\r\n    //\r\n    //////////////////////////////////////////////////////////////\r\n    XTIPTOE_MUS,\r\n    XFUNKIE_MUS,\r\n    XDEATH_MUS,\r\n    XGETYOU_MUS,                // DON'T KNOW\r\n    ULTIMATE_MUS,               // Trans Gr�sse\r\n\r\n    DUNGEON_MUS,\r\n    GOINGAFT_MUS,\r\n    POW_MUS,\r\n    TWELFTH_MUS,\r\n    ULTIMATE_MUS,               // Barnacle Wilhelm BOSS\r\n\r\n    NAZI_OMI_MUS,\r\n    GETTHEM_MUS,\r\n    SUSPENSE_MUS,\r\n    SEARCHN_MUS,\r\n    ZEROHOUR_MUS,\r\n    ULTIMATE_MUS,               // Super Mutant BOSS\r\n\r\n    XPUTIT_MUS,\r\n    ULTIMATE_MUS,               // Death Knight BOSS\r\n\r\n    XJAZNAZI_MUS,               // Secret level\r\n    XFUNKIE_MUS,                // Secret level (DON'T KNOW)\r\n\r\n    XEVIL_MUS                   // Angel of Death BOSS\r\n#endif\r\n};\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                               USER CONTROL\r\n\r\n=============================================================================\r\n*/\r\n\r\n/*\r\n===================\r\n=\r\n= PollKeyboardButtons\r\n=\r\n===================\r\n*/\r\n\r\nvoid PollKeyboardButtons (void)\r\n{\r\n    int i;\r\n\r\n    for (i = 0; i < NUMBUTTONS; i++)\r\n        if (Keyboard[buttonscan[i]])\r\n            buttonstate[i] = true;\r\n}\r\n\r\n\r\n/*\r\n===================\r\n=\r\n= PollMouseButtons\r\n=\r\n===================\r\n*/\r\n\r\nvoid PollMouseButtons (void)\r\n{\r\n    int buttons = IN_MouseButtons ();\r\n\r\n    if (buttons & 1)\r\n        buttonstate[buttonmouse[0]] = true;\r\n    if (buttons & 2)\r\n        buttonstate[buttonmouse[1]] = true;\r\n    if (buttons & 4)\r\n        buttonstate[buttonmouse[2]] = true;\r\n}\r\n\r\n\r\n\r\n/*\r\n===================\r\n=\r\n= PollJoystickButtons\r\n=\r\n===================\r\n*/\r\n\r\nvoid PollJoystickButtons (void)\r\n{\r\n    int buttons = IN_JoyButtons();\r\n\r\n    for(int i = 0, val = 1; i < JoyNumButtons; i++, val <<= 1)\r\n    {\r\n        if(buttons & val)\r\n            buttonstate[buttonjoy[i]] = true;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n===================\r\n=\r\n= PollKeyboardMove\r\n=\r\n===================\r\n*/\r\n\r\nvoid PollKeyboardMove (void)\r\n{\r\n    int delta = buttonstate[bt_run] ? RUNMOVE * tics : BASEMOVE * tics;\r\n\r\n    if (Keyboard[dirscan[di_north]])\r\n        controly -= delta;\r\n    if (Keyboard[dirscan[di_south]])\r\n        controly += delta;\r\n    if (Keyboard[dirscan[di_west]])\r\n        controlx -= delta;\r\n    if (Keyboard[dirscan[di_east]])\r\n        controlx += delta;\r\n}\r\n\r\n\r\n/*\r\n===================\r\n=\r\n= PollMouseMove\r\n=\r\n===================\r\n*/\r\n\r\nvoid PollMouseMove (void)\r\n{\r\n    int mousexmove, mouseymove;\r\n\r\n    SDL_GetMouseState(&mousexmove, &mouseymove);\r\n    if(IN_IsInputGrabbed())\r\n        IN_CenterMouse();\r\n\r\n    mousexmove -= screenWidth / 2;\r\n    mouseymove -= screenHeight / 2;\r\n\r\n    controlx += mousexmove * 10 / (13 - mouseadjustment);\r\n    controly += mouseymove * 20 / (13 - mouseadjustment);\r\n}\r\n\r\n\r\n/*\r\n===================\r\n=\r\n= PollJoystickMove\r\n=\r\n===================\r\n*/\r\n\r\nvoid PollJoystickMove (void)\r\n{\r\n    int joyx, joyy;\r\n\r\n    IN_GetJoyDelta (&joyx, &joyy);\r\n\r\n    int delta = buttonstate[bt_run] ? RUNMOVE * tics : BASEMOVE * tics;\r\n\r\n    if (joyx > 64 || buttonstate[bt_turnright])\r\n        controlx += delta;\r\n    else if (joyx < -64  || buttonstate[bt_turnleft])\r\n        controlx -= delta;\r\n    if (joyy > 64 || buttonstate[bt_movebackward])\r\n        controly += delta;\r\n    else if (joyy < -64 || buttonstate[bt_moveforward])\r\n        controly -= delta;\r\n}\r\n\r\n/*\r\n===================\r\n=\r\n= PollControls\r\n=\r\n= Gets user or demo input, call once each frame\r\n=\r\n= controlx              set between -100 and 100 per tic\r\n= controly\r\n= buttonheld[]  the state of the buttons LAST frame\r\n= buttonstate[] the state of the buttons THIS frame\r\n=\r\n===================\r\n*/\r\n\r\nvoid PollControls (void)\r\n{\r\n    int max, min, i;\r\n    byte buttonbits;\r\n\r\n    IN_ProcessEvents();\r\n\r\n//\r\n// get timing info for last frame\r\n//\r\n    if (demoplayback || demorecord)   // demo recording and playback needs to be constant\r\n    {\r\n        // wait up to DEMOTICS Wolf tics\r\n        uint32_t curtime = SDL_GetTicks();\r\n        lasttimecount += DEMOTICS;\r\n        int32_t timediff = (lasttimecount * 100) / 7 - curtime;\r\n        if(timediff > 0)\r\n            SDL_Delay(timediff);\r\n\r\n        if(timediff < -2 * DEMOTICS)       // more than 2-times DEMOTICS behind?\r\n            lasttimecount = (curtime * 7) / 100;    // yes, set to current timecount\r\n\r\n        tics = DEMOTICS;\r\n    }\r\n    else\r\n        CalcTics ();\r\n\r\n    controlx = 0;\r\n    controly = 0;\r\n    memcpy (buttonheld, buttonstate, sizeof (buttonstate));\r\n    memset (buttonstate, 0, sizeof (buttonstate));\r\n\r\n    if (demoplayback)\r\n    {\r\n        //\r\n        // read commands from demo buffer\r\n        //\r\n        buttonbits = *demoptr++;\r\n        for (i = 0; i < NUMBUTTONS; i++)\r\n        {\r\n            buttonstate[i] = buttonbits & 1;\r\n            buttonbits >>= 1;\r\n        }\r\n\r\n        controlx = *demoptr++;\r\n        controly = *demoptr++;\r\n\r\n        if (demoptr == lastdemoptr)\r\n            playstate = ex_completed;   // demo is done\r\n\r\n        controlx *= (int) tics;\r\n        controly *= (int) tics;\r\n\r\n        return;\r\n    }\r\n\r\n\r\n//\r\n// get button states\r\n//\r\n    PollKeyboardButtons ();\r\n\r\n    if (mouseenabled && IN_IsInputGrabbed())\r\n        PollMouseButtons ();\r\n\r\n    if (joystickenabled)\r\n        PollJoystickButtons ();\r\n\r\n//\r\n// get movements\r\n//\r\n    PollKeyboardMove ();\r\n\r\n    if (mouseenabled && IN_IsInputGrabbed())\r\n        PollMouseMove ();\r\n\r\n    if (joystickenabled)\r\n        PollJoystickMove ();\r\n\r\n//\r\n// bound movement to a maximum\r\n//\r\n    max = 100 * tics;\r\n    min = -max;\r\n    if (controlx > max)\r\n        controlx = max;\r\n    else if (controlx < min)\r\n        controlx = min;\r\n\r\n    if (controly > max)\r\n        controly = max;\r\n    else if (controly < min)\r\n        controly = min;\r\n\r\n    if (demorecord)\r\n    {\r\n        //\r\n        // save info out to demo buffer\r\n        //\r\n        controlx /= (int) tics;\r\n        controly /= (int) tics;\r\n\r\n        buttonbits = 0;\r\n\r\n        // TODO: Support 32-bit buttonbits\r\n        for (i = NUMBUTTONS - 1; i >= 0; i--)\r\n        {\r\n            buttonbits <<= 1;\r\n            if (buttonstate[i])\r\n                buttonbits |= 1;\r\n        }\r\n\r\n        *demoptr++ = buttonbits;\r\n        *demoptr++ = controlx;\r\n        *demoptr++ = controly;\r\n\r\n        if (demoptr >= lastdemoptr - 8)\r\n            playstate = ex_completed;\r\n        else\r\n        {\r\n            controlx *= (int) tics;\r\n            controly *= (int) tics;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n//==========================================================================\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//      CenterWindow() - Generates a window of a given width & height in the\r\n//              middle of the screen\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\n#define MAXX    320\r\n#define MAXY    160\r\n\r\nvoid CenterWindow (word w, word h)\r\n{\r\n    US_DrawWindow (((MAXX / 8) - w) / 2, ((MAXY / 8) - h) / 2, w, h);\r\n}\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= CheckKeys\r\n=\r\n=====================\r\n*/\r\n\r\nvoid CheckKeys (void)\r\n{\r\n    ScanCode scan;\r\n\r\n\r\n    if (screenfaded || demoplayback)    // don't do anything with a faded screen\r\n        return;\r\n\r\n    scan = LastScan;\r\n\r\n\r\n#ifdef SPEAR\r\n    //\r\n    // SECRET CHEAT CODE: TAB-G-F10\r\n    //\r\n    if (Keyboard[sc_Tab] && Keyboard[sc_G] && Keyboard[sc_F10])\r\n    {\r\n        WindowH = 160;\r\n        if (godmode)\r\n        {\r\n            Message (\"God mode OFF\");\r\n            SD_PlaySound (NOBONUSSND);\r\n        }\r\n        else\r\n        {\r\n            Message (\"God mode ON\");\r\n            SD_PlaySound (ENDBONUS2SND);\r\n        }\r\n\r\n        IN_Ack ();\r\n        godmode ^= 1;\r\n        DrawPlayBorderSides ();\r\n        IN_ClearKeysDown ();\r\n        return;\r\n    }\r\n#endif\r\n\r\n\r\n    //\r\n    // SECRET CHEAT CODE: 'MLI'\r\n    //\r\n    if (Keyboard[sc_M] && Keyboard[sc_L] && Keyboard[sc_I])\r\n    {\r\n        gamestate.health = 100;\r\n        gamestate.ammo = 99;\r\n        gamestate.keys = 3;\r\n        gamestate.score = 0;\r\n        gamestate.TimeCount += 42000L;\r\n        GiveWeapon (wp_chaingun);\r\n        DrawWeapon ();\r\n        DrawHealth ();\r\n        DrawKeys ();\r\n        DrawAmmo ();\r\n        DrawScore ();\r\n\r\n        ClearMemory ();\r\n        CA_CacheGrChunk (STARTFONT + 1);\r\n        ClearSplitVWB ();\r\n\r\n        Message (STR_CHEATER1 \"\\n\"\r\n                 STR_CHEATER2 \"\\n\\n\" STR_CHEATER3 \"\\n\" STR_CHEATER4 \"\\n\" STR_CHEATER5);\r\n\r\n        UNCACHEGRCHUNK (STARTFONT + 1);\r\n        IN_ClearKeysDown ();\r\n        IN_Ack ();\r\n\r\n        if (viewsize < 17)\r\n            DrawPlayBorder ();\r\n    }\r\n\r\n    //\r\n    // OPEN UP DEBUG KEYS\r\n    //\r\n#ifdef DEBUGKEYS\r\n    if (Keyboard[sc_BackSpace] && Keyboard[sc_LShift] && Keyboard[sc_Alt] && param_debugmode)\r\n    {\r\n        ClearMemory ();\r\n        CA_CacheGrChunk (STARTFONT + 1);\r\n        ClearSplitVWB ();\r\n\r\n        Message (\"Debugging keys are\\nnow available!\");\r\n        UNCACHEGRCHUNK (STARTFONT + 1);\r\n        IN_ClearKeysDown ();\r\n        IN_Ack ();\r\n\r\n        DrawPlayBorderSides ();\r\n        DebugOk = 1;\r\n    }\r\n#endif\r\n\r\n    //\r\n    // TRYING THE KEEN CHEAT CODE!\r\n    //\r\n    if (Keyboard[sc_B] && Keyboard[sc_A] && Keyboard[sc_T])\r\n    {\r\n        ClearMemory ();\r\n        CA_CacheGrChunk (STARTFONT + 1);\r\n        ClearSplitVWB ();\r\n\r\n        Message (\"Commander Keen is also\\n\"\r\n                 \"available from Apogee, but\\n\"\r\n                 \"then, you already know\\n\" \"that - right, Cheatmeister?!\");\r\n\r\n        UNCACHEGRCHUNK (STARTFONT + 1);\r\n        IN_ClearKeysDown ();\r\n        IN_Ack ();\r\n\r\n        if (viewsize < 18)\r\n            DrawPlayBorder ();\r\n    }\r\n\r\n//\r\n// pause key weirdness can't be checked as a scan code\r\n//\r\n    if(buttonstate[bt_pause]) Paused = true;\r\n    if(Paused)\r\n    {\r\n        int lastoffs = StopMusic();\r\n        LatchDrawPic (20 - 4, 80 - 2 * 8, PAUSEDPIC);\r\n        VH_UpdateScreen();\r\n        IN_Ack ();\r\n        Paused = false;\r\n        ContinueMusic(lastoffs);\r\n        if (MousePresent && IN_IsInputGrabbed())\r\n            IN_CenterMouse();     // Clear accumulated mouse movement\r\n        lasttimecount = GetTimeCount();\r\n        return;\r\n    }\r\n\r\n//\r\n// F1-F7/ESC to enter control panel\r\n//\r\n    if (\r\n#ifndef DEBCHECK\r\n           scan == sc_F10 ||\r\n#endif\r\n           scan == sc_F9 || scan == sc_F7 || scan == sc_F8)     // pop up quit dialog\r\n    {\r\n        ClearMemory ();\r\n        ClearSplitVWB ();\r\n        US_ControlPanel (scan);\r\n\r\n        DrawPlayBorderSides ();\r\n\r\n        SETFONTCOLOR (0, 15);\r\n        IN_ClearKeysDown ();\r\n        return;\r\n    }\r\n\r\n    if ((scan >= sc_F1 && scan <= sc_F9) || scan == sc_Escape || buttonstate[bt_esc])\r\n    {\r\n        int lastoffs = StopMusic ();\r\n        ClearMemory ();\r\n        VW_FadeOut ();\r\n\r\n        US_ControlPanel (buttonstate[bt_esc] ? sc_Escape : scan);\r\n\r\n        SETFONTCOLOR (0, 15);\r\n        IN_ClearKeysDown ();\r\n        VW_FadeOut();\r\n        if(viewsize != 21)\r\n            DrawPlayScreen ();\r\n        if (!startgame && !loadedgame)\r\n            ContinueMusic (lastoffs);\r\n        if (loadedgame)\r\n            playstate = ex_abort;\r\n        lasttimecount = GetTimeCount();\r\n        if (MousePresent && IN_IsInputGrabbed())\r\n            IN_CenterMouse();     // Clear accumulated mouse movement\r\n        return;\r\n    }\r\n\r\n//\r\n// TAB-? debug keys\r\n//\r\n#ifdef DEBUGKEYS\r\n    if (Keyboard[sc_Tab] && DebugOk)\r\n    {\r\n        CA_CacheGrChunk (STARTFONT);\r\n        fontnumber = 0;\r\n        SETFONTCOLOR (0, 15);\r\n        if (DebugKeys () && viewsize < 20)\r\n            DrawPlayBorder ();       // dont let the blue borders flash\r\n\r\n        if (MousePresent && IN_IsInputGrabbed())\r\n            IN_CenterMouse();     // Clear accumulated mouse movement\r\n\r\n        lasttimecount = GetTimeCount();\r\n        return;\r\n    }\r\n#endif\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n#############################################################################\r\n\r\n                                  The objlist data structure\r\n\r\n#############################################################################\r\n\r\nobjlist containt structures for every actor currently playing.  The structure\r\nis accessed as a linked list starting at *player, ending when ob->next ==\r\nNULL.  GetNewObj inserts a new object at the end of the list, meaning that\r\nif an actor spawn another actor, the new one WILL get to think and react the\r\nsame frame.  RemoveObj unlinks the given object and returns it to the free\r\nlist, but does not damage the objects ->next pointer, so if the current object\r\nremoves itself, a linked list following loop can still safely get to the\r\nnext element.\r\n\r\n<backwardly linked free list>\r\n\r\n#############################################################################\r\n*/\r\n\r\n\r\n/*\r\n=========================\r\n=\r\n= InitActorList\r\n=\r\n= Call to clear out the actor object lists returning them all to the free\r\n= list.  Allocates a special spot for the player.\r\n=\r\n=========================\r\n*/\r\n\r\nint objcount;\r\n\r\nvoid InitActorList (void)\r\n{\r\n    int i;\r\n\r\n//\r\n// init the actor lists\r\n//\r\n    for (i = 0; i < MAXACTORS; i++)\r\n    {\r\n        objlist[i].prev = &objlist[i + 1];\r\n        objlist[i].next = NULL;\r\n    }\r\n\r\n    objlist[MAXACTORS - 1].prev = NULL;\r\n\r\n    objfreelist = &objlist[0];\r\n    lastobj = NULL;\r\n\r\n    objcount = 0;\r\n\r\n//\r\n// give the player the first free spots\r\n//\r\n    GetNewActor ();\r\n    player = newobj;\r\n\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=========================\r\n=\r\n= GetNewActor\r\n=\r\n= Sets the global variable new to point to a free spot in objlist.\r\n= The free spot is inserted at the end of the liked list\r\n=\r\n= When the object list is full, the caller can either have it bomb out ot\r\n= return a dummy object pointer that will never get used\r\n=\r\n=========================\r\n*/\r\n\r\nvoid GetNewActor (void)\r\n{\r\n    if (!objfreelist)\r\n        Quit (\"GetNewActor: No free spots in objlist!\");\r\n\r\n    newobj = objfreelist;\r\n    objfreelist = newobj->prev;\r\n    memset (newobj, 0, sizeof (*newobj));\r\n\r\n    if (lastobj)\r\n        lastobj->next = newobj;\r\n    newobj->prev = lastobj;     // new->next is allready NULL from memset\r\n\r\n    newobj->active = ac_no;\r\n    lastobj = newobj;\r\n\r\n    objcount++;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=========================\r\n=\r\n= RemoveObj\r\n=\r\n= Add the given object back into the free list, and unlink it from it's\r\n= neighbors\r\n=\r\n=========================\r\n*/\r\n\r\nvoid RemoveObj (objtype * gone)\r\n{\r\n    if (gone == player)\r\n        Quit (\"RemoveObj: Tried to remove the player!\");\r\n\r\n    gone->state = NULL;\r\n\r\n//\r\n// fix the next object's back link\r\n//\r\n    if (gone == lastobj)\r\n        lastobj = (objtype *) gone->prev;\r\n    else\r\n        gone->next->prev = gone->prev;\r\n\r\n//\r\n// fix the previous object's forward link\r\n//\r\n    gone->prev->next = gone->next;\r\n\r\n//\r\n// add it back in to the free list\r\n//\r\n    gone->prev = objfreelist;\r\n    objfreelist = gone;\r\n\r\n    objcount--;\r\n}\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                                MUSIC STUFF\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= StopMusic\r\n=\r\n=================\r\n*/\r\nint StopMusic (void)\r\n{\r\n    int lastoffs = SD_MusicOff ();\r\n\r\n    UNCACHEAUDIOCHUNK (STARTMUSIC + lastmusicchunk);\r\n\r\n    return lastoffs;\r\n}\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= StartMusic\r\n=\r\n=================\r\n*/\r\n\r\nvoid StartMusic ()\r\n{\r\n    SD_MusicOff ();\r\n    lastmusicchunk = (musicnames) songs[gamestate.mapon + gamestate.episode * 10];\r\n    SD_StartMusic(STARTMUSIC + lastmusicchunk);\r\n}\r\n\r\nvoid ContinueMusic (int offs)\r\n{\r\n    SD_MusicOff ();\r\n    lastmusicchunk = (musicnames) songs[gamestate.mapon + gamestate.episode * 10];\r\n    SD_ContinueMusic(STARTMUSIC + lastmusicchunk, offs);\r\n}\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                        PALETTE SHIFTING STUFF\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define NUMREDSHIFTS    6\r\n#define REDSTEPS        8\r\n\r\n#define NUMWHITESHIFTS  3\r\n#define WHITESTEPS      20\r\n#define WHITETICS       6\r\n\r\n\r\nSDL_Color redshifts[NUMREDSHIFTS][256];\r\nSDL_Color whiteshifts[NUMWHITESHIFTS][256];\r\n\r\nint damagecount, bonuscount;\r\nboolean palshifted;\r\n\r\n/*\r\n=====================\r\n=\r\n= InitRedShifts\r\n=\r\n=====================\r\n*/\r\n\r\nvoid InitRedShifts (void)\r\n{\r\n    SDL_Color *workptr, *baseptr;\r\n    int i, j, delta;\r\n\r\n\r\n//\r\n// fade through intermediate frames\r\n//\r\n    for (i = 1; i <= NUMREDSHIFTS; i++)\r\n    {\r\n        workptr = redshifts[i - 1];\r\n        baseptr = gamepal;\r\n\r\n        for (j = 0; j <= 255; j++)\r\n        {\r\n            delta = 256 - baseptr->r;\r\n            workptr->r = baseptr->r + delta * i / REDSTEPS;\r\n            delta = -baseptr->g;\r\n            workptr->g = baseptr->g + delta * i / REDSTEPS;\r\n            delta = -baseptr->b;\r\n            workptr->b = baseptr->b + delta * i / REDSTEPS;\r\n            baseptr++;\r\n            workptr++;\r\n        }\r\n    }\r\n\r\n    for (i = 1; i <= NUMWHITESHIFTS; i++)\r\n    {\r\n        workptr = whiteshifts[i - 1];\r\n        baseptr = gamepal;\r\n\r\n        for (j = 0; j <= 255; j++)\r\n        {\r\n            delta = 256 - baseptr->r;\r\n            workptr->r = baseptr->r + delta * i / WHITESTEPS;\r\n            delta = 248 - baseptr->g;\r\n            workptr->g = baseptr->g + delta * i / WHITESTEPS;\r\n            delta = 0-baseptr->b;\r\n            workptr->b = baseptr->b + delta * i / WHITESTEPS;\r\n            baseptr++;\r\n            workptr++;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= ClearPaletteShifts\r\n=\r\n=====================\r\n*/\r\n\r\nvoid ClearPaletteShifts (void)\r\n{\r\n    bonuscount = damagecount = 0;\r\n    palshifted = false;\r\n}\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= StartBonusFlash\r\n=\r\n=====================\r\n*/\r\n\r\nvoid StartBonusFlash (void)\r\n{\r\n    bonuscount = NUMWHITESHIFTS * WHITETICS;    // white shift palette\r\n}\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= StartDamageFlash\r\n=\r\n=====================\r\n*/\r\n\r\nvoid StartDamageFlash (int damage)\r\n{\r\n    damagecount += damage;\r\n}\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= UpdatePaletteShifts\r\n=\r\n=====================\r\n*/\r\n\r\nvoid UpdatePaletteShifts (void)\r\n{\r\n    int red, white;\r\n\r\n    if (bonuscount)\r\n    {\r\n        white = bonuscount / WHITETICS + 1;\r\n        if (white > NUMWHITESHIFTS)\r\n            white = NUMWHITESHIFTS;\r\n        bonuscount -= tics;\r\n        if (bonuscount < 0)\r\n            bonuscount = 0;\r\n    }\r\n    else\r\n        white = 0;\r\n\r\n\r\n    if (damagecount)\r\n    {\r\n        red = damagecount / 10 + 1;\r\n        if (red > NUMREDSHIFTS)\r\n            red = NUMREDSHIFTS;\r\n\r\n        damagecount -= tics;\r\n        if (damagecount < 0)\r\n            damagecount = 0;\r\n    }\r\n    else\r\n        red = 0;\r\n\r\n    if (red)\r\n    {\r\n        VL_SetPalette (redshifts[red - 1], false);\r\n        palshifted = true;\r\n    }\r\n    else if (white)\r\n    {\r\n        VL_SetPalette (whiteshifts[white - 1], false);\r\n        palshifted = true;\r\n    }\r\n    else if (palshifted)\r\n    {\r\n        VL_SetPalette (gamepal, false);        // back to normal\r\n        palshifted = false;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= FinishPaletteShifts\r\n=\r\n= Resets palette to normal if needed\r\n=\r\n=====================\r\n*/\r\n\r\nvoid FinishPaletteShifts (void)\r\n{\r\n    if (palshifted)\r\n    {\r\n        palshifted = 0;\r\n        VL_SetPalette (gamepal, true);\r\n    }\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                                CORE PLAYLOOP\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= DoActor\r\n=\r\n=====================\r\n*/\r\n\r\nvoid DoActor (objtype * ob)\r\n{\r\n    void (*think) (objtype *);\r\n\r\n    if (!ob->active && !areabyplayer[ob->areanumber])\r\n        return;\r\n\r\n    if (!(ob->flags & (FL_NONMARK | FL_NEVERMARK)))\r\n        actorat[ob->tilex][ob->tiley] = NULL;\r\n\r\n//\r\n// non transitional object\r\n//\r\n\r\n    if (!ob->ticcount)\r\n    {\r\n        think = (void (*)(objtype *)) ob->state->think;\r\n        if (think)\r\n        {\r\n            think (ob);\r\n            if (!ob->state)\r\n            {\r\n                RemoveObj (ob);\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (ob->flags & FL_NEVERMARK)\r\n            return;\r\n\r\n        if ((ob->flags & FL_NONMARK) && actorat[ob->tilex][ob->tiley])\r\n            return;\r\n\r\n        actorat[ob->tilex][ob->tiley] = ob;\r\n        return;\r\n    }\r\n\r\n//\r\n// transitional object\r\n//\r\n    ob->ticcount -= (short) tics;\r\n    while (ob->ticcount <= 0)\r\n    {\r\n        think = (void (*)(objtype *)) ob->state->action;        // end of state action\r\n        if (think)\r\n        {\r\n            think (ob);\r\n            if (!ob->state)\r\n            {\r\n                RemoveObj (ob);\r\n                return;\r\n            }\r\n        }\r\n\r\n        ob->state = ob->state->next;\r\n\r\n        if (!ob->state)\r\n        {\r\n            RemoveObj (ob);\r\n            return;\r\n        }\r\n\r\n        if (!ob->state->tictime)\r\n        {\r\n            ob->ticcount = 0;\r\n            goto think;\r\n        }\r\n\r\n        ob->ticcount += ob->state->tictime;\r\n    }\r\n\r\nthink:\r\n    //\r\n    // think\r\n    //\r\n    think = (void (*)(objtype *)) ob->state->think;\r\n    if (think)\r\n    {\r\n        think (ob);\r\n        if (!ob->state)\r\n        {\r\n            RemoveObj (ob);\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (ob->flags & FL_NEVERMARK)\r\n        return;\r\n\r\n    if ((ob->flags & FL_NONMARK) && actorat[ob->tilex][ob->tiley])\r\n        return;\r\n\r\n    actorat[ob->tilex][ob->tiley] = ob;\r\n}\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n===================\r\n=\r\n= PlayLoop\r\n=\r\n===================\r\n*/\r\nint32_t funnyticount;\r\n\r\nvoid PlayLoop1 (int) {\r\n    PlayLoop(1);\r\n}\r\nvoid PlayLoop (int jumpto)\r\n{\r\nswitch (jumpto) { // re-entry state machine\r\ncase 0:\r\n    playstate = ex_stillplaying;\r\n    lasttimecount = GetTimeCount();\r\n    frameon = 0;\r\n    anglefrac = 0;\r\n    facecount = 0;\r\n    funnyticount = 0;\r\n    memset (buttonstate, 0, sizeof (buttonstate));\r\n    ClearPaletteShifts ();\r\n\r\n    if (MousePresent && IN_IsInputGrabbed())\r\n        IN_CenterMouse();         // Clear accumulated mouse movement\r\n\r\n    if (demoplayback)\r\n        IN_StartAck ();\r\n\r\ncase 1:\r\n#ifndef __EMSCRIPTEN__\r\n    do\r\n    {\r\n#endif\r\n        PollControls ();\r\n\r\n//\r\n// actor thinking\r\n//\r\n        madenoise = false;\r\n\r\n        MoveDoors ();\r\n        MovePWalls ();\r\n\r\n        for (obj = player; obj; obj = obj->next)\r\n            DoActor (obj);\r\n\r\n        UpdatePaletteShifts ();\r\n\r\n        ThreeDRefresh ();\r\n\r\n        //\r\n        // MAKE FUNNY FACE IF BJ DOESN'T MOVE FOR AWHILE\r\n        //\r\n#ifdef SPEAR\r\n        funnyticount += tics;\r\n        if (funnyticount > 30l * 70)\r\n        {\r\n            funnyticount = 0;\r\n            if(viewsize != 21)\r\n                StatusDrawFace(BJWAITING1PIC + (US_RndT () & 1));\r\n            facecount = 0;\r\n        }\r\n#endif\r\n\r\n        gamestate.TimeCount += tics;\r\n\r\n        UpdateSoundLoc ();      // JAB\r\n        if (screenfaded)\r\n            VW_FadeIn ();\r\n\r\n        CheckKeys ();\r\n\r\n//\r\n// debug aids\r\n//\r\n        if (singlestep)\r\n        {\r\n            VW_WaitVBL (singlestep);\r\n            lasttimecount = GetTimeCount();\r\n        }\r\n        if (extravbls)\r\n            VW_WaitVBL (extravbls);\r\n\r\n        if (demoplayback)\r\n        {\r\n            if (IN_CheckAck ())\r\n            {\r\n                IN_ClearKeysDown ();\r\n                playstate = ex_abort;\r\n            }\r\n        }\r\n    \r\n#ifndef __EMSCRIPTEN__\r\n    } while (!playstate && !startgame);\r\n#else\r\n    if (!playstate && !startgame) {\r\n        emscripten_async_call((void (*)(void *))PlayLoop1, (void *)1, -1);\r\n\r\n        return;\r\n    }\r\n#endif\r\n\r\n    if (playstate != ex_died)\r\n        FinishPaletteShifts ();\r\n} // end jumpto switch\r\n\r\n#ifdef __EMSCRIPTEN__\r\nem_continuation_return();\r\n#endif\r\n}\r\n","// WL_STATE.C\r\n\r\n#include \"wl_def.h\"\r\n#pragma hdrstop\r\n\r\n/*\r\n=============================================================================\r\n\r\n                            LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                            GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\nstatic const dirtype opposite[9] =\r\n    {west,southwest,south,southeast,east,northeast,north,northwest,nodir};\r\n\r\nstatic const dirtype diagonal[9][9] =\r\n{\r\n    /* east */  {nodir,nodir,northeast,nodir,nodir,nodir,southeast,nodir,nodir},\r\n                {nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir},\r\n    /* north */ {northeast,nodir,nodir,nodir,northwest,nodir,nodir,nodir,nodir},\r\n                {nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir},\r\n    /* west */  {nodir,nodir,northwest,nodir,nodir,nodir,southwest,nodir,nodir},\r\n                {nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir},\r\n    /* south */ {southeast,nodir,nodir,nodir,southwest,nodir,nodir,nodir,nodir},\r\n                {nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir},\r\n                {nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir,nodir}\r\n};\r\n\r\n\r\n\r\nvoid    SpawnNewObj (unsigned tilex, unsigned tiley, statetype *state);\r\nvoid    NewState (objtype *ob, statetype *state);\r\n\r\nboolean TryWalk (objtype *ob);\r\nvoid    MoveObj (objtype *ob, int32_t move);\r\n\r\nvoid    KillActor (objtype *ob);\r\nvoid    DamageActor (objtype *ob, unsigned damage);\r\n\r\nboolean CheckLine (objtype *ob);\r\nvoid    FirstSighting (objtype *ob);\r\nboolean CheckSight (objtype *ob);\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n===================\r\n=\r\n= SpawnNewObj\r\n=\r\n= Spaws a new actor at the given TILE coordinates, with the given state, and\r\n= the given size in GLOBAL units.\r\n=\r\n= newobj = a pointer to an initialized new actor\r\n=\r\n===================\r\n*/\r\n\r\nvoid SpawnNewObj (unsigned tilex, unsigned tiley, statetype *state)\r\n{\r\n    GetNewActor ();\r\n    newobj->state = state;\r\n    if (state->tictime)\r\n        newobj->ticcount = DEMOCHOOSE_ORIG_SDL(\r\n                US_RndT () % state->tictime,\r\n                US_RndT () % state->tictime + 1);     // Chris' moonwalk bugfix ;D\r\n    else\r\n        newobj->ticcount = 0;\r\n\r\n    newobj->tilex = (short) tilex;\r\n    newobj->tiley = (short) tiley;\r\n    newobj->x = ((int32_t)tilex<<TILESHIFT)+TILEGLOBAL/2;\r\n    newobj->y = ((int32_t)tiley<<TILESHIFT)+TILEGLOBAL/2;\r\n    newobj->dir = nodir;\r\n\r\n    actorat[tilex][tiley] = newobj;\r\n    newobj->areanumber =\r\n        *(mapsegs[0] + (newobj->tiley<<mapshift)+newobj->tilex) - AREATILE;\r\n}\r\n\r\n\r\n\r\n/*\r\n===================\r\n=\r\n= NewState\r\n=\r\n= Changes ob to a new state, setting ticcount to the max for that state\r\n=\r\n===================\r\n*/\r\n\r\nvoid NewState (objtype *ob, statetype *state)\r\n{\r\n    ob->state = state;\r\n    ob->ticcount = state->tictime;\r\n}\r\n\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n                        ENEMY TILE WORLD MOVEMENT CODE\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n/*\r\n==================================\r\n=\r\n= TryWalk\r\n=\r\n= Attempts to move ob in its current (ob->dir) direction.\r\n=\r\n= If blocked by either a wall or an actor returns FALSE\r\n=\r\n= If move is either clear or blocked only by a door, returns TRUE and sets\r\n=\r\n= ob->tilex         = new destination\r\n= ob->tiley\r\n= ob->areanumber    = the floor tile number (0-(NUMAREAS-1)) of destination\r\n= ob->distance      = TILEGLOBAl, or -doornumber if a door is blocking the way\r\n=\r\n= If a door is in the way, an OpenDoor call is made to start it opening.\r\n= The actor code should wait until\r\n=       doorobjlist[-ob->distance].action = dr_open, meaning the door has been\r\n=       fully opened\r\n=\r\n==================================\r\n*/\r\n\r\n#define CHECKDIAG(x,y)                              \\\r\n{                                                   \\\r\n    temp=(uintptr_t)actorat[x][y];                  \\\r\n    if (temp)                                       \\\r\n    {                                               \\\r\n        if (temp<256)                               \\\r\n            return false;                           \\\r\n        if (((objtype *)temp)->flags&FL_SHOOTABLE)  \\\r\n            return false;                           \\\r\n    }                                               \\\r\n}\r\n\r\n#ifdef PLAYDEMOLIKEORIGINAL\r\n    #define DOORCHECK                                   \\\r\n            if(DEMOCOND_ORIG)                           \\\r\n                doornum = temp&63;                      \\\r\n            else                                        \\\r\n            {                                           \\\r\n                doornum = (int) temp & 127;             \\\r\n                OpenDoor(doornum);                      \\\r\n                ob->distance = -doornum - 1;            \\\r\n                return true;                            \\\r\n            }\r\n#else\r\n    #define DOORCHECK                                   \\\r\n            doornum = (int) temp & 127;                 \\\r\n            OpenDoor(doornum);                          \\\r\n            ob->distance = -doornum - 1;                \\\r\n            return true;\r\n#endif\r\n\r\n#define CHECKSIDE(x,y)                                  \\\r\n{                                                       \\\r\n    temp=(uintptr_t)actorat[x][y];                      \\\r\n    if (temp)                                           \\\r\n    {                                                   \\\r\n        if (temp<128)                                   \\\r\n            return false;                               \\\r\n        if (temp<256)                                   \\\r\n        {                                               \\\r\n            DOORCHECK                                   \\\r\n        }                                               \\\r\n        else if (((objtype *)temp)->flags&FL_SHOOTABLE) \\\r\n            return false;                               \\\r\n    }                                                   \\\r\n}\r\n\r\n\r\nboolean TryWalk (objtype *ob)\r\n{\r\n    int       doornum = -1;\r\n    uintptr_t temp;\r\n\r\n    if (ob->obclass == inertobj)\r\n    {\r\n        switch (ob->dir)\r\n        {\r\n            case north:\r\n                ob->tiley--;\r\n                break;\r\n\r\n            case northeast:\r\n                ob->tilex++;\r\n                ob->tiley--;\r\n                break;\r\n\r\n            case east:\r\n                ob->tilex++;\r\n                break;\r\n\r\n            case southeast:\r\n                ob->tilex++;\r\n                ob->tiley++;\r\n                break;\r\n\r\n            case south:\r\n                ob->tiley++;\r\n                break;\r\n\r\n            case southwest:\r\n                ob->tilex--;\r\n                ob->tiley++;\r\n                break;\r\n\r\n            case west:\r\n                ob->tilex--;\r\n                break;\r\n\r\n            case northwest:\r\n                ob->tilex--;\r\n                ob->tiley--;\r\n                break;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        switch (ob->dir)\r\n        {\r\n            case north:\r\n                if (ob->obclass == dogobj || ob->obclass == fakeobj\r\n                    || ob->obclass == ghostobj || ob->obclass == spectreobj)\r\n                {\r\n                    CHECKDIAG(ob->tilex,ob->tiley-1);\r\n                }\r\n                else\r\n                {\r\n                    CHECKSIDE(ob->tilex,ob->tiley-1);\r\n                }\r\n                ob->tiley--;\r\n                break;\r\n\r\n            case northeast:\r\n                CHECKDIAG(ob->tilex+1,ob->tiley-1);\r\n                CHECKDIAG(ob->tilex+1,ob->tiley);\r\n                CHECKDIAG(ob->tilex,ob->tiley-1);\r\n                ob->tilex++;\r\n                ob->tiley--;\r\n                break;\r\n\r\n            case east:\r\n                if (ob->obclass == dogobj || ob->obclass == fakeobj\r\n                    || ob->obclass == ghostobj || ob->obclass == spectreobj)\r\n                {\r\n                    CHECKDIAG(ob->tilex+1,ob->tiley);\r\n                }\r\n                else\r\n                {\r\n                    CHECKSIDE(ob->tilex+1,ob->tiley);\r\n                }\r\n                ob->tilex++;\r\n                break;\r\n\r\n            case southeast:\r\n                CHECKDIAG(ob->tilex+1,ob->tiley+1);\r\n                CHECKDIAG(ob->tilex+1,ob->tiley);\r\n                CHECKDIAG(ob->tilex,ob->tiley+1);\r\n                ob->tilex++;\r\n                ob->tiley++;\r\n                break;\r\n\r\n            case south:\r\n                if (ob->obclass == dogobj || ob->obclass == fakeobj\r\n                    || ob->obclass == ghostobj || ob->obclass == spectreobj)\r\n                {\r\n                    CHECKDIAG(ob->tilex,ob->tiley+1);\r\n                }\r\n                else\r\n                {\r\n                    CHECKSIDE(ob->tilex,ob->tiley+1);\r\n                }\r\n                ob->tiley++;\r\n                break;\r\n\r\n            case southwest:\r\n                CHECKDIAG(ob->tilex-1,ob->tiley+1);\r\n                CHECKDIAG(ob->tilex-1,ob->tiley);\r\n                CHECKDIAG(ob->tilex,ob->tiley+1);\r\n                ob->tilex--;\r\n                ob->tiley++;\r\n                break;\r\n\r\n            case west:\r\n                if (ob->obclass == dogobj || ob->obclass == fakeobj\r\n                    || ob->obclass == ghostobj || ob->obclass == spectreobj)\r\n                {\r\n                    CHECKDIAG(ob->tilex-1,ob->tiley);\r\n                }\r\n                else\r\n                {\r\n                    CHECKSIDE(ob->tilex-1,ob->tiley);\r\n                }\r\n                ob->tilex--;\r\n                break;\r\n\r\n            case northwest:\r\n                CHECKDIAG(ob->tilex-1,ob->tiley-1);\r\n                CHECKDIAG(ob->tilex-1,ob->tiley);\r\n                CHECKDIAG(ob->tilex,ob->tiley-1);\r\n                ob->tilex--;\r\n                ob->tiley--;\r\n                break;\r\n\r\n            case nodir:\r\n                return false;\r\n\r\n            default:\r\n                Quit (\"Walk: Bad dir\");\r\n        }\r\n    }\r\n\r\n#ifdef PLAYDEMOLIKEORIGINAL\r\n    if (DEMOCOND_ORIG && doornum != -1)\r\n    {\r\n        OpenDoor(doornum);\r\n        ob->distance = -doornum-1;\r\n        return true;\r\n    }\r\n#endif\r\n\r\n    ob->areanumber =\r\n        *(mapsegs[0] + (ob->tiley<<mapshift)+ob->tilex) - AREATILE;\r\n\r\n    ob->distance = TILEGLOBAL;\r\n    return true;\r\n}\r\n\r\n\r\n/*\r\n==================================\r\n=\r\n= SelectDodgeDir\r\n=\r\n= Attempts to choose and initiate a movement for ob that sends it towards\r\n= the player while dodging\r\n=\r\n= If there is no possible move (ob is totally surrounded)\r\n=\r\n= ob->dir           =       nodir\r\n=\r\n= Otherwise\r\n=\r\n= ob->dir           = new direction to follow\r\n= ob->distance      = TILEGLOBAL or -doornumber\r\n= ob->tilex         = new destination\r\n= ob->tiley\r\n= ob->areanumber    = the floor tile number (0-(NUMAREAS-1)) of destination\r\n=\r\n==================================\r\n*/\r\n\r\nvoid SelectDodgeDir (objtype *ob)\r\n{\r\n    int         deltax,deltay,i;\r\n    unsigned    absdx,absdy;\r\n    dirtype     dirtry[5];\r\n    dirtype     turnaround,tdir;\r\n\r\n    if (ob->flags & FL_FIRSTATTACK)\r\n    {\r\n        //\r\n        // turning around is only ok the very first time after noticing the\r\n        // player\r\n        //\r\n        turnaround = nodir;\r\n        ob->flags &= ~FL_FIRSTATTACK;\r\n    }\r\n    else\r\n        turnaround=opposite[ob->dir];\r\n\r\n    deltax = player->tilex - ob->tilex;\r\n    deltay = player->tiley - ob->tiley;\r\n\r\n    //\r\n    // arange 5 direction choices in order of preference\r\n    // the four cardinal directions plus the diagonal straight towards\r\n    // the player\r\n    //\r\n\r\n    if (deltax>0)\r\n    {\r\n        dirtry[1]= east;\r\n        dirtry[3]= west;\r\n    }\r\n    else\r\n    {\r\n        dirtry[1]= west;\r\n        dirtry[3]= east;\r\n    }\r\n\r\n    if (deltay>0)\r\n    {\r\n        dirtry[2]= south;\r\n        dirtry[4]= north;\r\n    }\r\n    else\r\n    {\r\n        dirtry[2]= north;\r\n        dirtry[4]= south;\r\n    }\r\n\r\n    //\r\n    // randomize a bit for dodging\r\n    //\r\n    absdx = abs(deltax);\r\n    absdy = abs(deltay);\r\n\r\n    if (absdx > absdy)\r\n    {\r\n        tdir = dirtry[1];\r\n        dirtry[1] = dirtry[2];\r\n        dirtry[2] = tdir;\r\n        tdir = dirtry[3];\r\n        dirtry[3] = dirtry[4];\r\n        dirtry[4] = tdir;\r\n    }\r\n\r\n    if (US_RndT() < 128)\r\n    {\r\n        tdir = dirtry[1];\r\n        dirtry[1] = dirtry[2];\r\n        dirtry[2] = tdir;\r\n        tdir = dirtry[3];\r\n        dirtry[3] = dirtry[4];\r\n        dirtry[4] = tdir;\r\n    }\r\n\r\n    dirtry[0] = diagonal [ dirtry[1] ] [ dirtry[2] ];\r\n\r\n    //\r\n    // try the directions util one works\r\n    //\r\n    for (i=0;i<5;i++)\r\n    {\r\n        if ( dirtry[i] == nodir || dirtry[i] == turnaround)\r\n            continue;\r\n\r\n        ob->dir = dirtry[i];\r\n        if (TryWalk(ob))\r\n            return;\r\n    }\r\n\r\n    //\r\n    // turn around only as a last resort\r\n    //\r\n    if (turnaround != nodir)\r\n    {\r\n        ob->dir = turnaround;\r\n\r\n        if (TryWalk(ob))\r\n            return;\r\n    }\r\n\r\n    ob->dir = nodir;\r\n}\r\n\r\n\r\n/*\r\n============================\r\n=\r\n= SelectChaseDir\r\n=\r\n= As SelectDodgeDir, but doesn't try to dodge\r\n=\r\n============================\r\n*/\r\n\r\nvoid SelectChaseDir (objtype *ob)\r\n{\r\n    int     deltax,deltay;\r\n    dirtype d[3];\r\n    dirtype tdir, olddir, turnaround;\r\n\r\n\r\n    olddir=ob->dir;\r\n    turnaround=opposite[olddir];\r\n\r\n    deltax=player->tilex - ob->tilex;\r\n    deltay=player->tiley - ob->tiley;\r\n\r\n    d[1]=nodir;\r\n    d[2]=nodir;\r\n\r\n    if (deltax>0)\r\n        d[1]= east;\r\n    else if (deltax<0)\r\n        d[1]= west;\r\n    if (deltay>0)\r\n        d[2]=south;\r\n    else if (deltay<0)\r\n        d[2]=north;\r\n\r\n    if (abs(deltay)>abs(deltax))\r\n    {\r\n        tdir=d[1];\r\n        d[1]=d[2];\r\n        d[2]=tdir;\r\n    }\r\n\r\n    if (d[1]==turnaround)\r\n        d[1]=nodir;\r\n    if (d[2]==turnaround)\r\n        d[2]=nodir;\r\n\r\n\r\n    if (d[1]!=nodir)\r\n    {\r\n        ob->dir=d[1];\r\n        if (TryWalk(ob))\r\n            return;     /*either moved forward or attacked*/\r\n    }\r\n\r\n    if (d[2]!=nodir)\r\n    {\r\n        ob->dir=d[2];\r\n        if (TryWalk(ob))\r\n            return;\r\n    }\r\n\r\n    /* there is no direct path to the player, so pick another direction */\r\n\r\n    if (olddir!=nodir)\r\n    {\r\n        ob->dir=olddir;\r\n        if (TryWalk(ob))\r\n            return;\r\n    }\r\n\r\n    if (US_RndT()>128)      /*randomly determine direction of search*/\r\n    {\r\n        for (tdir=north; tdir<=west; tdir=(dirtype)(tdir+1))\r\n        {\r\n            if (tdir!=turnaround)\r\n            {\r\n                ob->dir=tdir;\r\n                if ( TryWalk(ob) )\r\n                    return;\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        for (tdir=west; tdir>=north; tdir=(dirtype)(tdir-1))\r\n        {\r\n            if (tdir!=turnaround)\r\n            {\r\n                ob->dir=tdir;\r\n                if ( TryWalk(ob) )\r\n                    return;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (turnaround !=  nodir)\r\n    {\r\n        ob->dir=turnaround;\r\n        if (ob->dir != nodir)\r\n        {\r\n            if ( TryWalk(ob) )\r\n                return;\r\n        }\r\n    }\r\n\r\n    ob->dir = nodir;                // can't move\r\n}\r\n\r\n\r\n/*\r\n============================\r\n=\r\n= SelectRunDir\r\n=\r\n= Run Away from player\r\n=\r\n============================\r\n*/\r\n\r\nvoid SelectRunDir (objtype *ob)\r\n{\r\n    int deltax,deltay;\r\n    dirtype d[3];\r\n    dirtype tdir;\r\n\r\n\r\n    deltax=player->tilex - ob->tilex;\r\n    deltay=player->tiley - ob->tiley;\r\n\r\n    if (deltax<0)\r\n        d[1]= east;\r\n    else\r\n        d[1]= west;\r\n    if (deltay<0)\r\n        d[2]=south;\r\n    else\r\n        d[2]=north;\r\n\r\n    if (abs(deltay)>abs(deltax))\r\n    {\r\n        tdir=d[1];\r\n        d[1]=d[2];\r\n        d[2]=tdir;\r\n    }\r\n\r\n    ob->dir=d[1];\r\n    if (TryWalk(ob))\r\n        return;     /*either moved forward or attacked*/\r\n\r\n    ob->dir=d[2];\r\n    if (TryWalk(ob))\r\n        return;\r\n\r\n    /* there is no direct path to the player, so pick another direction */\r\n\r\n    if (US_RndT()>128)      /*randomly determine direction of search*/\r\n    {\r\n        for (tdir=north; tdir<=west; tdir=(dirtype)(tdir+1))\r\n        {\r\n            ob->dir=tdir;\r\n            if ( TryWalk(ob) )\r\n                return;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        for (tdir=west; tdir>=north; tdir=(dirtype)(tdir-1))\r\n        {\r\n            ob->dir=tdir;\r\n            if ( TryWalk(ob) )\r\n                return;\r\n        }\r\n    }\r\n\r\n    ob->dir = nodir;                // can't move\r\n}\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= MoveObj\r\n=\r\n= Moves ob be move global units in ob->dir direction\r\n= Actors are not allowed to move inside the player\r\n= Does NOT check to see if the move is tile map valid\r\n=\r\n= ob->x                 = adjusted for new position\r\n= ob->y\r\n=\r\n=================\r\n*/\r\n\r\nvoid MoveObj (objtype *ob, int32_t move)\r\n{\r\n    int32_t    deltax,deltay;\r\n\r\n    switch (ob->dir)\r\n    {\r\n        case north:\r\n            ob->y -= move;\r\n            break;\r\n        case northeast:\r\n            ob->x += move;\r\n            ob->y -= move;\r\n            break;\r\n        case east:\r\n            ob->x += move;\r\n            break;\r\n        case southeast:\r\n            ob->x += move;\r\n            ob->y += move;\r\n            break;\r\n        case south:\r\n            ob->y += move;\r\n            break;\r\n        case southwest:\r\n            ob->x -= move;\r\n            ob->y += move;\r\n            break;\r\n        case west:\r\n            ob->x -= move;\r\n            break;\r\n        case northwest:\r\n            ob->x -= move;\r\n            ob->y -= move;\r\n            break;\r\n\r\n        case nodir:\r\n            return;\r\n\r\n        default:\r\n            Quit (\"MoveObj: bad dir!\");\r\n    }\r\n\r\n    //\r\n    // check to make sure it's not on top of player\r\n    //\r\n    if (areabyplayer[ob->areanumber])\r\n    {\r\n        deltax = ob->x - player->x;\r\n        if (deltax < -MINACTORDIST || deltax > MINACTORDIST)\r\n            goto moveok;\r\n        deltay = ob->y - player->y;\r\n        if (deltay < -MINACTORDIST || deltay > MINACTORDIST)\r\n            goto moveok;\r\n\r\n        if (ob->hidden)          // move closer until he meets CheckLine\r\n            goto moveok;\r\n\r\n        if (ob->obclass == ghostobj || ob->obclass == spectreobj)\r\n            TakeDamage (tics*2,ob);\r\n\r\n        //\r\n        // back up\r\n        //\r\n        switch (ob->dir)\r\n        {\r\n            case north:\r\n                ob->y += move;\r\n                break;\r\n            case northeast:\r\n                ob->x -= move;\r\n                ob->y += move;\r\n                break;\r\n            case east:\r\n                ob->x -= move;\r\n                break;\r\n            case southeast:\r\n                ob->x -= move;\r\n                ob->y -= move;\r\n                break;\r\n            case south:\r\n                ob->y -= move;\r\n                break;\r\n            case southwest:\r\n                ob->x += move;\r\n                ob->y -= move;\r\n                break;\r\n            case west:\r\n                ob->x += move;\r\n                break;\r\n            case northwest:\r\n                ob->x += move;\r\n                ob->y += move;\r\n                break;\r\n\r\n            case nodir:\r\n                return;\r\n        }\r\n        return;\r\n    }\r\nmoveok:\r\n    ob->distance -=move;\r\n}\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                STUFF\r\n\r\n=============================================================================\r\n*/\r\n\r\n/*\r\n===============\r\n=\r\n= DropItem\r\n=\r\n= Tries to drop a bonus item somewhere in the tiles surrounding the\r\n= given tilex/tiley\r\n=\r\n===============\r\n*/\r\n\r\nvoid DropItem (wl_stat_t itemtype, int tilex, int tiley)\r\n{\r\n    int     x,y,xl,xh,yl,yh;\r\n\r\n    //\r\n    // find a free spot to put it in\r\n    //\r\n    if (!actorat[tilex][tiley])\r\n    {\r\n        PlaceItemType (itemtype, tilex,tiley);\r\n        return;\r\n    }\r\n\r\n    xl = tilex-1;\r\n    xh = tilex+1;\r\n    yl = tiley-1;\r\n    yh = tiley+1;\r\n\r\n    for (x=xl ; x<= xh ; x++)\r\n    {\r\n        for (y=yl ; y<= yh ; y++)\r\n        {\r\n            if (!actorat[x][y])\r\n            {\r\n                PlaceItemType (itemtype, x,y);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= KillActor\r\n=\r\n===============\r\n*/\r\n\r\nvoid KillActor (objtype *ob)\r\n{\r\n    int     tilex,tiley;\r\n\r\n    tilex = ob->tilex = (word)(ob->x >> TILESHIFT);         // drop item on center\r\n    tiley = ob->tiley = (word)(ob->y >> TILESHIFT);\r\n\r\n    switch (ob->obclass)\r\n    {\r\n        case guardobj:\r\n            GivePoints (100);\r\n            NewState (ob,&s_grddie1);\r\n            PlaceItemType (bo_clip2,tilex,tiley);\r\n            break;\r\n\r\n        case officerobj:\r\n            GivePoints (400);\r\n            NewState (ob,&s_ofcdie1);\r\n            PlaceItemType (bo_clip2,tilex,tiley);\r\n            break;\r\n\r\n        case mutantobj:\r\n            GivePoints (700);\r\n            NewState (ob,&s_mutdie1);\r\n            PlaceItemType (bo_clip2,tilex,tiley);\r\n            break;\r\n\r\n        case ssobj:\r\n            GivePoints (500);\r\n            NewState (ob,&s_ssdie1);\r\n            if (gamestate.bestweapon < wp_machinegun)\r\n                PlaceItemType (bo_machinegun,tilex,tiley);\r\n            else\r\n                PlaceItemType (bo_clip2,tilex,tiley);\r\n            break;\r\n\r\n        case dogobj:\r\n            GivePoints (200);\r\n            NewState (ob,&s_dogdie1);\r\n            break;\r\n\r\n#ifndef SPEAR\r\n        case bossobj:\r\n            GivePoints (5000);\r\n            NewState (ob,&s_bossdie1);\r\n            PlaceItemType (bo_key1,tilex,tiley);\r\n            break;\r\n\r\n        case gretelobj:\r\n            GivePoints (5000);\r\n            NewState (ob,&s_greteldie1);\r\n            PlaceItemType (bo_key1,tilex,tiley);\r\n            break;\r\n\r\n        case giftobj:\r\n            GivePoints (5000);\r\n            gamestate.killx = player->x;\r\n            gamestate.killy = player->y;\r\n            NewState (ob,&s_giftdie1);\r\n            break;\r\n\r\n        case fatobj:\r\n            GivePoints (5000);\r\n            gamestate.killx = player->x;\r\n            gamestate.killy = player->y;\r\n            NewState (ob,&s_fatdie1);\r\n            break;\r\n\r\n        case schabbobj:\r\n            GivePoints (5000);\r\n            gamestate.killx = player->x;\r\n            gamestate.killy = player->y;\r\n            NewState (ob,&s_schabbdie1);\r\n            break;\r\n        case fakeobj:\r\n            GivePoints (2000);\r\n            NewState (ob,&s_fakedie1);\r\n            break;\r\n\r\n        case mechahitlerobj:\r\n            GivePoints (5000);\r\n            NewState (ob,&s_mechadie1);\r\n            break;\r\n        case realhitlerobj:\r\n            GivePoints (5000);\r\n            gamestate.killx = player->x;\r\n            gamestate.killy = player->y;\r\n            NewState (ob,&s_hitlerdie1);\r\n            break;\r\n#else\r\n        case spectreobj:\r\n            if (ob->flags&FL_BONUS)\r\n            {\r\n                GivePoints (200);       // Get points once for each\r\n                ob->flags &= ~FL_BONUS;\r\n            }\r\n            NewState (ob,&s_spectredie1);\r\n            break;\r\n\r\n        case angelobj:\r\n            GivePoints (5000);\r\n            NewState (ob,&s_angeldie1);\r\n            break;\r\n\r\n        case transobj:\r\n            GivePoints (5000);\r\n            NewState (ob,&s_transdie0);\r\n            PlaceItemType (bo_key1,tilex,tiley);\r\n            break;\r\n\r\n        case uberobj:\r\n            GivePoints (5000);\r\n            NewState (ob,&s_uberdie0);\r\n            PlaceItemType (bo_key1,tilex,tiley);\r\n            break;\r\n\r\n        case willobj:\r\n            GivePoints (5000);\r\n            NewState (ob,&s_willdie1);\r\n            PlaceItemType (bo_key1,tilex,tiley);\r\n            break;\r\n\r\n        case deathobj:\r\n            GivePoints (5000);\r\n            NewState (ob,&s_deathdie1);\r\n            PlaceItemType (bo_key1,tilex,tiley);\r\n            break;\r\n#endif\r\n    }\r\n\r\n    gamestate.killcount++;\r\n    ob->flags &= ~FL_SHOOTABLE;\r\n    actorat[ob->tilex][ob->tiley] = NULL;\r\n    ob->flags |= FL_NONMARK;\r\n}\r\n\r\n\r\n\r\n/*\r\n===================\r\n=\r\n= DamageActor\r\n=\r\n= Called when the player succesfully hits an enemy.\r\n=\r\n= Does damage points to enemy ob, either putting it into a stun frame or\r\n= killing it.\r\n=\r\n===================\r\n*/\r\n\r\nvoid DamageActor (objtype *ob, unsigned damage)\r\n{\r\n    madenoise = true;\r\n\r\n    //\r\n    // do double damage if shooting a non attack mode actor\r\n    //\r\n    if ( !(ob->flags & FL_ATTACKMODE) )\r\n        damage <<= 1;\r\n\r\n    ob->hitpoints -= (short)damage;\r\n\r\n    if (ob->hitpoints<=0)\r\n        KillActor (ob);\r\n    else\r\n    {\r\n        if (! (ob->flags & FL_ATTACKMODE) )\r\n            FirstSighting (ob);             // put into combat mode\r\n\r\n        switch (ob->obclass)                // dogs only have one hit point\r\n        {\r\n            case guardobj:\r\n                if (ob->hitpoints&1)\r\n                    NewState (ob,&s_grdpain);\r\n                else\r\n                    NewState (ob,&s_grdpain1);\r\n                break;\r\n\r\n            case officerobj:\r\n                if (ob->hitpoints&1)\r\n                    NewState (ob,&s_ofcpain);\r\n                else\r\n                    NewState (ob,&s_ofcpain1);\r\n                break;\r\n\r\n            case mutantobj:\r\n                if (ob->hitpoints&1)\r\n                    NewState (ob,&s_mutpain);\r\n                else\r\n                    NewState (ob,&s_mutpain1);\r\n                break;\r\n\r\n            case ssobj:\r\n                if (ob->hitpoints&1)\r\n                    NewState (ob,&s_sspain);\r\n                else\r\n                    NewState (ob,&s_sspain1);\r\n\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                CHECKSIGHT\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= CheckLine\r\n=\r\n= Returns true if a straight line between the player and ob is unobstructed\r\n=\r\n=====================\r\n*/\r\n\r\nboolean CheckLine (objtype *ob)\r\n{\r\n    int         x1,y1,xt1,yt1,x2,y2,xt2,yt2;\r\n    int         x,y;\r\n    int         xdist,ydist,xstep,ystep;\r\n    int         partial,delta;\r\n    int32_t     ltemp;\r\n    int         xfrac,yfrac,deltafrac;\r\n    unsigned    value,intercept;\r\n\r\n    x1 = ob->x >> UNSIGNEDSHIFT;            // 1/256 tile precision\r\n    y1 = ob->y >> UNSIGNEDSHIFT;\r\n    xt1 = x1 >> 8;\r\n    yt1 = y1 >> 8;\r\n\r\n    x2 = plux;\r\n    y2 = pluy;\r\n    xt2 = player->tilex;\r\n    yt2 = player->tiley;\r\n\r\n    xdist = abs(xt2-xt1);\r\n\r\n    if (xdist > 0)\r\n    {\r\n        if (xt2 > xt1)\r\n        {\r\n            partial = 256-(x1&0xff);\r\n            xstep = 1;\r\n        }\r\n        else\r\n        {\r\n            partial = x1&0xff;\r\n            xstep = -1;\r\n        }\r\n\r\n        deltafrac = abs(x2-x1);\r\n        delta = y2-y1;\r\n        ltemp = ((int32_t)delta<<8)/deltafrac;\r\n        if (ltemp > 0x7fffl)\r\n            ystep = 0x7fff;\r\n        else if (ltemp < -0x7fffl)\r\n            ystep = -0x7fff;\r\n        else\r\n            ystep = ltemp;\r\n        yfrac = y1 + (((int32_t)ystep*partial) >>8);\r\n\r\n        x = xt1+xstep;\r\n        xt2 += xstep;\r\n        do\r\n        {\r\n            y = yfrac>>8;\r\n            yfrac += ystep;\r\n\r\n            value = (unsigned)tilemap[x][y];\r\n            x += xstep;\r\n\r\n            if (!value)\r\n                continue;\r\n\r\n            if (value<128 || value>256)\r\n                return false;\r\n\r\n            //\r\n            // see if the door is open enough\r\n            //\r\n            value &= ~0x80;\r\n            intercept = yfrac-ystep/2;\r\n\r\n            if (intercept>doorposition[value])\r\n                return false;\r\n\r\n        } while (x != xt2);\r\n    }\r\n\r\n    ydist = abs(yt2-yt1);\r\n\r\n    if (ydist > 0)\r\n    {\r\n        if (yt2 > yt1)\r\n        {\r\n            partial = 256-(y1&0xff);\r\n            ystep = 1;\r\n        }\r\n        else\r\n        {\r\n            partial = y1&0xff;\r\n            ystep = -1;\r\n        }\r\n\r\n        deltafrac = abs(y2-y1);\r\n        delta = x2-x1;\r\n        ltemp = ((int32_t)delta<<8)/deltafrac;\r\n        if (ltemp > 0x7fffl)\r\n            xstep = 0x7fff;\r\n        else if (ltemp < -0x7fffl)\r\n            xstep = -0x7fff;\r\n        else\r\n            xstep = ltemp;\r\n        xfrac = x1 + (((int32_t)xstep*partial) >>8);\r\n\r\n        y = yt1 + ystep;\r\n        yt2 += ystep;\r\n        do\r\n        {\r\n            x = xfrac>>8;\r\n            xfrac += xstep;\r\n\r\n            value = (unsigned)tilemap[x][y];\r\n            y += ystep;\r\n\r\n            if (!value)\r\n                continue;\r\n\r\n            if (value<128 || value>256)\r\n                return false;\r\n\r\n            //\r\n            // see if the door is open enough\r\n            //\r\n            value &= ~0x80;\r\n            intercept = xfrac-xstep/2;\r\n\r\n            if (intercept>doorposition[value])\r\n                return false;\r\n        } while (y != yt2);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n/*\r\n================\r\n=\r\n= CheckSight\r\n=\r\n= Checks a straight line between player and current object\r\n=\r\n= If the sight is ok, check alertness and angle to see if they notice\r\n=\r\n= returns true if the player has been spoted\r\n=\r\n================\r\n*/\r\n\r\n#define MINSIGHT        0x18000l\r\n\r\nboolean CheckSight (objtype *ob)\r\n{\r\n    int32_t deltax,deltay;\r\n\r\n    //\r\n    // don't bother tracing a line if the area isn't connected to the player's\r\n    //\r\n    if (!areabyplayer[ob->areanumber])\r\n        return false;\r\n\r\n    //\r\n    // if the player is real close, sight is automatic\r\n    //\r\n    deltax = player->x - ob->x;\r\n    deltay = player->y - ob->y;\r\n\r\n    if (deltax > -MINSIGHT && deltax < MINSIGHT\r\n        && deltay > -MINSIGHT && deltay < MINSIGHT)\r\n        return true;\r\n\r\n    //\r\n    // see if they are looking in the right direction\r\n    //\r\n    switch (ob->dir)\r\n    {\r\n        case north:\r\n            if (deltay > 0)\r\n                return false;\r\n            break;\r\n\r\n        case east:\r\n            if (deltax < 0)\r\n                return false;\r\n            break;\r\n\r\n        case south:\r\n            if (deltay < 0)\r\n                return false;\r\n            break;\r\n\r\n        case west:\r\n            if (deltax > 0)\r\n                return false;\r\n            break;\r\n\r\n        // check diagonal moving guards fix\r\n\r\n        case northwest:\r\n            if (DEMOCOND_SDL && deltay > -deltax)\r\n                return false;\r\n            break;\r\n\r\n        case northeast:\r\n            if (DEMOCOND_SDL && deltay > deltax)\r\n                return false;\r\n            break;\r\n\r\n        case southwest:\r\n            if (DEMOCOND_SDL && deltax > deltay)\r\n                return false;\r\n            break;\r\n\r\n        case southeast:\r\n            if (DEMOCOND_SDL && -deltax > deltay)\r\n                return false;\r\n            break;\r\n    }\r\n\r\n    //\r\n    // trace a line to check for blocking tiles (corners)\r\n    //\r\n    return CheckLine (ob);\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= FirstSighting\r\n=\r\n= Puts an actor into attack mode and possibly reverses the direction\r\n= if the player is behind it\r\n=\r\n===============\r\n*/\r\n\r\nvoid FirstSighting (objtype *ob)\r\n{\r\n    //\r\n    // react to the player\r\n    //\r\n    switch (ob->obclass)\r\n    {\r\n        case guardobj:\r\n            PlaySoundLocActor(HALTSND,ob);\r\n            NewState (ob,&s_grdchase1);\r\n            ob->speed *= 3;                 // go faster when chasing player\r\n            break;\r\n\r\n        case officerobj:\r\n            PlaySoundLocActor(SPIONSND,ob);\r\n            NewState (ob,&s_ofcchase1);\r\n            ob->speed *= 5;                 // go faster when chasing player\r\n            break;\r\n\r\n        case mutantobj:\r\n            NewState (ob,&s_mutchase1);\r\n            ob->speed *= 3;                 // go faster when chasing player\r\n            break;\r\n\r\n        case ssobj:\r\n            PlaySoundLocActor(SCHUTZADSND,ob);\r\n            NewState (ob,&s_sschase1);\r\n            ob->speed *= 4;                 // go faster when chasing player\r\n            break;\r\n\r\n        case dogobj:\r\n            PlaySoundLocActor(DOGBARKSND,ob);\r\n            NewState (ob,&s_dogchase1);\r\n            ob->speed *= 2;                 // go faster when chasing player\r\n            break;\r\n\r\n#ifndef SPEAR\r\n        case bossobj:\r\n            SD_PlaySound(GUTENTAGSND);\r\n            NewState (ob,&s_bosschase1);\r\n            ob->speed = SPDPATROL*3;        // go faster when chasing player\r\n            break;\r\n\r\n#ifndef APOGEE_1_0\r\n        case gretelobj:\r\n            SD_PlaySound(KEINSND);\r\n            NewState (ob,&s_gretelchase1);\r\n            ob->speed *= 3;                 // go faster when chasing player\r\n            break;\r\n\r\n        case giftobj:\r\n            SD_PlaySound(EINESND);\r\n            NewState (ob,&s_giftchase1);\r\n            ob->speed *= 3;                 // go faster when chasing player\r\n            break;\r\n\r\n        case fatobj:\r\n            SD_PlaySound(ERLAUBENSND);\r\n            NewState (ob,&s_fatchase1);\r\n            ob->speed *= 3;                 // go faster when chasing player\r\n            break;\r\n#endif\r\n\r\n        case schabbobj:\r\n            SD_PlaySound(SCHABBSHASND);\r\n            NewState (ob,&s_schabbchase1);\r\n            ob->speed *= 3;                 // go faster when chasing player\r\n            break;\r\n\r\n        case fakeobj:\r\n            SD_PlaySound(TOT_HUNDSND);\r\n            NewState (ob,&s_fakechase1);\r\n            ob->speed *= 3;                 // go faster when chasing player\r\n            break;\r\n\r\n        case mechahitlerobj:\r\n            SD_PlaySound(DIESND);\r\n            NewState (ob,&s_mechachase1);\r\n            ob->speed *= 3;                 // go faster when chasing player\r\n            break;\r\n\r\n        case realhitlerobj:\r\n            SD_PlaySound(DIESND);\r\n            NewState (ob,&s_hitlerchase1);\r\n            ob->speed *= 5;                 // go faster when chasing player\r\n            break;\r\n\r\n        case ghostobj:\r\n            NewState (ob,&s_blinkychase1);\r\n            ob->speed *= 2;                 // go faster when chasing player\r\n            break;\r\n#else\r\n        case spectreobj:\r\n            SD_PlaySound(GHOSTSIGHTSND);\r\n            NewState (ob,&s_spectrechase1);\r\n            ob->speed = 800;                        // go faster when chasing player\r\n            break;\r\n\r\n        case angelobj:\r\n            SD_PlaySound(ANGELSIGHTSND);\r\n            NewState (ob,&s_angelchase1);\r\n            ob->speed = 1536;                       // go faster when chasing player\r\n            break;\r\n\r\n        case transobj:\r\n            SD_PlaySound(TRANSSIGHTSND);\r\n            NewState (ob,&s_transchase1);\r\n            ob->speed = 1536;                       // go faster when chasing player\r\n            break;\r\n\r\n        case uberobj:\r\n            NewState (ob,&s_uberchase1);\r\n            ob->speed = 3000;                       // go faster when chasing player\r\n            break;\r\n\r\n        case willobj:\r\n            SD_PlaySound(WILHELMSIGHTSND);\r\n            NewState (ob,&s_willchase1);\r\n            ob->speed = 2048;                       // go faster when chasing player\r\n            break;\r\n\r\n        case deathobj:\r\n            SD_PlaySound(KNIGHTSIGHTSND);\r\n            NewState (ob,&s_deathchase1);\r\n            ob->speed = 2048;                       // go faster when chasing player\r\n            break;\r\n#endif\r\n    }\r\n\r\n    if (ob->distance < 0)\r\n        ob->distance = 0;       // ignore the door opening command\r\n\r\n    ob->flags |= FL_ATTACKMODE|FL_FIRSTATTACK;\r\n}\r\n\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= SightPlayer\r\n=\r\n= Called by actors that ARE NOT chasing the player.  If the player\r\n= is detected (by sight, noise, or proximity), the actor is put into\r\n= it's combat frame and true is returned.\r\n=\r\n= Incorporates a random reaction delay\r\n=\r\n===============\r\n*/\r\n\r\nboolean SightPlayer (objtype *ob)\r\n{\r\n    if (ob->flags & FL_ATTACKMODE)\r\n        Quit (\"An actor in ATTACKMODE called SightPlayer!\");\r\n\r\n    if (ob->temp2)\r\n    {\r\n        //\r\n        // count down reaction time\r\n        //\r\n        ob->temp2 -= (short) tics;\r\n        if (ob->temp2 > 0)\r\n            return false;\r\n        ob->temp2 = 0;                                  // time to react\r\n    }\r\n    else\r\n    {\r\n        if (!areabyplayer[ob->areanumber])\r\n            return false;\r\n\r\n        if (ob->flags & FL_AMBUSH)\r\n        {\r\n            if (!CheckSight (ob))\r\n                return false;\r\n            ob->flags &= ~FL_AMBUSH;\r\n        }\r\n        else\r\n        {\r\n            if (!madenoise && !CheckSight (ob))\r\n                return false;\r\n        }\r\n\r\n\r\n        switch (ob->obclass)\r\n        {\r\n            case guardobj:\r\n                ob->temp2 = 1+US_RndT()/4;\r\n                break;\r\n            case officerobj:\r\n                ob->temp2 = 2;\r\n                break;\r\n            case mutantobj:\r\n                ob->temp2 = 1+US_RndT()/6;\r\n                break;\r\n            case ssobj:\r\n                ob->temp2 = 1+US_RndT()/6;\r\n                break;\r\n            case dogobj:\r\n                ob->temp2 = 1+US_RndT()/8;\r\n                break;\r\n\r\n            case bossobj:\r\n            case schabbobj:\r\n            case fakeobj:\r\n            case mechahitlerobj:\r\n            case realhitlerobj:\r\n            case gretelobj:\r\n            case giftobj:\r\n            case fatobj:\r\n            case spectreobj:\r\n            case angelobj:\r\n            case transobj:\r\n            case uberobj:\r\n            case willobj:\r\n            case deathobj:\r\n                ob->temp2 = 1;\r\n                break;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    FirstSighting (ob);\r\n\r\n    return true;\r\n}\r\n","// WL_TEXT.C\r\n\r\n#include \"wl_def.h\"\r\n#pragma hdrstop\r\n\r\n/*\r\n=============================================================================\r\n\r\nTEXT FORMATTING COMMANDS\r\n------------------------\r\n^C<hex digit>           Change text color\r\n^E[enter]               End of layout (all pages)\r\n^G<y>,<x>,<pic>[enter]  Draw a graphic and push margins\r\n^P[enter]               start new page, must be the first chars in a layout\r\n^L<x>,<y>[ENTER]        Locate to a specific spot, x in pixels, y in lines\r\n\r\n=============================================================================\r\n*/\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                                 LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n#ifndef SPEAR\r\n\r\n#define BACKCOLOR       0x11\r\n\r\n\r\n#define WORDLIMIT       80\r\n#define FONTHEIGHT      10\r\n#define TOPMARGIN       16\r\n#define BOTTOMMARGIN    32\r\n#define LEFTMARGIN      16\r\n#define RIGHTMARGIN     16\r\n#define PICMARGIN       8\r\n#define TEXTROWS        ((200-TOPMARGIN-BOTTOMMARGIN)/FONTHEIGHT)\r\n#define SPACEWIDTH      7\r\n#define SCREENPIXWIDTH  320\r\n#define SCREENMID       (SCREENPIXWIDTH/2)\r\n\r\n/*\r\n=============================================================================\r\n\r\n                                LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nstatic int pagenum;\r\nstatic int numpages;\r\n\r\nstatic unsigned leftmargin[TEXTROWS];\r\nstatic unsigned rightmargin[TEXTROWS];\r\nstatic char*    text;\r\nstatic unsigned rowon;\r\n\r\nstatic int     picx;\r\nstatic int     picy;\r\nstatic int     picnum;\r\nstatic int     picdelay;\r\nstatic boolean layoutdone;\r\n\r\n//===========================================================================\r\n\r\n#ifndef JAPAN\r\n/*\r\n=====================\r\n=\r\n= RipToEOL\r\n=\r\n=====================\r\n*/\r\n\r\nvoid RipToEOL (void)\r\n{\r\n    while (*text++ != '\\n')         // scan to end of line\r\n        ;\r\n}\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= ParseNumber\r\n=\r\n=====================\r\n*/\r\n\r\nint ParseNumber (void)\r\n{\r\n    char  ch;\r\n    char  num[80];\r\n    char *numptr;\r\n\r\n    //\r\n    // scan until a number is found\r\n    //\r\n    ch = *text;\r\n    while (ch < '0' || ch >'9')\r\n        ch = *++text;\r\n\r\n    //\r\n    // copy the number out\r\n    //\r\n    numptr = num;\r\n    do\r\n    {\r\n        *numptr++ = ch;\r\n        ch = *++text;\r\n    } while (ch >= '0' && ch <= '9');\r\n    *numptr = 0;\r\n\r\n    return atoi (num);\r\n}\r\n\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= ParsePicCommand\r\n=\r\n= Call with text pointing just after a ^P\r\n= Upon exit text points to the start of next line\r\n=\r\n=====================\r\n*/\r\n\r\nvoid ParsePicCommand (void)\r\n{\r\n    picy=ParseNumber();\r\n    picx=ParseNumber();\r\n    picnum=ParseNumber();\r\n    RipToEOL ();\r\n}\r\n\r\n\r\nvoid ParseTimedCommand (void)\r\n{\r\n    picy=ParseNumber();\r\n    picx=ParseNumber();\r\n    picnum=ParseNumber();\r\n    picdelay=ParseNumber();\r\n    RipToEOL ();\r\n}\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= TimedPicCommand\r\n=\r\n= Call with text pointing just after a ^P\r\n= Upon exit text points to the start of next line\r\n=\r\n=====================\r\n*/\r\n\r\nvoid TimedPicCommand (void)\r\n{\r\n    ParseTimedCommand ();\r\n\r\n    //\r\n    // update the screen, and wait for time delay\r\n    //\r\n    VW_UpdateScreen ();\r\n\r\n    //\r\n    // wait for time\r\n    //\r\n    Delay(picdelay);\r\n\r\n    //\r\n    // draw pic\r\n    //\r\n    VWB_DrawPic (picx&~7,picy,picnum);\r\n}\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= HandleCommand\r\n=\r\n=====================\r\n*/\r\n\r\nvoid HandleCommand (void)\r\n{\r\n    int     i,margin,top,bottom;\r\n    int     picwidth,picheight,picmid;\r\n\r\n    switch (toupper(*++text))\r\n    {\r\n        case 'B':\r\n            picy=ParseNumber();\r\n            picx=ParseNumber();\r\n            picwidth=ParseNumber();\r\n            picheight=ParseNumber();\r\n            VWB_Bar(picx,picy,picwidth,picheight,BACKCOLOR);\r\n            RipToEOL();\r\n            break;\r\n        case ';':               // comment\r\n            RipToEOL();\r\n            break;\r\n        case 'P':               // ^P is start of next page, ^E is end of file\r\n        case 'E':\r\n            layoutdone = true;\r\n            text--;             // back up to the '^'\r\n            break;\r\n\r\n        case 'C':               // ^c<hex digit> changes text color\r\n            i = toupper(*++text);\r\n            if (i>='0' && i<='9')\r\n                fontcolor = i-'0';\r\n            else if (i>='A' && i<='F')\r\n                fontcolor = i-'A'+10;\r\n\r\n            fontcolor *= 16;\r\n            i = toupper(*++text);\r\n            if (i>='0' && i<='9')\r\n                fontcolor += i-'0';\r\n            else if (i>='A' && i<='F')\r\n                fontcolor += i-'A'+10;\r\n            text++;\r\n            break;\r\n\r\n        case '>':\r\n            px = 160;\r\n            text++;\r\n            break;\r\n\r\n        case 'L':\r\n            py=ParseNumber();\r\n            rowon = (py-TOPMARGIN)/FONTHEIGHT;\r\n            py = TOPMARGIN+rowon*FONTHEIGHT;\r\n            px=ParseNumber();\r\n            while (*text++ != '\\n')         // scan to end of line\r\n                ;\r\n            break;\r\n\r\n        case 'T':               // ^Tyyy,xxx,ppp,ttt waits ttt tics, then draws pic\r\n            TimedPicCommand ();\r\n            break;\r\n\r\n        case 'G':               // ^Gyyy,xxx,ppp draws graphic\r\n            ParsePicCommand ();\r\n            VWB_DrawPic (picx&~7,picy,picnum);\r\n            picwidth = pictable[picnum-STARTPICS].width;\r\n            picheight = pictable[picnum-STARTPICS].height;\r\n            //\r\n            // adjust margins\r\n            //\r\n            picmid = picx + picwidth/2;\r\n            if (picmid > SCREENMID)\r\n                margin = picx-PICMARGIN;                        // new right margin\r\n            else\r\n                margin = picx+picwidth+PICMARGIN;       // new left margin\r\n\r\n            top = (picy-TOPMARGIN)/FONTHEIGHT;\r\n            if (top<0)\r\n                top = 0;\r\n            bottom = (picy+picheight-TOPMARGIN)/FONTHEIGHT;\r\n            if (bottom>=TEXTROWS)\r\n                bottom = TEXTROWS-1;\r\n\r\n            for (i=top;i<=bottom;i++)\r\n                if (picmid > SCREENMID)\r\n                    rightmargin[i] = margin;\r\n                else\r\n                    leftmargin[i] = margin;\r\n\r\n            //\r\n            // adjust this line if needed\r\n            //\r\n            if (px < (int) leftmargin[rowon])\r\n                px = leftmargin[rowon];\r\n            break;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= NewLine\r\n=\r\n=====================\r\n*/\r\n\r\nvoid NewLine (void)\r\n{\r\n    char    ch;\r\n\r\n    if (++rowon == TEXTROWS)\r\n    {\r\n        //\r\n        // overflowed the page, so skip until next page break\r\n        //\r\n        layoutdone = true;\r\n        do\r\n        {\r\n            if (*text == '^')\r\n            {\r\n                ch = toupper(*(text+1));\r\n                if (ch == 'E' || ch == 'P')\r\n                {\r\n                    layoutdone = true;\r\n                    return;\r\n                }\r\n            }\r\n            text++;\r\n        } while (1);\r\n    }\r\n    px = leftmargin[rowon];\r\n    py+= FONTHEIGHT;\r\n}\r\n\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= HandleCtrls\r\n=\r\n=====================\r\n*/\r\n\r\nvoid HandleCtrls (void)\r\n{\r\n    char    ch;\r\n\r\n    ch = *text++;                   // get the character and advance\r\n\r\n    if (ch == '\\n')\r\n    {\r\n        NewLine ();\r\n        return;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= HandleWord\r\n=\r\n=====================\r\n*/\r\n\r\nvoid HandleWord (void)\r\n{\r\n    char    wword[WORDLIMIT];\r\n    int     wordindex;\r\n    word    wwidth,wheight,newpos;\r\n\r\n\r\n    //\r\n    // copy the next word into [word]\r\n    //\r\n    wword[0] = *text++;\r\n    wordindex = 1;\r\n    while (*text>32)\r\n    {\r\n        wword[wordindex] = *text++;\r\n        if (++wordindex == WORDLIMIT)\r\n            Quit (\"PageLayout: Word limit exceeded\");\r\n    }\r\n    wword[wordindex] = 0;            // stick a null at end for C\r\n\r\n    //\r\n    // see if it fits on this line\r\n    //\r\n    VW_MeasurePropString (wword,&wwidth,&wheight);\r\n\r\n    while (px+wwidth > (int) rightmargin[rowon])\r\n    {\r\n        NewLine ();\r\n        if (layoutdone)\r\n            return;         // overflowed page\r\n    }\r\n\r\n    //\r\n    // print it\r\n    //\r\n    newpos = px+wwidth;\r\n    VWB_DrawPropString (wword);\r\n    px = newpos;\r\n\r\n    //\r\n    // suck up any extra spaces\r\n    //\r\n    while (*text == ' ')\r\n    {\r\n        px += SPACEWIDTH;\r\n        text++;\r\n    }\r\n}\r\n\r\n/*\r\n=====================\r\n=\r\n= PageLayout\r\n=\r\n= Clears the screen, draws the pics on the page, and word wraps the text.\r\n= Returns a pointer to the terminating command\r\n=\r\n=====================\r\n*/\r\n\r\nvoid PageLayout (boolean shownumber)\r\n{\r\n    int     i,oldfontcolor;\r\n    char    ch;\r\n\r\n    oldfontcolor = fontcolor;\r\n\r\n    fontcolor = 0;\r\n\r\n    //\r\n    // clear the screen\r\n    //\r\n    VWB_Bar (0,0,320,200,BACKCOLOR);\r\n    VWB_DrawPic (0,0,H_TOPWINDOWPIC);\r\n    VWB_DrawPic (0,8,H_LEFTWINDOWPIC);\r\n    VWB_DrawPic (312,8,H_RIGHTWINDOWPIC);\r\n    VWB_DrawPic (8,176,H_BOTTOMINFOPIC);\r\n\r\n\r\n    for (i=0; i<TEXTROWS; i++)\r\n    {\r\n        leftmargin[i] = LEFTMARGIN;\r\n        rightmargin[i] = SCREENPIXWIDTH-RIGHTMARGIN;\r\n    }\r\n\r\n    px = LEFTMARGIN;\r\n    py = TOPMARGIN;\r\n    rowon = 0;\r\n    layoutdone = false;\r\n\r\n    //\r\n    // make sure we are starting layout text (^P first command)\r\n    //\r\n    while (*text <= 32)\r\n        text++;\r\n\r\n    if (*text != '^' || toupper(*++text) != 'P')\r\n        Quit (\"PageLayout: Text not headed with ^P\");\r\n\r\n    while (*text++ != '\\n')\r\n        ;\r\n\r\n\r\n    //\r\n    // process text stream\r\n    //\r\n    do\r\n    {\r\n        ch = *text;\r\n\r\n        if (ch == '^')\r\n            HandleCommand ();\r\n        else\r\n            if (ch == 9)\r\n            {\r\n                px = (px+8)&0xf8;\r\n                text++;\r\n            }\r\n            else if (ch <= 32)\r\n                HandleCtrls ();\r\n            else\r\n                HandleWord ();\r\n\r\n    } while (!layoutdone);\r\n\r\n    pagenum++;\r\n\r\n    if (shownumber)\r\n    {\r\n#ifdef SPANISH\r\n        sprintf(str, \"Hoja %d de %d\", pagenum, numpages);\r\n        px = 208;\r\n#else\r\n        sprintf(str, \"pg %d of %d\", pagenum, numpages);\r\n        px = 213;\r\n#endif\r\n        py = 183;\r\n        fontcolor = 0x4f;                          //12^BACKCOLOR;\r\n\r\n        VWB_DrawPropString (str);\r\n    }\r\n\r\n    fontcolor = oldfontcolor;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= BackPage\r\n=\r\n= Scans for a previous ^P\r\n=\r\n=====================\r\n*/\r\n\r\nvoid BackPage (void)\r\n{\r\n    pagenum--;\r\n    do\r\n    {\r\n        text--;\r\n        if (*text == '^' && toupper(*(text+1)) == 'P')\r\n            return;\r\n    } while (1);\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= CacheLayoutGraphics\r\n=\r\n= Scans an entire layout file (until a ^E) marking all graphics used, and\r\n= counting pages, then caches the graphics in\r\n=\r\n=====================\r\n*/\r\nvoid CacheLayoutGraphics (void)\r\n{\r\n    char    *bombpoint, *textstart;\r\n    char    ch;\r\n\r\n    textstart = text;\r\n    bombpoint = text+30000;\r\n    numpages = pagenum = 0;\r\n\r\n    do\r\n    {\r\n        if (*text == '^')\r\n        {\r\n            ch = toupper(*++text);\r\n            if (ch == 'P')          // start of a page\r\n                numpages++;\r\n            if (ch == 'E')          // end of file, so load graphics and return\r\n            {\r\n#ifndef SPEAR\r\n                CA_CacheGrChunk(H_TOPWINDOWPIC);\r\n                CA_CacheGrChunk(H_LEFTWINDOWPIC);\r\n                CA_CacheGrChunk(H_RIGHTWINDOWPIC);\r\n                CA_CacheGrChunk(H_BOTTOMINFOPIC);\r\n#endif\r\n                //                              CA_CacheMarks ();\r\n                text = textstart;\r\n                return;\r\n            }\r\n            if (ch == 'G')          // draw graphic command, so mark graphics\r\n            {\r\n                ParsePicCommand ();\r\n                CA_CacheGrChunk (picnum);\r\n            }\r\n            if (ch == 'T')          // timed draw graphic command, so mark graphics\r\n            {\r\n                ParseTimedCommand ();\r\n                CA_CacheGrChunk (picnum);\r\n            }\r\n        }\r\n        else\r\n            text++;\r\n\r\n    } while (text<bombpoint);\r\n\r\n    Quit (\"CacheLayoutGraphics: No ^E to terminate file!\");\r\n}\r\n#endif\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= ShowArticle\r\n=\r\n=====================\r\n*/\r\n\r\n#ifdef JAPAN\r\nvoid ShowArticle (int which)\r\n#else\r\nvoid ShowArticle (char *article)\r\n#endif\r\n{\r\n#ifdef JAPAN\r\n    int snames[10] = {\r\n        H_HELP1PIC,\r\n        H_HELP2PIC,\r\n        H_HELP3PIC,\r\n        H_HELP4PIC,\r\n        H_HELP5PIC,\r\n        H_HELP6PIC,\r\n        H_HELP7PIC,\r\n        H_HELP8PIC,\r\n        H_HELP9PIC,\r\n        H_HELP10PIC};\r\n    int enames[14] = {\r\n        0,0,\r\n#ifndef JAPDEMO\r\n        C_ENDGAME1APIC,\r\n        C_ENDGAME1BPIC,\r\n        C_ENDGAME2APIC,\r\n        C_ENDGAME2BPIC,\r\n        C_ENDGAME3APIC,\r\n        C_ENDGAME3BPIC,\r\n        C_ENDGAME4APIC,\r\n        C_ENDGAME4BPIC,\r\n        C_ENDGAME5APIC,\r\n        C_ENDGAME5BPIC,\r\n        C_ENDGAME6APIC,\r\n        C_ENDGAME6BPIC\r\n#endif\r\n    };\r\n#endif\r\n    unsigned    oldfontnumber;\r\n    boolean     newpage,firstpage;\r\n    ControlInfo ci;\r\n\r\n#ifdef JAPAN\r\n    pagenum = 1;\r\n    if (!which)\r\n        numpages = 10;\r\n    else\r\n        numpages = 2;\r\n#else\r\n    text = article;\r\n    oldfontnumber = fontnumber;\r\n    fontnumber = 0;\r\n    CA_CacheGrChunk(STARTFONT);\r\n    VWB_Bar (0,0,320,200,BACKCOLOR);\r\n    CacheLayoutGraphics ();\r\n#endif\r\n\r\n    newpage = true;\r\n    firstpage = true;\r\n\r\n    do\r\n    {\r\n        if (newpage)\r\n        {\r\n            newpage = false;\r\n#ifdef JAPAN\r\n            if (!which)\r\n                CA_CacheScreen(snames[pagenum - 1]);\r\n            else\r\n                CA_CacheScreen(enames[which*2 + pagenum - 1]);\r\n#else\r\n            PageLayout (true);\r\n#endif\r\n            VW_UpdateScreen ();\r\n            if (firstpage)\r\n            {\r\n                VL_FadeIn(0,255,gamepal,10);\r\n                firstpage = false;\r\n            }\r\n        }\r\n        SDL_Delay(5);\r\n\r\n        LastScan = 0;\r\n        ReadAnyControl(&ci);\r\n        Direction dir = ci.dir;\r\n        switch(dir)\r\n        {\r\n            case dir_North:\r\n            case dir_South:\r\n                break;\r\n\r\n            default:\r\n                if(ci.button0) dir = dir_South;\r\n                switch(LastScan)\r\n                {\r\n                    case sc_UpArrow:\r\n                    case sc_PgUp:\r\n                    case sc_LeftArrow:\r\n                        dir = dir_North;\r\n                        break;\r\n\r\n                    case sc_Enter:\r\n                    case sc_DownArrow:\r\n                    case sc_PgDn:\r\n                    case sc_RightArrow:\r\n                        dir = dir_South;\r\n                        break;\r\n                }\r\n                break;\r\n        }\r\n\r\n        switch(dir)\r\n        {\r\n            case dir_North:\r\n            case dir_West:\r\n                if (pagenum>1)\r\n                {\r\n#ifndef JAPAN\r\n                    BackPage ();\r\n                    BackPage ();\r\n#else\r\n                  pagenum--;\r\n#endif\r\n                    newpage = true;\r\n                }\r\n                TicDelay(20);\r\n                break;\r\n\r\n            case dir_South:\r\n            case dir_East:\r\n                if (pagenum<numpages)\r\n                {\r\n                    newpage = true;\r\n#ifdef JAPAN\r\n                    pagenum++;\r\n#endif\r\n                }\r\n                TicDelay(20);\r\n                break;\r\n        }\r\n    } while (LastScan != sc_Escape && !ci.button1);\r\n\r\n    IN_ClearKeysDown ();\r\n    fontnumber = oldfontnumber;\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n#ifndef JAPAN\r\n#ifdef ARTSEXTERN\r\nint     endextern = T_ENDART1;\r\n#ifndef SPEAR\r\nint     helpextern = T_HELPART;\r\n#endif\r\n#endif\r\nchar helpfilename[13] = \"HELPART.\",\r\n    endfilename[13] = \"ENDART1.\";\r\n#endif\r\n\r\n/*\r\n=================\r\n=\r\n= HelpScreens\r\n=\r\n=================\r\n*/\r\n#ifndef SPEAR\r\nvoid HelpScreens (void)\r\n{\r\n    int     artnum;\r\n    char    *text;\r\n#ifndef ARTSEXTERN\r\n    memptr  layout;\r\n#endif\r\n\r\n\r\n    //      CA_UpLevel ();\r\n    //      MM_SortMem ();\r\n#ifdef JAPAN\r\n    ShowArticle (0);\r\n    VW_FadeOut();\r\n    FreeMusic ();\r\n    CA_DownLevel ();\r\n    MM_SortMem ();\r\n#else\r\n\r\n#ifdef ARTSEXTERN\r\n    artnum = helpextern;\r\n    CA_CacheGrChunk (artnum);\r\n    text = (char *)grsegs[artnum];\r\n#else\r\n    CA_LoadFile (helpfilename,&layout);\r\n    text = (char *)layout;\r\n#endif\r\n\r\n    ShowArticle (text);\r\n\r\n#ifdef ARTSEXTERN\r\n    UNCACHEGRCHUNK(artnum);\r\n#else\r\n    free(layout);\r\n#endif\r\n\r\n    VW_FadeOut();\r\n\r\n    FreeMusic ();\r\n#endif\r\n}\r\n#endif\r\n\r\n//\r\n// END ARTICLES\r\n//\r\nvoid EndText (void)\r\n{\r\n    int     artnum;\r\n    char    *text;\r\n#ifndef ARTSEXTERN\r\n    memptr  layout;\r\n#endif\r\n\r\n    ClearMemory ();\r\n\r\n#ifdef JAPAN\r\n    ShowArticle(gamestate.episode + 1);\r\n\r\n    VW_FadeOut();\r\n\r\n    SETFONTCOLOR(0,15);\r\n    IN_ClearKeysDown();\r\n    if (MousePresent && IN_IsInputGrabbed())\r\n        IN_CenterMouse();  // Clear accumulated mouse movement\r\n\r\n    FreeMusic ();\r\n#else\r\n\r\n\r\n\r\n#ifdef ARTSEXTERN\r\n    artnum = endextern+gamestate.episode;\r\n    CA_CacheGrChunk (artnum);\r\n    text = (char *)grsegs[artnum];\r\n#else\r\n    endfilename[6] = '1'+gamestate.episode;\r\n    CA_LoadFile (endfilename,&layout);\r\n    text = (char *)layout;\r\n#endif\r\n\r\n    ShowArticle (text);\r\n\r\n#ifdef ARTSEXTERN\r\n    UNCACHEGRCHUNK(artnum);\r\n#else\r\n    free(layout);\r\n#endif\r\n\r\n\r\n    VW_FadeOut();\r\n    SETFONTCOLOR(0,15);\r\n    IN_ClearKeysDown();\r\n    if (MousePresent && IN_IsInputGrabbed())\r\n        IN_CenterMouse();  // Clear accumulated mouse movement\r\n\r\n    FreeMusic ();\r\n#endif\r\n}\r\n#endif\r\n","\n#ifdef __EMSCRIPTEN__\n#include <emscripten.h>\n#endif\n#include <assert.h>\n#include \"web.h\"\n\n\ncontinuation_ptr_t em_continuation_stack[100];\nint em_continuation_stack_top = 0;\n\nvoid em_continuation_push(continuation_ptr_t returnto) {\n  #ifdef __EMSCRIPTEN__\n  assert(returnto != NULL);\n  em_continuation_stack[em_continuation_stack_top] = returnto;\n  em_continuation_stack_top++;\n  #endif\n}\n\nvoid em_continuation_return() {\n  #ifdef __EMSCRIPTEN__\n  continuation_ptr_t returnto = em_continuation_stack[em_continuation_stack_top];\n  assert(em_continuation_stack_top>0);\n  assert(returnto != NULL);\n  em_continuation_stack_top--;\n\n  emscripten_async_call((void (*)(void *))returnto, 0, -1);\n  #endif\n}\n"]}