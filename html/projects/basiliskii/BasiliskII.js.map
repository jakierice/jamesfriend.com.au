{"version":3,"sources":["./../extfs.cpp","./../uae_cpu/memory.h","./../uae_cpu/cpu_emulation.h","./../main.cpp","/Users/jfriend/code/tools/emsdk_portable/emscripten/1.37.21/system/include/libcxx/vector","./../include/video.h","./../prefs.cpp","./../prefs_items.cpp","sys_unix.cpp","./../rom_patches.cpp","./../uae_cpu/readcpu.cpp","/Users/jfriend/code/tools/emsdk_portable/emscripten/1.37.21/system/include/libcxx/memory","./../slot_rom.cpp","/Users/jfriend/code/tools/emsdk_portable/emscripten/1.37.21/system/include/libcxx/iterator","/Users/jfriend/code/tools/emsdk_portable/emscripten/1.37.21/system/include/libcxx/new","./../uae_cpu/memory.cpp","./../uae_cpu/newcpu.cpp","./../uae_cpu/newcpu.h","././sysdeps.h","./../uae_cpu/m68k.h","./../cdrom.cpp","./../audio.cpp","./../emul_op.cpp","./../uae_cpu/fpu/mathlib.h","./../uae_cpu/fpu/flags.h","./../uae_cpu/fpu/fpu_ieee.cpp","./../uae_cpu/fpu/exceptions.h","cpuemu.cpp","./../video.cpp","./../uae_cpu/fpu/rounding.h","./../uae_cpu/fpu/impl.h","./../SDL/video_sdl.cpp","rpc_unix.cpp","./../ether.cpp","/Users/jfriend/code/tools/emsdk_portable/emscripten/1.37.21/system/include/libcxx/__tree","/Users/jfriend/code/tools/emsdk_portable/emscripten/1.37.21/system/include/libcxx/__functional_base","./../include/ether.h","././tinyxml2.h","tinyxml2.cpp","./../rsrc_patches.cpp","main_unix.cpp","/Users/jfriend/code/tools/emsdk_portable/emscripten/1.37.21/system/include/libcxx/string","prefs_unix.cpp","/Users/jfriend/code/tools/emsdk_portable/emscripten/1.37.21/system/include/libcxx/__string","./../disk.cpp","./../sony.cpp","./../adb.cpp","extfs_unix.cpp","/Users/jfriend/code/tools/emsdk_portable/emscripten/1.37.21/system/include/libcxx/string.h","disk_sparsebundle.cpp","./../timer.cpp","audio_oss_esd.cpp","./../scsi.cpp","./../serial.cpp","./../uae_cpu/basilisk_glue.cpp","/Users/jfriend/code/tools/emsdk_portable/emscripten/1.37.21/system/include/libcxx/__split_buffer","/Users/jfriend/code/tools/emsdk_portable/emscripten/1.37.21/system/include/libcxx/type_traits","./../dummy/ether_dummy.cpp","./../dummy/scsi_dummy.cpp","./../include/serial.h","./../dummy/serial_dummy.cpp","/Users/jfriend/code/tools/emsdk_portable/emscripten/1.37.21/system/include/libcxx/stdexcept","timer_unix.cpp","/Users/jfriend/code/tools/emsdk_portable/emscripten/1.37.21/system/include/libcxx/algorithm","/Users/jfriend/code/tools/emsdk_portable/emscripten/1.37.21/system/include/libcxx/map","user_strings_unix.cpp","xpram_unix.cpp","vm_alloc.cpp","video_blit.cpp","./../macos_util.cpp","./../xpram.cpp","./../include/macos_util.h","./../dummy/clip_dummy.cpp","./../dummy/prefs_editor_dummy.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+mEA;AACA;AACA;;;;;;;AAEA;;;;;;;AAqHA;AAAA;;;;AA9pBA;ACv5CA;ADyzBA;AACA;AAAA;AACA;AACA;ACh0BA;;;;AAAA;;;;ADg6CA;ACh6CA;AAAA;ADm6CA;;;AAOA;;AC16CA;;;;;;;;;;;;;;;ADs6CA;AACA;;;;AC35CA;ADm6CA;AACA;;;;;AAyoBA;AAAA;;;;AA9bA;AC3nDA;;;ADyjEA;AAAA;;AA1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;AAAA;;;;AAEA;AAAA;AAAA;;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;;AAzCA;AACA;AACA;AACA;AACA;AAJA;AACA;AACA;AACA;AACA;AAAA;AAJA;AACA;AACA;AACA;AACA;AAAA;AAJA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AAAA;AApBA;AACA;AACA;AACA;AACA;AAJA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAXA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AAAA;AAaA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;;AAhBA;AACA;AACA;AACA;AAKA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAYA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAEA;AAAA;;;AAjBA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAAA;AAlCA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AAAA;AAKA;AACA;AACA;AACA;AAKA;AACA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;;AARA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AATA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAAA;AA5BA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AAAA;AAAA;AR42CA;;;;;;;;AQnlCA;AP3MA;AOzEA;AACA;AACA;AACA;AAAA;AAHA;AACA;AACA;AACA;AAAA;AA2GA;AACA;AACA;AACA;AACA;AACA;AAzBA;AAnHA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAAA;AApBA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAAA;AApBA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAAA;AApBA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAAA;AApBA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAAA;AApBA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAAA;AApBA;AACA;AACA;AACA;AACA;AAAA;AAJA;AACA;AACA;AACA;AACA;AAAA;AAJA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAAA;AAZA;AACA;AACA;AACA;AACA;AAAA;AAJA;AACA;AACA;AACA;AACA;AAAA;AAJA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAAA;;AAZA;AAAA;AACA;AACA;AACA;AACA;AAAA;;;AAJA;AAAA;AACA;AACA;AACA;AACA;AAAA;;;AAJA;AAAA;AACA;AACA;AACA;AACA;AAAA;;;AAJA;AAAA;AACA;AACA;AACA;AACA;AAAA;;;AAJA;AAAA;AACA;AACA;AACA;AACA;AAAA;;;AAJA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;AAaA;AACA;AACA;AACA;AAAA;AAyRA;AR0sCA;;AASA;;AOtCA;APmCA;;AShQA;;;;;;;;;;AD5tCA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;;AAhBA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAAA;AA5BA;AACA;AACA;AACA;AACA;AAAA;AAJA;AACA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AAAA;AAaA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;;AAhBA;AACA;AACA;AACA;AAKA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAYA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAEA;AAAA;;;AAjBA;AACA;AADA;AACA;AADA;AACA;AAYA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAEA;AAAA;;;AAJA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAEA;AAAA;;;AAjBA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAAA;AAlCA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AAAA;AApBA;AACA;AACA;AACA;AACA;AAAA;AAJA;AACA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAAA;AApBA;AACA;AACA;AACA;AACA;AAAA;AAAA;AR43CA;;;;;;;;;AQh4CA;AACA;AACA;AACA;AACA;AAAA;AAAA;ACyvCA;;;;;;;;;;AD7vCA;AACA;AACA;AACA;AACA;AAAA;AAJA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AAAA;AApBA;AACA;AACA;AACA;AACA;AA+XA;AA1WA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAKA;AACA;AATA;AACA;AACA;AACA;AAKA;AACA;AAAA;AAwWA;AACA;AAcA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;;;;AAIA;AAFA;;;;;;;;;;;AAIA;AACA;AACA;AACA;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;;;;;;;;;;AmByFA;;;AAIA;;;;;AADA;;;;;;;;;;;;;;;AAklBA;AAAA;;;;;;;AAAA;AAAA;;;;AAnEA;AAAA;AAAA;;AAmEA;AAAA;;;;AA3DA;AnB3mBA;AmB2mBA;AnB3mBA;;AmBsqBA;AAAA;;;;AAvDA;;AAuDA;AAAA;;;;AAnDA;;AAmDA;AAAA;;;;AA/CA;AAAA;AACA;AACA;AnB7mBA;AmB8mBA;AnB9mBA;;AmB0pBA;AAAA;;;;AAvCA;AnBvnBA;;AmB8pBA;AAAA;;;;;AAAA;AAAA;;;;AAhCA;;AAgCA;AAAA;;;;AA5BA;;AA4BA;AAAA;;;;AAxBA;;AAwBA;AAAA;;;;AApBA;;AAoBA;AAAA;;;;AAhBA;;AAgBA;AAAA;;;;AAXA;;AAWA;AAAA;;;;AAPA;AnBvpBA;;AmB8pBA;AAAA;;;;;AAAA;AAAA;;;;AAHA;AAAA;;AAGA;AAAA;;;;;;;;;;;;;;;;;AC1kBA;AACA;AAEA;;;;;;AAOA;AACA;AACA;AACA;AACA;;;AAoPA;AAAA;;AAlPA;ApBpGA;AoByGA;ApBzGA;AoB0GA;ApB1GA;AoB2GA;ApB3GA;AoB4GA;ApB5GA;AoB6GA;ApB7GA;AoB8GA;ApB9GA;AoB+GA;;AA8FA;AACA;;ApB9MA;AoBkHA;ApBlHA;AoBmHA;ApBnHA;AoBoHA;ApBpHA;AoBqHA;ApBrHA;AoBsHA;ApB1HA;AoB2HA;ApBvHA;AoBwHA;ApBxHA;AoByHA;ApBzHA;AoB0HA;ApB1HA;AoB2HA;;AAkFA;AACA;;ApB9MA;AoB8HA;ApB9HA;AoB+HA;ApB/HA;AoBgIA;ApBpIA;AoBqIA;ApBjIA;AoBkIA;ApBlIA;AoBmIA;ApBnIA;AoBoIA;ApBpIA;AoBqIA;;AAwEA;AACA;;ApB9MA;AoBwIA;ApBxIA;AoByIA;ApBzIA;AoB0IA;ApB1IA;AoB2IA;ApB3IA;AoB4IA;ApB5IA;AoB6IA;ApBjJA;AoBkJA;ApB9IA;AoB+IA;ApB/IA;AoBgJA;ApBhJA;AoBiJA;ApBjJA;AoBkJA;;AA2DA;AACA;;ApB9MA;AoBqJA;ApBrJA;AoBsJA;ApBtJA;AoBuJA;ApBvJA;AoBwJA;ApBxJA;AoByJA;ApBzJA;AoB0JA;ApB9JA;AoB+JA;ApB3JA;AoB4JA;ApB5JA;AoB6JA;ApB7JA;AoB8JA;ApB9JA;AoB+JA;;AA8CA;AACA;;ApB9MA;AoBkKA;ApBlKA;AoBmKA;ApBnKA;AoBoKA;ApBpKA;AoBqKA;ApBrKA;AoBsKA;ApBtKA;AoBuKA;ApB3KA;AoB4KA;ApBxKA;AoByKA;ApBzKA;AoB0KA;ApB1KA;AoB2KA;ApB3KA;AoB4KA;;AAiCA;AACA;;ApB9MA;AoB+KA;ApB/KA;AoBgLA;ApBhLA;AoBiLA;ApBjLA;AoBkLA;ApBtLA;AoBuLA;ApBnLA;AoBoLA;ApBpLA;AoBqLA;ApBrLA;AoBsLA;ApBtLA;AoBuLA;;AAsBA;AACA;;ApB9MA;AoB0LA;ApB1LA;AoB2LA;ApB3LA;AoB4LA;ApB5LA;AoB6LA;ApB7LA;AoB8LA;ApBlMA;AoBmMA;ApB/LA;AoBgMA;ApBhMA;AoBiMA;ApBjMA;AoBkMA;ApBlMA;;AoB6MA;AACA;;;AAPA;AACA;;;;;;AAEA;;AA4IA;AAAA;;;;AApIA;AAAA;;;AAoIA;AAAA;;AAlIA;;;AACA;;;AAOA;AACA;AACA;;;AAPA;AACA;AACA;;AA6HA;AAAA;;;AAtHA;;AAsHA;AAAA;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;AAAA;AAAA;;;;;AAAA;AAAA;;;;;;AAAA;AAAA;;;;AAAA;AAAA;;AAjFA;ApBzQA;AoB0QA;ApB1QA;AoB2QA;ApBvQA;AoBwQA;ApBxQA;AoByQA;ApB7QA;AoB8QA;ApB9QA;AoB+QA;ApB/QA;AoBgRA;ApBhRA;AoBiRA;ApBjRA;AoBoRA;AAAA;AACA;AACA;AACA;AACA;AAAA;;AAkEA;AAAA;;;;ApBtWA;AAYA;;AoB0VA;AAAA;;;;AAtDA;;;;;AAKA;;;;;ApBrTA;AoByTA;ApBzTA;AoByTA;ApBzTA;;;;;;;;;;;;;;;;AAgBA;;;;;;;;;;;;;;;;AoBlDA;ApB8CA;;;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;AoBtDA;ApBsDA;;;;;;;;;;;;;;;AoB9FA;AACA;AACA;;;;ApB4FA;AoBx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;;;;;;;;AAFA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAiDA;AAAA;AAAA;;;;;;;;;;;;;;;AAhDA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AA4DA;;;;;;;;;;;;AA5DA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAqEA;;;;;;;;;AAwCA;AACA;;;;;;;;;;;;;AAUA;;;;;;;;;;;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;AA7LA;;;;;;;;;;;;;;;;;;;;AN4gBA;;;AA9PA;AACA;;AAEA;;AAMA;AACA;;AAGA;AAiPA;;;AA1OA;AACA;AACA;;AAwOA;;;AAnOA;AACA;AACA;;AAiOA;;;AA/NA;AClUA;ADsUA;ACtUA;ADuUA;ACvUA;ADwUA;;AAuNA;AACA;;AChiBA;AD2UA;AC3UA;AD4UA;AC5UA;AD8UA;AAAA;AC9UA;AD+UA;AC/UA;ADgVA;AChVA;ADiVA;ACjVA;ADkVA;AClVA;ADmVA;ACnVA;ADoVA;ACpVA;ADqVA;ACrVA;ADsVA;;AAyMA;AACA;;AChiBA;ADyVA;ACzVA;AD0VA;AC1VA;AD2VA;AC3VA;AD4VA;AC5VA;AD6VA;AC7VA;AD8VA;AC9VA;AD+VA;AC/VA;ADgWA;;AA+LA;AACA;;AChiBA;ADmWA;ACnWA;ADoWA;ACpWA;ADqWA;ACrWA;ADsWA;ACtWA;ADuWA;ACvWA;ADwWA;ACxWA;ADyWA;ACzWA;AD0WA;AC1WA;AD2WA;AC3WA;AD4WA;;AAmLA;AACA;;AChiBA;AD+WA;AC/WA;ADgXA;AChXA;ADiXA;ACjXA;ADkXA;AClXA;ADmXA;ACnXA;ADoXA;ACpXA;ADqXA;ACrXA;ADsXA;ACtXA;ADuXA;;AAwKA;AACA;;AChiBA;AD0XA;AC1XA;AD2XA;AC3XA;AD4XA;AC5XA;AD6XA;AC7XA;AD8XA;AC9XA;AD+XA;;AAgKA;AACA;;AChiBA;ADkYA;AClYA;ADmYA;ACnYA;ADoYA;ACpYA;ADqYA;ACrYA;ADsYA;ACtYA;ADuYA;;AAwJA;AACA;;AChiBA;AD0YA;AC1YA;AD2YA;AC3YA;AD4YA;AC5YA;AD6YA;AC7YA;AD8YA;AC9YA;AD+YA;AC/YA;ADgZA;;AA+IA;AACA;;AChiBA;ADmZA;ACnZA;ADoZA;ACpZA;ADqZA;ACrZA;ADsZA;ACtZA;ADuZA;ACvZA;ADwZA;;AAuIA;AACA;;AChiBA;AD2ZA;AC3ZA;AD4ZA;AC5ZA;AD6ZA;AC7ZA;AD8ZA;AC9ZA;AD+ZA;AC/ZA;ADgaA;;AA+HA;AACA;;AChiBA;ADmaA;ACnaA;ADoaA;ACpaA;ADqaA;ACraA;ADsaA;ACtaA;ADuaA;ACvaA;ADwaA;ACxaA;ADyaA;ACzaA;AD0aA;;AAqHA;AACA;;AChiBA;AD6aA;AC7aA;AD8aA;AC9aA;AD+aA;AC/aA;ADgbA;AChbA;ADibA;ACjbA;ADkbA;AClbA;ADmbA;;AA4GA;AACA;;AChiBA;ADsbA;ACtbA;ADubA;ACvbA;ADwbA;ACxbA;ADybA;ACzbA;AD0bA;AC1bA;AD2bA;;AAoGA;AACA;;AChiBA;AD8bA;AC9bA;AD+bA;AC/bA;ADgcA;AChcA;ADicA;ACjcA;ADkcA;AClcA;ADmcA;ACncA;ADocA;ACpcA;ADqcA;;AA0FA;AACA;;AChiBA;ADwcA;ACxcA;ADycA;ACzcA;AD0cA;AC1cA;AD2cA;AC3cA;AD4cA;AC5cA;AD6cA;AC7cA;AD8cA;;AAiFA;AACA;;AChiBA;ADidA;ACjdA;ADkdA;ACldA;ADmdA;ACndA;ADodA;ACpdA;ADqdA;ACrdA;ADsdA;;AAyEA;AACA;;AChiBA;ADydA;ACzdA;AD0dA;AC1dA;AD2dA;AC3dA;AD4dA;AC5dA;AD6dA;AC7dA;AD8dA;;AAiEA;AACA;;AChiBA;ADieA;ACjeA;ADkeA;ACleA;ADmeA;ACneA;ADoeA;ACpeA;ADqeA;ACreA;ADueA;;AAwDA;AACA;;AArDA;ACveA;ADweA;ACxeA;ADyeA;AC7eA;AD8eA;AC9eA;AD+eA;AC/eA;ADgfA;AChfA;ADmfA;AAAA;AAEA;AACA;AACA;AAIA;AC3fA;AD4fA;AC5fA;AD6fA;AC7fA;AD8fA;AEtnBA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AFunBA;AAAA;ACngBA;ADogBA;AAAA;ACpgBA;ADqgBA;ACrgBA;ADsgBA;ACtgBA;ADugBA;ACvgBA;ADwgBA;AACA;AACA;AAKA;AC3hBA;AD2hBA;AC/gBA;ADghBA;AACA;AACA;AACA;AACA;AAKA;AAAA;ACzhBA;AD0hBA;ACthBA;ADuhBA;AC3hBA;AD4hBA;AACA;AACA;AAOA;;;;AA1PA;AA0PA;;;;;;;;;;;;;;AuB1HA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAlBA;AAAA;AAAA;AAAA;AAAA;;;;;;ACrYA;;;;;AC+vDA;AAAA;;;;;AAqGA;;AA9FA;AAAA;;AFt0CA;;;AAAA;AAAA;;AEw0CA;AAAA;ADxwDA;;ACfA;;;AAgyDA;;;AF9/CA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAeA;AAAA;AAAA;AAAA;AAAA;;;AAYA;AAAA;AAlFA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAzDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AA2IA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAtEA;;AACA;;AACA;;AA0FA;AAnJA;AAAA;AAoJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;;;AEm+CA;;AACA;;;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADpyDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AC+yDA;AD/yDA;;;;ACozDA;AAAA;;AAgDA;;;;;AA3CA;AAAA;;AAAA;ADzzDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACo2DA;;;;;AA9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AA6BA;;;;;;;;;;;ACp7DA;;;;;;AFgFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACo2DA;;;;;;;AAAA;;;;AR71DA;;AhBhBA;;;;;AgBgBA;;;;AhBhBA;AAAA;;;;;;;;;AwBg4DA;ACv7DA;;;;AHsYA;;;AAGA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;;;AAHA;;AAGA;;;;AAAA;;;AAHA;;AAAA;;;;;AAGA;;AAAA;AAAA;AAAA;AAAA;;AAHA;AAAA;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAHA;AAAA;AAAA;AAAA;AAGA;AAAA;AEkkDA;;;;;;;;;;AAxBA;AAAA;AAAA;;;AAoBA;AAAA;AAAA;AAAA;;;AFjkDA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;;;;AAHA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAHA;AAAA;;AAGA;AAAA;AAHA;AAAA;;AAAA;AAAA;;AAAA;AAGA;AAHA;;;;AAAA;AAAA;;;AAGA;;;;AAAA;;;AAHA;AAGA;AAAA;;AAHA;AAAA;;AAGA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAHA;AAAA;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AE8kDA;;;;;AEpkEA;;;AAGA;AACA;;AAEA;AAAA;;;;;;AAEA;;AAAA;;AACA;AAAA;;;;;;;AAWA;AAAA;AAAA;;;;AACA;;A1B+HA;AAAA;;;;;A0B3HA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AACA;AACA;A1BsIA;AAAA;A0BpIA;;;;;;A1BwHA;AAAA;AAAA;;;;;;A0B1GA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AACA;A1BkHA;;A0BhHA;AAAA;;AAEA;;;AAOA;;;;AAGA;;;AAAA;A1BwFA;AAAA;AAAA;AAAA;A0BtFA;;AAGA;AAAA;AACA;AAAA;AAAA;;A1B8FA;AAAA;AAAA;;A0B5FA;;AAEA;;;;;;;AAUA;;;;AT4VA;;;AjBxRA;;;;A0BhEA;;;AACA;;;;;;;;;;;;AAaA;;;AACA;;;ATyUA;ADlRA;AUtDA;;;AAIA;AAAA;;;;AACA;AAAA;AAAA;;A1BuDA;AAAA;;;A0BpDA;;;;;;;;;;;;;;AFkvCA;AxBltCA;AAAA;AAAA;AAAA;AAAA;AwBktCA;AAEA;AAAA;;;AAGA;AAAA;AAAA;;;;;;AA5EA;ARnmCA;;;AhBhBA;AAAA;;AgBOA;;AQs2DA;;;AAjvBA;AAAA;AAAA;;;;;;;;AAKA;AAAA;;;AxB7oCA;;;;;;;;;AsBuLA;AAAA;;AAGA;AAAA;AAAA;;AChMA;;;;;;;;;;ADuPA;AAEA;AAAA;AGlTA;;;AzB+DA;;AwBupCA;AAAA;;;AAEA;;;;;;;;AAGA;;;AAIA;AAAA;;AAEA;AAAA;;AAutBA;;;;;AAnqBA;;;;AR1rCA;AAAA;;AAAA;AAAA;;AhBhBA;AAAA;AAAA;;AAAA;AAAA;AgBMA;AQ0wCA;;;;;;;AAYA;AAAA;;;;;;;;;;;AAQA;AAAA;;;;AAeA;;;AALA;AAAA;;;;;;;;AxBt0CA;;AAAA;;;;;AAAA;AAAA;;AwB80CA;AAAA;AAAA;;AAhqCA;AAAA;AAAA;;;;;;;;;;AAKA;AAAA;;;;;AFoLA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAAA;;AE5JA;AAAA;;AASA;;AAGA;AAAA;;AACA;AAAA;AAAA;;;AAAA;AAAA;;AAAA;AAqnCA;AAZA;;;;;;;;;;;;AAwBA;AAAA;;AANA;;;AxBt1CA;;AAAA;;AwBw1CA;AAAA;;AxBx1CA;AAAA;;AwB01CA;;;AxB11CA;;;;;AwB8KA;;;;AAKA;;AFoLA;AAGA;AAAA;;AAAA;AAAA;;;;;AE5JA;;;AAMA;;;;AAHA;;AAFA;AAAA;AAQA;;AAIA;AAAA;AAAA;;AADA;AACA;AAAA;;;;;;;;;;;;AAioCA;AAOA;;;;;AACA;AAAA;;;;;;AAEA;;AAAA;;;;;;;;;;;;AR9zCA;AAAA;;AhBhBA;AAAA;;AAAA;AAAA;AAAA;;AgBMA;AAAA;;AACA;AQysCA;;AAIA;AAAA;AAAA;;;;;;;;;;;;;AAMA;;;;;;;;;;;;;;;AAQA;;;;;;;;;;;;;AArhCA;AAAA;;;;;AA4BA;;;;;AAOA;;;AAEA;AAAA;;AACA;;;AxB/PA;;;AAAA;;;;AAAA;;;;AAAA;;;;AwB+vCA;AAXA;;;;;;;;;;;;;;;;;;;AA3hCA;AAAA;AAAA;;;AAAA;;AA4BA;;;;;AAOA;AAEA;AAAA;;;;AxB9PA;AAAA;;AwBwwCA;;AxBxwCA;;;;;AwB0wCA;;AAEA;;AAEA;;;;;;;AAGA;;;;AACA;AAAA;AAAA;;;;;AAEA;AAAA;;;;;;;AAqmBA;;;;AAxhBA;;AACA;;;;;;;;;;;;;;;;;;;;;;;AA6BA;;;;AAKA;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;;;;AAIA;;;;;;;;;;;;;;AAYA;;;;;;;;;ARl5CA;;AAAA;;AQ46CA;;;;;;ARt7CA;AQu7CA;;;;;;;ADp7CA;;;;;;ACmYA;AAIA;;;;;AAOA;AAEA;;;;;AAGA;;;;;;;;;;;;;;;;;;AxBpaA;A2BmgBA;A3BngBA;A2BogBA;A3BxgBA;;A2BgvBA;AAAA;;;;A3B5vBA;A2B4hBA;A3BxhBA;A2ByhBA;A3BzhBA;;;A2BwvBA;AAAA;;AA9NA;;;AA8NA;AAAA;;AA3NA;;;;;AAEA;AAEA;AACA;AACA;A3BvhBA;A2BwhBA;A3BxhBA;A2ByhBA;A3BzhBA;;;;;;;;;A2B4uBA;AAAA;;;;AAAA;AAAA;;;;;;AA1MA;AACA;AACA;A3BpiBA;A2BqiBA;A3BriBA;A2BsiBA;A3BtiBA;;;;;;;;;;A2B4uBA;AAAA;;;;AA7LA;A3B/iBA;;A2B4uBA;AAAA;;;;AAxLA;A3BxjBA;A2ByjBA;AAAA;;AAuLA;AAAA;;;;A3BxuBA;;A2BwuBA;AAAA;;;;A3BxuBA;;A2BwuBA;AAAA;;;;A3BhvBA;;A2BgvBA;AAAA;;;;A3BxuBA;;A2BwuBA;AAAA;;;;A3B5uBA;A2BilBA;A3BrlBA;A2BslBA;A3BllBA;A2BmlBA;A3BvlBA;;A2BgvBA;AAAA;;;;A3B5uBA;A2BylBA;A3BrlBA;A2BslBA;A3BtlBA;A2BulBA;A3B/lBA;A2BgmBA;A3BhmBA;;A2BgvBA;AAAA;;;;A3B5vBA;AG+xCA;AAhBA;;;AwBnhBA;AAAA;;;;;;;;AfwYA;;;;;;;;AexYA;AAAA;;AAvIA;A3BzmBA;A2B0mBA;A3B1mBA;A2B8mBA;A3B9mBA;;A2BgvBA;AAAA;;;;AA5HA;A3BpnBA;;A2BgvBA;AAAA;;;;A3B5uBA;A2BsnBA;A3B1nBA;;A2BgvBA;AAAA;;;;A3B5vBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AYooCA;;;;;;;;AT2JA;AAAA;AAhBA;AAAA;;;AwBnhBA;AAAA;;;;;;;;;AfwYA;;;;;;;;AexYA;AAAA;;;;;;;;;AfwYA;;;;AeleA;A3BtpBA;;A2BgvBA;AAAA;;;;;;;;;AApFA;A3B5pBA;AGmxCA;AAhBA;;;;;;;;;;;AS3IA;;;;;;;;;;;;;AezdA;A3B/pBA;A2BgqBA;A3BhqBA;A2BiqBA;A3BjqBA;A2BkqBA;AxBinBA;AAhBA;;;;;;;AwB3wCA;AAAA;AfgoCA;;;;;;;;;AZpnCA;A2B+pBA;A3BnqBA;;A2BgvBA;AAAA;;;;A3B5vBA;A2BqrBA;A3BjrBA;A2BmrBA;AxBgmBA;AAhBA;;;AwB3gBA;AAAA;;;;;AAhEA;;;;;;AfwcA;;;;;;;;;;AexYA;AAAA;;AA/DA;A3B7rBA;AAYA;A2BmrBA;A3B/qBA;A2BgrBA;A3BhrBA;A2BirBA;A3BjrBA;A2BkrBA;A3BlrBA;A2BmrBA;A3BnrBA;A2BorBA;A3BprBA;A2BqrBA;A3BrrBA;A2BsrBA;A3B1rBA;A2B2rBA;A3B3rBA;A2B4rBA;A3B5rBA;A2B8rBA;;;;;;;;;;;;;;;;;;;;;;AAYA;;;;;;;;AAKA;A3B3sBA;A2B4sBA;A3B5sBA;A2B6sBA;A3B7sBA;A2B8sBA;A3B9sBA;A2B+sBA;A3BntBA;A2BotBA;A3BptBA;;A2BgvBA;AAAA;;;;A3B5vBA;;;;AAYA;;A2BgvBA;AAAA;;;;AAdA;A3B9tBA;A2B+tBA;A3B3tBA;A2B4tBA;A3B5tBA;A2B6tBA;A3BruBA;A2BsuBA;A3BtuBA;;A2BgvBA;AAAA;;;;;AAAA;AAAA;;;;;;;AAHA;AAAA;;AAGA;AAAA;;;;;;;;;;;;;;AHkSA;AAAA;AAAA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;AAAA;;;AAheA;AAAA;AAAA;;;AAmeA;AAAA;AAAA;;;;AAjeA;AAAA;AAAA;;;;;AAQA;;;;;;;;;;;AAtCA;;;;;AAGA;;;;;AASA;AA+BA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAhDA;AAAA;AAAA;AAAA;;;;AAEA;;;;;;;;;;;AAMA;;;;;;AAGA;;;;AAyCA;AI9nBA;AJ0kBA;AAAA;;;;;;;;;;;;;AAWA;;;;;;;;;AAMA;AAAA;;;;;;;;;;;;;;;AAkDA;AAAA;;;;;;AAGA;;;;;;;;;;;;;;;AAIA;;;AAIA;AP1VA;AAAA;;;;AAAA;;;ADlRA;;;;;;;;;;;;;AADA;ACmRA;ADlRA;AQ+mBA;;;;;;;;;;;;;;;;;;AP7VA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AADA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AD1QA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AC2QA;AAAA;AAAA;ADlRA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AA0BA;AAAA;AAAA;AA3BA;;;;;;ACmRA;AAAA;AAAA;AAAA;;;;;ADlRA;;;;AA0BA;AQ0mBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AxB1nBA;;;;;;AAAA;AgBMA;;;;;;;;;;;;;;;AapGA;AAAA;AAAA;AAAA;ALknBA;;;;;;;AAEA;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AxBriBA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AwBy3DA;;;;;AAhqDA;;AAAA;;;;AA4BA;AAAA;AAAA;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AxB9PA;AAAA;AAAA;AAAA;AAAA;AAAA;AwBy3DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AA5hDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;;;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;;AAIA;AAAA;;;AAAA;;;;;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AACA;;;AADA;;AAAA;AAAA;;AAAA;AAAA;;AACA;;AADA;AADA;;;AACA;AAAA;;AAAA;AAAA;;;AAAA;;AAAA;AAAA;;;AACA;;;;;;;AAAA;AADA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAFA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AADA;AAAA;AADA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;;AAAA;;AACA;;AADA;;;AAAA;AAAA;;AAAA;;;;;;AAAA;;;AAAA;;AAAA;;;;;;;;;;AAIA;AAAA;;;;;;;;;;;;;;;;;;AGtEA;AAIA;A3BrTA;A2BuTA;;;AAoLA;AAAA;;;;AAAA;AAAA;;AAhLA;AxBw9BA;AAhBA;;;AwBxxBA;AAAA;;;;;;;;;;Af6oBA;;;;;;;;;;Ae7oBA;AAAA;;;;AAAA;AAAA;;AA7KA;AAAA;AAAA;;AA6KA;AAAA;;;;;Af6nBA;ARtuCA;;;AuBymBA;AAAA;;A3BvfA;A2B2VA;A3BvVA;A2BwVA;A3BxVA;;;A2BmfA;AAAA;;AA1JA;;;AA0JA;AAAA;;AAnJA;AAAA;;;;;;;;AACA;AAAA;A3B7UA;A2B8UA;;;;;AAIA;A3BtWA;A2BuWA;;;;AAGA;;;;;;;AAKA;;;;;;;;;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;AAQA;AACA;AACA;;;;;;;;;;;;;AAbA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;AAEA;;;;;;;;;;;;;;AAMA;AACA;AACA;;;;;;;;;;;AAqHA;AAAA;;AA/GA;;;;;;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;AAQA;AACA;AACA;;;;;;;;;;;;;;;AAZA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;AAEA;;;;;;;;;;;;;;AAMA;AACA;AACA;;;;;;;;;;;AAIA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AA6FA;AAAA;;;;AAtFA;;AAsFA;AAAA;;;;AAjFA;;;AAiFA;AAAA;;AfqoBA;AAAA;Ae1sBA;;;;;;;;;;;;;;;;;;AAIA;A3B1aA;A2B2aA;AAFA;AfusBA;AevsBA;;;;;;;;;;;AADA;;;;;;;;;;;;;AAmEA;AAAA;;AAxDA;;AAwDA;AAAA;;;;AAjDA;;AAiDA;AAAA;;;;AA5CA;;AA4CA;AAAA;;;;AAtCA;;AAsCA;AAAA;;;;AAjCA;AACA;A3BvdA;A2B2dA;A3B/cA;A2BidA;;;AA0BA;AAAA;;;;;AAAA;AAAA;;;AxBwyBA;AAhBA;;;AwBxxBA;AAAA;;;;;;;;;;Af6oBA;;;;;;;;;;Ae7oBA;AAAA;;;;AAAA;AAAA;;AAnBA;AAAA;AAAA;;AAmBA;AAAA;;;;AAZA;AACA;A3B5eA;A2B8eA;AACA;;AAQA;AAAA;;;;AAHA;AAAA;;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;AGsiBA;;;AAtIA;AAGA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAUA;;;AAwCA;;;;;;;AAlCA;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;AAeA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;;;AAAA;;;;;;;;AAWA;AAAA;AAAA;;;;AALA;AAAA;AAAA;AAAA;AACA;;;;AA4FA;;;;;;AAiBA;AAAA;AAEA;AAHA;AAMA;;;;;;AAEA;AAAA;;;;;AAEA;AAAA;;;;;;;;;AAGA;;AACA;;;;AAEA;;;;;;AACA;;AACA;;;;;;AAEA;;;;;;;;;AAGA;AA2BA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAWA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAj1BA;AACA;AACA;AACA;AACA;A3BijCA;;AASA;;AOtCA;AAAA;AAAA;AAAA;AAAA;AAAA;APmCA;;;A2B3OA;;;;;;;;;AAPA;AAAA;;;;;;;;AAh6BA;;;;;;;AAuFA;AACA;AACA;AACA;AACA;A3BijCA;;AASA;;AOtCA;AAAA;AAAA;AAAA;AAAA;AAAA;APmCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A2BtPA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAr0BA;AACA;AACA;AACA;AACA;A3BijCA;;AASA;;AOtCA;AAAA;AAAA;AAAA;AAAA;AAAA;APmCA;;;A2BvPA;;;;;;;;AALA;AAAA;;;;;;;;AAt5BA;;;;A3B4NA;AAAA;;A2BitBA;;AAyDA;AAAA;;;;;;;;;;;;;;AlBpFA;;;;;;;;;;;;;;;;;;;;;AkBkEA;A3BiEA;;;;A2B9DA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AlB1EA;;;AkB+EA;AA1iCA;AAAA;AA2iCA;A3B0KA;;AASA;;AOtCA;APmCA;;;A2B5KA;AAAA;;;;;;;;;;;AC/lBA;AAAA;AAAA;;;AA6HA;AAAA;;;;;;;;AA5HA;AAAA;AAAA;;;;;AAnGA;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;AAFA;;;;;;;;;;;;;AAEA;;;;;;;;;;AAmCA;;;;;;;;;;;;;;AArCA;;;;;;;;;;;;;AAEA;;;;;;;;;;AA+CA;;;;;;;;;;;;;AAjDA;;;;;;;;;;;;;AAEA;;;;;;;;;;AA2DA;;;;;;;;;;;;;;;;;;;AA7DA;;;;;;;;;;;;;AAEA;;;;;;;AA+CA;;;;;AAjDA;;;;;;;;;;;;;AAEA;;;;;;;AA2DA;AAkEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;AAIA;;;;;;;;;;AArIA;;;;;;;;;;;;;;;;;;;;;;;;AA4IA;;;;;;AAoCA;;;;;;;;;;;AAIA;;;;;AAIA;AANA;;;;;;;AAQA;;;;;;;;AAnZA;AAEA;;;;;;;;AACA;AADA;;;;;;;;;;;;;;;AAuZA;AAAA;;;;;;;;;;;;AAGA;AAAA;AADA;;;;;;;;;;;AAMA;;;;;;;;;;AAjaA;AAEA;;;;;;;;AACA;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyTA;AAAA;AAAA;;;;;;;;;AA+DA;;;;;;;;;;;;;AAjKA;;;;;;;;;;;;;AAEA;;;;;;;AAuKA;AANA;;;AAQA;AAzEA;AAAA;AAAA;;;;;;;AAgDA;;;;;;;;;;;;;AAlJA;;;;;;;;;;;;;AAEA;;;;;;;AAwJA;AANA;;;AAQA;AA1DA;AAAA;AAAA;;;;;;;;;;;AA6HA;AAAA;;;;;AAAA;AAAA;;;;;AAAA;AAAA;;;;AAtFA;;AAsFA;AAAA;;;;AAxEA;;AAwEA;AAAA;;;;AAzDA;;AAyDA;AAAA;;;;AA1CA;;AA0CA;AAAA;;;;AA3BA;;AA2BA;AAAA;;;;AApBA;AAAA;AAAA;;AAoBA;AAAA;;;;AATA;AAAA;AAAA;;AASA;AAAA;;;;AAAA;AAAA;;;;;;;;;;;;;;;;AbuHA;AAAA;;AAAA;;;;;;AACA;;;;;AACA;;;;;;;;AAEA;AAAA;AAAA;;;;AACA;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;;;;;;;AACA;;;;AACA;;AAAA;;;;;AAAA;AAAA;AAAA;;;;;;;AHqPA;;;;AACA;;AAAA;;;;;;;;;;;ACvkCA;AAAA;;AAAA;AAAA;;;AD0kCA;AACA;;;;AAwCA;AAAA;;;;;;AAEA;AACA;;;;;;;;AA5hBA;;AAIA;;AACA;;;AANA;AAAA;;;;;;;;AAoiBA;AAAA;AAAA;;;AAEA;;;;;;;;;;;;;;;AEv4BA;;AFq5BA;AAAA;AAAA;;;;;;;;AAEA;;;;AACA;AAYA;AAAA;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ANvkBA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;AACA;AAAA;;;;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3lBA;;;;;;;;;;;;;;;;;;;AASA;AAAA;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAFA;;;;;;;;;;;;;AAOA;;;AAPA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuDA;;;;;;AAMA;;;AAGA;;AAEA;AACA;;;;;;;AAEA;AACA;;;;;AAXA;;;;AAeA;;AAAA;;;;AAEA;AAAA;AAAA;;;AAEA;AAAA;;AAAA;;;;;;;;;AAEA;AAAA;AAAA;;;;AAKA;;AAAA;;;;;AAMA;;;;;;;;;AAGA;;;;;;;;;;;;;;AAgBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAnBA;;;;;;;;AAAA;AAAA;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AuB5DA;AhCnFA;;;;;;AgC8MA;AAAA;;;AAAA;AAAA;;;;;;AAAA;AAAA;;;AAAA;AAAA;;;;AAxGA;AAAA;AACA;AhC3GA;;;AgCkNA;AAAA;;;;AAAA;AAAA;;ACsqBA;;;;;;;;;;;;;;;AAo3CA;;;;;;;;AAHA;;;;;;;;;;;ADvhEA;AAAA;;;;;;;AErUA;;AD+3DA;;;;;;;;;;;;;AAUA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ApB/uDA;AH0zCA;AANA;AuBmhBA;AACA;AACA;AAEA;AACA;;;;AACA;;;AACA;AACA;;;ADrwDA;;AAiGA;AAAA;;;;AAzFA;AAAA;;;AAyFA;AAAA;;;;AAAA;AAAA;;ACsqBA;;;ADtqBA;AAAA;;;;;;;;;;;AC0hEA;;;;;;;;AAHA;;;;;;;;;;ADvhEA;AAAA;;;;AAAA;AAAA;;AC/MA;;AArGA;AAAA;;;;;;AAkpBA;AAlpBA;AAAA;;;;;;;AAkEA;;;;;;;;;;AA8oEA;;AACA;AAEA;ApBlkEA;;AmBmKA;AAAA;;;;AA5EA;AhCtIA;;;AgCkNA;AAAA;;AAtEA;AACA;AhCrHA;AChIA;AAAA;AAAA;AAAA;AAAA;AAAA;;;A+B0TA;AAAA;;;;AAAA;AAAA;;;;;;AhC9MA;;;;;AmC5FA;AnCwFA;ACzGA;AkCkBA;;;;;;;;;;AHiPA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA;AACA;AACA;;;;;AAqCA;AAAA;;;;AAAA;AAAA;;;;AAnBA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAEA;AAAA;AhCrLA;AgCsLA;AhCtMA;ACxGA;;A+B0TA;AAAA;;;;;AAAA;AAAA;;;;;AAAA;AAAA;;;;AAHA;AAAA;;AAGA;AAAA;;;;;;;;;;;;;AvB2JA;;;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;;AAGA;;;;;;;;;;;;;;;AAKA;;;;;;;;;AAKA;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAcA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;;;;;;;AAGA;;;;AAEA;AAAA;;;AAIA;AAAA;;;;AAGA;;;;;;;;;;;;;;;;;;AAcA;;;;;AAFA;AAAA;;;;;;;AAMA;AAAA;;;;;;;;;;;;;;;AAOA;AAAA;;;;;;;;;;;AAKA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAaA;;;;;AAIA;;AAGA;;;;;;;;;;;AAIA;;AAEA;;;;;;AACA;;;;;;;;AAQA;;;AAEA;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;AASA;;;;AAAA;AAOA;AAAA;;;;;;;;;;;;AASA;AAAA;AAAA;;;AAAA;;AAAA;;;AAAA;;AACA;AAAA;;AAGA;;AAIA;AAJA;;;AAAA;;;;;;;;;;;;;;;;;;;;;AAUA;AAAA;;AAEA;;;AAAA;AAAA;;;;;AAQA;;;AAGA;AAAA;AAAA;;;AACA;AAAA;AAGA;;AACA;;AAAA;AAAA;AAHA;AAGA;AACA;;;;;;;;;;AsBvJA;AAAA;AAIA;AAAA;AAAA;;;AAyFA;AAAA;;;;;;AA3IA;AACA;;AApDA;AASA;;;;;;;;;;;AAkBA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AA+EA;AAAA;AAAA;AAAA;AAtEA;;AArCA;AASA;;;;;;;;;;;AAkBA;AACA;;;;;;AAmFA;AAAA;AAAA;AA5DA;AACA;;AApDA;AASA;;;;;;;;;;;AAkBA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AAsFA;AAAA;AAAA;AAhDA;AACA;;AAnEA;AASA;;;;;;;;;;;AAkBA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AAyFA;AAAA;AAAA;;;;;;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAvEA;AACA;;AApDA;AASA;;;;;;;;;;;AAkBA;AAAA;AAAA;AAAA;AAAA;AACA;AAsCA;AACA;;AAnEA;AASA;;;;;;;;;;;AAkBA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAqGA;AAAA;AAAA;AAzHA;AARA;AASA;;;;;;;;;;;;;;;;;;AAiIA;AAAA;AAAA;;;;;;;AAvFA;AACA;;AApDA;AASA;;;;;;;;;;;AAkBA;AAAA;AAAA;AAAA;AAAA;AACA;AA+GA;;;;;;AAOA;AAAA;AAAA;;;;;;;AAhFA;AACA;;AAnEA;AASA;;;;;;;;;;;AAkBA;AAAA;AAAA;AAAA;AAAA;AACA;AAuHA;;;;;;AAOA;AAAA;AAAA;;;;;;;AAEA;AADA;;;;;;;;;;;;;;;;AAhLA;AAEA;;;;;;;;AACA;AADA;;;;;;;;;;;;;;;AAsLA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AADA;;;;;;;;;;;;;;;;;;AAzLA;AAEA;;;;;;;;AACA;AADA;;;;;;;;;;;;;;;AAsMA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AA9EA;AAAA;AAAA;;;;;;;;;;AAqEA;AAAA;AAAA;;AAoBA;AAAA;;AATA;AAAA;AAAA;;AASA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AtB+JA;;;;;;;;;;;;;;;;;;;;AAWA;;;AAKA;;AAAA;AACA;;;;;;AACA;AAAA;AACA;;;AAAA;AAAA;AAAA;;;;AAKA;;AACA;AAGA;;;;;AAUA;;;;;;;;;;;AAjBA;AAAA;;;AAdA;;;;;;;;;;;;AASA;AAAA;AAAA;;;AAAA;;AAAA;AACA;AAAA;AAAA;;;;;;;;AACA;;AACA;AAAA;;;;;AAMA;AAAA;;AAGA;;;;AAIA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;;;;AACA;;;;;;;;;;AAjBA;;;;;;;AAfA;;;;;;;;;;;;;;;;;;;;;;;;;;AAiDA;AAAA;;;;;;;;AQvcA;AAAA;AAAA;;AAAA;AAAA;;AOohBA;AAAA;;AAGA;AxB/xBA;;AAAA;;AgBOA;AQyxBA;;AAUA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;;AASA;;AR5yBA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AQouBA;;AFhkBA;;AAGA;;;;;;;;;;;;;;;;;AEukBA;AAAA;;AAAA;;;AACA;AAAA;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;;;AACA;AAAA;;;;AACA;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAIA;;AACA;AAAA;;;;;;;;;;AAGA;AAAA;AAAA;;;;;;;;AAIA;;;;;;;AAEA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;;;;;;;;;;AYpgBA;;;;;;;;;AACA;AADA;;;;;;;;;;;;AC8FA;;;;AAAA;;;;;;;;;;;;;;;;;;;;ADnEA;;;;;;;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;;;;;AC4DA;AAAA;AA0BA;AACA;AD1bA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAusBA;AAAA;ACvSA;;;;;;;AANA;AAAA;AA+BA;AACA;AD1bA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACqgCA;AAFA;AACA;AAzmBA;;;;;;;AANA;AAAA;AAoCA;AACA;AD1bA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC01BA;AApcA;;;;;;;AARA;AAAA;AA2CA;AACA;AD1bA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAusBA;ACvTA;AD2SA;;;;;;;AClTA;AAAA;AAgDA;AACA;AD1bA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC6vBA;AAnXA;;;;;;;AANA;AAAA;AAqDA;AACA;AD1bA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC2yBA;AAtaA;;;;AA+BA;;AAEA;;;;;;;;AlBmTA;AAEA;AnBnrBA;AGmxCA;AAhBA;;;;;;;;;;;ASnIA;;;;;;;;AO5cA;AnBprBA;AmBwrBA;AAAA;;;;AAEA;AnB9rBA;;;;;;;;;;;;AmB+yBA;AAAA;;;AAvFA;AnB5sBA;;AmBmyBA;AAAA;;;;;;;;;;AAAA;AAAA;;;AApGA;AnB/rBA;;AmBmyBA;AAAA;;;;;;;;;;;;AAAA;AAAA;;;AA7GA;AnBtrBA;;AmBmyBA;AAAA;;;;;;;;;;;AAAA;AAAA;;;AA9EA;AnBrtBA;;AmBmyBA;AAAA;;;;;;;;;;AAAA;AAAA;;;AA1FA;AnBrsBA;;AmB+xBA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;AA1GA;AnBzrBA;;AmBmyBA;AAAA;;;;;;;;;;AAAA;AAAA;;;;;AnB/xBA;;AAAA;;AmBksBA;AnBlsBA;;AmB+xBA;AAAA;;;;;;;;;;;AAAA;AAAA;;;AApFA;AnB/sBA;;AmBmyBA;AAAA;;;;;;;;;;;AAAA;AAAA;;;AAjFA;AnB9sBA;;AmB+xBA;AAAA;;;;;;;;;;AAAA;AAAA;;;AAvGA;AnB5rBA;;AmBmyBA;AAAA;;;;;;AhBweA;AAhBA;;;;;;;AgB1hBA;AAAA;APuZA;;;;;;;;;AOpZA;AnB5tBA;;AmB2xBA;AAAA;;;;;AhBjWA;;;AgBiWA;AAAA;;;;;;;;;;AA/CA;AnB5vBA;;;AmB2yBA;AAAA;;AA9CA;AnBjwBA;AAgBA;AmBmvBA;AnBvvBA;AmBwvBA;AnBxvBA;;AmBmyBA;AAAA;;;;AApCA;AAAA;AlBl3BA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AkBs5BA;AAAA;;;;AAhCA;AnB/vBA;;AmB+xBA;AAAA;;;;AA5BA;AACA;;;AA2BA;AAAA;;AnB/xBA;;AmB+xBA;AAAA;;;;AApBA;AnB3wBA;;AmB+xBA;AAAA;;;;AAhBA;AnB/wBA;;AmB+xBA;AAAA;;;;AAZA;AnBvxBA;;AmBmyBA;AAAA;;;;AARA;AnBvxBA;AmBwxBA;AnBxxBA;;AmB+xBA;AAAA;;;;AAHA;AAAA;;AAGA;AAAA;;;;;;;;;;;;;;Ad76BA;AAAA;AAGA;AACA;AAGA;AAGA;;AAqEA;;;;;;;AAlEA;AAAA;;;;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAGA;;AAEA;AAAA;;;;AAGA;AAAA;AACA;;;;;AAQA;;;;AAsKA;AApBA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;AApJA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AA6MA;;;;;AApEA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyDA;;;;;AApEA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;;;;;;;;;;AA/IA;;;;;;;;;;;;;;;;;;AAiNA;;;;;AA7EA;;;;;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA1LA;AAAA;;;;;;AAqEA;;;;;;;;;;;;AAfA;;;;;;;;;AAIA;;;;AAEA;AAAA;AADA;;;AAEA;AAAA;;;;;;;;AATA;;;;;;;AAiBA;;;;;;;;;;AmBmmBA;AAAA;;;;;;;;;;;;;;ADnhBA;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;;;;;ACmlDA;AAAA;;;;;;;ADnlDA;;;AC6lDA;;;AAuQA;AAAA;;;;ADp2DA;;;ACumDA;;ADvmDA;ACo2DA;;;;;AAxPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AAKA;AAmPA;;;ADp2DA;;;;;;AC2nDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAyOA;;;;ADp2DA;;;;;;;;;;AC+oDA;AAAA;AAAA;AAAA;;;;AD/oDA;AAAA;AAAA;AAAA;;;;;ACypDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;ADzpDA;;AC8pDA;AD9pDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;ACo2DA;;;AAAA;;;AFxoDA;;AACA;AAAA;AACA;;AAuMA;AAAA;AAAA;;AAAA;AAAA;AEsxCA;;AFr3CA;;;AAAA;;;;AAGA;;;;;;;;;;;;AA7GA;AAAA;;AAEA;AAAA;AAAA;;;AAAA;AAAA;;;;AAmNA;AAAA;;AAAA;;;;;;AA3GA;AAAA;AAAA;;AAGA;;;AAAA;;;;AEs4CA;;;AAqJA;;;AFp6CA;AAAA;;;;AEhdA;AAAA;AAAA;AAAA;;AACA;;;AA8uDA;AF58CA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAeA;AAAA;AAAA;AAAA;;AAYA;AAlFA;AACA;AAAA;;;AAxDA;AAAA;;AAEA;AAAA;AAyIA;;;AACA;AAAA;;;;AAfA;AAAA;AAAA;;AAqBA;AAAA;AAAA;;;;AA3FA;AAEA;AAAA;AAAA;;AAzDA;AAqJA;;;;AEw6CA;;;;;;;;;;;;;;;AzBxjCA;;;AAuGA;AAAA;;AApGA;;;;AAoGA;AAAA;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AA/FA;AAAA;AACA;ACptBA;AAAA;AAYA;AAAA;ADysBA;ACrsBA;AAAA;ADssBA;ACtsBA;AAAA;ADusBA;ACnsBA;AAAA;ADosBA;ACpsBA;AAAA;ADwsBA;AACA;AACA;;;AArCA;AACA;AAEA;;;AAsHA;AAAA;;;;AA1EA;ACxtBA;;;;;;;;;;;;ADyqBA;AACA;AAEA;;;;;;;;;;;;;;;;;;AAyDA;AACA;AAAA;;;;;AAKA;AC3uBA;;;;;;;;;;;AAhBA;AAwBA;AApBA;AAAA;;;;;;;;;AD2KA;AACA;AAKA;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;AAlFA;AA9CA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AAksBA;AAAA;AChwBA;ADmwBA;ACvvBA;;;;;;;;;;AAhBA;AAwBA;AApBA;AAAA;;;;;;;;;AD2KA;AACA;AAKA;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;AAlFA;AA9CA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AAwtBA;;;;AAwBA;AAAA;;;;;;;AClzBA;;;;;;ADkzBA;AAAA;;;;;;;;;AAJA;;AAIA;AAAA;;;;;A+BygDA;AACA;;AACA;;;AAuEA;AAAA;;;;AACA;AACA;AAAA;AAAA;AACA;;AAnNA;;AAAA;;AAMA;AAMA;AA6BA;;AAAA;;AA1BA;AA2BA;AACA;;;AA7MA;AAIA;AACA;AAKA;;;;;;;;;AACA;;;;;AADA;;;;;;;;AAMA;;;;;;;;AAEA;;;;;;;;AAKA;;;;AAMA;AAAA;AAAA;;;AACA;AAEA;AACA;;;;;;;;AACA;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;AAUA;;;;;;;AAKA;AAAA;;;;;AADA;;;;;;;;;;;;;;;;;;;;AAQA;AAEA;;;;AAaA;AADA;AAGA;AAAA;AAAA;AACA;;;;;;;;;AAFA;AAIA;AADA;AAFA;AAAA;AACA;;;;AAgBA;AAIA;;;;;;;;AACA;AAEA;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;AAIA;;;;;;;AACA;AACA;;;;AAFA;;;;;;;;;;;;;;;;;;;;;;;AASA;;;;;;;;;;;;AAOA;;;;;;;AAIA;AACA;AACA;AAAA;AACA;;;;;;;;AAIA;;;;;;;;;;;AACA;;;AAGA;;;;;;;;;;AQnyEA;;;;;;;AACA;;;;AAEA;;;;;;;;;;;;;;AAkDA;;;;AArDA;;;;;;AACA;;;;;AAEA;;;;;;;;;AAgHA;AACA;AACA;;;AArHA;;;;;;;;;AACA;;;;AAEA;;;;;;;;;;;;;;AA4HA;AACA;AACA;;;AAKA;;AAtIA;;;;;;;AACA;;;;AAEA;;;;;;;;;;;;;;AA2IA;AACA;;;;AA/IA;;;;;;AACA;;;;;AAEA;;;;;;;;;AAyJA;;;AA5JA;;;;;;;;;AACA;;;;AAEA;;;;;;;;;;;;;;AAmKA;AACA;;;;AAvKA;;;;;AACA;;;;AAEA;;;;;;;;AAgLA;AACA;AAAA;AACA;AACA;;;;AAMA;;;AAEA;;AA9LA;;;;;;;AACA;;;;AAEA;;;;;;;;;;;;;;AAkMA;AACA;AACA;AACA;AAEA;;;;AA1MA;;;;;;;AACA;;;;;AAEA;;;;;;;;;AAoNA;;;AAvNA;;;;;;;;;;AACA;;;;AAEA;;;;;;;;AA8NA;AAAA;AACA;AACA;;;;AAMA;;;AAEA;;AAIA;;;;AAQA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;;;;AA/PA;;;;;;;AACA;;;;AAEA;;;;;;;;;;;;;;AAwQA;;;AAKA;;AAhRA;;;;;;;AACA;;;;AAEA;;;;;;;;;;;;;;AAqRA;;;;AAUA;AACA;AACA;;;;;;AApSA;;;;;;;AACA;;;;AAEA;;;;;;;;;;;;;;AA4SA;AACA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;ALHA;;;;;AAAA;;;;;;;AA/MA;;;;;;;;;;;AAkNA;;AAIA;;;AACA;;AAzRA;;AA4RA;;;;;;;;;AAQA;;;;;;;;AAIA;AAAA;;;;AAMA;AAAA;AAAA;;AAKA;AAAA;AAmWA;AAjWA;AAAA;;AAiWA;;AA9VA;;;;;;;;;;AAqBA;;;;AA7UA;;;;;;;;AA+YA;AACA;AAlOA;AACA;AAAA;AAAA;;AAueA;;AApeA;AAAA;AAlLA;;AAuLA;AA+dA;AAlQA;;;;AAMA;AAAA;;;;;;;AACA;;;;;;;AAEA;AAqPA;AAlPA;;;;;;;;;;;;;AArEA;AACA;AAlMA;AAAA;AACA;AAAA;;AA2fA;;AAxfA;AAAA;AA9JA;;AAmKA;AAmfA;AAtTA;;;;AAMA;;;;;;;AACA;;;;;;;;AAEA;AAySA;;;;;;;;;;;;;;;AAlpBA;;;;;AA8WA;;;;;;;;;;;AAoDA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtCA;AACA;AA9MA;AAAA;AAAA;;AAueA;;AApeA;AAAA;AAlLA;;AAuLA;AA+dA;;;;;AAtOA;AAAA;AAAA;AACA;AAtRA;AAAA;;AA2fA;;AAxfA;AAAA;AA9JA;;AAmKA;AAmfA;;;;;;AAJA;AA9QA;AAAA;AACA;AACA;AA5OA;AAAA;AACA;AAAA;;AA2fA;;AAxfA;AAAA;AA9JA;;AAmKA;AAmfA;;;AAJA;AA1NA;AAAA;AACA;AACA;AA5QA;AACA;AAAA;AAAA;;AAueA;;AApeA;AAAA;AAlLA;;AAuLA;AA+dA;;;;;;;;;;;;;;;;;;;;;;;AM5RA;AAGA;AACA;AACA;AACA;AAOA;AAAA;AAAA;AAAA;AACA;AAAA;;AAIA;AAAA;;;AACA;AAAA;;;;;;;;;AAQA;AAAA;;AAEA;AAAA;AACA;;;;;;;AAGA;AAAA;;;;;AAEA;AAAA;AACA;;;;;AAGA;AAAA;;;;;AAGA;AC8UA;AD7UA;;;;;;;;AAGA;AACA;;;;;;AA9BA;;;;;AACA;AAAA;;;;;;;;AACA;AAAA;;;;;;;;;;;;;;;AAmCA;;;;;;;;;AAIA;;;;AAEA;AAAA;AADA;;;AAEA;AAAA;;;;;;;;AATA;;;;;;;;;AAcA;;AACA;AAAA;;AACA;AAgYA;AAAA;;;AA3WA;AAGA;;;;;;AACA;AADA;;;;;;;;AAEA;AAAA;AAAA;AACA;;;;;;AA+CA;;;;AAkBA;AAAA;;;AAEA;AAuiCA;;AACA;AAAA;AAAA;;AACA;AAAA;;;;;;;;AAUA;AAAA;AAAA;;;;;;;;;;;;;AAl6CA;;AA0aA;AACA;;AAEA;AACA;AA2BA;AAEA;AAAA;AAGA;;AAEA;AACA;;AAEA;AAAA;AACA;AAAA;;;;;;;;;;;;;AAEA;AACA;AACA;;;;;;;;;;;AAFA;AACA;AACA;;;;;;;;;;;;;AAFA;AACA;AACA;;;;;;;;;;;;AAFA;AACA;AACA;;;;;;;;;;;AAFA;AACA;AACA;;;;AAEA;AACA;;AACA;AACA;AACA;;AA+BA;;AAiEA;AA6EA;AACA;AAEA;AACA;;AA9IA;;;;;;;;;;;;;;;ACicA;;AClnCA;;A/BqlEA;AAAA;AAAA;AgCz8DA;;AF4xCA;;;AA5RA;AAAA;;;;;;;;;;AAiFA;A3BjlCA;A2BkjCA;AAPA;AAVA;;;;;;AEzhCA;;;;AAjBA;AFolCA;AAAA;AAAA;AArGA;AAAA;AAhUA;AA8ZA;AA24EA;;AA3sEA;;;AApQA;AAAA;;;;;;;;;;AAiFA;A3BjlCA;A2BkjCA;AAPA;AAVA;;;;;;AEzhCA;;;;AAjBA;AFy9GA;AC1lHA;;A5BkJA;;;AAAA;;;A2BurBA;;ACt0BA;;AAGA;;AAIA;AACA;AAOA;;;AAUA;;AAVA;;;AAWA;AACA;AAZA;;;A/BikEA;AAAA;AAAA;AgCz8DA;;AF4xCA;;;AA5RA;AAAA;;;;;;;;;;AAiFA;A3BjlCA;A2BkjCA;AAPA;AAVA;;;;;;AEzhCA;;;;AAjBA;AFolCA;AAAA;AAAA;AArGA;AAAA;AAhUA;AA8ZA;AA24EA;;AA3sEA;;;AApQA;AAAA;;;;;;;;;;AAiFA;A3BjlCA;A2BkjCA;AAPA;AAVA;;;;;;AEzhCA;;;;AAjBA;AFy9GA;A9BvgDA;AAAA;AAAA;A8Bz8BA;AAAA;AEx/BA;AAAA;AAAA;AAAA;AAAA;AAjBA;AFolCA;AAAA;AAAA;AArGA;AAAA;AAhUA;AA8ZA;AA61EA;;AA7pEA;;;AApQA;;;;;;;;AAiFA;A3BjlCA;A2BkjCA;AAPA;AAVA;;;;;AEzhCA;;;AAjBA;AF26GA;AC3jHA;;A5BiKA;;;AAAA;;;AAAA;;;AAAA;;A4BhKA;;AAEA;AAAA;AACA;;AAEA;AACA;AA0BA;;;;;A1B2tCA;;;;AACA;;;;;;;;;;;;;AAIA;AACA;;;;;;;;AA9gBA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AAEA;AACA;AA4gBA;AACA;AAAA;;;;;;;;;;;AAnhBA;;;;;;;;;AAqfA;AAEA;;;AChlCA;AhBhBA;AAAA;AgBMA;AAAA;AACA;AhB3BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Ae6mCA;AAEA;;;AAwCA;;;;;AACA;AACA;;;;;;AA3hBA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;AAEA;AACA;AAAA;AAyhBA;;;;AA/hBA;;;;;;;AAoiBA;AAAA;;;;;AAOA;;AAJA;;AAIA;;;;;;;;;;;APlxCA;AAAA;AAAA;;;;;;AADA;;;;;;;;;AAooCA;AAAA;;;;AAIA;AACA;AAAA;;;AACA;;;;;AAQA;AAAA;;AACA;AAAA;AACA;;;;AACA;AAAA;;AACA;AAAA;AACA;;AAAA;;;AACA;AACA;;AAAA;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;AACA;AAwCA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;;;;;AAxsCA;AAAA;AAAA;;;;;AAEA;;;;;;;;;;AA8sCA;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;AACA;AAAA;;;;;;AAptCA;;;;;;;;AADA;;;;;;;;;;;;AA+tCA;AAAA;AAAA;AACA;AAAA;;;;;AAgXA;;;;;AA/kDA;AAAA;AAAA;;;;;;AAEA;AAHA;;;;;;;;;;AACA;AAAA;AAAA;;;;AAAA;;;;;AAAA;AAAA;AAAA;;;;;;AQ8IA;ADqdA;AAAA;AADA;;AAoEA;AACA;;AAIA;;;;;;;;;;;;;AfrjBA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;AAAA;;;;;;;;;AekkBA;AAAA;AftkBA;AewkBA;AAAA;AfpkBA;;;;;;;;;;AAAA;;AeykBA;AAAA;Af7kBA;Ae+kBA;AAAA;Af3kBA;Ae6kBA;AACA;AAEA;AAAA;AfhlBA;;;;AewlBA;AAAA;;Af5lBA;AegmBA;Af5lBA;Ae6lBA;AfjmBA;;AemmBA;AAOA;AAAA;AAAA;AACA;AAAA;AfvmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AewmBA;AAAA;AAAA;AfxnBA;AAAA;AAAA;AAAA;AAAA;AAwBA;AAAA;AAAA;AAAA;AAAA;AAAA;AgBMA;AAAA;AACA;AD4lBA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AATA;AAAA;AfvmBA;Ae0mBA;AAAA;AAAA;AACA;AAAA;AfvmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AewmBA;AAAA;AAAA;AfxnBA;AAAA;AAAA;AAAA;AAAA;AAwBA;AAAA;AAAA;AAAA;AAAA;AAAA;AgBMA;AAAA;AACA;AD4lBA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;A4BhXA;AAEA;A3C1QA;AGmxCA;AAhBA;;;;;;;;;;;ASnIA;;;;;;;;A+Br3BA;A3C3QA;A2C+QA;;;;AAkFA;AAAA;;;;;AAvBA;AAAA;A1CrbA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;A0C4cA;AAAA;;;;AAnBA;;AAmBA;AAAA;;;;AAfA;;AAeA;AAAA;;;;AAXA;;AAWA;AAAA;;;;AAPA;;AAOA;AAAA;;;;AAHA;AAAA;;AAGA;AAAA;;;;AAhFA;A3CrRA;;;;;;;;;;;;A2CqWA;AAAA;;;AAhDA;A3CzSA;;A2CyVA;AAAA;;;;;;;;;;AAAA;AAAA;;;AA7DA;A3C5RA;;A2CyVA;AAAA;;;;;;;;;;;;AAAA;AAAA;;;AA5EA;A3C7QA;;A2CyVA;AAAA;;;;;;;;;;;AAAA;AAAA;;;AAvCA;A3ClTA;;A2CyVA;AAAA;;;;;;;;;;AAAA;AAAA;;;AAnDA;A3ClSA;;A2CqVA;AAAA;;;;;;;;;;;;;AAAA;AAAA;;;AA7CA;A3C5SA;;A2CyVA;AAAA;;;;;;;;;;;AAAA;AAAA;;;AA1CA;A3C3SA;;A2CqVA;AAAA;;;;;;;;;;AAAA;AAAA;;;AAhEA;A3CzRA;;A2CyVA;AAAA;;;;;;;;;;;;AAAA;AAAA;;;;;A3CrVA;;AAAA;;A2C+RA;A3C/RA;;A2CqVA;AAAA;;;;;;;;;;AAAA;AAAA;;;;AAnEA;A3CtRA;;A2CyVA;AAAA;;AAxEA;AAAA;;A3CjRA;;AAAA;;A2CyVA;AAAA;;A3CzVA;;A2CyVA;AAAA;;;;;;;;;;;;;;;;A5C49BA;;;AAiFA;AAAA;;AA3EA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;AAOA;AACA;;;;;;AALA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AACA;AAAA;AACA;AACA;AC33CA;;AD83CA;;;;AAKA;ACv3CA;ADw3CA;ACh3CA;ADi3CA;AAAA;ACz3CA;AD03CA;AC13CA;AD23CA;AC33CA;AD43CA;AC53CA;AD63CA;AC73CA;AD+3CA;AACA;AAAA;AC54CA;AAYA;ADk4CA;ACl4CA;ADm4CA;ACn4CA;ADo4CA;ACx3CA;ADw3CA;AA/uCA;;;;;AAEA;AAAA;;;;;;;;;;;;;;;;;;AAKA;;;;;;;AA0uCA;AAAA;;;;;;;;;;;AUrsCA;;;;;;;;;;AAKA;AAAA;;;;;AAEA;;;;;;;;;;;;;;AAOA;AAAA;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;;;;;;;;;;;AAqBA;;;AAGA;AAIA;;;;;;;;;AAgBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;;AACA;;;;;;;AAKA;;;;;AAEA;AAAA;;;AACA;AAAA;;;;;;AACA;AAAA;;;;AAEA;;;;;;;;;;;AAMA;;;;;;;AAIA;;AACA;;;;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA;;;;;;;;;AAMA;;;AAEA;AACA;;AAAA;;;;;AAGA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AeqoCA;AA0ZA;;;AArZA;;;;;;;AAKA;;AAAA;AAAA;;ADp9CA;AAAA;;;;;;;;;;;;;;;;;AC89CA;;;;;;;;;;;;;;;AAsYA;AAAA;;;;;AAvXA;;;AAKA;;;ADl/CA;;;;;;;ACu/CA;;AA6WA;AAAA;;;;;;;;AAxWA;AAAA;;;;;;;;AAKA;AAmWA;;;;;AA9VA;;;;;;AAKA;AAAA;;;;;;AFxvCA;AAAA;;AA0BA;;;;;;;AAEA;;;AA1IA;;;AA2IA;;AACA;;;AAKA;AApBA;AAAA;;;;AAtEA;;;AACA;;;AACA;;AA0FA;;;AAnJA;;;;;;;;;;;AEg3CA;;;AAIA;;;AFhtCA;;;;AAAA;;;AEqtCA;;;;;;;;;;;;;;;AFxoCA;AACA;;;;;;;;;;AAlBA;;;;;;ACrYA;;;;;;AC+jDA;;;;;;;Afj4BA;;;;;;;AAEA;AAAA;AAAA;AAAA;;;;;AAEA;AA9EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAYA;AAAA;;;;;;;;AAUA;;;;;;;;;;;;AAjBA;AAAA;;;AAdA;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAYA;AAAA;;;;;;AAMA;AAAA;;;;;;;AAIA;;;;;;;;;;;;AAjBA;AAAA;;;AAdA;;;;;;;;;AADA;;;;;;;;;;;;;;AA0CA;;;;;;;;;;AAMA;;;;;;;;;;;;AmCrhBA;A5C7MA;A4CiNA;AAAA;;;;A5CrMA;;A4CiSA;AAAA;;;;A5CjSA;;A4CiSA;AAAA;;;;AzCs+BA;AAhBA;;;;;AyC/sCA;;AAGA;AACA;AACA;AACA;;AhCskCA;;;AgCt6BA;AACA;A5C3NA;A4C2NA;A5C/MA;A4CgNA;;AAiFA;AAAA;;;;AA5EA;A5CjOA;AGmxCA;AAhBA;;;;;;;;;;ASnIA;;;;;;;;;;;;;;;;;;;;;;AgCv5BA;AAAA;;;;;;;;;;;AAQA;;;;;AACA;;;;;;;AAOA;AAAA;;;;;AAEA;A5C3OA;;;;;;;;;;;;;;;A4CmPA;A5C3PA;;;;;;;A4C+PA;A5C/PA;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAAA;;;;AAAA;;;;;;;;;;;;;;;A4CiRA;;;;;;;;;AAMA;A5CnSA;AAwBA;A4C6QA;;;;;;AAMA;AAAA;;;;;A5C3RA;;A4CiSA;AAAA;;;;;;;;;;;;;;;;;AlBtNA;AAEA;ATmMA;AAAA;AAAA;;;ASlMA;;ATkMA;AAAA;;AjB5RA;;AAAA;AAAA;;;;;A0BiGA;AAAA;;;;;;AASA;AAEA;AAAA;;AACA;;;AT+KA;;;;AAAA;;AAAA;ADlRA;AAAA;AAAA;;AhBVA;AAAA;AAAA;;;AAAA;A0BgHA;;AAGA;AAAA;AAAA;;AAAA;A1BvGA;AAAA;;;;;;;;;AiBgRA;;AAAA;ASjKA;AAAA;AAAA;;ATiKA;AAAA;AAAA;;AAAA;ASjKA;A1B3HA;;;A0B6HA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;;;A1BpHA;AAAA;;A0BsHA;AAAA;AAAA;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;;AToJA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;;;AS9IA;AAAA;AAAA;;AAAA;AAAA;AADA;;A1BhIA;AAAA;AAAA;;A0BoIA;AAAA;AAAA;;;;;;;;;;AAMA;AAAA;;AACA;AAAA;;ATqIA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;ASnIA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AWycA;AAEA;AACA;;;;;AD/oBA;AAAA;AAAA;ACopBA;;;AAEA;AAAA;AAAA;AACA;AACA;AD0vBA;;ACwIA;AACA;AACA;;;;;;;;;;;;;AA33BA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;AAMA;;;;;;;;;;;AAWA;AD/MA;;;;AAnIA;;;;;;;;;AAAA;;;;;;;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmIA;ACojCA;AACA;AACA;AAh2BA;AAAA;AAAA;AACA;;;;;;;AA/LA;AAAA;;;AAaA;;AAGA;AACA;AAAA;;;;;;;AA/jBA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAovBA;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;ArChqBA;;;;;A6C4RA;;;;;;AA7HA;AAIA;AACA;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;;;A7C3JA;AAAA;AAAA;AAAA;AARA;AAYA;A6CgNA;AACA;;;A7CjNA;;AAAA;A6C4NA;A7C5NA;A6C6NA;A7C7NA;A6C8NA;A7C9NA;;AAAA;A6CkOA;A7ClOA;A6CmOA;A7CnOA;;A6CqOA;A7CzPA;A6C0PA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;A7C9OA;;AAAA;A6CkKA;A7ClKA;A6CmKA;A7CnKA;A6CoKA;A7CpKA;;AAAA;A6CwKA;A7CxKA;A6CyKA;A7CzKA;;A6C2KA;A7C/LA;A6CgMA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AA+DA;;;;;;;;;;;;;;;;AAGA;AACA;A7CvPA;AAAA;AAAA;A6C6PA;AACA;AACA;AACA;AACA;AACA;AAfA;;;A7C3PA;A6C+QA;A7C/QA;A6CgRA;;;;;;;;;;;AFhGA;A3CxLA;A2C4LA;AAAA;;;;AxCulCA;AAhBA;;;;;AwCttCA;;AAGA;;AACA;;;AAIA;;AAGA;AACA;AACA;AACA;;A/BqkCA;;;A+B97BA;A3ClMA;A2CkMA;A3CtLA;A2CuLA;;AA8DA;AAAA;;;;;AAAA;AAAA;;;;AAxDA;A3CzMA;AGmxCA;AAhBA;;;AwClgCA;AAAA;;;;;;;;A/B+3BA;;;;;;;;;;A+B/3BA;AAAA;;;;AAAA;AAAA;;;;;AAjDA;AAAA;;AAiDA;AAAA;;;;;;AAAA;AAAA;;AAzCA;AAAA;;AAyCA;AAAA;;;;AAnCA;AAAA;;AAGA;AACA;AACA;;AA8BA;AAAA;;AA7BA;;;AA6BA;AAAA;;AA3BA;A3CtNA;;A2CiPA;AAAA;;;;;AArBA;A3CpOA;;A2CyPA;AAAA;;;;AAjBA;AAAA;;A3CxOA;;AAAA;;A2CyPA;AAAA;;A3CzPA;;A2CyPA;AAAA;;;;;;AAVA;;;AAUA;AAAA;;AATA;A3ChPA;;A2CyPA;AAAA;;;;AAHA;AAAA;;AAGA;AAAA;;;;;;;;;;;AbyrEA;;AAKA;;;;AAvfA;;;;AAMA;;;AAEA;;;;;;AAQA;AAIA;;AAQA;AAAA;;;;;AAQA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAlDA;AAAA;;;;;;AAyDA;;;AAEA;;;;;AAKA;;AAgbA;AA/GA;;AAGA;AACA;AAAA;;AAGA;AAyHA;;;;;;;;;AOhwCA;;;;;;;AD/5BA;;;;;;;;;AACA;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACw3BA;AD5RA;AAp6BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACisCA;AAAA;AAAA;AACA;AAEA;;;;;;AD3WA;;;;;;AAAA;;;;AAtfA;;;;;;;;;;AAAA;;;;;;;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACu1BA;ADptBA;ACojCA;AACA;AACA;;AArTA;;;AAjCA;AAAA;AAAA;;AACA;AAmVA;AACA;AACA;;AArTA;;;AAdA;;AAcA;;;;AAAA;;AALA;AAwTA;AACA;AACA;;AArTA;;;;;;;;AV1xCA;AADA;AxByVA;AACA;AAAA;AOsvDA;APhjDA;AAAA;AAAA;;;;;;;AAoSA;;AUrsBA;AVssBA;AAAA;AACA;AAmRA;AOubA;;AAGA;AACA;AAAA;AiBjhDA;AAAA;AAAA;;;;;;;;;;;;;;AfytCA;;;;;;;;;;;;;;;;AeztCA;AAAA;AAAA;;;;;AAKA;;;;;;;;;;;;AfotCA;;;;;;;;AeptCA;;;;;;;;;;;;AfotCA;;;;;;;;AeptCA;;;;;;;;;;;;AfotCA;;;;;;;;AeptCA;;;;;;;;;;;;AfotCA;;;;;;;;AeptCA;;;;;;;;;;;;AfotCA;;;;;;;;;ARlpCA;;;AuB3DA;AAAA;;;;;;;;;;;;;Af6sCA;;;;;;;;Ae7sCA;AAAA;;;;;;;;;;;;;Af6rCA;AejlCA;AACA;AAIA;AA6IA;AACA;AAGA;AAAA;AACA;AAGA;AAAA;AAAA;AAGA;AAAA;A3BxLA;AAYA;A2B6KA;AAAA;A3BzLA;AAAA;AAYA;A2B8KA;A3B9KA;A2B+KA;AACA;AACA;A3BrMA;A2BwMA;A3BpLA;A2BqLA;AACA;AACA;A3B3MA;A2B2MA;AACA;AAAA;AACA;AACA;AACA;AAGA;A3BtMA;A2BuMA;A3B/LA;A2BgMA;AACA;AACA;A3BlMA;A2BmMA;AACA;AACA;A3BzNA;A2ByNA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AAGA;A3B7NA;AAYA;A2BkNA;AACA;AAGA;A3B9NA;A2B+NA;A3B/NA;;A2BoPA;;;A3BpPA;AAAA;AAZA;;A2BuPA;A3BvPA;AAAA;AAYA;;AAZA;A2BgQA;;;;;;;;;AHqsBA;AAAA;;AAGA;AxBh7BA;AgBMA;AAAA;AACA;AQ06BA;AAwFA;;;;;;;AA/EA;AAAA;AxBl9BA;;;;;AwBq9BA;;;;;;;;;;;;;AAKA;AAAA;;;;;;;;;;;;;;;AAIA;AAAA;;;;;AxB99BA;AwBq+BA;AAAA;;;;;;AAEA;;;;;;;;;;;;;;AAKA;AAAA;;;;;;;;;;;;;;;;;AAIA;AAAA;;;;;;;;AAUA;AAAA;AxB1/BA;;;;;AwB6/BA;;;;;;;;;;;;;AACA;AAAA;;;;;;;;;;;;;;;;AAEA;AAAA;;;;;;;;;;;;;;;AAEA;AAAA;;;;;AxBlgCA;AwBwgCA;AAAA;;;;;;AAEA;;;;;;;;;;;;;;AAEA;AAAA;;;;;;;;;;;;;;;;;;AAGA;AAAA;;;;;;;;;;;;;;;;;AAKA;AAAA;;;;;;;;;;AAMA;;;;;AAOA;;;;AAHA;AAGA;;;;;;;;;;;Aa98BA;AAAA;AAAA;AAAA;;AA9EA;AAAA;AACA;AAAA;;;;AAGA;;;;;;;AAIA;AAAA;;;AAIA;AAAA;AAMA;;;;;AAGA;AAAA;AAMA;;;;;;AAqCA;;;;;AA7BA;;AACA;AAAA;;AAAA;AAAA;;AAEA;;;;;AAEA;AAAA;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;;;;;AAMA;;;;;;;;;;;;;;;;;AAaA;;;;;AAKA;;;;AAEA;AAEA;AAAA;AAAA;AAAA;;;;;;AzBiiCA;ADprCA;AAhCA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAAA;AAgCA;AA3BA;AAAA;AACA;AADA;AACA;AADA;AACA;AA6BA;AA9BA;AACA;AA8BA;AA/BA;AACA;AADA;AACA;AADA;AACA;AATA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAHA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAHA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAHA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAkFA;;;AA7EA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAAA;AAAA;;AATA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAHA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAkFA;;;;;A0BwzCA;AA13BA;AAAA;;;;;;;AAcA;AAAA;AAAA;;;AAGA;AAAA;;;;;;;;AAIA;;;;AAGA;;AAEA;AAtBA;AAAA;AAAA;AAJA;;;;AAMA;AAAA;AAs3BA;;AAAA;;ADnrCA;AA7DA;AAAA;;;;;;;;AAgEA;;;;;AAAA;;;;AADA;;;;;;;;;;;;;AAvGA;;AAqGA;AA7DA;AAAA;;;;;;;;AAgEA;;;;;AAAA;;;;AADA;;;;;;;;;;;;;AAvGA;;AAqGA;AA7DA;AAAA;;;;;;;;AAgEA;;;;;AAAA;;;;AADA;;;;;;;;;;;;;AAvGA;;AAqGA;AA7DA;AAAA;;;;;;;;AAgEA;;;;;AAAA;;;;AADA;;;;;;;;;;;;;ACksCA;;;ADzyCA;ACyyCA;;;;;;;;;;;;ASx5CA;ACAA;ADIA;AAMA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAlBA;ACAA;ADIA;AAMA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAlBA;ACAA;ADUA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;;AACA;;AACA;AA8PA;AAzRA;ACAA;ADIA;AAMA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAlBA;ACAA;ADIA;AAMA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAlBA;ACAA;ADUA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;;AAEA;AAkQA;AAGA;AAAA;AAAA;AAAA;;AAtQA;AACA;AAkQA;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;AzCwDA;;;;;AA7CA;;;AAGA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;;;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;;;;;;;;AAUA;;;AArKA;AApBA;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;;;;;;;;;AAiLA;;;;;;;;;;;;;;;;;;;;;;;AA/GA;;;;AA7EA;;;;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;AA0LA;;;;;;;;;;;;;;;;;A2C1KA;AAAA;;;AAqDA;AAAA;;AA/HA;;;AZ2dA;;AAAA;;;AA2iCA;AYhgDA;;;;;AAMA;;;;;;;;;AAIA;;;;AAKA;;;;;AALA;;;;AAKA;;;;AALA;;;;;AAKA;;;;AAiFA;AAAA;;;;;AA7CA;;;;;;;;;;AAAA;;;;;AAoDA;;;;;;AAOA;;;;AAMA;AAAA;;;;;AAEA;AAnRA;AAFA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAmRA;;;;;;;AA5BA;;;;;;;AALA;;;;;;AArFA;;;;;;AAPA;;AAgIA;AAAA;;;;;;AlC0NA;AADA;;AAIA;AAAA;AAEA;AAAA;AACA;AACA;;;AAiCA;;;;;;;;;AAEA;AADA;;;;;;;AAOA;AADA;;;;AAhCA;AAAA;;;;;;;;;;AA2BA;AADA;;;;;;;;;AAOA;AADA;;;;;;;;AALA;AADA;;;;;;;;;AAOA;AADA;;AADA;;;;AAlCA;AAAA;;;;;;;;;;AA8BA;AADA;;;;;;;;;;;AAOA;AADA;;AADA;;;;;;;;;;;AAJA;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;AuBlPA;AAEA;;;AAsEA;;AAtEA;;;;;AAOA;;;AA+DA;;AU3UA;;;AV2UA;;;;AAAA;;AApDA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;AAiDA;;;;;;;AAAA;;;;AU3UA;;;AV2UA;;;;AAAA;;AAnBA;;AAGA;;;;;;;;;;;;;;;;AAEA;;AAFA;;;;;;;;;;;;;AAgBA;;;;;;;;;;;;;;;;;;;;;;;AA9FA;;;;AAVA;;;;;;AAcA;;;AAIA;;;;;;;;;;;;;;;;AAIA;;;;AAkFA;;;;AEpEA;;AACA;AAAA;AAAA;AAAA;;AAGA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;;;;;;;;;;;;;;;AAMA;AAAA;AACA;AAAA;;AA+3BA;AAAA;;AACA;AAlBA;AvCnhCA;AuCs9BA;AAgEA;AAIA;AAAA;;AACA;;AAjCA;AACA;;;;AAiDA;;AAQA;;AA9FA;AAAA;;;;;;;;;;;AAAA;AA0GA;;AAv5BA;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AACA;AAAA;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAKA;;;;AACA;;;;;;;;;;;AZxGA;;;;;;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;AA6DA;AAAA;;;;;A3BxJA;A2B+GA;A3B/GA;A2BgHA;A3BhHA;A2BiHA;A3BjHA;A2BkHA;A3BlHA;A2BmHA;A3BnHA;A2BsHA;;;AAEA;A3BpHA;A2BmHA;;;A3BnIA;;A2BoKA;AAAA;;AAzBA;;AAyBA;AAAA;;AAvBA;A3B7IA;;;;;;;;;A2BoKA;AAAA;;;AApBA;A3BhJA;;A2BoKA;AAAA;;AAjBA;A3BnJA;;A2BoKA;AAAA;;AAZA;AAAA;AA7DA;;;;;;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;AA6DA;AAAA;;;;;A3BhJA;AC/HA;;;A0B+QA;AAAA;;AAHA;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AsBxPA;;;;;;;;;AAiJA;AjD7DA;;AiD+FA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAhCA;AAGA;AjDxEA;;AiDwFA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAZA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AjDtEA;;AiD6FA;AjDzFA;AiD4FA;AAAA;;;AAhDA;AAgDA;AAAA;;;;;;;;;;AnBsaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAkSA;AACA;AACA;AAAA;AAAA;AAIA;AAGA;;;;;;;;;;;;;;;;;;;;AA9kBA;;;;;AA+kBA;AAAA;;AA0DA;;;AA5BA;AAAA;AACA;AAl0BA;;;;;;AAGA;AAEA;;;;AAGA;;;;;;;;;;;;AACA;AAAA;;;AA0zBA;AACA;AAAA;AAAA;AAAA;AAIA;AAGA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA5nBA;;;AA6nBA;A1Bz5BA;;;;;;A0B85BA;AAAA;AADA;;;;AAIA;;;;;;;;;;;;;;;;;;A1B34BA;AAAA;AQwoCA;AkBlxBA;AACA;AACA;AAIA;AAAA;AAkhBA;AACA;;;;;;;;;;;;;;ACiKA;AAAA;;;;AAAA;AAAA;;AAvlCA;AAAA;;AAuYA;AACA;AAwqBA;AACA;AAAA;AAAA;;;;;;;;;AA/dA;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;AAEA;;;;;;;;;;;;;AAweA;AACA;;;;;;AA3eA;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAFA;;;;;;;;;;;;;AAEA;;;;;;;;;;;;AAyfA;;;;;;AA7kCA;;AAulCA;AAAA;;;;;;AM6NA;;;AAoBA;;AD30BA;AAAA;;;AAnIA;;;;;;;;;AAAA;;;;;;;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;;;;;;AC88BA;;;;;AAAA;;;;;;AAdA;AAAA;;;;;;ADtcA;AAAA;;;AA1fA;;;;;;;;;AAAA;;;;;;;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACg8BA;AAAA;;;;;;;;AAcA;;;;;;;;AAAA;;;;;;;;AOr9BA;AAEA;A5CtTA;A4C0TA;A5C1TA;AGmxCA;AAhBA;;;;;;;;;;ASnIA;;;;;;;;;;;AgCj0BA;;;;;;;;;;AAoBA;AAAA;A3C9bA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;A2C4aA;A5CjUA;;;;;A4CkUA;A5CtUA;AAgBA;AAJA;A4C6TA;A5C7TA;;;;;;;;;;;;;;;A4C+UA;AAAA;AAAA;A5C/UA;;;;;;;;;;;;;;;A4CsVA;A5ClVA;;;;;;;;;;;;;;A4CyVA;A5CrVA;;;;;;A4CyVA;AAAA;;;;;A5C7VA;A4CmWA;AAAA;;;;;;;;;;A5C3VA;;AgCwPA;;;AAvBA;AhCrPA;AgCwPA;AAAA;AC4nBA;;ADxmBA;;;;;;;;;;;;AC49DA;;;;;;;;AAHA;;;;;;;;;ADz9DA;;;;AAAA;;;;;;;AEnYA;;AD+3DA;;;;;;;;;;;;;;AAUA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ApB/uDA;AH0zCA;AANA;AuBmhBA;AACA;AACA;AAEA;AACA;;;;AACA;;;AACA;AACA;;;ADvnDA;;AAiBA;;;AAZA;AhC5OA;AC/HA;AAAA;AAAA;;AAAA;AAAA;AAAA;;A+BgXA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;;;;;;;;;;;A3B9RA;;AAgCA;;;;;;AA/BA;AAAA;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;;AA5BA;;;;;;;AAgCA;;;;;;;AgCiaA;AAAA;;;;;;;AAcA;AAAA;AAAA;;;AAGA;AAAA;;;;;;;;AAIA;;;;AAGA;;AAEA;AAtBA;AAAA;AAAA;AAJA;;;;AAMA;AAAA;AA84BA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;;AAAA;;AACA;AA0EA;AACA;AACA;;;AAyBA;;AAnBA;AAAA;;AAwFA;AACA;AACA;;AAvEA;;AAZA;AAEA;ADzoCA;;;;;;;;;;AACA;AADA;;;;;;;;;;;;AC2oCA;AA50CA;AAGA;;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAk5CA;AACA;AACA;;AAvEA;;AAFA;;AAEA;;;;;;;;AJ50CA;AAAA;;;;;;;AA2cA;AA1cA;;;;;AAxMA;AAAA;AAAA;;AA6MA;;;;;AACA;;;;;;;;;;;;AA0BA;;;;;;;;AAvBA;;;;;;;;;;;;;;;;AAvDA;AAAA;AACA;AAAA;;;;AA2fA;;;AAxfA;AA9JA;;AAmKA;AAmfA;;;;AAxbA;AAEA;AAlDA;AACA;AAAA;AAAA;;AAueA;;AApeA;AAAA;AAlLA;;AAuLA;AA+dA;;;;AAxeA;AACA;AAAA;AAAA;;;;AAueA;;;AApeA;AAlLA;;AAuLA;AA+dA;;;;;;;AA9ZA;AAEA;AAhGA;AAAA;AACA;AAAA;;AA2fA;;AAxfA;AAAA;AA9JA;;AAmKA;AAmfA;;;;;;;;;;;AiBtRA;AAGA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;AAGA;AAgFA;;;AAvEA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;AAKA;AAKA;AACA;AAEA;AAIA;AlDlUA;;;;AkDoUA;AlDpUA;AkDoUA;AAAA;AAEA;AAAA;;;;AAWA;AALA;;AACA;AlD7UA;AAwBA;;;;AAxBA;AAwBA;;AkD0TA;;;;AACA;AADA;;;;AjD3bA;;AiD+bA;AAAA;;;;;;;;AAYA;;;AAWA;;;;;;;;AAEA;AACA;AAGA;AACA;AAAA;AAEA;;;;AAPA;AACA;AAMA;;;;;;;AjCtFA;AAAA;AAAA;;AjBxRA;AAAA;;A0B/BA;;;;;;AAAA;AACA;;A1B0CA;A0BxCA;;;;;;AAOA;AAAA;;AT4SA;AAAA;AAAA;;;AAAA;AAAA;;;;;;AAAA;AAAA;;;;;AjBvRA;AAAA;;A0BjBA;AAAA;AAAA;;;AADA;AAAA;;AAEA;A1B4BA;;A0B1BA;;;;;;;;AASA;;;AAEA;;;;;;;;AASA;AAEA;ATgRA;AAAA;;AAAA;AS9QA;;AAEA;;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;AAWA;;AT8PA;;AAAA;;AAAA;AjB5RA;AAAA;;AAAA;AAAA;AAAA;;;A0BmCA;;AADA;;;;;A1BtBA;;;A0B0BA;;;;;;;AAWA;AAAA;;;;;;;;;;;;;AnBohBA;AAAA;AAAA;;;AACA;;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmBA;AAAA;AAAA;;;AAKA;;AADA;AAAA;;;;;;;;;;;;;;;;;;AAmBA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;AAsBA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;;;AAtBA;AAsBA;;;;;;;;;;;;;;;;;;;;;;AQeA;AAAA;AAtBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtmBA;ADyhCA;AAAA;AAAA;AAKA;;;;;;;AA3ZA;;;;;;;AACA;;;;;;;AAEA;;;;;;;AAYA;;;;;;;AACA;;;;;;;AACA;;;;;;;AACA;;;;;;;AACA;;;;;;;AACA;;;;;;;AACA;;;;;;;AACA;;;;;;;AACA;AAAA;;;;;AAAA;;;;;;;AACA;AAAA;;;;;AAAA;;;;;;;AACA;;;;;;;AACA;;;;;;;AACA;;;;;;;AC9pBA;ADyhCA;AAAA;AAAA;AAKA;;;;;;;;AAzXA;AAAA;;;;;;;;;;Ae3LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAqGA;AADA;AAAA;AAEA;AAEA;AAGA;;AAUA;;AAGA;AAAA;;AA3ZA;;AAoaA;AA5CA;;;;;;AAiDA;AAIA;AAMA;AA6BA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AAIA;AAAA;AAAA;AAUA;AASA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAjfA;;;AAkfA;A1B9wBA;;;;;;A0BoxBA;AAFA;;;;AASA;;;;;;;;;;;;;;;;;;A1BrwBA;AAAA;AQwoCA;AkBlxBA;AACA;AACA;AAIA;AAAA;AA4YA;AACA;;;;;;;;AqB30BA;;;AnD0FA;AmDrFA;AnDiFA;AAAA;AmDhFA;AnDgFA;AAAA;AmD/EA;;;;;;;;;;;;;;;;;;;;;;;AnD2FA;;;;;;;;;AAZA;AmDzCA;AnDqDA;;;;;;;AAZA;AAYA;;;;;;;AmD7CA;AnD6CA;;;;;;;;;;;AAYA;;AAAA;AmDhFA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AnDgFA;AmDzEA;AAAA;AACA;;;;;;AAGA;;;;AAPA;;AAuCA;AAAA;;AARA;;AAQA;AAAA;;AAJA;AAAA;;AAIA;AAAA;;AAAA;AAAA;;;;;;;;;;;APsGA;A5C7EA;A4C8EA;A5CtFA;A4CsFA;A5C1EA;A4C2EA;A5C3FA;A4C+FA;AAAA;A5C/FA;AAYA;AAAA;AAIA;AGuwCA;AAhBA;;AyCrnCA;AAAA;;;;;AAvCA;AACA;AAAA;AAEA;;AAIA;AACA;AACA;;AAEA;AAAA;AAIA;A5C1GA;A4C2GA;A5CvGA;A4CwGA;A5CxGA;A4CyGA;A5CzGA;A4C0GA;A5C1GA;A4C2GA;A5C3GA;A4C4GA;A5C5GA;A4C6GA;A5C7GA;;A4CiHA;A5CjHA;A4CkHA;A5ClHA;A4CoHA;;AAKA;AACA;AACA;;;AhCq/BA;;AgCl/BA;AAAA;;;;;;;;AvCqHA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;AAxHA;;;;AAyHA;AAAA;AAAA;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;AAOA;;;;;;;;;;;;AEkFA;AAKA;AAEA;AAGA;;;;;;;;;;;;;;AAxBA;;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAqFA;AAAA;AACA;AACA;AAAA;AACA;AA7cA;AACA;AACA;AACA;;;;;;AAudA;;;;;;;;;AA6EA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAxLA;;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAyHA;AACA;AACA;AACA;AAAA;AACA;AAAA;;AAEA;AAGA;AAEA;AACA;AACA;;;AAIA;;AAEA;;;;;AAiCA;;AAniBA;AACA;AACA;AACA;;AAuiBA;AAAA;;;;AAAA;AAAA;;;;;;AiBoVA;;;;;AADA;;;;;;;AxBp1BA;;AAAA;AAAA;;;AgBOA;;;;;;;;;AQ21BA;AAAA;AAAA;AACA;;;;AxBn2BA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AwB+2BA;;;;AR/1BA;;;AAAA;AhBhBA;AAAA;AAAA;AAAA;;;;AAAA;AgBMA;;AQq3BA;AxBv4BA;;;;;AAAA;;;;AwBk5BA;;;;;;;AxBl5BA;;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;A6CnFA;;AACA;AACA;AAEA;AACA;AACA;;;AAMA;AAAA;AAIA;AAAA;AAAA;;;;;;;;AAQA;;;;AACA;;;;;;;AAEA;;;;;AAEA;;;;;;;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;;;;;;;;;;;;;;;;;;;;AAUA;AAAA;;;;;AA6DA;;;;;;;;;AApDA;;;;;;;;AAIA;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;AAUA;AACA;AAEA;AAEA;AAAA;AAEA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;;;;;AAIA;AACA;AACA;;;;;AAGA;;;;;;;;;;;;;;;;;;ArB61BA;AAAA;;AAIA;AxBn3BA;AgBMA;AAAA;AACA;AQ62BA;AAgDA;;;;;;;AAzCA;AAAA;AxBv4BA;;;;;AAAA;;;;;;AwBk5BA;AxBl5BA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AwBq5BA;;AxBr5BA;;;;;AAAA;AwB85BA;AxB95BA;AwBi6BA;AxBj6BA;AwBi6BA;AxBj6BA;AwBi6BA;AxBj6BA;AwBi6BA;AxBj6BA;AAAA;;;;;;;AwB66BA;AAGA;;;;AApCA;;AAoCA;;;AAPA;AAOA;;;;;;;;;;;;AzBlVA;AAAA;AACA;AAAA;AACA;AACA;AACA;;AAGA;ACjnBA;AAAA;AAYA;ADwmBA;ACxmBA;;ADwmBA;;AAGA;ACnnBA;ADqnBA;AAAA;;;AAoDA;AAAA;;;;;AA/CA;;AA+CA;AAAA;;;;;AA1CA;;AA0CA;AAAA;;;;;AArCA;;AAqCA;AAAA;;AAlCA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AChpBA;ADkpBA;AAAA;;;AA2BA;AAAA;;AAzBA;AAAA;;AAyBA;AAAA;;;;;AAnBA;;AAmBA;AAAA;;AAjBA;AACA;ACjpBA;ADmpBA;AACA;AAEA;AAAA;;;AAWA;AAAA;;AATA;AAAA;;AASA;AAAA;;;;;AAAA;AAAA;;;;;;;;;;;;AiC9nBA;AACA;AACA;;;AA6BA;AAAA;;AA3BA;AAGA;AhCtCA;AgCuCA;AAAA;AhC3CA;AgC4CA;AAAA;AhC5CA;AgC8CA;AhC1CA;AgC2CA;AhC3CA;AgC4CA;AhChDA;AgCiDA;AhC7CA;AgC+CA;AhCnDA;AgCqDA;AhCjDA;AgCkDA;AhClDA;AgCmDA;AhCnDA;AgCoDA;AhCpDA;AgCqDA;AhCrDA;AgCsDA;AhCtDA;AgCuDA;AhCvDA;AgCwDA;AhCxDA;AgCyDA;AhCzDA;AgC0DA;AhC1DA;AgC2DA;AhC3DA;AgC4DA;AhC5DA;;AgC8DA;AAAA;;;;;;;;;;;;AoBhJA;AAAA;;AA/CA;AACA;;;AA8CA;AAAA;;AA1CA;AAAA;AACA;AAAA;AACA;AAGA;AAAA;AAAA;;;AAqCA;AAAA;;AA/BA;AACA;AACA;AAAA;;AACA;;;AAGA;AACA;AAAA;AAGA;ApDuGA;AoDtGA;AAAA;ApDkGA;AoDjGA;ApDiGA;AAIA;AoDlGA;ApDkGA;AoDjGA;ApD6FA;AoD5FA;ApDgGA;AoD9FA;ApD8FA;AoD7FA;AAAA;ApDyFA;AoDxFA;ApDwFA;AAIA;AoDzFA;ApDyFA;AoDxFA;ApDoFA;AoDnFA;ApDuFA;AoDrFA;;;;AAGA;AAAA;;;;;;;;;AjCgRA;AnBlMA;AmBmMA;AhBwkCA;AAhBA;;AgB1gCA;AAAA;;;;;AAxCA;AACA;AAAA;AAEA;;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;;AAEA;AAAA;AAIA;AnBrNA;AmBsNA;AnBtNA;AmBuNA;AnBvNA;;AmB4NA;AnB5NA;AmBmBA;AAgBA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;AACA;;;;;;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAoLA;AACA;;AAKA;AACA;AACA;;;AP04BA;;AOv4BA;AAAA;;;;;;;;;;;;;;;AKuTA;AAAA;;;;;;AAgIA;AAAA;AxBpqBA;AAAA;AwBq3DA;;;;;;;AxBz3DA;AAAA;AAAA;AwBy3DA;;AI/6DA;;;;;;;;;AJ8lBA;;;;;;;;;;AAi1CA;;;;;AR71DA;AAAA;;;;;;AQghCA;AACA;AADA;;;;;;;;;ADpiCA;;AAEA;AAEA;;AD+UA;AAAA;;;;;;AO3bA;;ALqqCA;AAozBA;AAnzBA;AAAA;;;;;;AF/4BA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;ApB5GA;;AAzDA;;;;;;;AAhIA;;;;;;;;AAKA;AACA;AACA;AACA;AAAA;;;;;;;;AAKA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;AAKA;AAIA;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAIA;AAIA;AAGA;AAGA;AAMA;AAGA;AAEA;;;;;;;;;;;;;;;;AAkCA;;AA5BA;AACA;AACA;AACA;AACA;AAGA;;;AAqBA;;AAfA;;;AAeA;;AAyDA;;AAzDA;;;;;;;;A4CtHA;ACAA;ADIA;AAMA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAoOA;AAtPA;ACAA;ADIA;AAMA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAsOA;;;AAkBA;AAAA;;;;;AAAA;AAAA;;;AAbA;AACA;AArRA;;;AAEA;AACA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkRA;AACA;AACA;AAzRA;;;AAEA;AACA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsRA;;AAMA;AAAA;;;;;;ATi7BA;;;;;;;;AD9SA;;;;;;AAtfA;;;;;;;;;;AAAA;;;;;;;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACuzBA;;;;AAXA;AAAA;AD3OA;AAp6BA;;AAAA;AAAA;AAAA;AAAA;ACgpCA;AAAA;;;AA9rCA;AACA;AACA;AAAA;AAOA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAyrCA;AAAA;;AAEA;;;;;;AO19BA;A5ChJA;AAAA;A4CmJA;A5C3JA;AGmxCA;AAhBA;;;;;;;;;;ASnIA;;;;;;;;;;;AgCl+BA;AAAA;;;;AAEA;A5ChJA;A4CmJA;A5CvKA;AAwBA;A4CgJA;A5CxKA;A4CyKA;A5CzKA;AAAA;;A4C8KA;;;;;;A5ClKA;AAAA;AAAA;;;;;;;;;;;AAAA;A4C0LA;A5C1LA;;;;;;;;;AAIA;A4CwLA;;;;;;AD7DA;A3C/HA;AAAA;A2CkIA;A3C1IA;AGmxCA;AAhBA;;;AwCplCA;;;;;;;;A/Bi9BA;;;;;;;;;;A+Bj9BA;;;;AAAA;;AAlCA;;;AAkCA;;AA9BA;A3CrJA;AAwBA;A2C8HA;A3CtJA;A2CuJA;A3CvJA;AAAA;A2CwJA;;AACA;A3CzJA;A2CyJA;A3CzJA;;A2CmLA;;;;AAAA;;AArBA;;;;AAqBA;;;;;AAAA;;;;AAAA;;;A3CvKA;A2CqKA;A3CrKA;;A2CuKA;;;;;;;;;;AZnFA;AAAA;;AA9CA;;;AA8CA;AAAA;;AA3CA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AACA;AACA;;AAmCA;AAAA;;AA/BA;AAAA;;AAAA;AAAA;;AACA;AACA;AAAA;AAjHA;AAcA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAGA;AAJA;;;AAQA;AAGA;;;;AAuFA;AACA;;;AA0BA;AAAA;;;;;;;;;;;;;;;AATA;;;;;;;;;;AANA;AACA;AACA;;AAaA;AAAA;;AATA;;;AASA;AAAA;;AANA;AACA;;AAKA;AAAA;;AAAA;AAAA;;;;;;;;;AvBgfA;AACA;AAAA;AACA;AACA;AACA;ARplBA;AAYA;AQ0kBA;ARtkBA;AQukBA;ARvkBA;AQ0kBA;AACA;AACA;AACA;AACA;AR9lBA;AAYA;AQolBA;ARhlBA;AQilBA;ARjlBA;AQolBA;AACA;AACA;AACA;AACA;ARxmBA;AAYA;AQ8lBA;AR1lBA;AQ2lBA;AR3lBA;AQ8lBA;AACA;AACA;AACA;AACA;ARlnBA;AAYA;AQwmBA;ARpmBA;AQqmBA;ARrmBA;AQsmBA;;;;;;;;;;;A6B+OA;;;AAsBA;AAAA;;AArBA;;;;;;AAqBA;AAAA;;;;;;ADtlBA;AADA;;;;;;;;;;;ACulBA;AAAA;;;;AAAA;AAAA;;AAXA;AD5kBA;;;;;;;;;;;AACA;AADA;;;;;;;;;;;;;;;;;;;;;;;;ACulBA;AAAA;;;AALA;AAAA;AACA;AAl7BA;AAGA;;;;;;;;;;;;;AAKA;AALA;;;;;;;;AA7BA;;;AACA;;AAAA;;;ADqDA;AACA;AACA;;;;;ACw5BA;AAAA;;;;;;;;;AM7yBA;A3ClEA;A2CmEA;AxCwsCA;AAhBA;;AwCtoCA;AAAA;;;;;AA5CA;AACA;AAAA;AAEA;;AAIA;AACA;AACA;;AAEA;AAAA;AAIA;A3CpFA;A2CqFA;A3CjFA;;A2CoFA;A3CpFA;;;;A2CuFA;A3CvFA;;;;;;A2C4FA;A3C5FA;A2C6FA;;AAEA;;AACA;;AAGA;AAAA;A3CvGA;A2CwGA;A3CxGA;A2C4GA;AACA;AACA;;;A/BsgCA;;A+BngCA;AAAA;;;;;;;AnBm+BA;AAiyBA;;;AA/wBA;AAAA;AAAA;;;;;AAEA;;;ARpmCA;AC2QA;AD1QA;;AapFA;AAAA;;;;;AL2rCA;;;;;AP71BA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AM3QA;;AAEA;AAAA;;AAEA;;;;;;AD+UA;;;;AAGA;AAAA;;AGzZA;AAAA;;AIrCA;AAAA;;;;;ALy9DA;AAAA;;ARj3DA;AAAA;AC2QA;;;;;AAAA;AAAA;;;AAAA;AAAA;;;;;AAAA;AAAA;;;AOk2BA;AAowBA;;AAjtBA;AAAA;;;AR5oCA;;;;;;AhBhBA;;;;;;AgBgBA;AAAA;AqC1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ArC0BA;AqCxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;ArDHA;AqDKA;AAAA;ArDLA;AqDSA;ArDDA;AgBMA;AAAA;AACA;AqCJA;AACA;AAGA;ArDPA;AgBMA;AAAA;AACA;AqCQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;ArCFA;AAAA;AqCqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ArCrBA;AqCuBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;ArDlDA;AqDoDA;AAAA;AAAA;ArDxDA;AAYA;AgBMA;AAAA;AACA;AqC2CA;AACA;AAGA;ArDtDA;AgBMA;AAAA;AACA;AqCuDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AtCDA;;;;;;;AAEA;AACA;AACA;AAPA;;AAyBA;AACA;AAxEA;AAAA;;;;;;AAKA;AAEA;;;;;;;;;;AAWA;AADA;;AAEA;AAAA;;;;;;AAEA;;AAFA;AAAA;;;;;;AAOA;AAAA;AAAA;;;;AAGA;;AACA;;;;;AAGA;;;;AAVA;;;AASA;;;AA+CA;;;;;;;;AAzCA;;AAFA;AAAA;;AA2CA;;;;;;;ASylBA;;;;AAMA;;AAoCA;;;;AAjCA;;AAiCA;;;;AA9BA;;AA8BA;;;;AA3BA;ARjtBA;ACmRA;ADlRA;AQgtBA;;AA2BA;;;;AAxBA;ARptBA;ACmRA;ADlRA;AQmtBA;;AAwBA;;;;;;;AR5uBA;ACmRA;ADlRA;AQwtBA;;AAmBA;;;;ARruBA;AC2QA;AD1QA;AQotBA;;AAgBA;;;;ARjtBA;AAAA;AQosBA;AR/tBA;ACmRA;ADlRA;AQ+tBA;;AAYA;;;;ARjtBA;AAAA;AA3BA;ACmRA;ADlRA;AQouBA;;AAOA;;;;;AAAA;;;;;;;;;AAAA;;;;;;;;;;;ALlfA;AnB3PA;AAAA;AmB8PA;AnBtQA;AGmxCA;AAhBA;;;AgBt9BA;;;;;;;;APm1BA;;;;;;;;;;AOn1BA;;;;AAAA;;AApCA;;;AAoCA;;AAhCA;AnBjRA;AAwBA;AmB0PA;AnBlRA;AmBmRA;AnBnRA;AAAA;;;AmBiTA;;AA3BA;AAAA;AAGA;;;AAwBA;;;;;;;AAdA;;;;;AAcA;;;;AnBrSA;AmBmSA;AnBnSA;;AmBqSA;;;;;AQ3PA;;;;;;;;AAEA;AAAA;A3BhCA;A2BiCA;;;;;AAIA;A3BzDA;A2B0DA;;;;AAGA;;;;;;;AAIA;AACA;;;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AATA;;;;;;;AAYA;AAAA;AAAA;AAAA;;;;;;AAXA;AAMA;AACA;AACA;AATA;;;;;;;AAYA;AAAA;AAAA;AAAA;;;;;;;AHgrBA;AAAA;AACA;AFjkBA;AAAA;AAKA;AE6jBA;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCA;;;;;;;A0B1qBA;AAzHA;AAKA;AAEA;A/C6bA;;A+CpbA;A/Co2CA;;AASA;;;AOtCA;APmCA;;;A+Cv2CA;;A/C02CA;;AOtCA;APmCA;;A+Ct2CA;A/Cg2CA;;AASA;;;AOtCA;APmCA;AAAA;;;AA57BA;A+CtaA;AAAA;A/CsaA;A+CraA;AAAA;A/CqaA;A+CpaA;AAAA;;;;;;;;;;;;;;;AAIA;AAQA;AAkHA;AAAA;AAAA;AAAA;AAzPA;AACA;AACA;AA4PA;AAUA;;;;;;;;;;;AboZA;;;;;;;;;;;;;;;;;AAAA;;;;;;ADnIA;;;;;;AAnIA;;;;;;;;;AAAA;;;;;;;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACsQA;;;;AAAA;;;;;ArCjjBA;AAAA;AmB6bA;AAAA;AAAA;AnB7bA;AAAA;AmB8bA;AAAA;AnB9bA;AAAA;AmB+bA;AnB/bA;AAAA;AAAA;AmB0pBA;;AAvNA;;;AAOA;AnBtdA;;AAAA;AAAA;AAgBA;AAAA;AAAA;AClIA;AkB8kBA;;AAEA;AAAA;;AACA;AnBndA;;AmBmdA;;AACA;AAAA;AAAA;;;;AnBpdA;;;AAAA;;AmBqdA;AnBrdA;AAAA;AmBsdA;AAAA;AAAA;AAAA;;;;;;;;;AF3MA;AAAA;AAAA;AAAA;AAAA;;;;AStCA;;ATuCA;;;AAAA;;ASvCA;;;A1BzPA;;A0B2PA;AACA;;;A1BhPA;A0BoPA;;;;;;;;AAWA;;;AToBA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;ASnBA;AACA;;ATmBA;;;ASnBA;AAAA;AAAA;AAAA;;;A1B7QA;A0BiRA;AAAA;;;;;A1BrQA;;;;;;;;;AiBmRA;AAAA;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;ASLA;;ATMA;AAAA;;;;;AoB8HA;AAqBA;AAAA;;;;;;;AAcA;AAAA;AAAA;;;AAGA;AAAA;;;;;;;;AAIA;;;;AAGA;;AAEA;AAtBA;AAAA;AAAA;AAJA;;;;AAMA;AAAA;AAzBA;AAAA;;AAgCA;;AACA;;AAEA;;;AACA;AAAA;;;;;;;AAIA;;AAEA;;AACA;;AAEA;;AAliBA;;;AAGA;AACA;AACA;AAAA;;;AAJA;;AAEA;AACA;AACA;AAAA;;;AAJA;AAEA;AACA;AACA;AAAA;;;;;;;;;AtB+xBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvqBA;ADyhCA;AAAA;AAAA;AAKA;;AAzVA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrsBA;ADyhCA;AAAA;AAAA;AAKA;;AAzVA;AAAA;;;;;;AAAA;AAAA;;;;;;;;;AsBlMA;;;;;AARA;;;;;;;;;;;;;;AAQA;;;;;;AARA;;;ADjGA;;;;;;AAnIA;;;;;;;;;AAAA;;;;;;;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC4OA;;;;;;;;;;AAmIA;AAAA;AACA;AAvuBA;;;;;;;;;;;AAKA;AALA;;;;;;;;AA7BA;;;AACA;;AAAA;;;ADqDA;AACA;AACA;;;;;;;;ACmhDA;AACA;AACA;;;;;AAhjDA;;;;;;;;;;;AAKA;AALA;;;;;;;AA7BA;;;AACA;;AAAA;;;ADqDA;AACA;AACA;;;;;ACssBA;AA60BA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A5Bv4BA;;AAMA;;;;;AAAA;AAAA;;;;;AAjiBA;AAAA;;;;;;;;ADicA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;ARtiBA;AAYA;AQ4hBA;ARxhBA;AQ2hBA;AR/hBA;AAAA;AQgiBA;AACA;;AAoBA;;;AAdA;AACA;AACA;AACA;AAAA;AACA;AACA;ARxjBA;AAYA;AQ8iBA;AR1iBA;AAJA;AQkjBA;AACA;AAEA;;;;;;;ANlpBA;;;;;;;;;AAIA;AAIA;;AAGA;;AAAA;;AACA;AAAA;;AAAA;AAAA;;;AAEA;;;AAKA;;AAEA;AAEA;AAEA;AACA;AAEA;;;AAIA;AAEA;AACA;;AAOA;AAAA;AACA;AACA;;AACA;AACA;AAAA;;AAKA;;AASA;AAYA;AAKA;AAEA;;;;;AAAA;;;;;AAMA;AUgnCA;AV/mCA;AEnBA;;AFyBA;;;AAmBA;;;AAbA;AAAA;;;;;;;;;;AGqFA;;AAAA;;;;AADA;;;AA0BA;;;;;;;;;;;;;AAjEA;AAAA;;AAEA;AACA;AAAA;AACA;AAAA;AAEA;;;;AAEA;AAAA;;;;;;;;;AA+BA;;;;;;AACA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AArCA;AAAA;;;;;AAGA;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;A4CrJA;;;;;;;AADA;;;;;;;;;AA4GA;AjDxBA;;AiDoCA;AjD5BA;;AiDmBA;AjDfA;AiDoBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AjD1BA;;AiDtGA;AAwIA;AAAA;;;AAvBA;AAAA;AAuBA;AAAA;;;;;;;;;;AjBtIA;AACA;;;AAuEA;;;AADA;AACA;;;AAlEA;AACA;AAGA;AAAA;;AAEA;AA4DA;;;AAtDA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;AAEA;AACA;AACA;;;;AAKA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AACA;;;;;;;;AAIA;AAGA;AACA;AACA;AACA;AACA;AACA;AAIA;AAIA;AACA;AAAA;AAAA;;AAUA;;AALA;AACA;;;;;;;;;;;;;;AI2dA;ACg5BA;AAAA;AA77BA;AACA;AD1bA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACqgCA;AAFA;AACA;AAmXA;AAx6CA;;AAGA;AACA;AACA;AAAA;AAOA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;AAwzCA;;;;;AD9bA;AAIA;AA0QA;ACxpCA;;;AACA;;AAAA;;;AAEA;AACA;AACA;AAAA;AAOA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;AAwzCA;;;;;ADxmCA;AAAA;;AAEA;AAAA;AACA;AAlHA;AAAA;AAoDA;;;;;AACA;AACA;AACA;AAAA;;;;AAEA;;;AAEA;AACA;;;;AA3DA;AAAA;;;;AAoHA;AAAA;;AAEA;AACA;;;;;AAGA;AAEA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAJA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;AApBA;AAAA;;AAEA;AAAA;AACA;AAlHA;AAAA;AAoDA;;;;;AACA;AACA;AACA;AAAA;;;;AAEA;;;AAEA;AACA;;;;AA3DA;AAAA;;;;AAoHA;AAAA;;AAEA;AACA;;;;;AAGA;AAEA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAJA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;AApBA;AAAA;;AAEA;AAAA;AACA;AAlHA;AAAA;AAoDA;;;;;AACA;AACA;AACA;AAAA;;;;AAEA;;;AAEA;AACA;;;;AA3DA;AAAA;;;;AAoHA;AAAA;;AAEA;AACA;;;;;AAGA;AAEA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAJA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;AApBA;AAAA;;AAEA;AAAA;AACA;AAlHA;AAAA;AAoDA;;;;;AACA;AACA;AACA;AAAA;;;;AAEA;;;AAEA;AACA;;;;AA3DA;AAAA;;;;AAoHA;AAAA;;AAEA;AACA;;;;;AAGA;AAEA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAJA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;ArC0EA;AAxEA;;;;;AAEA;AAAA;;;;;;;;;;;;;;;;;AAKA;;;;AAkEA;AAzEA;;;;;AAEA;AAAA;;;;;;;;;;;;;;;;;AAKA;;;;AAqEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AAAA;;;;;;;;;;AAKA;;;;;;AsCjSA;AAAA;AD0TA;;;;;;;;;;;AACA;AADA;;AC1TA;;;;;;;;AAAA;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;ADyTA;AADA;;;;;;;;;;;;AC9SA;;;;;;;;;;AAGA;AACA;AACA;AAXA;;;;;;;;AAaA;;;;;;;AX0SA;;;;ATRA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;ASSA;;;ATTA;AAAA;;AAAA;AAAA;;;AAAA;AAAA;;;;AAAA;;ASWA;AAAA;AAAA;;AAEA;AADA;AACA;AACA;;AAIA;AAAA;;;AAFA;AAAA;;;;;;;;;AASA;;AVhRA;AAAA;AAAA;;;;AUmRA;AT3BA;;AS4BA;;AACA;AAAA;;AAAA;AAAA;A1BrTA;AAAA;;AAAA;;;A0BsTA;;;;;A1BtTA;;;;;;;;AQ9GA;;;;;;AAAA;;;;AA+vCA;;AAAA;;;;;;;AAgVA;;;;;;;AA1UA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AACA;AACA;AAAA;;;AAIA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAEA;AAAA;AACA;;AAAA;;;;;AkBl0BA;AAAA;AAAA;A1BlWA;;;;AAAA;;;;A0BoWA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;;;;;AV3UA;AAAA;AAAA;AUiVA;AAAA;AACA;AAAA;AAAA;A1BlXA;AAAA;AAAA;AAAA;AAAA;A0BmXA;;;;;;;;;;;;;;;AK4JA;;;;;;;;;;;;;;;AAEA;;;;;;;;;AAyEA;;;;;AAIA;;;AAWA;AAAA;;;;;;AA1FA;;;;;;;;;;;;;;;;;;;;;;;;AAqFA;;;;AAHA;;AAQA;AAAA;;;AAHA;;AAGA;AAAA;;AAAA;AAAA;;;;;;;;AJ5pBA;;;;;;;;AA1CA;AAAA;AAKA;Af+4CA;;;;;Ae12CA;;Af02CA;;;;;;;Ae/4CA;AAAA;;;;;Af+4CA;;;Ae/4CA;;;;;;;AfotCA;;;;;;;;;;;;;AyB/uBA;;ADzbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC20CA;AAPA;AACA;AACA;AACA;AACA;AACA;AACA;AD3qCA;AA3GA;AACA;AACA;AAyGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA3GA;AACA;AACA;AAyGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA3GA;AACA;AACA;AAyGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA3GA;AACA;AACA;AAyGA;AAAA;AAAA;AAAA;AAAA;AAAA;AC6qCA;;;;;;;;;ArChxCA;AClIA;AAAA;;AAAA;AAAA;;A6C2JA;;A7C3JA;AAAA;;AAAA;AAAA;;;A6C6JA;A9CnCA;A8CoCA;A9CxCA;A8C/CA;;AA4FA;;;;;;AAGA;;;;;;;;;AAOA;;;;;AAEA;;;;;;AADA;;;;;;;;;;;;A9CxDA;A8C8DA;A9C9DA;;;;;;;;;;AegwBA;;;AAGA;AAKA;AAHA;AAAA;;;;;;;;;AAkCA;AAAA;;AAEA;AACA;AACA;;;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAtCA;AAAA;AAAA;AACA;AAEA;AAAA;;AAEA;AACA;AACA;;;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AA8PA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA1iBA;AAAA;AA6iBA;AAAA;AACA;AAEA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAEA;AACA;AACA;;;;;;;;A+B56BA;;;;;;;;AA7NA;AAKA;;AAKA;;AAIA;;;AAdA;;AAUA;;AACA;AAOA;;AAwPA;AAdA;AACA;AACA;AArRA;AACA;AAAA;;AACA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;;;;AALA;AACA;;AAEA;;;;;;;;AAEA;AAAA;;;;;;A3Ci3CA;AAgBA;;;AgBpnCA;;;;;;;;APi+BA;;;;;;;;;;AOj+BA;;;;AAAA;;AATA;AnBtIA;AmBmBA;AAgBA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;AACA;;;;;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AA8FA;;;;AAOA;;;AALA;;AAKA;;;;;;;;;;;A8B5CA;;;;;;AAGA;AACA;AjDvHA;;AiDuHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AjD9GA;AiDkHA;AjDlIA;;AiDsIA;AACA;AACA;;;;;AAhBA;;AAoBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A5CmBA;AAAA;AAAA;AAoHA;;;;AAAA;AAAA;AAAA;;AAGA;AAjLA;;;;AACA;;;;;;;;;;AAkEA;;;;AA8GA;AAAA;;;;;AAOA;;;;AC1XA;;;AAKA;AAEA;AAEA;AACA;;;;;;;;;ACyDA;;;;;;;AA6JA;AAAA;;;;;;AuC3NA;AAqCA;AACA;AAWA;;AAVA;;;;;ACvCA;;ADUA;;AACA;;AAsCA;;;AA4HA;;AAQA;A9CrEA;AAAA;AAAA;A8CiEA;;A9CjEA;AAAA;;AAAA;AAAA;AAAA;AAAA;A8CmEA;;AACA;AACA;;;;;;;AAkBA;;;;;;AAEA;;;;;;;;;;;;;AzCjNA;;;;AAIA;AAKA;;;;;;AAwJA;AACA;AACA;;;;;;;;;;AAGA;;;;;;;;;;;;;;;;;;AAzJA;;;;;;;;;;;;AAEA;;;;;;;;;;;AAGA;;;;;;;;;;;AAoLA;AAAA;;AAAA;AAAA;;;;;;AADA;;;;;;AA0BA;;;;;;;AAjEA;;;;;;AFysCA;AAgBA;;;AwCpvCA;;;;;AAjBA;;;;A/BknCA;;;;;;;;;;A+BjmCA;;;;AAAA;;AAbA;AAAA;AACA;AAAA;A3CHA;A2CIA;A3CJA;A2CKA;;AAEA;AAAA;AAAA;;;;;;;;AACA;A3CZA;A2CaA;A3CbA;A2CcA;;AAKA;;;;;;AG5IA;A9CiIA;AAAA;;;AARA;;A8CoCA;;;A9CxCA;;AAYA;;AAAA;AAAA;A8CmCA;;AAoBA;;AAZA;;AAEA;AAGA;AAAA;AAAA;;;;;;AAJA;AAAA;AAAA;AAAA;;;;;;;;;;A9CxDA;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A8CmEA;;;;;;;;;AhB+2EA;;;AAtfA;;;;;;;;;AAmBA;AAYA;AACA;AAAA;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AtB5hEA;;;;;;;;AAQA;;AACA;;;;;;;;AANA;AAAA;AACA;AAEA;;;;;;;;;;AASA;;;;;;;;;;;;AAzEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AsBwiEA;AAwDA;;AACA;AAEA;;;AAKA;;AAgbA;AAAA;;AA7GA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;;;;AA4HA;;;;;;;;;;;;;AgBljFA;AACA;;;;;;;ApCwkDA;AAEA;APrGA;;AAAA;;;;AA/6BA;;;AA06BA;;;;AAtrCA;AAslBA;;;;AmDzoBA;AAAA;A5CwtCA;APoBA;AOqGA;AACA;;;;;;A6C+rFA;AAAA;ADp/HA;;AnDitCA;;AOuMA;AG/gDA;;;;;;;;;;;;;AiBqsCA;AACA;AAGA;AAAA;;AAAA;AAAA;;;;;;;AOr0BA;AAAA;;;;;;;AAcA;AAAA;AAAA;;;AAGA;AAAA;;;;;;;;AAIA;;;;AAGA;;AAEA;AAtBA;AAAA;AAAA;AAJA;;;;AAMA;AAAA;AA84BA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;;AAAA;;AACA;AA0DA;;AAgHA;AACA;AACA;;AAzGA;;AAHA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Ab7YA;AAAA;;AxBlgCA;;AAAA;;AwBygCA;;;;;;AACA;AAAA;;;;;;;;AAEA;;;;;;;;;;;;AAGA;;;;;;;;;;;;;ATjlBA;AAGA;;;;;AAoBA;;AAjBA;AACA;;;;ACxbA;ACmRA;ADlRA;;;;;;AAMA;AC2QA;AD1QA;;;;;;;;;ADqbA;;;;AC7bA;ACmRA;ADlRA;;;;;;AAMA;AC2QA;AD1QA;;;;;;;;;ADwbA;AAAA;;;;;;;;;AAQA;;;;;;;AStVA;;;;;;;;;;;;;;AASA;AACA;AAFA;AAAA;AAAA;;;AAAA;;;;;;;;;;;AAgBA;;;;;;;;;;;AAIA;;;;AxB3JA;;;AwB2gBA;;;AxB3gBA;;;AwB6gBA;;;AxB7gBA;;;;;A0B+TA;AACA;;;;;;;;;;;AACA;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;;AV5RA;;;;;AUySA;AAAA;ATjDA;ASkDA;;ATlDA;ASkDA;;AAAA;;AACA;AAAA;A1B3UA;AAAA;AAAA;AAAA;;;A0B4UA;A1B5UA;AAAA;AAAA;A0B+UA;;;;;;;Aa5CA;;;AAcA;;;;;AAEA;;;AAGA;;AAEA;;;ACgVA;;AD3UA;AAAA;;AAEA;;;;AA9BA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AAzHA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA+3BA;;AAjBA;;;AA7DA;;AAoEA;;;AAhCA;;AAkDA;AAOA;AAAA;AA7FA;AAAA;AAAA;;AvCl+BA;;;;;;AuCqLA;;;;AAAA;;;;;;;AT+zBA;AAAA;AACA;;AAAA;;AAi6CA;;;AAt4CA;;;;;;;;AA9fA;AAAA;AAAA;AAAA;AAEA;AAqGA;AAAA;AAIA;AAGA;AAAA;AASA;;AAIA;AASA;;;AAAA;AACA;;;AAcA;AA6BA;AAEA;AAAA;;;;;;AA3UA;;AAXA;AACA;AAAA;;AAubA;;;;;;AA8FA;;;;;;;;;AAlVA;AArgBA;;;AA41BA;AA/UA;;;AAqUA;;;A3BrnBA;;A2BhGA;AAAA;A3BsEA;;A2BtEA;;;;AA8kCA;;;;;;A3B3eA;;;AmDpoBA;;A5CwtCA;;AAyHA;;;;;;;AAoGA;;AwC90CA;AAVA;;AAEA;;AAqBA;;;AASA;;;AAUA;;;;AAcA;;AAGA;AAAA;;;;AACA;AAAA;AAAA;AACA;;;;;;AM9RA;AxDmBA;AAAA;AAAA;AwD1BA;AAAA;AxD0BA;AAAA;AAAA;AwD1BA;;;;;;;;AC1IA;;AASA;;;;;AAkBA;;;;;;;;;;;APwSA;AAAA;AAMA;AAoBA;;;;AAJA;;;;;;AAyBA;AAEA;AA4QA;AACA;;;AAYA;;AAeA;;;AAKA;;AAeA;;;;;;;;;;;;;;;;;AXnYA;AACA;;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;;;;;;;;;AFmoBA;;ADvWA;AAAA;;;ACuWA;;AD1eA;;;;;;;;;;;AAAA;;;;;;;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;AC0eA;;;;;;;;;;;;;;;AAAA;;;;AAAA;;;;;;APvPA;AAAA;AAAA;;AArgBA;;;;;AA8gBA;;;;AA6MA;AAGA;AAAA;AAFA;AAAA;AAGA;;;;AA+BA;AAAA;;AA1BA;AAAA;AAAA;AAQA;AAAA;;;AA3aA;AACA;;;;;;;;;;;;;;;;AOyeA;;ADtZA;AAAA;;;ACsZA;;ADzhBA;;;;;;;;;;;AAAA;;;;;;;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;ACyhBA;;;;;;;;;;;;;;;AAAA;;;;AAAA;;;;;;;;AA9FA;;ADxTA;AAAA;;;ACwTA;;AD3bA;;;;;;;;;;;AAAA;;;;;;;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;AC2bA;;;;;;;;;;;;;;;AAAA;;;;AAAA;;;;;AqBt2BA;;;ACOA;;AAAA;;AACA;;;AAAA;;;;;;;;AHFA;;;;;;;AA6BA;;;;AAUA;AAWA;AxD4EA;;AAAA;AwD3EA;AACA;;;;AA2BA;AAEA;;;;;;;;;;AnBiuBA;;AD1QA;AAAA;;;AC0QA;;AD7YA;;;;;;;;;;;AAAA;;;;;;;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;AC6YA;;;;;;;;;;;;;;;AAAA;;;;AAAA;;;;;AErhBA;AAAA;AAKA;AAAA;;;AACA;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AAMA;;;;;;;;;;;AA8FA;AAAA;AAAA;AAAA;;;;;;AT0pCA;AAnGA;;AAGA;;AAQA;;AAAA;;;AACA;;AACA;;AAAA;AACA;AALA;;;;;;AAWA;AAEA;AAAA;AAAA;AAl8BA;AAAA;AAAA;AAAA;AA+7BA;AAwBA;;;;;;;AAjaA;AAAA;AAAA;AAAA;;;;;;;ApB2XA;APmCA;;;AANA;;AAMA;;;AANA;;;;AAMA;AA57BA;AAAA;A+CtaA;A/CsaA;AAAA;AAAA;AAAA;A+CpaA;AACA;;;;AAGA;A/CgwCA;A+C7vCA;AAEA;AAqHA;;AAAA;AAAA;AAAA;;;AAeA;;;;;;;;;AlDzJA;AkD0TA;AACA;AAAA;;;;;AjD5bA;;;AiD+bA;;;;;;AAmBA;;;;;;AAMA;AAKA;AAAA;AALA;;;;AAsGA;AALA;;AAAA;AACA;AAAA;;;AA3OA;;AACA;AACA;;;;;;AnB+yBA;;;;;ADzfA;;AAmBA;;;AACA;;AArgBA;;AA4gBA;AACA;AAqBA;;;;AAjDA;;;;AAoBA;AACA;AACA;;AAKA;;AAEA;;;;AAtGA;;;;;;;;;;;;;AgBziBA;ACJA;ADIA;AAMA;;AACA;;AAcA;;;;;AAuQA;;AArQA;;;AA4QA;;;;;;;;;;;;AazSA;;;;;;;;;;;AAwCA;;;;;;;A7BmrCA;;;;;AAoBA;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;AA91BA;;;;A3BqkCA;;;;;;;;AYveA;AASA;AAPA;AAAA;AAGA;AACA;;AAeA;AAAA;AAGA;AACA;AAAA;;AAEA;;;;;;;;;;AAEA;;;;;AAzBA;AAAA;AAGA;AACA;AAAA;;AAEA;;;;;AAEA;AAAA;;;;;;AAEA;;;;;;;;;;AZydA;AAAA;AASA;;AAHA;;A2BvPA;;;;;AALA;;AAAA;;;;;A3B1rBA;;A2B0wBA;;AAhDA;AAAA;AAAA;AAAA;;;;;AlBmGA;;;;;;;AkBrEA;A3BiEA;;;;;;;A2BvTA;;AAAA;;;;AAWA;;;;;AALA;;;AAoGA;;;;AAUA;AAMA;;;AACA;;AAEA;AAAA;AAAA;;AAIA;;AACA;;AACA;;;;;;AAGA;;;;;;;;;;;;AtB1rCA;;;;;;AAkjCA;AAAA;AACA;AAAA;;;;AArjCA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;;;;;;AA6jCA;;;;;;;;;;;;;;;;;;;;AA7jCA;;;;AAEA;;;;;;;;;;;;;;AsB2ZA;;AAkBA;;;AAGA;;A3BkjCA;;AASA;;;;;;A2B5PA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AgBnuCA;ACAA;ADIA;AAMA;AAAA;AAAA;AACA;AAGA;AAIA;AAiBA;AAEA;AAAA;;;AAYA;AAAA;;;;AAAA;AAAA;;AAjDA;ACAA;ADUA;AAAA;AACA;AAGA;AAWA;;AACA;;AACA;;;AAsBA;AAAA;;AAJA;;AAIA;AAAA;;;;;;;;A/BiGA;;;;AACA;;AACA;AAAA;;AAAA;AAAA;;;;;;;AAKA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;;;;;;;AAHA;;;;;;;;;;;;ADwUA;;;;;;;;;ACzWA;AAAA;;AA0hCA;;;AAvhCA;;;;;;;;;;;ACQA;AAAA;AAAA;AAAA;;;ADyhCA;AAAA;;;AAKA;AAtiCA;;;;;;;ACQA;;;AAAA;AAAA;ADodA;AAAA;;;;;;;;;;;;;;;;;;;;;;Ae2ZA;AAGA;AACA;AAEA;AAAA;AAAA;AACA;AAcA;;;;AAEA;;;;;;;;;AAkBA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;ACWA;AAAA;;;;AAAA;AAAA;;AA/nBA;AACA;AAiCA;AAAA;AAAA;AACA;AAglBA;AACA;;;AAWA;AAAA;;AArkBA;AACA;;AApDA;AASA;;;;;AA+mBA;AAAA;;;;;AA7lBA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AA5BA;AASA;;AA+mBA;AAAA;;;;;;;;;;;;;;;;;;;APzHA;;AR1yBA;AAAA;;AAAA;AhBhBA;AAAA;AAAA;AAAA;;AAAA;AgBMA;AQszBA;;AAEA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAQA;;ARxzBA;;AhBhBA;;AAAA;;AgBOA;AQ6zBA;;;;;AxBx0BA;AAAA;;AAAA;;;;;;AiB2QA;;;AAAA;;;AS9EA;;A1BjNA;AAAA;;AAAA;;A0BoNA;;;AACA;;A1BzMA;;;A0B6MA;;;;;;;;ATsEA;AAAA;;AAAA;;AAAA;;;AAAA;AAAA;;AjB/RA;;;AAAA;;;;A0B0OA;;;AAAA;AACA;;A1B/NA;;A0BiOA;;;;;;;;;;;;;;;;AIqvBA;AlBkJA;AkB/IA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;;;;AAAA;;;;;AAGA;;;;AAAA;;;;;;;;AAoCA;AAAA;;;AA9BA;AACA;;AA6BA;AAAA;;;AAdA;AAWA;;AAGA;AAAA;;;;;;;;;;;;A/BhdA;;;AAyBA;;AAzBA;;;AAyBA;;AAxBA;ACpkBA;ACxGA;AF6qBA;ACzjBA;;ADglBA;;;;AAhBA;AAAA;;AAgBA;;;;AATA;AAAA;AAAA;;AASA;;;;;;;AAAA;;;;;AAAA;;;;;;;;;;;AsCxnBA;;AAbA;;;AAaA;;;;;;AD0UA;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;AClVA;AADA;;;;;;;;;AASA;;;;AAAA;;;;AAxDA;;AAAA;;;ADqDA;AACA;AACA;;ACCA;;;;;A5BmYA;AAGA;;;;;;;;AAKA;AAAA;;AAFA;;;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AMiJA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAcA;;;;;;;;;;AAJA;;;;;;AAcA;;;;;;AAUA;;;;;;;Ae4pBA;AAAA;AAAA;AAAA;AAAA;;AlB1EA;;;;;AkB39BA;;A3BqtCA;;;;A2BvKA;;;;;;;A3B/wBA;AAAA;;AAAA;AA06BA;AArmBA;;AACA;AAAA;;AO6vCA;;;;AP3vCA;AAEA;;;;;;;;AyD9tBA;;AlDugDA;AGphDA;;;;;;;;;;;AVwvCA;AAhBA;ASgDA;;;;;;;;;;;;;AA3LA;;;;;;;;;Ae1rCA;;;;;;;;;;Af0rCA;;;;;;;;;;;;;;;;Ae1rCA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;;;;;;;AHwXA;AAAA;;;AACA;AACA;;AAAA;;;AACA;AAAA;;;;AAAA;AACA;AAAA;;AACA;;;;;AACA;;;AACA;AAAA;AAAA;AAAA;;;AACA;;;;AACA;;;AACA;;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;;;AAAA;;;;;;;;AxB/UA;AAAA;;AAYA;;AAAA;;AAAA;AAIA;AAAA;AQ6iBA;AAAA;ARjjBA;AAAA;;;;;;;;;;;;;;AQokBA;AACA;AAAA;;;;;AAGA;;;;AACA;;ARzkBA;;;AAAA;AAAA;;;;AAIA;;AAAA;;;;;AAAA;;AQ0kBA;AACA;;;AAAA;;;;;ACjBA;AAAA;AAAA;AAAA;AAAA;AAHA;;AAGA;;AACA;AAAA;;AAAA;;;;;AAFA;;;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AuCjqBA;;;AA8BA;AAAA;;AA1BA;AAAA;;;;;AAKA;AAAA;;AACA;;AACA;AAAA;AACA;AAEA;AAAA;AAGA;AAAA;AAAA;;;;;;;;;;;AAOA;AAAA;;AAEA;;;AAEA;;;;;AAEA;AAAA;;;;;A/B2UA;AAAA;AAAA;AAAA;;;;;AHlPA;AGmPA;AAAA;AHjPA;;AAIA;;;AAKA;;;AAkBA;AAAA;AGmNA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;A4C5NA;AACA;AAAA;AAAA;AAAA;;;;;;;AA2DA;AA5DA;AACA;AAAA;AAAA;;AAAA;;AAAA;AAwEA;AAAA;;;;;AAIA;AACA;AACA;;;;;;;;;;;AAKA;;;;;;;A9CoXA;AACA;AAAA;AACA;AAgBA;;;;;;;;AATA;;;;;;;;;;;;;;;;;;;;;AA8BA;AAOA;;;;;;;;AAqFA;;;;;;;;AfloBA;AAAA;AAAA;AemmBA;Af/mBA;;AAwBA;;AAAA;AAAA;;AgBMA;;;ADqlBA;;AfvmBA;;;AAAA;;;;;Ae2mBA;AfvmBA;AAAA;;;AAAA;AAAA;;;AewmBA;AfhmBA;AgBMA;;;;AD8lBA;;;AACA;;;;;;;;;AAjjBA;AAAA;AACA;;;AAyCA;;;;;;;;AAuUA;;AAEA;;;AACA;;;;;AAEA;;AAiBA;;;;;;;;;AEnLA;;;;AAAA;;;AFuKA;AAAA;AAAA;;;;;;AAsDA;AAAA;AAAA;AAAA;AAEA;;AAHA;;AAoEA;AAAA;;AACA;;;;;;;;;;;;;AfjjBA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;AAAA;;;AAAA;;;;;;;;;;;;AAJA;AAAA;AAAA;;;AG2wCA;AAhBA;;;AgBzhBA;AAAA;AAAA;;;;;AnB1tBA;;;;;;AmB4uBA;AnB5vBA;AmB4vBA;;;;;;;;;;;;;;;;;;;AX+sBA;;;AAt1CA;;;ARzHA;;;;;AQ0HA;AAAA;AAAA;;;ARtHA;AAAA;;;AAAA;AAJA;AQ4HA;;;;AR5HA;;;AQ6HA;AACA;AAAA;;;;;;;AA+gBA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AOxLA;;;AAQA;;AACA;;AAAA;AAAA;;;AA8BA;AAAA;AACA;;AAAA;;;AAAA;;;;;AACA;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;;AAMA;;;;AAGA;;;AACA;AAAA;AACA;;;;;;AA4EA;AfrkBA;AAAA;AAAA;AeskBA;;;;AftkBA;AAAA;;AAAA;AAJA;AAAA;Ae+kBA;;AACA;;;Af5kBA;;;;;Ae6kBA;AACA;AAAA;;;AAEA;AAAA;;;AfhlBA;AewlBA;Af5lBA;;;;AegmBA;;;AAAA;Af5lBA;AAAA;;;;;;;AGwbA;AAAA;AAAA;AAAA;AA06BA;;AApmBA;;AO6vCA;AP/0DA;AAslBA;AAFA;;;;;;AyD5tBA;;;;;;;ANoFA;AACA;A5CwtCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyHA;;AAEA;;A6C8rFA;AAAA;AAAA;;;;A1C3mIA;;;;;;AIgPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AF2KA;AAAA;;;AC5bA;AD4bA;;;ACtbA;;;AC2QA;;;;;;;AAAA;AAAA;;;AAAA;;AF8KA;;;;;;;;;;;;;Af7bA;AAAA;AAAA;AAAA;;;;;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;;;;;AAAA;;;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;AekkBA;;;;;;;;;;;;;;;;AN5FA;AAAA;;AAKA;;;;;AAIA;;;;;;;;;;AAGA;;;AAAA;AAAA;;;;;;;;;AAWA;;;;;AAEA;;;;;;;ANvEA;AAAA;AAAA;AAAA;AA06BA;;AApmBA;;AO6vCA;AP/0DA;AAslBA;AAFA;;;;;;AyD5tBA;;;;;;;ANoFA;AACA;A5CwtCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyHA;;AAEA;;A6C8rFA;AAAA;AAAA;;;;A1C3mIA;;;;;;;AJgaA;AAAA;AAEA;AASA;;;;;;;;;AAIA;AAAA;;;;;;;;;;;;AAOA;;;;;;;AAKA;;;;;;;;;;;;;;;;;;;;AArGA;AASA;;;;;;;;;AAKA;;;;;;;;;;;AAKA;;;;;;;;;;;;;;;AAMA;;;;;;;;;;;AD+TA;AACA;AACA;AACA;AASA;;AACA;;AACA;AAAA;;AAIA;AAIA;AACA;AACA;;AACA;;;AACA;;;;;AAEA;AAAA;AACA;;;AACA;AAAA;;;AAIA;AACA;AACA;;;;AAEA;;;AAAA;AACA;AAAA;;;;;;;AQ5tBA;AAAA;AAAA;ADyhCA;;AAAA;;;;;;AA1+BA;AACA;AAAA;;;;;;;;;;AAGA;AACA;AAAA;;;AAPA;AAAA;;;;;AA3CA;;;;AAEA;;;;;;;;;;;;;;;AD8UA;;;;AAqBA;AAAA;;AADA;;;AAjBA;;AAkBA;;;AADA;;;;;;;AARA;;;;;;;;;;;;;AAHA;;;;AAYA;AAAA;;;;;;;;;;;;ANqRA;;AACA;AAAA;;AAQA;AAIA;AACA;AAAA;;AAIA;;;AACA;;;;;AAKA;AAAA;AAGA;;;AACA;AAAA;;;AAMA;AACA;AAKA;;;;AAOA;;;AAGA;AAAA;AACA;;;;;;;ACrtBA;;;;;;;;;;;AA+tBA;;AAAA;;AAAA;;;AAAA;;;;;AAAA;;;;;AA5EA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AqBk+CA;;;;;;;;;;;;;;;;AAcA;;;;;;;;AAUA;;AA6PA;AA1PA;;;;;;;;ArBjoDA;AAAA;;;;;;;;;;;;;AASA;;;;;;;;;;;;;;;AAgBA;AAAA;;;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqEA;;;;;AAMA;AAAA;AAAA;;;AAAA;AAAA;;;;AAjiBA;;;;;;;;AAijBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvMA;;;;;;;;;AAKA;;;;;;;;;AAMA;AACA;;;;;;AmC5gBA;AAAA;AAAA;AhCosCA;AA2LA;;;;;;;AT9kCA;AyCzOA;;;;;;;;;;A5CIA;AAAA;AAAA;;;AARA;AAAA;A4CsFA;AAAA;AAAA;AAAA;AAAA;A5C1EA;AAAA;AAhBA;;;;;;;AQizBA;AACA;AAAA;AACA;AAKA;;AACA;;AAEA;AAAA;;AAEA;AAEA;AAAA;;;;;;AAr6BA;;;;;AAEA;AAHA;;;;;;;;;AAy7BA;ARl1BA;;;;AQk1BA;;;AAEA;AAAA;AACA;;;;;;;;;;;;;AsB6BA;A1B55BA;AAAA;AAxEA;;;;;A0Bq+BA;;;;;;;AAIA;AAhiBA;AAEA;AAAA;;AASA;AACA;AAAA;AACA;A1B3XA;A0B+XA;;;;;;;;;;;;;;;;;;ArBiEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AuC9gBA;;;AApBA;;;;;;;;;;;;;;AAyBA;AAAA;AACA;AAAA;AAEA;AACA;AAOA;;;;;;;;;;;;;AApCA;;;;;;;;;;;;;AxBqmCA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAIA;;;;;;AAUA;AAAA;AxB1/BA;AAAA;AAAA;AAAA;;;;AwB6/BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AnBx4BA;AAAA;AACA;;;;AAEA;AA7DA;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;;;;;;;;;;;A2B4IA;;;;;;;;;;;;;;;AAAA;ACybA;;AAxoBA;AArGA;;;AAAA;;;;;;;;;;;AeHA;;;AAxBA;;;;;;;;;;;;;;AA6BA;AAAA;AACA;AAAA;AAEA;AACA;AAOA;;;;;;;;;;;;;AAxCA;;;;;;;AxCs4BA;AACA;AAAA;AAGA;AAOA;;AACA;;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAAA;;;AACA;;;;;AAEA;AACA;AAAA;;;AACA;AAAA;;;AAKA;AAAA;AAEA;;;;AAEA;;;AACA;AAAA;AAAA;;;;;;;;;;;;;AA/GA;AAGA;AAAA;;AAEA;;;AAKA;;AAGA;;;AAEA;AAAA;AACA;AAKA;;AACA;;AAIA;;AAEA;;;AAOA;;AAAA;AACA;;AAGA;;;AAEA;;AACA;AAMA;AAAA;AACA;AACA;AAAA;AAAA;;;;;;;AAybA;;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAGA;AAAA;AACA;AACA;AAEA;;;AAzxCA;;;;;AAiyCA;;;AAKA;AAKA;AAAA;AACA;AACA;AAMA;;AAEA;AACA;AAGA;AAAA;AACA;AACA;;;;;;;AAjbA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAWA;AAAA;;AACA;AAAA;;;AACA;AACA;;AACA;AAAA;;AACA;AAAA;;;AACA;;AACA;AAAA;;AACA;AAAA;;;;AAGA;AACA;;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACteA;AACA;;;;;;;;AAOA;;;;;;;;;AAGA;AAAA;;;;;;AqDsLA;A3DwPA;AmD3oBA;;;A5Ci7CA;AkDpgDA;A/CbA;;AyCkGA;A5CwtCA;APoBA;AAAA;AOsGA;AACA;;A6C8rFA;;;;;AZ5vIA;AAAA;A/BsuCA;AA2LA;;;;;;;;;;;;;;AHlyCA;;;;;;;;;;;AAtCA;;;;;;;AAEA;;;;;AACA;;;;;AACA;AAAA;;;;;AAGA;;;;AACA;;;;;AACA;;;;;;;;;;;;;;;;;;AkCkBA;;A/BknCA;;;;;;;AZhnCA;AAAA;AAAA;AAAA;;;A2CIA;AAAA;AAAA;AAAA;;;;;;;;AZnFA;AAwYA;AAAA;AAwqBA;;AACA;AAAA;AAAA;AAGA;;;;AAleA;;;;;;;;;;;;;;AAiDA;AA0bA;;;;;;;;;;AtBr2BA;;;AAGA;;;AASA;AAMA;AACA;AAAA;;;;;;;;;;AAnJA;;;;;AAAA;;;;;;;;;;;AAuXA;AAQA;;;;;;;;;;;;;AT5ZA;AAAA;AAAA;AAAA;A4CyKA;A5CzKA;AAIA;AAAA;AAAA;A4C6KA;AAAA;AAAA;;;A5CrKA;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;;;A4CmLA;AAAA;AACA;;;;;;;A5CpLA;;;;;;;A+BkTA;AAAA;;;;AAGA;;;;;;;;;;AAsZA;;;;;;;AAGA;AAAA;;AADA;;;AA3ZA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;A7BvOA;;;AAzDA;;;;;;;;;;AA3HA;AAAA;;;AAGA;AACA;;;;;AAKA;;;AACA;AACA;AAAA;;;;;;AFsGA;AAAA;AmByaA;AnBzaA;AmB2aA;AAAA;AnB3aA;AAAA;AmB8aA;AAAA;AAAA;;;AAGA;AAVA;;;AAmPA;;AnB9pBA;AAAA;AAAA;AAAA;;;AmB+bA;AAAA;AAAA;AAAA;;;;;;;;;;AwB9dA;;AAUA;;;;;;;;;AARA;AAIA;;;AA3FA;AAAA;AAAA;AAAA;AxCk+CA;;AASA;;AOtCA;AAAA;AAAA;AAAA;AAAA;AAAA;APmCA;;;AwCn5CA;;;;;;;AAUA;;;;;;AA4HA;AAAA;A3CvGA;AAAA;A2C6GA;AAAA;A/BugCA;;;;;;;;;AZxnCA;AAAA;A2CkIA;;AAqCA;;;;;;AAvPA;;;;;;;;;;AXgEA;;AACA;AACA;AAAA;AACA;;ACy3BA;AA0wBA;AACA;;;;;;;;;;ADplDA;;AAEA;AAAA;;;;;AAEA;AhCnCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AgCuCA;;;;;;;AjCmjBA;AACA;AAAA;AACA;AAEA;;AAGA;ACjnBA;AAYA;;ADwmBA;ACxmBA;AAAA;;AARA;AAAA;ADqnBA;AAAA;;;AAoDA;AA/CA;;;;AA+CA;;;;;;AU/HA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;AAAA;;;AAMA;AAGA;AACA;;;;;;;AAGA;AAAA;AAAA;;;;;;ADspBA;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;AAGA;AAGA;AACA;AAAA;AACA;AAGA;AAAA;AAEA;;AAn1CA;;;AAAA;;;AAAA;;;;AA21CA;AACA;AAEA;AAAA;AACA;AAIA;AAEA;AAAA;AACA;;;;;;;;;;;;;ANt0CA;AACA;;AAEA;;AAGA;;AAGA;AAAA;;AAMA;AAIA;AACA;AAEA;;AAGA;;;AAKA;;;;;;;AAIA;AAAA;;;AAOA;AAcA;AAWA;;;;;;;;;;;;;;;;;AUwoCA;;;AOpzBA;AAAA;AAAA;AAAA;;;;;;AAWA;AAAA;;;;AASA;AAAA;;;AnB5VA;AAAA;AAAA;AAAA;;;;;;;AAYA;AAAA;AmBoVA;;;;AnB5VA;AAAA;AAAA;;AmBkqBA;;AnBlqBA;AAAA;AAAA;;AmB0WA;AnB9WA;AAAA;;;;;AmBwXA;;;AnB5XA;AAAA;AAAA;AAAA;;;;;;;;AGocA;AAAA;AAAA;AAAA;AA06BA;;AApmBA;;AO6vCA;AP/0DA;AAslBA;AAFA;;;;;;AyD5tBA;;;;;;;ANoFA;AACA;A5CwtCA;AAAA;AAAA;AAAA;AAyHA;;AAEA;;A6C8rFA;AAAA;AAAA;;;;A1C3mIA;;;;;;Ab3CA;AAAA;AmBkYA;;;AASA;AnBvYA;AAAA;AAAA;AAAA;;;AAJA;AAAA;;AmB0qBA;;;AnBtqBA;AmBkZA;;;;;AAGA;AnBzZA;AAAA;AAAA;;;;;;;;;;;;;;;;;AgDpBA;;;;;;;;AAGA;;;AAeA;;AAXA;;;AAWA;;AARA;AAAA;AAAA;AcgiBA;Ad/hBA;AACA;AAEA;;Ac4hBA;Ad5hBA;;;AAIA;;;;;ALyBA;AAAA;;A3CXA;A2CaA;A3CbA;AAAA;AAAA;AAAA;A2CcA;;;;;AAlFA;;AAIA;;AAIA;AAAA;AACA;;;;;;;;;;;;;;A3C+DA;A4C2GA;AAAA;A5C3GA;AAAA;;A4CiHA;AAAA;A5CjHA;AAAA;;A4CkHA;AAAA;;;A5ClHA;AAAA;;A4CoHA;;AAKA;;;;;AhCkrCA;;;;;;;;;;;;;;;;;;;AThCA;AAhBA;AAAA;;;;AwB30CA;;;;AAAA;;;;AfgsCA;AA2LA;;;Ae13CA;AAAA;AAKA;;;;;;;AAyEA;;;;;;;;;;AxBqbA;AA5QA;AAolBA;AmDzoBA;;;;;AzChGA;;;;;;;AH0zCA;APoBA;AAAA;;;;AoDqyFA;AAAA;ADp/HA;AAAA;AAAA;AAAA;;A5Cw5CA;;;;;;;;;;AsBp9CA;AhCtGA;AAAA;AAAA;AAJA;AgC6GA;;;AAMA;;AA+FA;;;;;;;;;A+B4FA;A7BjaA;;;;;AD+1EA;AARA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AGlyDA;ACk6BA;AAAA;AA/8BA;AACA;AD1bA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAusBA;AAAA;AAAA;ACksBA;AA17CA;;AAGA;AACA;AACA;AAAA;AAOA;AACA;AAAA;AAAA;AACA;AACA;AACA;AD4tBA;AC+CA;;;;;;;;;;;;;AN/KA;AAAA;;;;;AAKA;;;;;;;;;;;AALA;;AAKA;;;;;;;;;;;;AahjBA;;AAKA;;AAUA;;;;;;;;;AARA;AAIA;;;AAzDA;AAAA;AAAA;AAAA;AzCg8CA;;AASA;;AOtCA;AAAA;AAAA;AAAA;APmCA;;;AyCn5CA;;;;;;;AAUA;;;;;;;A5CKA;AAAA;AAQA;AAAA;AmBwaA;;AAKA;AAAA;AAAA;;AADA;;;;;;;AAQA;AAAA;AAAA;AAAA;;;AnBxaA;AAAA;AAAA;AAAA;;;;;;;;;A+BidA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AAhFA;;;AAnEA;;;;;AA2BA;AAwHA;;;AAOA;AAAA;AAAA;AAAA;AACA;;;;;;;;AqBlfA;AAAA;AAIA;;;AAkBA;;;;;;;;;;;;;;AARA;ApDUA;AoDTA;ApDKA;AoDJA;ApDIA;;AoDEA;;;;;;;;;;;;AAZA;ApDcA;;AoDFA;;;;AAAA;;;;;;;A5C0rCA;AACA;;;AAEA;AAAA;;AACA;AAAA;AACA;;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;AACA;AAAA;;;;AAEA;AAAA;;AACA;;;;;;;;ACx0BA;AAAA;;;;AAQA;AAAA;AAGA;;;AAoBA;AAtZA;;;AAAA;;;;;AAqhBA;;;;;;;;;;;;;;AA1jBA;;;;;;;;;AUyaA;AnB7YA;AmB8YA;AAAA;AAAA;AAAA;AnB9YA;AmB+YA;AnBnZA;AAAA;;;;AmBuZA;AAAA;AAAA;AnBnZA;AAAA;AmBoZA;AAAA;AnBpZA;AAAA;;AAAA;;;AAAA;;;;;;;A2CoEA;AAIA;AAEA;A3C9EA;A2CqFA;A3CjFA;A2CmFA;AAAA;;AACA;A3CpFA;AAAA;;A2CsFA;A3CtFA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;A2C8FA;AAAA;AAAA;;;;;;;;;;APkLA;;;;;;;;;AACA;AADA;;;;;;;;;;;ACk8BA;;;AAhBA;;;;;;;;;AAIA;;;AAYA;;AAPA;;;AAOA;;;;AAAA;;;;AAAA;;;AAAA;;;;;ALj8BA;AAAA;;AAAA;AAAA;AAGA;;;;;AAMA;;AACA;;;;AAEA;AAAA;;;AAGA;;;;;A7B5DA;AO0vDA;AkCviEA;AAAA;AAAA;AAAA;;;AzC+TA;;;;;;;;AwChTA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;AAAA;;;;;;A/B+1CA;;;;;;;;;;;;;AT9kCA;AUlMA;;;;A+BpEA;AACA;AAKA;;;;;;;AAEA;;AAIA;AACA;;;;AzCs4CA;AAAA;AASA;;;;;AOtCA;;AkCh3CA;;;;;;;A5C2BA;AAAA;AAAA;AAAA;AYmzCA;;AgCptCA;AAAA;AAGA;AAAA;;AAMA;;;;AAMA;A5C1GA;;AAAA;AAAA;A4C2GA;;;AACA;AAAA;A5CxGA;AAAA;AAAA;AAAA;AAAA;AAAA;A4CyGA;A5CzGA;;;;;;;;;;AIhHA;AACA;;AuBqCA;;;;;;;;AAAA;;;AAAA;;;;;;;AA4GA;AAAA;AAAA;AAAA;AAAA;AAAA;;A3BlDA;;;;;;;;A8B+jEA;;;;;;;;;;;;AAWA;;AAGA;AAYA;AACA;AAAA;AA8SA;;AA/SA;AACA;AAAA;AAAA;AAAA;;AAgBA;;;;;;;AXl7DA;AAGA;APq8BA;;;AOh0BA;AnBhUA;AAAA;AAAA;AmBgUA;AnBpTA;AAAA;;AmB0TA;AnBtUA;AAAA;;;;AmB0qBA;;;;AA/VA;AnB3UA;AAAA;AAAA;;;;;;;AAQA;AAAA;A4CmJA;;AAlMA;;;AhCk2CA;;;;;;;;;;AgC7pCA;A5C1JA;AAAA;;;;A4C4JA;A5ChJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AApBA;;;;;;;AmB8JA;;AAKA;;;;;AAxJA;AAAA;;AAKA;AAKA;;;;AAXA;;;;;;AAYA;AAAA;AAAA;AAAA;;;;;;AhBoPA;;AA1BA;;;;;;;AwBvUA;AxBwVA;AACA;AAAA;AOsvDA;APhjDA;;;;AOkkDA;AP5xCA;AAmRA;AAAA;;;AOwbA;;;AAEA;;;;;;;AV36CA;AAAA;AAAA;AgCoDA;AACA;AAEA;AAAA;AhCvDA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AgC0DA;AhC1DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AgC5DA;AACA;;AACA;AACA;;;AACA;;AAQA;AAAA;AACA;;;AAIA;AAAA;AAMA;;;;;AALA;;;;;;;;;;AFujEA;;;AAOA;;AAAA;;;;;AAQA;;AACA;;AAEA;;;;AAKA;;;AAOA;;;;;AARA;;;;;;;;;AAxrCA;AAjEA;;AAqCA;;AACA;;;;;AA/zBA;;;;;;AAg0BA;AAKA;AAGA;AAEA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;AN9BA;;AAEA;AxB3zBA;AgBMA;AAAA;AACA;AQqzBA;AAYA;;;;AATA;AAAA;AASA;;;;AALA;AxBn0BA;AgBMA;AAAA;AACA;AQ6zBA;AAIA;;;AADA;AxB30BA;AwB40BA;;;;;;;AmBr3BA;;;;;AAQA;AAAA;AAIA;AACA;;AA5FA;AAAA;AxCk+CA;;AAMA;AwCn5CA;;;;;AxCudA;AAAA;;;AAAA;AA06BA;AArmBA;;;;;;;;;;AwBxzBA;Af+qCA;;AeptCA;AAAA;AAAA;Af+4CA;;;;Ae12CA;;;Af+qCA;;;;AA2LA;;;;;;;;;;;Ae/4CA;;;;;;;;;;;;;;AHkiCA;AxBl9BA;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AwB09BA;AAAA;;;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;AzBkQA;AAAA;;AChuCA;;;;;;;;;;;;;AKoCA;;;;;;;;;;;;;;;;;;AAzIA;;AAEA;;;;;AAGA;;;;AAIA;;;;;;;AA2KA;AApBA;;;;;;;;;AAMA;;;;;;;;;;;A+BiYA;AC26BA;AAAA;AAx9BA;AACA;AD1bA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC2yBA;AAumBA;AACA;AAp8CA;;AAGA;AACA;AACA;AAAA;AAOA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAw2BA;;;;;ArCnxBA;AAAA;AAAA;AAAA;AD6dA;AC7dA;AAAA;AAAA;AD+dA;AAgEA;AACA;;AChiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADqeA;ACreA;;;;;;;;;;;AmB8EA;AACA;AAAA;AACA;;AA8kBA;;;;AAnEA;AnBvmBA;AAAA;AmBumBA;;;;AnBnmBA;AAAA;AAAA;;;;;AmBmnBA;;;;;;;;;;;;;;;AA7hBA;AAAA;AACA;AAAA;;;;AA+kBA;;;AnBtqBA;AAAA;AmBghBA;;;AACA;AAAA;;;AA1cA;AAAA;;AACA;;;;AAIA;;;;;;;;AgC3CA;AAOA;;;AANA;;;;;AAQA;;;;;;;;;AA2CA;AACA;;;;;AALA;;;;;;;;;;AxChNA;AACA;AAAA;AACA;AAAA;AAAA;AR43CA;;ACjyCA;AAAA;ADk0CA;AQh6CA;AAEA;AAAA;AACA;;;;AAFA;;AACA;;AAAA;;;;AAFA;;;;;;AH2FA;;;;;;AA68CA;AAEA;AAAA;AACA;AAAA;AAAA;ARn7CA;AAAA;;AQ5EA;AR4EA;;AAAA;;AAIA;;AQ5EA;;;;AAGA;;;;;;A2C+KA;;;AAIA;;;;;;;;AApMA;;;AnD0FA;AmDrFA;AnDiFA;AAAA;;;;;;;;;;;;;;;;;;AAYA;;;;;AAZA;AAAA;AAAA;AAYA;AAAA;AAAA;AAAA;;AmD7CA;AnD6CA;AAAA;;;AmDpEA;AAAA;AnDgFA;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AWhHA;AAAA;AAAA;AACA;AATA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AADA;AAAA;;;;;;;;;;;;;AAAA;;;;;;;AmB+4EA;;;;;AASA;;;;;;;AA0EA;;AAQA;AANA;AAlNA;AAAA;AAyCA;AAnCA;AASA;AA2BA;AACA;AAAA;A1BzwEA;A0B4jEA;AAKA;;;;;;;;;;AH5wDA;;AAGA;AACA;Af62BA;AR1oCA;AuB8RA;AAAA;AACA;AAAA;AAAA;AACA;AAIA;AACA;AACA;;;AAaA;AAAA;;AAXA;AAIA;AACA;AACA;AA7PA;AACA;AAIA;;AA6PA;AAAA;;;;;;AyB1NA;;AAZA;AAAA;;AnB+dA;AvB09CA;AuBpuBA;;;;AA5ZA;AAwtBA;;;;;;;AAOA;;;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AFj+BA;AAAA;;;AA6HA;;;;;;;;;AAAA;;;AAAA;AApBA;AAAA;AAWA;AASA;;;;;;;;;;;;A/B1uBA;AAAA;AAAA;AAAA;AgC+CA;AhC3CA;AgC4CA;AAAA;AhChDA;AAAA;;AAIA;AAAA;;;AAAA;;AgC+CA;AhCnDA;AAAA;;;AAAA;AAAA;AgCqDA;AhCjDA;AAAA;AAAA;AAAA;AAAA;AAAA;AgCkDA;;;;;;;ADkhBA;AAsGA;AAjEA;AAAA;;;;;AAgDA;;;;;;;AAlJA;;;AAKA;AAHA;;AAwJA;AANA;;;;AAlDA;;;;;;AA+BA;AAAA;;;AAhIA;;AAEA;;;;;AAEA;;;;AAgBA;;;;;;;AAmKA;AAAA;AANA;;;;;;;;;AC3tBA;;AAEA;AADA;AAhEA;AAGA;AAAA;AACA;AA6DA;;;AAtDA;AAAA;;;AAEA;;AACA;AAAA;AAAA;;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAKA;AAEA;;;;;;;;;;A7BiTA;AOyvDA;ACzkEA;AADA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;;;;;AACA;;;;;;;ACg5CA;;Ae/4CA;;;;AAqCA;AAAA;;;;;;Af02CA;;;;;;;;;Ae/4CA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;A3BgGA;;;;;;;;AgCuEA;;AhCnFA;AAAA;;;AgCqFA;;AAMA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;AAKA;;;;;;;;;;ACgxDA;A8BxtBA;A/B95BA;AACA;;AAIA;;AhC5OA;AAAA;;;AAAA;AAAA;;AgCkPA;AAAA;AACA;;;AAEA;AAEA;;;;;;;;AAeA;;;;;;;;;;;;;AIoKA;ACo7BA;AAAA;AAj+BA;AACA;AD1bA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC01BA;AAikBA;AA58CA;;AAGA;AACA;AACA;AAAA;AAOA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAu5BA;;;;;;;;;;;ADhZA;ACy5BA;AAAA;AAt8BA;AACA;AD1bA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC6vBA;AAmoBA;AAj7CA;;AAGA;AACA;AACA;AAAA;AAOA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAyzBA;;;;;;AlC5SA;AAAA;AAAA;AAAA;AA06BA;;AApmBA;;AO6vCA;AP/0DA;AAslBA;AAFA;;;;;;AyD5tBA;;;;;;;ANoFA;A5CytCA;AAyHA;;AAEA;;A6C8rFA;AAAA;AAAA;;;;A1C3mIA;;;;;;AmDxHA;;;;;;;;;AAGA;AAHA;;;;;;;;;;;;;;;AAQA;;;;;;AAMA;;;;;;;AAHA;AAHA;;;;;;;;;;;;;AAMA;;;;;AAAA;;;;;AlCqyBA;AAFA;;;AASA;;AA1ZA;;;;;;;;;A1B3WA;A0BsXA;AACA;AAAA;;;;;AA+KA;AlBkmBA;AAAA;AkB/lBA;AAoSA;;;;;;;;;A9BzyBA;AmD0HA;AAYA;AARA;AACA;AAAA;AAAA;AAAA;AACA;AnDhIA;AAAA;AmDqIA;;;AAsBA;AAAA;AAAA;AAAA;;;;;AhD6EA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AKstCA;AAAA;AAAA;;;;AAt1CA;AAAA;AAAA;;ARzHA;;AQyHA;AAAA;AAAA;;AACA;AAAA;AACA;;ARvHA;;;AAAA;;;;AQwHA;;AR5HA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AiDAA;AjDIA;AiDJA;AjDgBA;;;;;;;;;AiDhGA;;;;;;;;;;AAkFA;AAMA;;;;;;AAjHA;;;;;AADA;;;;;;;;AAEA;AACA;;AA+GA;;;AAFA;AAEA;;;;;;;;;;;AjDgBA;AmDzEA;AAAA;AACA;;;AAGA;AAAA;;;;AAPA;AA+BA;;;;;;;;;;;;;;AxCxEA;AAKA;AACA;AAwWA;AAeA;AAGA;AAAA;AACA;AAIA;AAAA;;;AAGA;;AAEA;;AAtBA;;ARvCA;;;;;;;;;;;;;;;;;;;;;;;;;A4ByYA;;AAAA;;AA+DA;AAAA;;AAjKA;AAKA;;;AAAA;;;;;;;;;AvBg6BA;AAAA;AACA;AAIA;AAIA;AACA;AACA;;;AA2BA;AAOA;;;;;;;;;;;;;;;;;;;;;;;AgB3hCA;;;;;;;;;ARhcA;AQmcA;;;;;;;;;APjLA;ADlRA;AQwcA;;;;APvLA;AAAA;AAAA;AAAA;;;;;ADlRA;ACmRA;AO6LA;AAAA;;;;;;;;;ARrbA;;;;;;AGuSA;AnB3UA;AGmxCA;AAhBA;;AgBzlBA;;AAtrBA;;;;;;AAwVA;AAAA;;;AA8VA;AAAA;;;AAnVA;;;;;;;AhB6GA;AAAA;AAAA;AAAA;AA06BA;;AApmBA;;AO6vCA;AP/0DA;AAslBA;AAFA;;;;;;AyD5tBA;;;;;;;ANoFA;A5CytCA;AAyHA;;AAEA;;A6C8rFA;AAAA;AAAA;;;;A1C3mIA;;;;;;;;;ACrGA;;;;;;;;AGqVA;AAAA;AAAA;AAAA;;;AHxTA;;;;;;AK6MA;AACA;;AAIA;;AAIA;AAEA;;APq8BA;;;;;;AuCroCA;AACA;;;AAgBA;AACA;AACA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;A9CkHA;;;;AA7EA;;;;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;;;;;;;;;ALtDA;AAAA;AAJA;AAAA;AAAA;AD62BA;AC72BA;AAAA;AD82BA;AC12BA;AAAA;AAAA;AAAA;AD42BA;ACp2BA;AAAA;AChIA;AFq+BA;AC72BA;AD82BA;ACl3BA;AAAA;AAAA;;;;;;AqDwDA;AAAA;AAAA;ArD5CA;AqDmDA;AAGA;ArDtDA;AAAA;AgBMA;AqCwDA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;;;;;;;;;;;AT8GA;;;;;;;;;;;;;A5CpMA;AAAA;AAAA;;;AAYA;AAAA;;A4CiSA;AAAA;AAAA;AAAA;;A5CjSA;AAAA;;;;;;;;AGwbA;AAAA;AAAA;AAAA;AA06BA;;AApmBA;;AO6vCA;AP/0DA;AAslBA;AAFA;;;;;;AyD5tBA;;;;;;;ANoFA;A5CytCA;AAyHA;;AAEA;;A6C8rFA;AAAA;AAAA;;;;A1C3mIA;;;;;;AkBweA;;AAKA;AAAA;;;AAHA;;;;;AA+CA;;AAjDA;;;;;;;AA6DA;;;;;AAkEA;AAEA;;;;;;AqB9lBA;;AACA;AAAA;AAGA;AAAA;;AAAA;;;AAEA;;;;AAUA;;AAjBA;;AAkBA;;;AAjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;ArB6jBA;;AAAA;;;;;;AACA;AAAA;;AAnGA;AACA;;AAIA;;;;;;ApBppBA;AACA;AAAA;AACA;AADA;AAAA;AACA;AACA;AAHA;AAEA;AAMA;AAEA;;AAFA;;AACA;;AACA;;AAMA;;;AAEA;;;;;;;AHohDA;AAr+CA;AAAA;ARuDA;;;AQ5CA;AAAA;AAAA;AACA;AACA;AAMA;;AAGA;;;;;;AAPA;;;;;;;;;;;AuBwWA;;;;;;;;;;;;;AAsMA;AAAA;;;;AA9EA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AA4BA;AAzHA;AARA;;;;AAAA;;;;;;;AA0IA;;AAAA;AAAA;;AAtFA;AApDA;;;;;;;;;;;;AZ6ZA;;;AnB5tBA;AAAA;AAAA;AmB2xBA;;AP4dA;;;;;AZvwCA;AmB4vBA;;;AACA;AnBjwBA;AAAA;AAAA;AmBmwBA;AAAA;AnBvvBA;AmBwvBA;;;;;;AiC3rBA;;AAfA;;AAAA;;AACA;AACA;AAAA;;;AAEA;;AAAA;;AACA;AACA;AAAA;;;;AAUA;;;;AAhBA;;AAAA;;AACA;AACA;AAAA;;;AAEA;;;;AAAA;;;;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AxCojCA;AAAA;ADptCA;AAAA;AACA;AACA;AAiCA;AAAA;AA1BA;AADA;AAAA;;AA8BA;;AA9BA;;AACA;;AA8BA;;;AA/BA;;;;;;;AQ2iBA;AAAA;AnB/bA;AAAA;AAAA;AmB0pBA;;;AAAA;;AAhNA;AAAA;AAAA;AnBtdA;AAAA;AmBsdA;;AACA;AnBvcA;AAAA;;AmB4cA;;;;;;;AQuBA;AAAA;AACA;A3BxfA;A2ByfA;A3B7fA;AGuxCA;AAhBA;;;AwBlwBA;;;;;AAxmBA;AfuuCA;;;;;;;;;;;Ae/nBA;;;;AAAA;;;AAAA;;;;;;AX7dA;AAAA;AA3BA;ACmRA;ADlRA;;;;AQyyBA;AxB/xBA;AgBMA;AAAA;AACA;AQyxBA;;;;;AASA;AAAA;AACA;AADA;;;;AAOA;AxBhzBA;AgBMA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AbyaA;AAAA;AAAA;AAAA;AA06BA;;AApmBA;;AO6vCA;AP/0DA;AAolBA;;;;;;AyD5tBA;;;;;;;ANoFA;A5CytCA;AAyHA;;AAEA;;A6C8rFA;AAAA;AAAA;;;;A1C3mIA;;;;;;;;;;;;;;;;;;;;;;;;;;;AN/CA;;AA4iBA;;AACA;;;;AAzQA;;AACA;AACA;;AAEA;;AACA;AACA;;;AAuQA;;AACA;;AACA;;AACA;;AACA;;;;;;;AoB2MA;AAAA;AACA;A3B7vBA;A2B8vBA;A3BlwBA;AGuxCA;AAhBA;;;AwB7fA;;;;;AA72BA;AfuuCA;;;;;;;;;;;Ae1XA;;;;AAAA;;;AAAA;;;;;A5BwoBA;;AA7xCA;;;AAGA;;;;;;AAGA;AAAA;AACA;AAZA;;;;;;;;;;;;;;AsBUA;AAAA;AAAA;AA8RA;;;AA1RA;;;AAIA;AAAA;AAsRA;AAlRA;AAAA;;AAIA;;AAAA;;;;;;AAIA;;;;;;AUiWA;AAjLA;AAAA;AAAA;;;;AAGA;;;;;;;;;;;AAqLA;;AAEA;AAAA;AAAA;AAAA;;;;;;;ApB9mBA;AACA;AAAA;AAaA;AAjBA;AACA;AACA;AACA;AAAA;AAsBA;AACA;AACA;;AACA;;AAFA;;AACA;;AAMA;;;AACA;;;;;;;;;;;;;;AiB6CA;AJsoCA;AAAA;;;;;;AFz5BA;;;AAGA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;AAsDA;AAAA;;;;AACA;;;;;;;;;AtB/PA;AAAA;AAAA;AAAA;AAAA;AQ7EA;AR6EA;AAAA;;AAIA;;AQ5EA;;;;ARwEA;;;AQrEA;;;;;;;;;;;A6B2rCA;;ADtPA;AAp6BA;;;;;;ACgpCA;AAAA;AACA;AA9rCA;AACA;AAOA;AAAA;;AACA;AAAA;;AAEA;AA0rCA;AAAA;;;;;;;;;;ADniCA;AAAA;AACA;AACA;AACA;;;;;;;AAGA;;AA1DA;AAAA;AAAA;;;;AAoHA;AAAA;;AADA;;;AAGA;;;;;;;AFtQA;;AD+3DA;;;;;;;;AAUA;;;;;;;;;;;;;;;;;;ApB/uDA;AkDomCA;A9BouBA;;;;;;;;;;;;;AF18CA;AACA;AAAA;AA3EA;;AARA;AASA;;;;;AAqFA;;;;;AAnEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AA5BA;AASA;;;AAqFA;;AA9FA;;AA8FA;;;;;;;;AhCo9CA;;;;ACj4DA;AAAA;AAAA;AAAA;ADyzBA;AACA;AAAA;AACA;AACA;ACh0BA;ADilDA;AAAA;;;ACjlDA;;;;;;;AiB+RA;AAAA;AAAA;AAAA;AHzQA;;;AG0QA;AAAA;;AH9PA;AAAA;;AAMA;AGyPA;;;;;;;;AgD9ZA;AACA;AACA;AAAA;;AAIA;AAAA;;AAKA;;AACA;;;AAaA;AAIA;AAAA;;;;AhBMA;;;;;;;;AzCu2BA;AAAA;AACA;AAAA;AAAA;AACA;;AAKA;AAAA;;AACA;AAAA;;AAAA;;AAAA;;;;AACA;;AACA;;AAAA;;AAEA;;AACA;;AACA;AAAA;;;AACA;AAAA;;;;;;;;AT6xCA;;;;;AApjCA;ACrgCA;AAAA;ADqgCA;;;AAMA;AAEA;;ACzgCA;AAAA;AAAA;AAAA;;;;;;;;;;AiB6RA;AAAA;AAAA;AAAA;AAAA;AH5SA;;AG6SA;AAAA;;AHlSA;AAAA;;;;;;;;;;;;;;;;Af6pCA;AAAA;;;;;;AA9PA;AAGA;;AAupCA;;AAxuCA;;;;;;;;AsCz4BA;;;;;;;;;;;AAKA;AALA;;;;;;;AA7BA;;;AACA;;AAAA;;;ADqDA;AACA;AACA;;ACszBA;;;AAFA;AA+tBA;AACA;AACA;;AA/tBA;;;;;;;;;;;;;;;;;;;;;;AtCpsBA;;;AADA;AA7BA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;AAmBA;;;;;;;;;;;;;;;;;;;;;;;;AM0CA;;;;AApEA;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHnLA;;AAoMA;;;;;;;;;;;;AmC/IA;;;;;;;;;;;AAKA;AALA;;;;;;;AA7BA;;;AACA;;AAAA;;;ADqDA;AACA;AACA;;ACuwBA;;;AAFA;AA8wBA;AACA;AACA;;AA9wBA;;;;;;;;;;A7BjpBA;AAAA;;;AAIA;;AAAA;;;;;AAiBA;;AR9GA;;AAAA;;;;;;;;;;;;;;AQm9CA;;;;;AA/yBA;AAAA;;;;;ARppBA;AAAA;AAAA;;AAZA;AAAA;AAAA;AAJA;AAwBA;AAAA;AAAA;AARA;AAAA;;AAhBA;;AAAA;;AqBqOA;;ArBrOA;;;;AAgBA;;;;;;AD6kCA;AAAA;AACA;;;;;AAOA;AAAA;;;ACrmCA;ADymCA;;;ACzmCA;AAwBA;ADyIA;AAAA;AAAA;;AAEA;;;;;;;;;;;AgCySA;;AAAA;;;AACA;;AAAA;;;AAAA;AAtEA;;;;AAxBA;AAuCA;AAAA;;AAnEA;;;;;;;;;AK+GA;AAAA;ACk6BA;AAAA;AAAA;AAAA;;AA98BA;AD6QA;AAAA;ACksBA;AAAA;;;AAt7CA;;AASA;AAAA;AAGA;ADguBA;AC2CA;;;;;;AAMA;AAAA;;AAAA;;;;;;;;;;;ArCpsBA;AAAA;AAAA;AmBofA;;;AnBxfA;AmB4fA;AnBhgBA;;;;AmBgFA;;;;;;;AAIA;AACA;;;;;;;;;;;;;;;;;;AX3LA;AAAA;;;;;;AAEA;AAHA;;;;;;;;;;;;;;;AACA;AAAA;;;;;;;;;;;;;;;;AyDjCA;AAAA;;AAUA;AACA;;;AAEA;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAVA;AAAA;;AAeA;;AAIA;;;AAHA;AACA;AAEA;;;;;;A5CyFA;AACA;AAMA;AAAA;AAAA;;AAeA;;;AAVA;;AACA;;;;AAEA;;;;;AAEA;;;;;;;;Aeq4BA;ACt9BA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;AAEA;;;AAHA;;;ADs9BA;ACr9BA;ADq9BA;;ACr9BA;ADq9BA;;;;;;ACmOA;;;;;;;;AMt8BA;A3C1JA;AAAA;A2C6JA;AAAA;AACA;AAMA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAQA;A3CvKA;AAZA;AAAA;A2CiLA;A3CrKA;AAAA;;;;;;AoCmTA;;;AAGA;;;AAEA;;;;;;;;;;;;;;;;;;;;;;A8B1RA;;;AA6DA;AAbA;;;;AAoBA;;AA0DA;;;;;;;;;A/DiFA;AiBhYA;;;;;;AHsaA;;;AAAA;AAAA;;AAAA;AAAA;;;ASnHA;;;AAGA;AAAA;;AACA;AACA;;;AACA;;;;;;;;AASA;;AToGA;;;;;;AAAA;;AAAA;;ASjGA;;A1B9LA;;;A0BgMA;;;;AAGA;;A1BvLA;;;;;;;;;;;ADo2CA;;AA9qCA;;;;;;;;;;;;;;;;;;;AIqlCA;;AHvwCA;AAAA;AmB+rBA;AnB/rBA;AAAA;;AAAA;AAAA;;;;;;AAJA;AAAA;;;AmBmyBA;;;;;;AmBxpBA;;AAUA;AAAA;AAAA;AACA;AAKA;AAgBA;;AAxTA;;AACA;;AADA;;;AA8SA;;AAUA;;AARA;;;;;;;A9BmXA;AACA;;ARniBA;;;AAAA;;;AAAA;;AAAA;AAAA;;AAYA;AAAA;AAAA;;AAAA;;;;AAIA;;AAAA;AQ2hBA;;;;;;AR/hBA;AQgiBA;;AAOA;AAAA;AAAA;;;;ARnjBA;;;AQsjBA;;;;;AmCrbA;;;;AAzCA;AAIA;AACA;AAOA;A3CpFA;AAAA;A2CqFA;A3CjFA;AAAA;AAAA;A2CmFA;A3CnFA;AAAA;AAAA;;;;;;;;;;;;;;;;;AG2PA;;;;;AA9BA;AA8BA;;AwCpSA;AAAA;;;;;;;;;AN4/BA;AAAA;;;;;;;;AAhhCA;;AAIA;ADmVA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;ApC9RA;A2B8sBA;A3B9sBA;AAAA;AAJA;AAAA;AAAA;AAAA;;A2BgvBA;A3B5vBA;;;AAYA;AAAA;;;;;A2BgvBA;;A3B5uBA;;;;;;;;AqCxEA;;;;;;;;;AAKA;AALA;;;;;;;AA7BA;;;AACA;;AAAA;;;ADqDA;AACA;AACA;;ACq2BA;;;AAFA;AAgrBA;AACA;AACA;;AAhrBA;;;;;ArCx0BA;AAAA;ADyyCA;AACA;AAKA;;;;;;;;;;;;;;;;;;;;;;;;AS3dA;AAAA;AAAA;;AAIA;;;AACA;;AA4BA;;AACA;;AAAA;AAAA;;AAAA;AAAA;;AACA;AAIA;AACA;AAAA;AAEA;;AACA;AAAA;;AAAA;;AAGA;;;;AAEA;AAAA;;;;;A4BluBA;;AAUA;AAPA;AAMA;;;;AAQA;;;;AAvDA;AA7DA;AA+DA;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A3B5HA;;;;;;;;;;;;;AAEA;;;;;AmCsSA;;;;AAMA;;;;;;AAOA;A5CpTA;AAAA;AAAA;AAAA;AAAA;AY2zCA;;;;;;;;;;;;;;AyBhBA;ADnrCA;AAAA;AA7DA;;;;;AAgEA;;;AADA;;;;;AAvGA;;;;;;;ACmtBA;;AAZA;;;;;;AAkEA;AA3YA;AACA;AAiXA;AAumBA;AAAA;AAAA;AAAA;AAAA;AAn8CA;AAYA;AACA;;;;;;AlCghBA;AiB9gBA;;;;;;;;AAiDA;AACA;ApBoCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AoBnCA;ApBmCA;AAJA;;;;;;AqB8JA;;;AAIA;;;AAQA;AAkOA;;AA9NA;AA8NA;;AA1NA;;AA0NA;;;;AAtNA;;;;;;;;;;A6B6GA;AAAA;;;AAKA;;;;AAUA;;;AlD9TA;;;;AAAA;AAAA;AAAA;AAAA;AkDoUA;AAAA;AAEA;;AAWA;AlDjVA;AAwBA;;;;;;;;;AoCuSA;AAEA;AACA;AAHA;;;AAKA;;;AAAA;;;AARA;;;;AAGA;;;;;;ApC/SA;AAAA;AAAA;AAAA;AAAA;A2BsrBA;A3B1rBA;AAAA;AAAA;AAAA;A2B4rBA;A3B5rBA;AAAA;;;;;AAIA;;;;;;AWxGA;AACA;AAAA;AADA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;;AAhCA;;AACA;;AACA;;AACA;;;AAaA;;;;;;;AHynCA;AAGA;AAAA;AACA;;;;AAznCA;;;;AAioCA;AAIA;AACA;AACA;AAIA;AAKA;AACA;AAAA;AAAA;AAEA;;;;;;AR3iCA;AqByVA;AACA;AAAA;AA0DA;AAvDA;AAuDA;;ArBhYA;AAAA;AAxBA;AAAA;AqBwZA;;AA9CA;AAAA;;AAKA;AAAA;AAAA;ArB3WA;;;;;;;;AQxCA;AAAA;AAAA;AACA;;;;;AAIA;;AAnBA;;;;;;AAy9CA;;;AAEA;;;;;;;AyBrqCA;;;AACA;AAAA;;;;;AAKA;;;;AA5WA;AAAA;;AA8WA;;;;;;;;;;AdxJA;;AAKA;;AAKA;;;;;;;;;AAJA;;AA1KA;AAAA;AAAA;AAAA;AhB86CA;;AASA;;AOtCA;APmCA;;;AgB3wCA;;;;;;;AAKA;;;;;;AkBrLA;AAAA;;;;;;;AA7BA;ADsDA;ACohDA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;;ADp1BA;;;;;;;;;AjBxkBA;;;;;AAEA;AACA;;;AA+kBA;;;;;;AnBtqBA;;;AmB0fA;;;;AACA;AAAA;;;;AnB/fA;;;;;;;;;;AoDyBA;AAAA;AAmBA;;;AAVA;AAAA;;;AAUA;;AATA;AAAA;AAAA;;;AAEA;AAAA;AAEA;;;;;AAKA;;;;;;;;;ApDpCA;AAAA;AAAA;AoBgRA;AACA;ApBjRA;AAAA;AoBoRA;AAAA;AAIA;;;;ApBpSA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AoB0VA;;;;;;;ApB9VA;AAIA;AD6iEA;;;;;;;;;;;;;;;;;;;;;;AkC96CA;AC9vBA;AAAA;A6BoaA;A7BpaA;AAAA;AD+3DA;;;;;;AC/3DA;;;;ADy4DA;;;;;;;;;;;;;;;;;;;AI71CA;;AAUA;AACA;AACA;;;AAEA;AACA;AAAA;;;AAKA;AAliBA;;;AAGA;AAEA;AAJA;;;;;;;;;AlBg5BA;;;AhB2dA;AAhBA;;AgB3cA;;;;;;AA3oBA;;AAGA;;AACA;;;AAIA;;AAGA;AACA;AACA;AACA;;APq8BA;;AOxUA;;;;;;AdxmBA;;AAEA;AAAA;AAGA;;AAKA;AAAA;;AAAA;AAAA;;;;AACA;AAGA;;;;;AA9LA;;;;;;AE0KA;;;;;;;;AAiKA;AAOA;AAAA;;;AAyBA;;AAqCA;;AAnFA;AAEA;AAsFA;;;;;;;;AuBm6BA;;;;AAGA;;;;AAQA;AAAA;AACA;AACA;AAJA;;;;;;;;;;;AAaA;AAAA;AAHA;;;AAqBA;AAEA;;;;;;;;;AaphCA;;;AxCq6BA;AAhBA;;AwCr5BA;;;;;;AAjUA;;AAGA;;AACA;;;AAIA;;AAGA;AACA;AACA;AACA;;A/BqkCA;;A+BlxBA;;;;;;A3C9VA;AAAA;AAAA;AAAA;AmBqZA;AnBrZA;AAAA;AAAA;AmBsZA;AnBtZA;;;AApBA;AmB+aA;AnB3aA;AAIA;AAAA;AAAA;AAAA;AmBwaA;;;;;;A8BrTA;AAAA;AjD3HA;AAAA;AAAA;AAAA;;;AiDwHA;;;;;;;AYhOA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AxBg8BA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;ADtZA;AAAA;;AAnIA;;;;;;AAAA;AAAA;;AAEA;;;;;;AOvXA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;AAGA;;;;;;;AAWA;AACA;AAKA;;;AAAA;;;;;;;;;A3CgCA;;;ADipCA;;;;;;;;;;;;;;;;;;;AgCrnBA;;;;;;;AA4CA;;;;;;;;;;;;;AAjDA;;;;;;;;;;;;;;Ae/mBA;AAKA;;AAKA;;AAIA;;;ACdA;;ADUA;;AACA;AAAA;AAGA;AAAA;AAIA;AAlBA;AAUA;AACA;AAAA;AAGA;;AATA;AAKA;;;;;;;;;;;;A3BkrBA;AnB5lBA;;;AAJA;AAJA;;;AmB+EA;AAEA;;;;;;;AAQA;AAIA;;;;;;;;;AiBkOA;;;;;;;;;;;;AAKA;;;;AAAA;;;;;;;;;AA8xBA;AAAA;;;AC6JA;;ADtcA;AA7fA;;;;;;ApCpSA;AAAA;AAAA;AAAA;AAxBA;AAAA;AAAA;AAAA;AmBoRA;AAAA;AAEA;AAAA;AAAA;AnBlRA;AmBqRA;AAwBA;;AArBA;AAAA;AACA;;;;;;;;AiBjUA;ACksCA;AAAA;AAAA;AAAA;ADkHA;;;AA3dA;ACyMA;;;;;;;ADlsBA;;;;;;;ACo7BA;;AAGA;AD9bA;AC14BA;;;;AAKA;AD64BA;ACmbA;;;;;;;AAGA;;;;;;;;A8Bn1BA;AACA;;;;AAriBA;AACA;;;;;AA4YA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;;;;;;;;;AvDujCA;;;AThCA;AAhBA;;;;;;;;;;;AwBnhBA;AAvxBA;Af+pCA;;;;;;;;Ab1lCA;;;;AAypCA;;;;;AAcA;AAAA;;;;;;;AAPA;;;;;;;;;;;AoB9rBA;AnBpgBA;AAAA;;;;AAJA;AAJA;;;;AmBgFA;;;;;;;;;;;AAaA;;;;;;;;AceA;AAAA;;;;;AA0BA;;;;;;AAxOA;AA4JA;;;;;;;;;;;AGsQA;AAAA;AAAA;AAAA;;AADA;;;;;;;;;AAKA;;;;;;;AAAA;;;;ACsbA;;;;;;;;;;;;;;;;;;AA4GA;AAqBA;;AArBA;AAAA;;;AAqBA;ADvlBA;;AACA;AADA;AAAA;;;;;ACwkBA;;;;;;;;;;;;;;A7BvHA;;;AAGA;;AACA;;;AACA;AAAA;AACA;AAEA;;AACA;;AACA;;AACA;;AACA;;AAEA;;;AACA;;AACA;AAGA;;;;;;;;;;AW7FA;;;;;;APopBA;;;;AOv0CA;;;;;;;AnBYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AoC+IA;AACA;;;;;;;;;AAKA;AAAA;AACA;;AAGA;;AACA;;AAAA;AAAA;AAAA;;;;AADA;AAAA;AAAA;;AACA;AAAA;;;AAnBA;;;;;;;;AazIA;AA3GA;;;AACA;AA6GA;;;;;;;;;AApFA;AAAA;;;;;;;;;;;;;;;;;;;;ADwDA;;;;;;;;AAXA;AACA;AAAA;;;;AAEA;;;AAQA;;AANA;;;AAMA;;;;;;AAFA;;AAEA;;;;;ArB6JA;A3BlHA;;AAhBA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;A2BoKA;;;;;;AS7BA;AAAA;AAAA;AAEA;AA7DA;;;AAEA;AACA;;;AAKA;;;;;;AA3DA;AAoHA;;;;;;;ApC7HA;AAAA;AAAA;AAAA;A2BkkBA;A3B1kBA;AAAA;;A2B+kBA;AAiKA;;AA5JA;AAAA;AAAA;AAAA;AAAA;AAAA;A3BhlBA;A2BilBA;A3BrlBA;;;;;;;;;;;AsCxBA;AAAA;;AArHA;;;AACA;;;;;AAuTA;;AA3LA;AAEA;;;;;;A9B9CA;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAMA;AAAA;AAGA;;;;;;;;;;;AWqkBA;;;;;;;;AA0IA;AAAA;;;AnB1qBA;AAAA;;;AAJA;;;;AmBujBA;AnBnjBA;;;AmBujBA;;;;;;AE7dA;AAAA;AAAA;;;AAQA;AAkTA;;AA9SA;AA8SA;;AA1SA;;AA0SA;;;;AAtSA;;;;;;;;;;;;;AtByCA;;;;AC3JA;AAYA;AAAA;AAJA;AAAA;AAAA;AAAA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAhBA;;;;;;;;;Ac2IA;;;;AAgCA;AGgHA;AAAA;AAAA;AAAA;AH/GA;;;;AAMA;AG0GA;;;;;;;;;;;;;AE8YA;;;;AnBtqBA;AAAA;AmBsqBA;AAzGA;;AAAA;;;;AnBjjBA;;;;;AAAA;;;;AAAA;;;;;;AAZA;AAAA;AARA;AAwBA;A2C8HA;A3CtJA;A2CuJA;A3CvJA;AAAA;A2CwJA;A3CpJA;A2CoJA;A3CxJA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;A2BmFA;AAXA;AAQA;AATA;AAAA;;AAYA;AAAA;AACA;;;;;;;;AAWA;;;;;;AnB3IA;AACA;;;;AAOA;AAAA;AAAA;AAGA;;;AARA;AAGA;;;AAOA;;;;AAnBA;;;;;;;;;;A4DvDA;;;ApE6GA;AAAA;AoExHA;ApEoHA;AAAA;AoEtHA;;;AAYA;ApE0GA;AAAA;;;;;;;;;ADwIA;;;;AA0DA;AAAA;;;;;;;;;;;;;;;;;;;;;;AgBw4BA;;AAIA;AAKA;;;;AAAA;;;AA5BA;;;;;;;;;;;;;AACA;AA2BA;;;;;;;;;;;;;AAtBA;AAsBA;;;;AC3iCA;ADyhCA;AAAA;AAAA;AAKA;AAaA;;;;;;AhB1iCA;;;;;;;;;ACzCA;AAYA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADusBA;;;;;;AsCpTA;;;;;;;;;;AD/HA;;;;;;AC2BA;AAmEA;;;;;;;;;AOrBA;;;A5C7VA;AAAA;;;;A4CgXA;AhC+7BA;;AgC/7BA;;;AAxUA;;;;;;A5CxDA;AAIA;AAAA;AGmxCA;;;AwB3hBA;;;;AAhEA;AAAA;;;AfwcA;AAAA;AAAA;AAAA;AA2LA;;;;;;;;;ASvyCA;AAOA;ArBnBA;AqByBA;ArBrCA;AAAA;AAAA;AAwBA;AAAA;AAAA;;AqBiBA;AAAA;AAAA;AAAA;AAAA;;;;;;;ArBzBA;AAZA;AAJA;AAAA;ADk0BA;AAovBA;;ACtjDA;AAAA;AAAA;ADwjDA;;ACxjDA;AAAA;AD2jDA;;AC/iDA;AAAA;;;;;;;;;;AAQA;;AmBukBA;AAAA;;;AACA;AAAA;AnBxkBA;AAAA;;AAAA;AmBykBA;;;AnBzkBA;;;;AmB0kBA;AAAA;AnB1kBA;;;AmB0kBA;;;;;;;;;;;;;;;;;;;AiDzqBA;AAHA;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ApEwEA;AAAA;AAAA;AAAA;;A2BofA;AAGA;;;;AAIA;A3BnfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A2BmfA;A3BvfA;AAJA;;;;;;;;AUi2CA;A6CyzFA;AAAA;;A1C3mIA;;AVwtCA;ASwDA;;AgC/3CA;;;;;;AAwEA;;;;;;A5CYA;AAAA;AARA;AAAA;AAAA;AAAA;AD43CA;AC53CA;AD63CA;AC73CA;AAAA;AD+3CA;AC34CA;AAAA;AAAA;AAAA;AAYA;ADk4CA;;;;;;;;;;;;;;AA2qBA;AA1FA;;AC/9DA;AAAA;;AAIA;AAAA;AAAA;AAAA;ADmjCA;AAGA;;;;;;;;;;;;;;;AA8TA;ACx3CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD63CA;;AAMA;;;;;;;AsCvrBA;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;ADvDA;AAAA;AAAA;;ACmBA;AAAA;;ADkmBA;AAGA;ACpmBA;AAvuBA;;;;;;;ADuXA;AAAA;AAAA;;;AAGA;AAHA;AAAA;AAAA;AAAA;AAAA;;AAKA;;;AAAA;;;;;;;;AAAA;;;AAyfA;;;;;;;;;AgCp2BA;AAAA;AAAA;AAEA;AAEA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;ACnGA;;;;;;;;;;ArEsIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A2BmXA;AACA;A3BpXA;AAAA;AAAA;AAAA;AAAA;AAAA;A2BoXA;;;;;;;AU2DA;AAcA;AAEA;;AACA;AACA;;;;;;;AAQA;AAtBA;AAAA;AAAA;AAAA;AAAA;;;;;;ArCvbA;AAYA;A2BmrBA;A3B/qBA;AAAA;AAAA;A2BgrBA;A3BhrBA;AAAA;AAAA;AAAA;AAAA;A2BkrBA;A3BlrBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAJA;AAIA;AAAA;AAAA;AD+mCA;ACnnCA;ADonCA;AAAA;AAAA;ACpnCA;;AAAA;AAAA;AAAA;ADwnCA;ACxnCA;AAAA;;;;;;;;;A2BuaA;AADA;AAGA;;;A3BzaA;AAAA;A2B2aA;AAFA;AAAA;AAAA;;;;;;;AADA;;;;;;;AGouDA;AACA;AAAA;;AACA;;AAJA;;;;;AAQA;;;AAAA;AAAA;AAAA;;;;;;A3Bt6DA;;;;;;;;AH5OA;ADu9BA;ACv9BA;AAAA;AAAA;ADy9BA;;;ACz9BA;AAAA;;AAIA;AAAA;;ADyiEA;;AA1tCA;AACA;;;;;;;AsBtpBA;AAAA;AAAA;ArB1MA;AAIA;AAAA;AqB4MA;;ArBhMA;;;;AAAA;;AAAA;;;;;AAZA;;;;;;;ADqCA;;;;;AA+hCA;;;;;AASA;;;;;AAFA;;;;;;;;;AuCtrCA;AAMA;;;;;;;;;;;;;;;;;;;;;;AtCyGA;AAAA;AAAA;AAAA;AAAA;A0B2aA;AAAA;;;AAEA;AAAA;;AAAA;;;AACA;AAAA;;;;AAAA;AAAA;;;;AAKA;;AAJA;;;;;AAkBA;;AACA;;;;AAEA;AAAA;;;;;;;AU2BA;;;AY5aA;;;;;;AZuYA;;;;;;;;;AAuFA;;;;;;;;;;;AY9dA;;;;AAAA;;;AAAA;;;;;AZiEA;;AAsCA;AAUA;AAPA;AAOA;;;;;AAOA;AAAA;AACA;;AAxDA;AA7DA;;;;;;;;ApCnDA;AqB7FA;AAIA;AAAA;AAAA;ArB6EA;AAAA;AqB5EA;AAAA;ArB4EA;AAAA;AAAA;AqB3EA;AAAA;ArB2EA;AAAA;AAAA;AqB1EA;AACA;;;;;;;;;;;;Ab09BA;;;AAGA;;AACA;;AACA;AAGA;AAAA;AACA;;;AAhgCA;;;;;;;;;;;;;;;;;;;;;A4B0YA;AAAA;AAAA;;;;;ACi3BA;AAAA;;;;;;ADv2BA;;;;;;;;;;AT1TA;AAAA;;;;;;;AAmgBA;AfoxBA;;AepxBA;AAAA;AAAA;AAAA;;AA7KA;;;;;;;;;ASnTA;AAqGA;AAEA;AAxEA;AAyEA;AAAA;;;AAAA;;;AADA;;;;AAvGA;;;;;;ApCnBA;AAJA;A2BnGA;AfuuCA;;;AA2LA;;;AerjBA;AAJA;;AAIA;AAAA;AAAA;AAAA;;;;;;;;;ARjrBA;;;AAIA;AAAA;;AADA;;;;;;AAEA;AACA;AACA;;;;;;;;;;;AkBu4BA;AAEA;AAAA;AAAA;AACA;AAHA;;AAKA;;;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAEA;;;;;;AD5gCA;AC01BA;AAikBA;AAx8CA;AAUA;AACA;AACA;;;;;AA65BA;AAAA;AAAA;AAAA;AAAA;AAAA;ADtZA;;;;;;;;ApClbA;AAJA;A2B4rBA;A3B5rBA;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;;;;;;;;AQvHA;AA8tCA;AAAA;AAEA;;;;;;AA7tCA;;;;;AA0uCA;AACA;;;;;;ARvnCA;AAAA;AoBkKA;ApBlKA;AAAA;AoBoKA;ApBpKA;AoBqKA;ApBrKA;AAAA;AAAA;AoBuKA;ApB3KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AoByKA;;;;;;AfnFA;AAAA;;;;;;;;;;AAwKA;AACA;AAAA;;;;AA1KA;;;;;;;;AN3DA;AAmoCA;;AAAA;;;;AAQA;;;;;;;;;;ACrrCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AqB+QA;AAAA;;ArB/QA;AAYA;AAZA;AsEuGA;AjDiLA;AAMA;AACA;;;ArB/RA;AsEuGA;;AjDkMA;;AAMA;;;;;;ArB3SA;AqB+WA;;ArB3VA;AqBgYA;AA3BA;AAAA;;ArB7XA;AqBkYA;ArBlYA;AqBoYA;;AAxfA;AA4fA;AAAA;AAMA;AAAA;;;;;;;ArBtXA;AAAA;AAAA;AAAA;AAAA;AAAA;AgBMA;AACA;AQi8CA;;;;;;;;;;;;;;;;;;;;;;;;AH5qCA;;AACA;;AAIA;AACA;AACA;;AAGA;ArB9TA;AAAA;;AqBoUA;AACA;ArBrUA;AAAA;AAAA;;;;;;;;;;;;AAQA;AAAA;AAAA;;;A4C8OA;AAAA;;AAOA;A5CrPA;AAAA;AAAA;AAAA;;;;;;;;AqB0IA;AAsQA;;AAlQA;;AAIA;AAAA;AA8PA;AA1PA;AAAA;;AAIA;;AAAA;;AAsPA;;AAlPA;;;AAAA;;;;;;;ArBtKA;AqBtEA;;AAQA;AAAA;AACA;;AAEA;AAAA;;;AAgCA;;AACA;AAAA;;;AACA;;;;;;;;;;;AiBxGA;;;;;;;;AAiOA;AACA;AAAA;AAAA;AACA;;;;;;;;AtC9EA;AAAA;ADotCA;ACptCA;AAAA;ADqtCA;AC7tCA;AAAA;AD8tCA;AC9tCA;AAAA;ADouCA;ACpuCA;ADwuCA;AAAA;AAAA;;;AAIA;;;;;;;;AIz+BA;;;;;;;AyCpSA;;AAMA;;AAUA;;;AARA;;;;;;APxEA;AAAA;AAAA;;AAGA;AAEA;AAAA;;AAJA;AAIA;;;;;;;;AALA;AACA;;;;;;;ArCgGA;AAAA;AD+uCA;AA2BA;ACtwCA;AAAA;ADuwCA;AAAA;AC3wCA;AD4wCA;AAAA;AC5wCA;AD6wCA;ACzwCA;AAAA;AD0wCA;AACA;AC/wCA;ADgxCA;;;;;;;;AMztCA;AAGA;;;;;AAiLA;AAAA;;;AAjJA;AAAA;;AAAA;;;;;;;;ALtFA;AAAA;AoB8HA;ApB9HA;AAAA;AAAA;AAAA;AAJA;AAAA;AoBsIA;ApBlIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AqCmEA;;AA7EA;AAAA;;AAMA;AAAA;;AACA;AAIA;AAAA;AACA;AADA;;;;;;;;AhCqFA;AAAA;;;;;;AAyDA;;AAoHA;AAAA;;AAGA;;AAjLA;;AACA;AAAA;;;;;;;;AgC9JA;AAAA;;;;;;;;;;;;;AAAA;;;AA7BA;AAAA;AAAA;;AACA;;;AAIA;ADiDA;ACtBA;;;;;;A9ByhBA;AAUA;AAGA;;AAgCA;AAjiBA;AACA;AAwiBA;;;;;;;;AA9hBA;;;;;;;APiBA;;AD6iEA;;ACrjEA;AAAA;AD84DA;AAGA;;AAhEA;AAKA;AAGA;AAAA;AAAA;AAAA;AAAA;ACr0DA;AAAA;AAAA;;;;;;AqBhFA;;AAOA;;;;;;;;;;;;;;;;;;;;AAbA;AACA;;AAkCA;;AACA;;AACA;AAAA;AAhCA;AAAA;AAEA;;;AAEA;;AACA;;;;;;AM2JA;AAiEA;A3BxJA;AAAA;AAAA;AAAA;AAAA;AAAA;A2BgHA;A3BhHA;AAAA;AAAA;AAAA;AAAA;AAAA;A2BkHA;A3BlHA;;;;;;AoC+SA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;;;AAGA;;AAHA;AAAA;;;;;;;;;AC6YA;ADxYA;;;;;;;;;;;;;ArCyiCA;AA3qCA;;;;;;;;;;;;;;;;;;;AC9LA;AAAA;AAAA;AAAA;ADyzBA;AACA;AACA;AAAA;AC/zBA;AAAA;ADghDA;;;;AChhDA;AAAA;;;;;;AY+zCA;;AZnzCA;AAAA;A2CkIA;A3C1IA;AGmxCA;;;;AwC31CA;A/BwsCA;AA2LA;;;;;;;;;;AyB/4CA;ADiDA;AACA;ACvBA;;AA4iDA;;;;;;AA3uBA;;;;;;;;;;;;;;;;AOrgBA;AAAA;A5C3PA;AAAA;;;A4C+PA;AAAA;A5C/PA;;;;;;;;;;;;;;;AsC0GA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;;AtBtFA;;;AQ+bA;;;AxB/cA;;AAAA;AAAA;AgBMA;;;AQ4cA;;;;;;;;;;;;;;;;;;;;AxBldA;;AAAA;;;AwB+dA;;;;;;;;;;AmB7hBA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAmHA;;;;;;AnCzJA;AR2EA;AAAA;AAAA;AQ1EA;AAEA;AAAA;AAAA;;AAGA;ARqEA;AAAA;AAAA;AQpEA;;;;AA4/CA;AAAA;;;;;;;AwB3qCA;AAGA;;AAgBA;;AAKA;;AAEA;AACA;;;AAMA;AAAA;AACA;AAAA;;AAGA;;;;;;AhC9RA;AAAA;AmB2aA;AAGA;AAAA;;AAPA;;;;;AnB3aA;AAAA;AAAA;AmB8bA;AnB9bA;AmB+bA;;;;;;;;AiBhVA;;AADA;AAAA;;;;;;;;AAFA;AAKA;AAAA;;;;;;;ACqRA;AApCA;AARA;AA2CA;AD8QA;ACvTA;;;AAPA;AAiDA;AAhDA;;;AANA;AAAA;ADpYA;ACqYA;;;;;;;;APxCA;;A3BqkCA;AAAA;AAAA;;AASA;AOtCA;;;AoBpNA;;;AALA;AAAA;;;;;;;;AQxwCA;;;;;AA+QA;AAhRA;;AACA;;;;AAEA;;;;;;;;AF6bA;;;;;;;;;;AAAA;AAAA;AAAA;;;;AAAA;;;;;;;;;AAKA;;;;;;;;;;;;ApChUA;A2ByDA;A3BzDA;A2B0DA;AACA;A3B3DA;AAAA;;;A2BiEA;AACA;;AAEA;AAAA;AAEA;AACA;AAAA;;;;;;AUkuCA;AA52BA;AAAA;AAEA;;;;;AAIA;;AACA;;;;AAKA;AAtBA;AAAA;;;;;;ADk9BA;;;;AClgCA;;;;AAEA;AAAA;AAAA;;ADqIA;;ACtIA;;;AAMA;AAAA;;;;;;;;AwBpZA;AAoBA;AAOA;;;AAGA;;;;AAiBA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;A7D/BA;;;AD6vCA;;;AAGA;AAFA;;;AAMA;;;AAIA;ACpwCA;AAAA;;;;;;;AAAA;A4CyTA;;;;AAkBA;A5C3VA;AAAA;AAAA;AAYA;AAAA;;;;;;;;;;;;AKwDA;AAAA;;;;;;;;;;;;AAkCA;;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AL/FA;AD8gDA;AAAA;AAGA;;;ACzhDA;AD8hDA;AAAA;;AClhDA;AAAA;AAAA;AAAA;AAAA;AAAA;AARA;ADiiDA;;;;;;;;;;;ACjiDA;AAAA;AmB0TA;AhBy9BA;;AgBtmCA;AnBzKA;AAAA;AAAA;AAAA;AmB4KA;AACA;;;;;;AnBjLA;AD0hCA;AC1hCA;AAAA;AAAA;;;ADsiCA;AAAA;AAAA;AACA;;;;AAqgBA;ACpiDA;AAAA;ADqiDA;;;;;;AIj0CA;;;AUjMA;AVgOA;;;;;;;;;;;;;;;;;;;;AyCcA;AAAA;A5CrRA;AAAA;;;A4CuRA;;A5C/RA;AAAA;AAAA;AAAA;AAwBA;AAAA;;;;;;;;;;A8B0NA;;AA2FA;A3BijCA;;AASA;AAAA;AAAA;AAAA;;AAHA;;;;;;;;;;;;AE3uCA;;AAAA;;;;AASA;;;;;;;;;;;;;;;AN41CA;AACA;ACn/CA;AAAA;AARA;;;;;;;;;;AAAA;ADyzBA;;;;;;;;Ae9wBA;AAAA;AGmPA;;;AH7OA;AAAA;;;;AAKA;AAAA;AAAA;;AGqOA;AAAA;;;;;;AjBnRA;AAAA;AAAA;;;AAIA;AAAA;;A2CqVA;;;;;;;;;AA7CA;A3C5SA;AAAA;;;;;;A4C9EA;AzCg8CA;AyC74CA;;;AAUA;;;AzC6cA;AAAA;AAsUA;AAllBA;AAAA;AAAA;AAolBA;AAAA;;;;;;;;AKsOA;;AA5lCA;;AAEA;;;;;AA0mCA;;AACA;AAAA;AAAA;AACA;AAEA;;;;;;A6ByQA;;;AAMA;AAAA;AAAA;AAAA;;;ADr/BA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ApChRA;;;AmB8mBA;AnB9mBA;AAAA;;;AAJA;;AmB8nBA;;AAgCA;;;;;;;;;;;;AnB9pBA;;;;;;AQ5DA;AAAA;;AAQA;AAAA;AAGA;;;AARA;;;;;AAUA;;AAEA;;;;;;;;;;;;;;;ARiCA;AAAA;AiDJA;AAAA;AjDgBA;;;AiD/FA;AAAA;;;;;;;AjDuGA;AAAA;AAxBA;AAAA;;AqBoVA;AAAA;ArBpVA;AAwBA;AAAA;AAxBA;AAAA;AqBsVA;AAAA;ArBtVA;AAAA;;;;;;;AqCiLA;;AAGA;;;AAIA;AAAA;;;;;;;;;;;;AAJA;;;;;;;;;;;;AlB3FA;;;;;AAKA;AAAA;;AACA;AACA;;;;;;;;AnBxFA;;;AmBuhBA;;;;;;;;AyC3eA;;A/CbA;;AH0zCA;AAyHA;AACA;AACA;A6C8rFA;;ApDnyFA;;;;AQvlCA;AAAA;;;;;;;;AHipBA;AACA;AACA;AACA;AAEA;AACA;AAIA;;AAjiCA;;;AAEA;AAHA;;;;;;;;;;A6B+CA;AACA;;AADA;AA7BA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AC5CA;;AA2JA;;AA4JA;;AAvTA;;AADA;;;;AAwTA;;;AAlJA;;;;;;;;AlBjHA;AjBohBA;AAAA;AiBhhBA;ApBwEA;AAAA;AGwcA;AiB9gBA;AAAA;AAAA;AAAA;;;AACA;ApBqFA;;;;;;;AAAA;AD4lCA;AAAA;AAAA;ACxlCA;AAAA;ADylCA;AAAA;ACjmCA;AAAA;AAAA;AAAA;AD0mCA;AAAA;AAAA;AC1mCA;AAAA;;;;;;AAIA;AQ2kBA;AAAA;AR3lBA;AQ+lBA;ARnlBA;AAAA;AQolBA;ARhlBA;AAAA;AAAA;AAAA;AAAA;AQqlBA;AACA;ARtmBA;;;;;;AiB+RA;AAAA;AHlNA;;AAMA;AAAA;AG6MA;AAAA;AH5MA;;AAKA;AAAA;AAAA;AAAA;;AAOA;;;;;;;;;;;;;;Ad5FA;AmB0TA;;;;;AA7IA;AnBzKA;AAAA;AmB4KA;AAAA;;;;;;AR+GA;AACA;AAEA;AACA;AAAA;AACA;AAFA;;;;AAIA;AAEA;AACA;AAAA;AACA;;;;;;;;;;;;;;;AgClCA;A3CxQA;AAAA;AAAA;AGmxCA;ASwCA;;;A+Bn4CA;;;;A/BwsCA;AA2LA;;;;;;AOtlCA;AnBrNA;AAAA;AAAA;AAAA;AAAA;AmBuNA;AnBvNA;AAAA;;AAAA;AAAA;AmBmCA;AACA;AAAA;AACA;AAEA;AAAA;;;;;;AduGA;;AA5DA;AAAA;AAAA;;;;;;;AAqEA;;;;;;;;;;;ASoHA;AA1EA;;;AASA;;AAMA;AACA;AAAA;AACA;;;;AAMA;;AAMA;;;;;;;AmCvLA;AA0CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AjDrGA;AAAA;;;;;;;;;AoCoUA;AARA;;;AAGA;AAAA;AAAA;;;AACA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;ApClTA;ADq7BA;ACz7BA;AD27BA;AC37BA;AD47BA;ACh7BA;AAAA;AClIA;AFmqEA;;;;;;;;;;;;;AYzxDA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;;;;AAIA;AAFA;;;;;;;;;;;AAIA;AACA;AACA;AACA;;;;;;AH9UA;;AARA;;;;AATA;;;;AAw6CA;AAEA;AAAA;AAAA;AACA;AACA;AACA;;;;;;AHntCA;;;;ACtQA;AAEA;AAIA;AAEA;AACA;AAaA;AAGA;AACA;;;;ACuMA;;;;;;;A8BmlCA;;;;;AAIA;ADjvCA;AC6vCA;AAPA;AACA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;;;;;;;ArCttCA;AD4tBA;;;;AC5uBA;AAwBA;AAAA;AAAA;AApBA;AAAA;AAAA;AAAA;;;;AD2KA;AACA;AAKA;;;;;;;;;AoBzHA;AAAA;AACA;AAAA;AACA;AAAA;AAqLA;AAKA;AACA;AP24BA;AA2LA;;;;;;;;;;;AwBzgCA;;;;;AC1VA;;;;;;;;;;AAQA;AAzDA;;;;;;;ArCyGA;AARA;AAAA;AAAA;AAAA;;;;;A2BkgBA;AA2OA;AAGA;;;;;;;;;;;;;AU5tBA;;;AAEA;AAqCA;;;AA5BA;AACA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;;;;;;;;ArCxBA;AAAA;AApBA;AAAA;A2B0NA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;AUoUA;;;;AASA;;;;;;;;AA0BA;;;AANA;;;;;;ArC/iBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD+6BA;AC/6BA;AAIA;AAAA;;;;;;AAJA;AAQA;AAZA;AAAA;AAYA;AqBAA;AAAA;;AAIA;AAAA;;;ArBxBA;AAAA;AAAA;AAYA;;;;;;;AmB+CA;;AACA;AAAA;AAAA;AACA;AACA;AAAA;;AAoLA;;AAMA;AAAA;;APukCA;;;;;;;A0CtrCA;AnD4uCA;;AOuGA;AAAA;A4CtzCA;;;;;;AnCpNA;AAAA;;;AAyLA;;;;;;;AnB3HA;AAhBA;AAAA;AAAA;AAAA;AAYA;AAAA;;;;AD6pCA;ACrqCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AoCwHA;AA7DA;AAAA;;;;;;;;AAgEA;;;;;AAAA;;;;AADA;;;;;;;;;;;;;AAFA;;;AArGA;AAqGA;;;;;;AAAA;AA7DA;AAAA;;;;;;;;AAgEA;;;;;AAAA;;;;AADA;;;;;;;;;;;;;AAFA;;;AArGA;AAqGA;;;;;;AAAA;AA7DA;AAAA;;;;;;;;AAgEA;;;;;AAAA;;;;AADA;;;;;;;;;;;;;AAFA;;;AArGA;AAqGA;;;;;;AAAA;AA7DA;AAAA;;;;;;;;AAgEA;;;;;AAAA;;;;AADA;;;;;;;;;;;;;AAFA;;;AArGA;AAqGA;;;;;;AjBkjBA;AnB1qBA;AmB6ZA;AAAA;AnB7YA;AmB8YA;AAAA;AnB9YA;AmB+YA;AnBnZA;AmB8pBA;;;;AAvQA;AnBnZA;;;;;;AApBA;;;AoEzGA;;;;;;;;AAXA;;;;ApEoHA;;;;;;;AoE1GA;ApE0GA;;;;;;;;;;AoEzGA;;;;;;;AzBgIA;A3CHA;A2CIA;AAAA;AAAA;A3CJA;AAAA;A2CMA;;AACA;AAAA;;AACA;AAAA;AAAA;A3CZA;AAAA;A2CaA;;;;;;;Abo5BA;;AAUA;;;;;;;;;;;AiBrgCA;;;;;;;AV6gBA;AAAA;;;;AAIA;;;;AAGA;AACA;;AAEA;AAtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;;;;;;ArC/aA;;;;;;AD68CA;ACj9CA;AAAA;ADq9CA;ACr9CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwBA;AAAA;;;;;;AGuvCA;;AwBxxBA;;;;;;;;AfoxBA;AAAA;AAAA;AAAA;;;AepxBA;;;;;;;AsB9ZA;AAAA;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;Ab2uBA;;ACmbA;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;ADvzBA;;;AAnIA;;;AAAA;;;;;;ArCsiBA;ACr2BA;AAAA;ADu2BA;ACv1BA;AAAA;AAAA;AAJA;AAAA;AAAA;ADw2BA;ACx2BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;;;;;;;AAhBA;;ADkpCA;;;;;;;;;;;;;;;;;A6C1oCA;;A5CIA;A4C8EA;A5C1EA;AAAA;A4C2EA;A5C3FA;AAAA;AAAA;AAYA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;;;;;;;;;AQy9CA;;;;;AA1VA;AACA;AAAA;AACA;AAAA;AAAA;;;;;ATw6BA;;;;;;;;;AAxvBA;AAiFA;AA1EA;ACh0CA;AAAA;;;;;;;;;;AAYA;A2BuLA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAGA;A3BtMA;AAAA;AAAA;A2BuMA;AvBjOA;;;;;;;;;A0B64BA;AAKA;AAAA;;AACA;;AAGA;AA9WA;AAIA;;AACA;;AAkBA;;AACA;AAAA;AAAA;AAAA;AArgBA;AAugBA;;AAKA;;AAgVA;;;AA/UA;AACA;AA8UA;;;;;;;;;;AT74BA;;AAKA;;AAMA;AAAA;;;AAKA;AAAA;AAAA;;;;;;;;ATwmCA;AkBjxBA;AAwhBA;;;AAs7CA;AAAA;;;;;AACA;;;;;;;;;;;;Aa78DA;;AxCk7BA;AH3wCA;AAAA;;AAJA;AAAA;AAAA;A2CqRA;A3CjRA;;;A2CyVA;;;;;;;;;;;;;;;;;;;;;;;;;;;AhBgBA;A3BjXA;AAAA;A2BmXA;A3BnXA;AAAA;A2BoXA;AAMA;AADA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;;;;;;A3B7XA;AAAA;;;AiDqHA;AACA;AAAA;AjDtHA;AAAA;;AiDuHA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;A5BpHA;AAKA;AAKA;ArBLA;AAAA;AAAA;AqBMA;AAAA;ArBEA;AqBDA;ArBXA;AAAA;AAAA;AAAA;AAYA;AAAA;;;;;;AARA;AmB8PA;;;AAlRA;AP4oCA;;;;AAuIA;;AO9/BA;AAAA;AAAA;AnBrQA;AmBqQA;;;;;;;AXlVA;ARqEA;AAAA;AAAA;;;AQs2CA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAn6CA;ARuDA;;;;;;AqByYA;;;;;ArB7XA;AAAA;AAZA;AAAA;AoEvIA;ApEmJA;AAAA;AAAA;AoE5IA;;ApEgIA;AAYA;AAAA;;;;;;;;;;AD42CA;AACA;AACA;AC13CA;AAAA;AD63CA;AACA;;AAKA;AAAA;AAAA;ACv3CA;ADw3CA;;;;;;AApCA;;AAGA;AAMA;;;;;;;;;;;;;;;;;;;;;;;;ASr5CA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAQA;AAAA;AAAA;AAAA;AAGA;;;;;;;;;;;;AsBw7BA;AAGA;AACA;;;;;AAEA;AAAA;;AAeA;;;;;;Aa94BA;AAKA;;;AAzFA;AAAA;;;AAMA;AAAA;;AAIA;AAAA;AACA;;AAIA;;;;;;;;AnC2wCA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AAAA;;;;AAn1CA;AAAA;AAAA;;AAAA;;;;;;ATs3CA;;;AAEA;AClwCA;AAAA;;;ADyiEA;ACzjEA;AD0yCA;;;;;AAKA;;;;;;;;;ACnyCA;AAAA;AAIA;AAJA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AwDPA;;;AAfA;ArB3FA;;AqBkGA;AACA;AAAA;;;;AAGA;AAJA;AACA;AAAA;;;AAKA;AAEA;;;;;;;AxDeA;A2C8FA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;A3CvGA;A2CwGA;AAAA;AAAA;A3CxGA;AAAA;A2C4GA;;;;;;;;;;AL7PA;;;;;;;AACA;;;;AAEA;;;;;;;;;;;;;;AAkBA;;;AApBA;;;;AAEA;;;;;;;;;;;;;;AAuBA;AACA;;;;;;AFiPA;AAAA;;AAEA;AACA;AAlHA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAsDA;;AAAA;AACA;AAAA;AAAA;AAEA;;;AAGA;;AA3DA;;;;;;;;;AAoGA;;AAHA;;;;;AAxEA;;;;AAwEA;AAAA;;;;;;;;;AvBvFA;AoB40DA;;AACA;AACA;AACA;;;ADlnDA;AhC5OA;AAAA;AAAA;AAAA;AAAA;AgCkPA;;;;;;AI7GA;AACA;;;;ACorCA;AA77BA;AACA;AD1bA;AAAA;AAAA;AAAA;ACqgCA;AADA;AAljCA;AAEA;;;;;;A7B89CA;AAEA;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAr9CA;;;;;;ARmEA;A2BgvBA;AAtHA;A3B1nBA;A2BgvBA;;AA5GA;AxB+nBA;;;;;;;;;;;;;;;;A6B7jCA;;;;;;AC7GA;;;AA2cA;AAAA;AAAA;AAAA;AAAA;AA1cA;;AAxMA;;;;;;;;;AGwHA;;AA2GA;;;;;AAGA;;;;AAiCA;AAAA;AAKA;AAEA;;;;;;AA9CA;;AACA;;;;;;;;AAxGA;AADA;;AAyCA;AA+DA;;AACA;;;;;;ArCuLA;;AAAA;AAMA;AAGA;AACA;AAiPA;;AAAA;;AAnOA;AAEA;;AAiOA;AAAA;AAAA;AAAA;;ACjiBA;AAAA;;;;;;AAIA;;AAAA;AAAA;A6CyKA;AAAA;A7CzKA;;A6C2KA;AAAA;A7C/LA;AAAA;AAAA;A6CgMA;AAAA;AAAA;AAAA;AAAA;A7ChMA;A6CiMA;;;;;;A7CjLA;AAAA;AoBgMA;ApBhMA;AAAA;AAAA;AoBmMA;;AAKA;;;;;;;;;AAUA;;;;;;;;AkBlWA;;AADA;;;;;AAwTA;AA7MA;AAAA;;AA3GA;;AACA;;;;;;AvCm7CA;AAAA;;;;AAvVA;AC59BA;AD69BA;AAEA;ACn9BA;AAZA;ADi+BA;;;AAwlCA;ACziEA;AAAA;;;;;;;;;;;;;;;;;;;AoC8RA;;;;;;;;;;AAOA;AAAA;AACA;;;;;;;;;;;A5BrWA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAMA;AAAA;AAAA;AAAA;AAGA;;;;;;;A8BwNA;;AAzSA;;AAdA;;;;;AAmBA;AACA;AApBA;AAAA;AAAA;;AADA;;;;;;;;AYwTA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAmBA;;;;AAAA;;;AAVA;AAGA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAGA;AACA;;;;;;;;;ANsIA;AAAA;A5C/TA;AAAA;AAAA;AAAA;AC/HA;;;A2C4aA;A5CjUA;AAAA;AAAA;;;;;;;AoBkCA;;;;;;;;;;;AAtBA;;;;;;;;AjBwbA;;;;;;AwB1DA;AAAA;AAAA;AAIA;AAFA;AACA;AACA;AAEA;AACA;AACA;AAbA;;;AAiBA;;;;;;;;AkBzWA;;AAEA;AA3DA;AAMA;AAAA;AAqDA;;;AAjDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;A/B4GA;AAaA;AGkKA;AAAA;AAAA;AAAA;AAAA;;;;AH3JA;AAAA;AG4JA;;;;;;;;;;;;A0BpWA;;;;;A3CwEA;AAAA;;AYuwCA;;A+B77BA;A3CtTA;AAAA;;;;;;;;;AqChFA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;AADA;;;;;;;;;AA7BA;AAAA;;;AACA;;;;;;;;;;A7BkCA;;;AAi6CA;AAt6CA;ARuDA;AQvDA;;;;;;AAWA;AAAA;;;;;;;A4B6HA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AACA;AAAA;;;;AACA;;;;AAxDA;;AAoHA;AAAA;;;;;;;AAkCA;;;AAvDA;AA7DA;;;AATA;AAyEA;AAAA;;;;;;;;AAzGA;;;;;;ArCu5DA;AACA;AAAA;AC96DA;ADk7DA;;;ACl7DA;AAAA;AAYA;AAAA;AD06DA;ACt7DA;AAIA;AAAA;AAAA;AAAA;AAYA;AAAA;;;;;;AmB+fA;AAAA;AnB3gBA;AAJA;AAAA;;;AmB+EA;AACA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;AX69BA;AAAA;AAGA;AACA;AAyCA;AACA;AACA;AACA;;AAzsCA;;;;;;AAgtCA;AACA;;;;;;;;;AYp4BA;AACA;AAAA;AA8HA;ApBlWA;AoBkPA;;;;;;AAgHA;;;AAAA;;;;;;;;ApBlWA;AAAA;AAAA;AAAA;A0BqDA;AAAA;;;AAEA;AADA;AACA;AACA;A1B5CA;AAAA;;A0B8CA;AAAA;;;;;;;;;;;;;;;;AlB7FA;;;AAnBA;;;;AAkiCA;;;AAtlCA;AAAA;;AADA;;;;;;AawJA;AAAA;;;AAuWA;AA7VA;AAAA;AAMA;AAKA;;;;AASA;;AAGA;;ArB9DA;;;AARA;;;;;;;;AD8wBA;;AAwBA;AAdA;;ACpyBA;AAQA;AAAA;AAAA;AD4xBA;;;;;AAcA;;;;;;;;AAjpBA;AAAA;AAAA;;;;;;AAOA;;;AAPA;AAAA;;;;;;AAEA;;;;;;;A8CJA;AAIA;AACA;AACA;AAEA;AAAA;AAAA;AAuCA;AAAA;AAAA;AAAA;;A7C9LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;A2B0XA;A3BtYA;AAAA;AAAA;AAAA;AAAA;A2BuYA;A3BvYA;AAAA;AAAA;A2BwYA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;;;;;;ASvPA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;;AAAA;AACA;;AAJA;AAEA;;AAAA;AACA;;;;;;;;;;ANgyCA;;;;;AAvFA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;A9Bz2CA;AAAA;AAgBA;AAAA;;;AqBmWA;ArBnXA;AAAA;AAIA;AAAA;AqB+WA;ArBnXA;AAAA;AAAA;AqBmXA;ArBnXA;;;;;;;;;;;AAYA;AAAA;AmBmyBA;;;;;AnBnyBA;;;;;;;;;AAAA;;;;;AAZA;AAAA;AAAA;A4C2VA;A5C/UA;AAAA;;;;;;;;;;;;;;;;;;;;;A8B6SA;AAAA;AAAA;AAAA;AAAA;;A3BqkCA;;;;;;;;;;;;AiBt4CA;AACA;AAGA;AAAA;AAEA;;;AAwWA;;;;;;ApBtWA;AoB4TA;;;;;;AOkEA;AADA;AAAA;AADA;;;AAIA;AAZA;;;;;A3BhXA;A2BiXA;A3BjXA;AAAA;;;;;;A6D0IA;;;;;;;;;;;;;;;;;;AA2DA;;;;;;;A7D7LA;AD8+CA;;;;;;;;;;;;;;;;;;;;ACt/CA;AGmwCA;ASwDA;;;;;AA3LA;AA2LA;;;;;;AZvzCA;AAAA;AAAA;;;;;;;;;ADkCA;AAAA;;;;AA43CA;AC15CA;AAAA;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;AD46CA;AAEA;;;;;;ACl6CA;AAAA;AAAA;AAAA;AAAA;AoB4HA;AAAA;;AAkFA;ApB9MA;AAAA;AoB8HA;ApB9HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AqC0uBA;AAAA;AD3bA;AAAA;AAAA;;AC2bA;ADtbA;;;;;;;;;;;;;;AfrbA;AAAA;AAQA;;;;;;AAeA;AAKA;ArB6GA;AAAA;AAAA;AAAA;AAAA;AqB5GA;ArBgGA;;;;;;AQxDA;;;AAEA;;AAMA;AAGA;AAAA;;;;AARA;AACA;AAAA;AAAA;AAAA;AAEA;;;;;;;;ARsDA;AAAA;AAAA;AAAA;AAAA;AAJA;AD4hBA;AAAA;AACA;AAlPA;;;;;;;;;;;;;;;A4BgdA;;AAGA;;;AwC1cA;AAgGA;AAAA;AAAA;AACA;;AAEA;;;;;AAKA;AAPA;;;;;;;AnErZA;;AAIA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;A2BoBA;AAIA;AAAA;AAAA;;A3BhCA;AAAA;AAAA;A2BiSA;AxB89BA;;;;;;AwBt9BA;;Afm1BA;;;;;;;AyB3gCA;;AAaA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAGA;;;AAIA;AACA;AACA;;;;;;;;;;;;;AtCinDA;ACjwDA;ADiwDA;AACA;;;;AAQA;AAGA;ACjwDA;AAAA;AAAA;;;;;;;;AiCsLA;AAAA;;;;AAOA;;;AAGA;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;AjCnNA;AAAA;AAYA;AAAA;;;;AD6iEA;ACrjEA;AAAA;AAAA;;;;;;;;ADyzBA;;;;;;;;;;;AiC7xBA;;;AAAA;;AACA;AAAA;;;;;;AAAA;;;;;;;;;;;;A3BGA;;;;AAAA;;;AAsMA;AAAA;;AAKA;AAEA;;;;;;;AgCzSA;;;;AAGA;AA4uBA;;;;;;;;AAi0BA;;;;;;;A1B9mDA;AACA;AAJA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAHA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAHA;;;;;;;AXoIA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AoByQA;AAAA;AAAA;AAAA;AAAA;ApB7QA;AoB8QA;ApB9QA;;;;;;AO8aA;AAEA;AA5cA;;AAueA;;;AAKA;AAAA;AA0DA;AAAA;AAAA;;AApLA;AAGA;AA2HA;;;;;;;A8B9PA;AAAA;;AAGA;;;;;;;;AA3PA;AAAA;;;;;;AD0TA;;;;AAAA;;;;;;;;;AjB0YA;;;AnBtqBA;AAAA;AmBsqBA;AAxTA;;;AnBlXA;AmB4XA;AAAA;AAAA;AAAA;;AnB5XA;;;;;;AAIA;AAAA;AAAA;;AD2jBA;;AAyBA;AC5lBA;AAAA;AAwBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD6iBA;ACzjBA;;;;;;AG4xCA;AAAA;A+C/3CA;AACA;;;;A/C8hBA;AAAA;;;AA5QA;A2D8VA;ARnZA;;;;AMnFA;;;;;;;;;;A7DuEA;;;;;;;;;;;;;;;;;AA4rDA;;;AAUA;AAIA;;;;;;;;;;;;;;;;;;;;AoBvpCA;;AnB1qBA;AAAA;AAAA;;;AmB+mBA;AnB3mBA;AAAA;AAAA;AmBsqBA;;AAAA;;;;;;;;AnBtpBA;AY4lCA;AR9pCA;AAAA;AAxEA;;AuB0RA;AAAA;;;;;;;;;;;;;;;;;AoCm+BA;A9BmuBA;AACA;AAGA;AACA;;AAAA;;A8BttBA;A/B5iCA;AAiGA;AAzFA;AhCrHA;AAAA;;;;;;A2B8YA;AADA;AAAA;AADA;;AAIA;AAAA;AAEA;AACA;AAdA;;;;;;;;AfmvBA;;;;;;;AR1oCA;AAAA;AuB4rBA;A3B9pBA;AAJA;;A2BgvBA;A3B5vBA;AAAA;AAIA;AAAA;AAAA;AAAA;AGmxCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AwB3hBA;AA9NA;;;A3B1hBA;AAAA;A2BmiBA;A3BvhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A2BwhBA;A3BxhBA;A2ByhBA;;;;;;AWzqBA;;;;;;AAoMA;AACA;AAEA;AAEA;AAKA;AA/MA;AAAA;;;;AACA;;;;;;;AqB8EA;;;;AA9DA;ADIA;AACA;AChCA;AA2BA;ADIA;AACA;AChCA;AA4BA;AACA;;;AASA;;;;;;A3DqHA;ADwbA;ACxbA;AAAA;AAAA;AAAA;AAAA;AD2bA;AACA;AAAA;;AAoGA;;;;;;AChiBA;AAAA;;;;;;AmBoaA;;;;AAOA;;;AACA;AnBxaA;AAAA;AmByaA;AAAA;AAAA;AAAA;AnBzaA;AAAA;;;;;;AmB0pBA;;AAxSA;AAGA;;;AnBjYA;AAAA;AmBuYA;;AnB3YA;AmB4YA;;;AA8RA;;;;;;;;;;AWoLA;AAOA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;A9B92BA;AAAA;;;;;;;AAIA;;;;;;;;;ADo8CA;AAGA;;;;;;;;A4B1pCA;;;;;;;;;;;;;;;;;;;;;;A5ByqCA;AC98CA;AAZA;AAAA;AAAA;AAAA;AAYA;ADg9CA;AC59CA;AAAA;AAAA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAZA;;;;;;AAgBA;AAAA;AAAA;ADi7BA;AAAA;AC77BA;AAAA;AAAA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;ADk7BA;ACl7BA;AAJA;;;;;;AWtFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AADA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAhBA;;;;;;AH4+CA;AAIA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AAr9CA;ARuDA;AAAA;AQvDA;AAAA;AAAA;AAAA;;;AAQA;;;;;;AT4iBA;AAAA;AC7eA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADgfA;AChfA;AAAA;AAAA;AAAA;AAAA;AAAA;ADqfA;;;;;;;;;;;;AAy/BA;ACl/CA;AAAA;AAAA;ADm/CA;ACn/CA;AAAA;ADo/CA;ACp/CA;AAAA;AARA;;;;;;AAIA;AAAA;AAJA;A2BudA;A3B/cA;AAAA;AAAA;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;A2B4dA;AAAA;;;;;;A3BhdA;AAAA;AoBqJA;ApBrJA;AAAA;AAAA;AAAA;AAAA;AoBuJA;ApBvJA;AAAA;AAAA;AAAA;AoByJA;ApBzJA;AAAA;;;;;;;;;;;;;;;AAJA;AAAA;A2CyVA;;;;;;;;;;;AhBiSA;AAAA;A3B1nBA;AAAA;;AAZA;AAAA;;A2BgpBA;AxB+nBA;;;;;;;;;;;;;AJ7kCA;;;;;;;;;;;;;;;;;;;;;;;;;A4BqTA;;A3BvfA;AAAA;AAAA;;A2BufA;AAAA;AAAA;AAAA;;AAjFA;A3BlaA;;;;;;;A8BusBA;AAAA;AAqBA;AACA;AAAA;;AACA;;AACA;;;;;;;;;;;;;;A1B7wBA;AAxEA;;;;;;A0BqdA;AACA;;;;;AA8KA;AAAA;AlBkmBA;AkBlmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAuSA;AAIA;;;;;;A9B7zBA;AAwBA;;ADmIA;AADA;;;;AAwxBA;ACt6BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;A6DvGA;AAkCA;AACA;;AAEA;AAAA;AAIA;;;AAiBA;AAAA;AACA;AAAA;AAAA;;;;;;;A7DwCA;AAYA;A2BsNA;A3B9NA;AAAA;AAAA;A2B+NA;A3B/NA;AAAA;A2BkOA;;AAkBA;;AAhBA;A3BpOA;AAAA;;;;;;;;AAZA;AmB+SA;AnBnSA;;;;;;;;;;;;;;;;;A8BycA;;;;;;AASA;;;;;;;AAgEA;AACA;;;;;;A/BiBA;;;AChiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD6ZA;AC7ZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAZA;A2BiWA;A3BjWA;AAAA;AAAA;AAAA;;A2B0WA;A3B1WA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AKlIA;;AAGA;AAIA;;;;;AAMA;;;;;AACA;;;;AAAA;AAAA;;;AAoJA;;;;;;;AACA;;;;;;;;AgBAA;ArBbA;AAAA;AqBaA;AAmXA;;;AA/WA;AAAA;AA+WA;;;;AA3WA;;;;;;;Abw1CA;AAGA;AAAA;AACA;AACA;AAj8CA;ARuDA;;;;;AQ5CA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;A6B2MA;AAAA;;AAsEA;AAtEA;;;;;;;AAOA;AAOA;AAwDA;;;;;;AV6TA;;;;AA0NA;AA7MA;AAKA;A3BpiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A2BqiBA;A3BriBA;A2BsiBA;;;;;;;AG2kBA;;AAoBA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAm+BA;;;AARA;;AAiBA;;;;;;AAHA;AACA;AAKA;;;;;;;;;AHz0DA;A3BjTA;AAAA;AAAA;AARA;AAAA;AAAA;A2B+TA;AAAA;AAAA;AAAA;;;AAoLA;AAhLA;;;;;;A3BnUA;ADyzBA;AAGA;ACh0BA;ADk0BA;ACl0BA;AAAA;AD6+CA;;;;;;AC7+CA;;AAQA;;;;;;;;;ADykCA;;;AAFA;;;;;;;;;;;;;;ACvkCA;AAAA;AAJA;AmB4fA;AnBhgBA;AAAA;AAAA;;AmB+EA;AACA;AACA;;;;AAGA;AACA;;;;;;AWikEA;AAQA;;;A3Bt6DA;AO0vDA;;;;;;;;;APlwDA;;;;;;;;;;A4ByYA;;AA+DA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AM8zBA;AACA;AAAA;;AA7wBA;;;;;;;AAZA;;;ADLA;AAAA;;;;;;;;;ACsEA;;;;;;;AAh0BA;;;AApDA;AAAA;AAAA;AAAA;AAAA;;;;ADsDA;AACA;AACA;AAAA;;;;;;;;;ACgrCA;;;;;;;ArCnoCA;AD6lCA;ACjmCA;AAAA;AAAA;AD0mCA;AAAA;AAAA;AAAA;AAAA;AAAA;AC1mCA;AD4mCA;ACxmCA;;;;;;AAhBA;AAYA;AAAA;AAAA;AD2yDA;AACA;AAIA;;;;AASA;;;;AA5rDA;;;;;;;;A+Bo9DA;;AAGA;;AAFA;;;;;;;;;;AAuBA;;;;;;;AAn4DA;A1B5RA;AAxEA;A0Bq+BA;;;;;;;;;AA5hBA;;;;;;;;;AtBzYA;;;AAo9CA;AAGA;AAAA;ARr6CA;AAAA;;;AQhDA;AAAA;;;;;;;;;;;;A4B4WA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;;;;;;;ApC/TA;;ADsjCA;AACA;;AAIA;;;;;;;AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;AS/mCA;AAMA;AAAA;AAAA;AAGA;AAAA;;;AARA;;;;;;AAUA;;AAnBA;;;;;;A4BoIA;;;AA+DA;AAEA;;;;;;;AAIA;AAEA;;AAIA;;;;;;AA4QA;;;;;;;;;;;;;;;;;;;;;;;AN0IA;AACA;;AAtBA;AACA;AAmBA;AACA;AAtgBA;AAAA;AAAA;AAAA;AAugBA;AAKA;AACA;AAqBA;;;;;;A3BgtBA;;;;AHnxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A2B4mBA;AAAA;A3B5mBA;A2BgvBA;;;;;;AAhiBA;AACA;AAAA;AACA;AACA;AAAA;AAAA;A3BvNA;AAAA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A2BmNA;A3B3NA;;;;;;AsC2KA;AAlLA;;AArIA;;;;;;AA6IA;AAAA;AAAA;AAAA;AACA;AAAA;AAKA;;;;;;;;;;;AjCoPA;;;AAEA;;;;AApKA;;;;;;;;AACA;;AAAA;;;;AAIA;;;;;;AALA;;;;;A+BxEA;;AAsHA;;AAOA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;;;;;;AAsKA;;;;;;;;ACuOA;;;;;;;AA0BA;;;;;;;;;;;;;AA9LA;AAAA;AAAA;;AACA;;AACA;;ADqIA;;ACtIA;;;;;;;;AAouBA;AAAA;AAnrCA;AA2rCA;AAAA;;;;ADxXA;AAAA;AAAA;AAAA;;;ACmFA;;;;;;;;;AA8bA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ArClwCA;;A2BojBA;A3BhkBA;AAAA;A2BikBA;AAGA;AAAA;AAAA;AAAA;;;A3BpjBA;AAAA;;;;;;AAJA;AAAA;AAJA;AAIA;AAAA;AoB6JA;ApB7JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AoBgKA;;;;;;;AR+oCA;Ae3zCA;AAAA;AAAA;AAAA;Af2zCA;;AR70CA;AAAA;AJ8BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;;;;;;;AcgLA;AGqGA;AAAA;AAAA;AAAA;AH7FA;;;AAKA;AGyFA;AAAA;AAAA;;AHnFA;AAAA;;;;;;;;;Af02DA;;AAnTA;;;;;;;AAIA;AC9vDA;;;;;;;AQu2CA;AACA;AA36CA;;AAOA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;A4BsKA;AA7DA;AAAA;;;;;;;;AAgEA;;;;;AAAA;;;;AADA;;;;;;;;;;;;;;;AAvGA;;;;;;AAqGA;AA7DA;AAAA;;;;;;;;AAgEA;;;;;AAAA;;;;AADA;;;;;;;;;;;;;;;AAvGA;;;;;;AAqGA;AA7DA;AAAA;;;;;;;;AAgEA;;;;;AAAA;;;;AADA;;;;;;;;;;;;;;;AAvGA;;;;;;AAqGA;AA7DA;AAAA;;;;;;;;AAgEA;;;;;AAAA;;;;AADA;;;;;;;;;;;;;;;AAvGA;;;;;;ArCuCA;AAAA;AAIA;AC9DA;AAAA;ADmwBA;AAAA;ACvvBA;;AAZA;;;;;AAJA;AAwBA;;;;;;AgD5BA;AAAA;AACA;;AAEA;AAGA;;;;;AA1EA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8BA;AA1BA;;;;;;AhBgMA;AAIA;;AAkFA;ACsqBA;;;;AC3+BA;AD+1EA;;;;;;;;AAHA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjCzuEA;AQpEA;;;;AAlBA;ARsFA;AAAA;AAAA;AAAA;AAAA;AQhFA;AAAA;AAAA;ARgFA;;;;;;;;;;;;;;;;;;AqCikBA;;;ADvGA;;;;;;;ACkPA;AAAA;AAAA;AD1QA;AAAA;AAnIA;AAAA;AAAA;AAAA;;;;;;AACA;;;;;;;;;;;;;;;AxBozBA;AehlCA;AAIA;AAAA;AA6IA;AAAA;AAAA;AAAA;AAAA;AACA;AvBpMA;;;;;;;AJ0BA;;;;;;;;;;AmBmyBA;AnBnyBA;;;AmBiuBA;;AACA;;;;;;;;;;;AoB5MA;AACA;;;;;AAFA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;AFscA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AACA;AAHA;;;;;;AAKA;AANA;AAMA;;;;;AArhCA;;;;;;;;AWZA;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;A7C+RA;;;;;AUlMA;;;;;;;;;AoCTA;AjD1BA;;;;;;;;;;;AiD3FA;AAAA;AAAA;;;;;;;AT4xBA;AAeA;;ACh0BA;ADu6CA;AAEA;;AA9RA;;;;;AAiFA;AAAA;AAAA;AAAA;AAAA;AAtCA;AAVA;;;;;;;;;;AJpwBA;;AC8YA;;;;;;;;;;AD8jBA;;;;;;;;;AA90BA;AC05BA;AAp6CA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;;AA+zBA;;;;;;AlB3jBA;;APq8BA;AOh0BA;AnBhUA;AAAA;AAAA;AAAA;AAYA;AAAA;;AmB8pBA;;;AnB1qBA;AAAA;AAAA;AAYA;;;;;;;AAhBA;AAAA;AAAA;;;;;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AgDzBA;AAGA;AAAA;AAAA;AAAA;AcgiBA;Ad/hBA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;;;;;;AjDoqBA;AACA;;;;;;;;;;;;;;;;;AoDjtBA;AAPA;;;;AAuCA;;;;;;;;;;;;;;;;;AnDiBA;ADqnBA;AAAA;AAEA;;AAkDA;;;;;;AArCA;AAAA;AAAA;AAAA;;AAGA;AACA;ACxoBA;;;;;;;AAYA;;;AAAA;AmB+xBA;;;;AnB/xBA;;AmB4xBA;;;;;AnBpyBA;;;;;;;AQXA;;;;;;;AAEA;;AAEA;;AROA;AAAA;;AAAA;;;AAAA;;AQPA;;AROA;;;;;;;AAAA;AAAA;;AAJA;;;AAAA;;AAAA;AAAA;;;;;ADilDA;ACrlDA;ADulDA;AC/kDA;AAAA;AAAA;AD+kDA;;AAkeA;;AC7iEA;;AARA;AAAA;AAAA;AAAA;AD2lDA;;;;;;;AI92CA;;;;;AwC9MA;;;AAjBA;A/BknCA;;;;;;A+B/mCA;;;;;;;Ab02BA;;;;;;A3B9oBA;AAAA;AAAA;AAAA;;A2BvEA;;AAukCA;;;;;;;AM76BA;AARA;;;AAGA;AAAA;AAAA;;AAEA;AAFA;;;;;;;;;;;;ATqFA;;A3BhZA;AAAA;AAAA;A2BsYA;A3BtYA;AAAA;AAAA;AAAA;A2BwYA;AACA;;;;;;A5ByfA;AACA;ACv4BA;ADy4BA;AAAA;AAKA;AAKA;AAAA;ACn4BA;;;;ADw1BA;;AAitCA;;;;;;;;;;AS7pEA;;;;;;;AAFA;AAAA;AAAA;;AAEA;;;;;;;ATg/CA;ACh4CA;AAAA;AAAA;AAYA;;AD2IA;;;;;;;;;;;;;;AqBxLA;AAAA;AAAA;ApBiCA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AoBlCA;ApB8BA;AAAA;AAAA;AAAA;AAAA;;;;;;A2ByhBA;AAAA;AACA;A3BthBA;A2BwhBA;A3BxhBA;AAAA;A2ByhBA;A3BzhBA;AAAA;AAAA;AAAA;A2BkhBA;;;AA0NA;;;;;;AAjrBA;AACA;AAEA;AAAA;AAPA;;AAYA;AAAA;AAXA;AAAA;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AARA;AAAA;;;;;;;AK5CA;AAAA;;;;;;;;;;;;;;AAKA;;AAAA;;;;;;;;;;;;;;;ARsaA;AACA;AAAA;;;;;AAAA;;;;;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AL/YA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AA+FA;;;;;;;A0BmBA;AAAA;;A7C5JA;AAAA;AAAA;AAAA;AAAA;A6CmKA;AAAA;AAAA;AAAA;AAAA;AAAA;A7CnKA;A6CoKA;AAAA;;;;;;;;;;A9CUA;;;;;;;;;;;;;;;;;;AwC6xCA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;;AACA;AAAA;;AAYA;;;;;AAFA;AAAA;AAAA;AAEA;;;;;;AxCxoBA;AAAA;AAAA;ACv1BA;ADi2BA;ACr2BA;AAAA;AAAA;ADu2BA;AAAA;ACv2BA;AAAA;AAAA;ADw2BA;ACx2BA;AAAA;AAIA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AqB+XA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAlJA;ArBvOA;AAAA;;AqB2OA;ArB3OA;;;AqB+OA;ArB/OA;;;;AqBkMA;;;;;;;;AVzUA;AACA;AAAA;AAAA;AACA;AAHA;AACA;AAAA;AAAA;AAEA;AAAA;AAJA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;AX2HA;AQ5EA;AAAA;AAAA;;ARwEA;AAAA;AQrEA;;;AA04CA;AAEA;AA96CA;AAAA;AAAA;AAAA;;;;;;;;;;;A+B8iDA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;;AACA;AAAA;;AAaA;;;;;AAFA;AAAA;AAAA;AAEA;;;;;;;;;;ApChhCA;AAAA;AiBraA;;;;;;;;;;AAAA;;;;;;AyBnEA;AACA;;AAUA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;AAuEA;;;;;;;A7C/CA;AAAA;AAAA;AD2KA;;AACA;AAGA;AAEA;;;;;;;;AAEA;;;AAxFA;;;;;;;;AC3FA;;;;;;;;AAAA;AAAA;AAAA;;;;;;AGmxCA;;;;;ASwCA;;;;;;;;;;AgCllCA;;;;;;;;;Adu0DA;AAGA;AADA;;;;;;;;;;;;;;;;A9BtjEA;ADm6DA;;ACv5DA;AAAA;AAAA;;;;AAZA;AAAA;AD06DA;ACt6DA;AAAA;AAAA;ADu6DA;;;;;;;A4BnxDA;A3BpJA;AAAA;AAAA;AAAA;AAAA;A2BwJA;AA7DA;;;AACA;;;AACA;AAGA;;;;;;A3B5EA;AAAA;AD6sCA;AApkCA;;AAEA;;;;;;AAmkCA;ACttCA;AAAA;AAAA;ADutCA;;;;;;AoB7vBA;AAAA;AAAA;AAAA;AnBtdA;AAAA;AmBsdA;AACA;AAAA;AAAA;AnBvdA;AAAA;AmBudA;AACA;AAAA;AAAA;AnBxdA;;;;;;;;A2B2aA;A3BvbA;AAAA;AAAA;A2B8bA;AAAA;;AAiDA;AAAA;AAAA;AAAA;;A3B/eA;A2BmcA;AAAA;;;;;;;;A5BswBA;;;;;;;;;AAGA;AApmCA;AAumCA;;;;;;;;;;;;;;ACvsCA;AAAA;AAAA;;;;;;;AAJA;AAAA;;;;;;;A2BkeA;AACA;AAAA;AAQA;;;;;;;AAIA;A3BnfA;AAAA;AAJA;AAAA;AAAA;;;;;;;;;;;;;AG2xCA;;;;AwB31CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;A3BwEA;AAZA;AAAA;AD6zBA;AACA;AAAA;AACA;AACA;ACh0BA;ADk0BA;AAo3BA;;;;;;;;ACtqDA;AAAA;AAAA;AAAA;ADgfA;AChfA;ADqfA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AC3fA;AAAA;AAAA;;;;;;AAhBA;AAAA;;;AAYA;A2BgvBA;A3B5uBA;AAAA;AAAA;AAAA;A2B+tBA;AAAA;AAAA;AAAA;A3B3tBA;AAAA;AAAA;AAAA;;;;;;A2CiVA;;AAhFA;A3CrRA;AAAA;AAAA;AAAA;;;;;;;A2CqWA;;A3CzVA;;;;;;AgCsMA;AAtEA;AhC5IA;AAAA;AAAA;AAwBA;AChIA;A+BwPA;;AAkEA;;;;;AAhEA;AAkCA;;AhChLA;;;;;;AoBmGA;AAAA;;AAOA;AAIA;AAAA;ApBlGA;AoByGA;ApBzGA;AAAA;AAAA;AAAA;AAAA;AAAA;AoB0GA;ApB1GA;AAAA;;;;;;;;;AgCiBA;;;;;;;;;;;;;AA2IA;AACA;;;;;;AK3IA;AAmCA;;AA1BA;;;AAEA;AADA;;;;;;;AAQA;;;;;;AAxEA;;AD8TA;AAAA;;AALA;AADA;;;;;;;;;;;;;;;;;;;;;;;ArCqxDA;AAAA;AAAA;AAAA;;;;AApLA;;;;;;AoBxuDA;;AAxJA;AAAA;AACA;;AAKA;AAAA;;;AAKA;AACA;AAIA;;;;;;;;;;AnBbA;AAAA;AAAA;AAAA;A2CmPA;;;A3C/OA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAIA;AAAA;AAAA;AAQA;AAAA;ADufA;AAAA;ACngBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADogBA;ACpgBA;AAAA;ADqgBA;;;;;;A4BiOA;A3BtuBA;AAAA;;;A2BgvBA;;;;AA9OA;AA2OA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AQj1BA;AnCwFA;AAAA;AAwBA;AAAA;AmC/GA;AACA;AACA;;;;;;;;AH+OA;;AAAA;;;;;;;;;AXnMA;;;;AAIA;;;;;AAIA;;;;;;;;;ASmRA;AA+kBA;AAAA;AA0DA;;AAjEA;AAqCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAj0BA;;;;;;;;AkBsCA;AAoDA;;;;;;AAaA;;;AAjRA;AAFA;;;;;;;;;AlBqzCA;AAAA;AAAA;;AAAA;;;;;;;AlBmGA;;;;;;;;AwBrvCA;AACA;AA0GA;;;;;AAlEA;AAAA;AA+DA;AAxEA;AAyEA;;;;;;;;ATqNA;AAEA;A3BtVA;AAIA;AAAA;AAAA;AAAA;AAAA;A2ByVA;;;;;;AAAA;AAOA;;;;;;;;;AZvUA;AA0hCA;;;;;;;;;;;;;AACA;AAxhCA;;;;;;;;;;;;;AA6hCA;AA7hCA;;;;ACQA;ADyhCA;AAAA;AAAA;AAKA;AAtiCA;;;;;;;;AP+7BA;AACA;AAEA;;AAxkCA;AAAA;;;AA8kCA;AAAA;AAAA;AACA;AAhiCA;ARuDA;;;;;;AAQA;AARA;AAwBA;AAAA;AAAA;A4C4QA;AACA;AAAA;;;;;;;AAMA;;A5C3RA;;;;;;AiCwCA;AA4fA;AApfA;AA4DA;AAEA;AAjDA;;AAueA;;;;;AApeA;AAAA;AAIA;AACA;;;;;;AdhFA;AAAA;AACA;;;;;;;;;;;;;;;;AAIA;;;;;;;AAYA;AAMA;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AYwjBA;AAAA;AAAA;;;;;;;;;;;A/BhlBA;AAAA;AD6uBA;;ACzuBA;;;;;AD4uBA;AACA;AACA;;;;;;AC9uBA;AAAA;AmB2fA;AAAA;;;;AAEA;AnBjgBA;AmBigBA;;AAyKA;;;;AAlKA;;;;;;AnBxfA;AAAA;AAAA;AmBydA;AACA;AAAA;AAAA;AnB1dA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AqCoCA;AACA;;AAIA;AAGA;AAHA;;;;;;AAjDA;;;;;;;;;AV6RA;AAAA;AxB8+BA;AAhBA;;;AwBt9BA;;;;;AApZA;AfuuCA;;;;;;;;;;;Aen1BA;;;;AAAA;;;AAAA;;;;;;AYwbA;AAAA;AAAA;AAKA;AAmCA;AAGA;;AACA;AACA;AACA;;AAwBA;AASA;;AAKA;;AAJA;;AAIA;;AAHA;AAAA;AAAA;AAGA;;;;;A/B8iBA;AAIA;AAt6CA;AAAA;ARuDA;AQvDA;;;AAOA;;;;;;;;AAIA;AAAA;;;;;;AR4CA;AAAA;AAAA;;;ADkMA;AAAA;;;;;;;;;;;;;;;;;AsC8mBA;;;;;;;AAv2BA;AAAA;;;;;;AA9BA;;;;;;;APqpEA;;AAMA;;;;;;AAPA;AAAA;AAAA;AAAA;AAAA;;AAaA;AAEA;;;;;;AO1kEA;AAEA;AAGA;AAAA;AAGA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;;;;;;;AtC4yBA;AACA;AC9zBA;ADsjDA;AAAA;;AAmgBA;ACzjEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD0jDA;AC1jDA;;;;;;AAIA;AAAA;AAAA;AAAA;A2C0JA;AAGA;;AAkBA;AAXA;;AAEA;AAAA;AASA;;A3CvKA;;;;;;A+BxCA;AACA;AAAA;AAEA;;;;AAIA;AA0FA;AAAA;AACA;;;;;;;;;;;;AM6sCA;;;;;;;;;;;;;AAMA;;AAAA;AAAA;;;;;;;ADr/BA;;;;;;;;AA2BA;AAAA;AAAA;;AACA;AACA;AAFA;;;;;;AAKA;;;;;;;ANm0DA;;AAKA;AAgQA;;;;;;;;;;AArPA;AAEA;;;;;;A9BzoEA;AAAA;AAAA;AoB8GA;ApB9GA;AAAA;AoB6MA;;ApB7MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;A2CyQA;A3C7QA;;;;;;AAAA;;A2CyVA;;;;;;;;AbmYA;;;;;AASA;;AA1ZA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;A/B8wBA;;ACrmCA;AAAA;AAwBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADyIA;AAEA;;;;;;;;AoB6HA;AnBpRA;;;;;;;;;;;;;;;;AG23CA;;;;;;AQ/9CA;AACA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AADA;;;;;;AXwFA;AAAA;ADk0BA;AAAA;AAo3BA;ACtrDA;AAAA;AAAA;;AD0rDA;AC1rDA;AAAA;AAAA;AAAA;AAAA;AAAA;AD2rDA;ACnrDA;;;;;;AAIA;AAAA;AAAA;AAAA;AoBuLA;AACA;ApBpLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AiBgRA;AAAA;AAAA;AAAA;ADxJA;;AACA;AD8iCA;;;AACA;AAYA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AfpsCA;ADgpDA;;;AChpDA;AAAA;ADwpDA;;;AAMA;AC9pDA;AAAA;AAwBA;;;;;;AD6gBA;ACzhBA;AD2hBA;AC3hBA;AAAA;AD4hBA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAOA;;;;;;;;;;AoBjeA;;;AAIA;AAAA;AACA;;;AAIA;AACA;;;AAGA;;;;;;;;;;AAEA;;;;;;;;;;AkBoVA;AAAA;;;;AAgBA;AACA;AAAA;;;;AAGA;AACA;;;;;;AA0tBA;AAAA;AAAA;;AAsVA;AArTA;;AAfA;AACA;AAAA;AACA;;AAIA;;;AAIA;AAwTA;AAEA;;;;;;AJv6CA;;AAIA;AA+dA;;;;ADxVA;AAAA;AhCpMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AoCIA;AAoDA;;;;;;;AACA;AAEA;AACA;;;;;;ACrKA;AAAA;;AA+eA;AAAA;;;;;;;;;;AD1HA;;;;;;;AN4fA;;AA/aA;;;;;AAuhBA;AAAA;AAAA;AAAA;AA9WA;AAIA;;AAoBA;;;;;;ACtBA;;;AAFA;;;AA8CA;AAAA;AAAA;AAAA;AAAA;;;AAjDA;;;;;;;AZjgBA;AAOA;;AADA;;;;;;;AnBhBA;AAAA;AmBmMA;APgnCA;;;;;;;AwBrqCA;AAIA;AAAA;AAAA;;;;;;;;AAnBA;AAGA;AA9DA;;;;;;;;;;;;;;ArCilDA;ACrpDA;AAAA;ADspDA;ACtpDA;;;;;;AG23CA;AAHA;AgB3wCA;AhB+UA;;AAsUA;AO6vCA;AP/0DA;A2D8VA;;;AFteA;AlDugDA;;;;;;AXuEA;;ACloDA;AAQA;AD8nDA;;AC1nDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AARA;AAAA;;;;;;AAYA;AAAA;AAAA;AoB2IA;ApB3IA;AoB4IA;ApB5IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAIA;;;;;;;;AAJA;AAAA;AAAA;AAAA;A2BiqBA;A3BjqBA;AAAA;A2BkqBA;;;AA1qBA;AAAA;;;;;;;;AGykCA;AAAA;AAGA;AACA;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AOlbA;;;;;;;;;;AAlQA;AAqBA;;;;;;AVgLA;AAyJA;A3B5uBA;AAAA;AAIA;AAAA;A2BulBA;A3B/lBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;ADgkBA;AAAA;AC5kBA;AAAA;ADmlBA;;;;;;;;;;;;;;;;;;ACnkBA;AAAA;ADwcA;AACA;ACzcA;AAAA;AAAA;AAAA;AD2cA;AC3cA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD4cA;;;;;;AmEraA;AAAA;;;;;;;;;;;;A/DkMA;AAAA;AADA;;;;;;;;AEzLA;AAEA;AACA;AAEA;;;;;AAiBA;;;;AA1BA;AA+BA;;;;;;;;;;;;A0Bk8BA;AAAA;AAAA;AAAA;;;AD9fA;;;;;;;;A/BkYA;;;AA/EA;AACA;AAuuCA;;;;;;AA7EA;ACh+DA;AAAA;;;;;;;AmB+dA;;;AnBvdA;AAAA;AmBwdA;;;AACA;AAAA;;AAAA;AnBzdA;;;AmB0dA;;;;AnB1dA;;;AAAA;;;;;;AAZA;AmBqQA;AnBrPA;AAxBA;;AmBsRA;AAAA;AAAA;AAGA;AnBrRA;AmBqRA;;;;;;;;AnB7QA;;A2CuKA;;;;;;AASA;A3CxLA;AAAA;AGmxCA;;;AwCtuCA;;;;;;;;A5BkgCA;AAIA;;;;;;;;;;;;;AACA;AAgBA;;;;;;;;;;;;;AAXA;AAWA;;;;AChiCA;ADyhCA;AAAA;AAAA;AAKA;AAEA;;;;;;AkBn/BA;AA+dA;AA5PA;;AACA;AAAA;;;;;;;AAEA;AAqPA;AAlPA;;;;;;;;;;;AzB7VA;;;AAnBA;AAAA;;;AAi+CA;AACA;AAAA;AAAA;AACA;AACA;;;;;;;AR96CA;AAAA;AAAA;AAAA;AAAA;AGmxCA;AAhBA;;;;;;;;;ASnIA;;;;;;AoBj8BA;AAAA;AhCnLA;AAQA;AAAA;;;AgC0LA;;;;;;AAAA;AAzHA;;;;;;;A3BwHA;;;AAiFA;;;;;AA3BA;AAAA;AAAA;;;;AAOA;;;;;;A+BiDA;AAAA;;;;;ACsyBA;;;;;AADA;;AAkBA;;;;;;;;AN1FA;;AA/sBA;;;AAyqBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA/dA;;;;;;;;;AAzNA;;AAGA;AAAA;AAAA;AAAA;AAAA;AADA;;;;;;;;;;;A5BxEA;;AAkBA;;AA1BA;AAAA;AAAA;AAAA;AAAA;;;;AUjMA;;;;;;Ad84BA;ACj7BA;AAAA;AAAA;AAIA;AAAA;;AAAA;AAAA;ADi7BA;AC77BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAYA;AAAA;AAAA;AAAA;ADmbA;AACA;AAAA;AA2GA;AACA;AAAA;AAAA;AAAA;;AChiBA;ADsbA;ACtbA;;;;;;AAAA;AAAA;AAAA;AoBkJA;ApBlJA;AAAA;AAAA;AoBqJA;AAAA;AAAA;AAAA;ApBrJA;AAAA;AAAA;AAAA;;;;;;AmBsMA;AAEA;AAWA;AnB/MA;AAAA;AmBuNA;AnBvNA;AAAA;AAAA;AmB4NA;AnB5NA;AAAA;AAAA;;;;;;;;;;;;A2CiVA;;;A3CrVA;AAAA;AAAA;AAAA;;;;;;AW1FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AH8BA;AAEA;AAAA;AAMA;AAAA;AAAA;AACA;AAEA;AAAA;;;;;;;;AAPA;;;;;;;A6BhBA;AACA;AADA;AAAA;AA7BA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AA+BA;;;;;;;;;;;AhC8MA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;AAAA;;;;;;ANjBA;AA0DA;;;;;;;;;;;;;;;;;AClLA;ADwWA;ACxWA;AAAA;AAAA;AAAA;AAAA;AD2WA;AC3WA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD6WA;;;;;;;AC7WA;AAJA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AoB2HA;AACA;;;;;;ApB5HA;AAAA;;;;;;;;AAJA;AAAA;;;;A2CyVA;;;;;;;ANmfA;;ADphBA;;;;;;;;;;;AAAA;;;ACohBA;;;;;AAMA;AAAA;;;;;;;;;;;Aa7jBA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AnBmMA;;;;AAAA;AAAA;;AAEA;AAlFA;AAlEA;;;;;;;;;;AA4BA;AAAA;;;;;;;;AADA;AAAA;AACA;AAAA;;AAyFA;;AAAA;AAAA;;;;;;;;;;;;;;;;AhCinDA;ACzjEA;;;AAQA;AAAA;AD+nDA;;AC3nDA;;AARA;AAAA;AAAA;;;;;;AW9EA;;;;AAGA;;AAjBA;AACA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;AHoCA;AAAA;AAQA;AAGA;;;;AARA;AACA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;AAovCA;AAEA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;;;;;;;AR9tCA;ADyjEA;;AAhdA;;AAgdA;AAAA;AAAA;AAAA;;;AC7iEA;;;;;;;;AQq3CA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;;;;;;AAqDA;AACA;AAKA;AAAA;AACA;AACA;;;;;;AA0BA;AAAA;;AAEA;AAMA;;;;;;AR79CA;AAAA;AAAA;AD6iEA;;;;ACziEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AD+0BA;;;;;;AC31BA;AAYA;AAAA;AAAA;AAAA;AAAA;ADu6DA;ACv7DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwBA;AAAA;;;;;;AAxBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AQ7EA;AR6EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;;;;;AWtFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AR0hBA;AAAA;AHxbA;AAJA;AAAA;AAAA;AAAA;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AoBpDA;;;;;;;;;;;AuBgPA;A3CxLA;AAAA;A2C4LA;AxCulCA;AAhBA;;AwCttCA;A3CzCA;AAAA;AAAA;AAAA;;A2C4CA;;;;;;AkB9DA;;AAEA;;AAsBA;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;;;;;;;;;;;;A5BgtEA;;;ACv1EA;;AFqUA;;;;;;A+B+FA;A9B29CA;;;;;;;AjC5vDA;AD0aA;AACA;AAAA;AC3aA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AmB8pBA;;AA1UA;AnB5VA;AmB4VA;;AAGA;AnBnVA;AmBoVA;;;;AAMA;AnBlWA;AAAA;;;;;;;AAZA;AwDlDA;;AAWA;;;;;;;;AA4BA;;;;;;;;A1B4uBA;AACA;;;;;;;;;;;;;AAhfA;;;;;;;ApBgwDA;;APlwDA;;;;AgB7HA;;;;;;;;;;;ApBHA;AAwmCA;;;AAthCA;;;;;;;;;;;;;;;;;;;;ACtLA;AAAA;AAAA;AD8sDA;AC9sDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAZA;ADyjEA;;;;;;;ACrjEA;AAAA;AD26CA;AC/6CA;;;AAIA;AAAA;ADyzBA;AACA;AAEA;AAAA;ACh0BA;;;;;;AW9FA;AACA;AAHA;AACA;AACA;AACA;;;ARqiBA;AAAA;AA06BA;AArmBA;;AO8vCA;AP/0DA;;;;;;AiCwGA;;;;;;;;;;;;;;;;;;;;;ACklBA;AACA;AA/6BA;;;;;;AtCmZA;AC3UA;AAAA;AAAA;AAAA;AAAA;AD8UA;AC9UA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAJA;AAAA;AAAA;;;;;AAIA;;;;;;;;;;;;AsCjJA;;AACA;;;;;AAiLA;;AAEA;AACA;;;;AAOA;AAEA;;;;;;;A3BrJA;AAAA;AACA;AADA;AACA;AADA;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AACA;;;;;;AZi8CA;;AANA;AAlqCA;AAAA;;;;;;;;;;;;;;;;;AC1LA;AAAA;AAAA;A2C6PA;;AAAA;;;;;;AAOA;A3CxQA;;;;;;;;AAIA;AAAA;A4CqOA;;;;;;;AAMA;;AAEA;A5C7OA;;;;;;AWlFA;AAAA;AAAA;AACA;AACA;;AAFA;AAGA;;;;;;AAJA;AAAA;AACA;AAAA;;;;;;;AH2+CA;AAx9CA;;AAOA;;;;;;;;AAIA;AAAA;AAAA;;;;;;ARgEA;AmBwkBA;AAAA;AnBxkBA;AmBykBA;AAAA;AAAA;AnBzkBA;AAAA;AmB0kBA;AnB1kBA;AAAA;AmB0kBA;AACA;;;;;;;AcurCA;AAAA;;;;;;;;;;;;;A8B/nBA;;;;;;;;AvD9sCA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAMA;;;;;;AyB9DA;;;;;;AAiRA;;;;;;AAAA;;AA/MA;;;;;;;;;;AjC4CA;AAAA;AG2vCA;;AgBljCA;AAGA;AAAA;AAAA;;AAEA;AAEA;;;;;;AnBpMA;;AgCoOA;AAAA;;;;;;;;A+BkDA;A7BjaA;AD+1EA;;;;;;;AjChuEA;AAAA;AG4bA;;;;;;;;;;;;;;AiBxiBA;AAEA;;;;;;;AyCuIA;AAAA;AAEA;AAAA;AAAA;;AACA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;A7BuJA;AAAA;AhCrLA;AgCsLA;AhCtMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwBA;AAAA;AgC0LA;;;;;;AgB3OA;AAAA;AZ2aA;AAIA;;;AAIA;;;;;;;;;;;;;;;AY9dA;AACA;;;;AAIA;AAAA;;;;;AACA;AACA;AAGA;AACA;;;;;;AhDiEA;AAAA;;;;A2C0NA;AAAA;A3C1NA;AAAA;AAAA;A2C6NA;AACA;AAAA;AACA;;AA8BA;AA7BA;;;;;;A3CxNA;AmD8HA;AAEA;AAAA;AnDhIA;AAAA;AAAA;AAAA;AmDmIA;AAAA;AAAA;AAAA;AACA;AAEA;;;;;;;;AxB6DA;AvBjOA;AJkCA;A2BqMA;A3BzNA;AAAA;AAAA;A2ByNA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;;;;;;A5ByqCA;ACh3CA;ADi3CA;AAAA;AACA;AC13CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD63CA;AC73CA;;;;;;AARA;;AAAA;AAAA;AAAA;A2BiXA;AACA;A3BlXA;A2BmXA;A3BnXA;AAAA;A2BoXA;;;;;;AgBpUA;AAAA;;AAWA;;;AAuIA;A3ClMA;AAAA;AAYA;;;A2CqPA;;;;;;;;A5CqBA;AAAA;AAAA;;;AAFA;;;;;;;AAMA;;;;;;;AC1QA;AAAA;AApBA;AAAA;AAAA;AAAA;A6C0PA;AACA;A7C3PA;AAAA;AAAA;AAAA;AAAA;AAAA;A6C4PA;AACA;;;;;;;;;ArC5RA;AAEA;AArBA;;;AA+6CA;AACA;AACA;AAAA;AAAA;AAEA;AACA;;;;;;A0C1pCA;;AAGA;AA4PA;AA7QA;AAYA;;AAEA;AAqQA;;;AAvQA;;AACA;AACA;;AA6QA;;;;;;;;;A1C3lBA;AAAA;;;;;AA44CA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AA/4CA;;;;;;;;AR2GA;AAAA;AAAA;AoBiaA;AAGA;AAgDA;;;;;ApBhcA;AAAA;;;;;;;;;;;AgDxJA;AAAA;AAAA;;;;;;;;;AAgHA;;;;;;;AjD8pBA;AC9oBA;ADmpBA;;AA0BA;AC7qBA;AAAA;AD6qBA;;AAjBA;AAAA;AChpBA;;;;;;A6C2HA;AAIA;AAKA;;;;;;;;;;;;;A7ChJA;;;;;;AAwBA;AmDhFA;;;AAGA;;;;;;;;;;AnD6EA;AmDzEA;;;;;;;;;;;ApD85CA;;;;;;;;;;;;;;;;;AAmDA;ACh6CA;AAQA;;AARA;ADyCA;;AACA;AADA;;;AA83CA;;;;;;AY5gDA;AAnBA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAHA;;;;;;A0BgvBA;;;ADvpBA;;;;;;;;;AAydA;;;;;;;;;;AY5YA;;;;AANA;;;;;;;;AAEA;;;;;;AX66BA;AAAA;;;;AA9mBA;AAoCA;AACA;AAgaA;AApcA;AAAA;AAAA;AAAA;AAAA;;AAmCA;ADzbA;;;;;;ACspBA;AACA;AAq4BA;;AA73BA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;ADqjBA;ACnjBA;AAEA;;;;;;AW1wBA;AAmRA;;;AAjCA;;;;;;;AArFA;;AAPA;;;;;;;AhDSA;;AmB0pBA;AA1EA;AnB5lBA;AAAA;AAAA;;AmBsqBA;AnB1qBA;AmBomBA;AnBxmBA;AAAA;;;;;;;A+BkmBA;AAAA;AACA;;;;AAGA;AA/EA;AACA;;AAIA;;;AAAA;AAAA;;;;;;AAgBA;;;;;;;;AA1eA;AACA;AAAA;AAjHA;AAcA;AAGA;;;AAIA;AAAA;;;;;;;;;AAIA;AAGA;;;;;;;A/B8BA;;;;;;AYmzCA;;AZ/yCA;AAAA;AAAA;AAAA;;AAAA;AAAA;AmB+xBA;;;;;;;;AiBhfA;;AAKA;AAAA;;;;;;AALA;AAAA;AAAA;AAAA;;;;;;;;AhB/QA;;AAEA;;;;;;AAEA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AO+TA;AAkBA;A3BlYA;AAAA;AAAA;AAAA;AAAA;A2BuYA;A3BvYA;A2BwYA;;AAMA;;;;;;;AA1dA;AxBkVA;;AA1BA;;AA0BA;;;;;;AAzBA;;;;;;;;A0CxSA;;AA0GA;;;;AAAA;;;;;;AA7FA;AAAA;AAAA;;;;;;;AF+SA;AA3BA;AAAA;;;AAUA;A3C5OA;AAAA;;AAIA;A2CyPA;;AAAA;;;;;;A3CzPA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;ADosBA;ACpsBA;AAAA;ADwsBA;;;;;;;;AammBA;;;;Ae30CA;AAAA;AAAA;AAAA;AAAA;;AvBFA;;;;;;;;A0C1EA;ACAA;ADIA;AAAA;AAOA;AAcA;AAAA;AACA;AA1BA;AAIA;AAMA;AAAA;AAAA;AACA;AAGA;ACdA;;;;;;A/CwGA;AAhBA;AoBxFA;;;;;;AjBg4CA;AAAA;AAAA;AAAA;AiB/3CA;AAAA;ApBuGA;AAAA;;;;;;A6DoDA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA2DA;AA3DA;AAAA;;;;;;;AxBwmCA;;AAtBA;ADptBA;ACojCA;AAnTA;;AAjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqVA;;;;;;;;AtC1rBA;AACA;AACA;AACA;ACh0BA;AAAA;AAAA;AAAA;AAAA;AAAA;AD45CA;;;;;;;;AgE3mCA;;;;A9Bq+CA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AGl9CA;;;;;;;;AC6PA;AAAA;;;;;;;;AAtHA;AApBA;;;;AAEA;AAAA;AAs3BA;ADnrCA;AA7DA;AA+DA;;;AACA;;;;;;;;ApC3HA;AD25DA;AC35DA;AAAA;AAAA;AAAA;AAQA;AAAA;AARA;AAAA;AAAA;AAAA;AAYA;AAAA;;;;;;AD+yBA;AC/zBA;;AAAA;AD85CA;;AAEA;ACh6CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AoBsHA;ApB1HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;;;;;AmBoEA;;;AASA;AAAA;;;;;AACA;AAAA;AACA;;;;;;;AoBkRA;AAGA;;;AAAA;;;;;;;;;;;AAGA;;;;;;;;;AT8mBA;AACA;AAAA;AAAA;AAIA;;;;;AAEA;;;;;;;;;;;;;;AGtyBA;AAAA;AAGA;AAAA;AAAA;AAAA;;;AA3SA;AA+SA;;;;;;AjCjMA;AAAA;ADwgBA;AAEA;ACthBA;AAAA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;ADghBA;AAEA;AAEA;;;;;;A4BiOA;A3B7vBA;AGmwCA;;;AwB12CA;AvByEA;AuBzEA;AAAA;AAAA;AAAA;AfuuCA;;;;;;;;;;A+B15BA;A3CtNA;AAAA;;A2CiPA;;;AArBA;A3CpOA;AAAA;A2CyPA;;;;AAjBA;A3C5OA;;;;;;;;;;;;;;;;;;;;;;;;;;A2CuQA;AxCwgCA;;AwC38BA;;;AAEA;AAAA;A3CtTA;AAAA;AAAA;AAAA;AAAA;AAAA;AC/HA;;;;;;;AgCsRA;;AA/MA;;;;AAkNA;AAAA;AAAA;AAAA;AAAA;;;;AApRA;;;;;;AzBi8CA;AACA;AACA;AAv7CA;ARsFA;AQtFA;ARsFA;;AQ5EA;AR4EA;AAAA;AQ3EA;AR2EA;AAAA;AAIA;;;;;;AiB4RA;AAAA;AHnQA;;AAKA;AAAA;;;;;AAMA;AGyPA;AAAA;AAAA;;;;;;AuB4uBA;;AA+EA;;AA/EA;AAkFA;AAYA;AC3tCA;AD6nCA;AAkFA;AC9sCA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;;;;;;;;;ALgbA;;;;AAAA;;;;;;;;AA8HA;ACsjCA;AAh2BA;;;;;;;A7B5vBA;AAHA;;;AAy5CA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;AmB5hCA;AAlPA;;;;AAiQA;A3BjSA;AAAA;;;;AIlCA;;;;;;A4BqLA;AAAA;;;;;AAjIA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;ArBvIA;AAKA;AAAA;AAEA;AAAA;AAnBA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAJA;;;;;;AH0FA;;AR+BA;AAAA;;;AQhDA;AACA;AAAA;AAAA;AAAA;;;AAGA;AAAA;;;;;;AR4DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADqYA;ACrYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADsYA;;;;;;;;AqD1ZA;ApDQA;AoDHA;;;;;;;;;;;;AASA;ApDUA;;;;;;;AAIA;;;AApBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A4CiUA;;A5CrUA;;;;;;;;;AgDnGA;;AAtBA;AAoBA;AAAA;;;AAKA;AAAA;AACA;;;;;;;AAqLA;;AZiZA;;AA2iCA;AAAA;AAAA;AAAA;;;AY1/CA;;;;;;;;;;;;AZoJA;;AAPA;AAAA;AAKA;AAAA;AACA;;;AAQA;;;;;;;;;ALscA;;;;;AA6HA;AAAA;AAAA;AAAA;;;AAtFA;;;;;;;;A/BhqBA;ADssDA;AAIA;AAAA;;AA+WA;;;;;;AA3WA;AC9sDA;AD8sDA;;;;;;;;;;;;;;;;;AqC1iCA;AAAA;AAAA;;;;;AAeA;;;AAGA;;;;;;;;;ArC/fA;;AAxFA;AAAA;;;;;;;;;;AAvCA;AAGA;;;;;;;;AA8nBA;AACA;AAEA;AAyCA;;;ACjuBA;AAIA;AAAA;AD8tBA;;ACluBA;ADouBA;ACxtBA;;;;;;;;;AmBupBA;AnBvpBA;AAAA;;;;;;;;;;;;A8C7FA;AAGA;AAdA;AAIA;AAMA;AAAA;AAIA;AAWA;AAAA;AAEA;AAqQA;AAAA;;AAtQA;AAsQA;;;;;;;AnCvSA;AADA;AAAA;AACA;AAEA;AAAA;AAHA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AA5BA;;;;;;AuC2JA;AAEA;AACA;;;;AAMA;AACA;AACA;AAAA;AAGA;AAkHA;AAAA;A/CsoCA;;;;;;;AkCn8BA;AACA;AAAA;AACA;;;;AAPA;AAqDA;AAAA;AAAA;AAAA;AAAA;AAkXA;AAvYA;;;;;;;AhC5TA;;;AAEA;;;;;;;;;;;;;AAzJA;;;;;AAEA;AAAA;;AAAA;AAAA;;AAGA;;;;;AgCmIA;;AADA;;AACA;AAAA;;;;;;;;;;;;;;;;;;AJ0jEA;AjC/mEA;AAAA;AAIA;AAAA;;;;;;AgC8MA;AhClNA;AAAA;AAwBA;;;;;;;;AqCuiBA;;ADnQA;;;;;;;AAGA;AAAA;;AACA;;;;;;AGqGA;;;AAmBA;;;AAEA;AAuiCA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AvC/9CA;AAAA;ADyzBA;AC7zBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADk0BA;AAuvCA;ACzjEA;;;;;;AqC8sCA;;;AAwBA;;;;;;AAfA;;;;;;;;AAGA;ADjvCA;;AAAA;;;ACsvCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjBjnCA;AACA;AAEA;;;AAGA;ApBpGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AiClHA;;AA2MA;AA5BA;;AAueA;AAAA;;AApeA;AAAA;AAAA;AAAA;AAAA;AAlLA;AAsLA;AAgeA;;;;;;;AGtZA;AACA;;;;ACusBA;;;AAqBA;AAAA;AAAA;AAAA;;ADvlBA;AAAA;;;;;;;;;;ArC0UA;AC9mBA;AAAA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;ADwmBA;ACxmBA;AAAA;ADwmBA;;;;;;AAk9BA;;AC9jDA;AAAA;ADojDA;AAAA;;;;;;AA6fA;AC7iEA;;;;;;;;AuC2hBA;AA+KA;;;AAxfA;AAEA;AAAA;AASA;AACA;AAAA;AAAA;AAAA;AAAA;;AA+fA;AAKA;;;;;;;AoBn3BA;;;;;;;;;AA+DA;;;;;;;;;;;;;;;;;;A5B0fA;AAAA;;;;;AAIA;;;;;;;;;;AM+CA;AAAA;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AP+CA;AAIA;;AACA;;AAkBA;;AACA;AAAA;AAAA;AAAA;AArgBA;AAugBA;;AAKA;;AAgMA;AAUA;;;AAzMA;AACA;AA8LA;AAUA;;;;;;A9BnvBA;ADuWA;ACvWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD0WA;AC1WA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD2WA;;;;;;AiD9VA;;;AAAA;AAIA;AAAA;AACA;;AANA;;AAKA;AAAA;AACA;;;;;;AInHA;ApD6FA;AAAA;AAAA;AAIA;AAAA;AoD9FA;ApD8FA;AAAA;AoD7FA;ApDyFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AoDxFA;;;;;;AfqgBA;AAQA;AAEA;;;AACA;;;;;;;;;AAMA;AACA;;;;;;ArC/bA;AAAA;AAAA;AAAA;ADwgBA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAKA;AC3hBA;AAYA;AAAA;;;;;;;;AAIA;AGwbA;;;;;;;;;;;;;;;AH5bA;A2BgvBA;A3BxvBA;AAAA;AAAA;AAAA;;;A2B0hBA;;;;A3B1hBA;;;;;;AQgqCA;AAGA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;AgCq0EA;AA1+EA;AA+EA;;AC5rCA;;AD6mCA;AAkFA;AAAA;AAAA;AAAA;AAYA;;;AAZA;;;;;;;;;AjCpeA;;;AAGA;;AAoBA;AAAA;AAAA;AAAA;AAnBA;AAsBA;;;;;;;A8B6CA;;AA7SA;;AAteA;AACA;AAOA;AAAA;AAAA;AAAA;AACA;AACA;AD8tBA;;;;;;;ApC/nBA;AApBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AYwnCA;AevjCA;;;;;;;;AhBnKA;AACA;AADA;AADA;AAAA;AAEA;AAHA;AAEA;AAAA;AAFA;AACA;;;;;;;;;AmBynBA;AAIA;;AACA;;AAkBA;;AACA;AAAA;AAAA;AAAA;AArgBA;AAugBA;;AAKA;;AA/BA;AAqDA;;;AArBA;AACA;AAjCA;AAqDA;;;;;;AO7CA;;;;;AAEA;;;;;AAFA;;;;;;;;;;;ANoNA;;;;;AAAA;;;;;;AATA;AAAA;AASA;;;;;;;A/BtuBA;AAAA;AAAA;AAAA;AAAA;AAAA;ADseA;AACA;AAAA;AAAA;AAAA;AAAA;;ACneA;AAAA;;;;;;AoBoLA;ApBxLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AoB8LA;ApBlMA;;;;;;A2BvCA;;A3BuCA;AAAA;;A2BgvBA;;;AApFA;A3B5pBA;AGmwCA;ASgDA;;;;;;;;A0Bj7CA;;;;AAdA;AAAA;AAAA;;;;;;;;;;;AA+BA;AA/BA;AAAA;;;;;;;;AP4pBA;;;;;;;;;;;;;;;;;;;ApBtmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AyBgIA;AAyEA;AAAA;;;AADA;;;;;;;;;;;ArCo0DA;;;;ACl8DA;AAAA;AAAA;AAAA;;;;;;;ADyjEA;AA9pBA;ACv5CA;;;;;;AoBwHA;ApB5GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AoBgHA;AA8FA;;;;;;AapKA;;AA0fA;AAxfA;AA9JA;AAAA;AAAA;AA+JA;AAIA;AAmfA;AAAA;AAAA;AAAA;AAtZA;AAAA;;;;;;;;;AI8sBA;AAIA;AD5kBA;AAAA;;AACA;AADA;;;;;;;;;;;;;;ArCswBA;;;;AAsgBA;ACpiDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADsiDA;ACliDA;;;;;;;AmB2vBA;;;AnBnvBA;AAAA;AAAA;;AmBuvBA;AnB/vBA;AAAA;;;AAAA;;;AAAA;;;;;;;;AAZA;;AmBZA;;;AP4oCA;;;AOn1BA;;;;;;;;;;;;;AX4lCA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;;;;;;ARx4CA;AAAA;A2B8mBA;A3B9mBA;AAAA;AAAA;A2BgvBA;;AA5HA;A3BpnBA;AAAA;;;;;;;;AqCjGA;ADs9BA;;;;;;;;;;AA5EA;;AAtfA;;;;;;;AV8DA;AAAA;AACA;;;;;;;AAAA;;;;;;;;AAMA;;;;;;AV5VA;;AUiWA;;;;;;;;;ArBnUA;AAAA;;;;;;;;AAgCA;AAAA;;AADA;;;;;;;;AeyHA;ApB9MA;AoByIA;ApBzIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;;;;;;AAQA;AAAA;AAAA;;AAhBA;AAAA;AAAA;A2ByIA;;;;;AA2BA;A3BpKA;A2B2IA;;;;;;;ApBmcA;;AAAA;;;;AAWA;;AAGA;AAAA;AAAA;;AACA;;;;;;;APjmBA;AAAA;AAQA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AARA;AD2lDA;;;;;;AC/kDA;AAAA;AD+hBA;AACA;;AChiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD6aA;AC7aA;AAAA;;;;;;;AQy9CA;AAnPA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AAAA;AACA;AAAA;;;;;;;;ARpvCA;AAZA;ADi2DA;AAIA;AAYA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;AanjBA;AZvzCA;A2CyCA;;AAGA;AACA;AAIA;AAGA;;A/BwkCA;;;;;;;;;AJ3uCA;;;;;AAiyCA;AACA;;AAKA;AAGA;AAAA;AACA;AACA;AACA;;;;;;AsB7aA;AAhaA;AA0ZA;;AAnaA;;;;;;AAsaA;;AAQA;AAQA;;;;;;A9BtxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADsZA;ACtZA;AAAA;;;;;;AqCpGA;;;;;;;;;;;;;;;;;;;;AjCsEA;AO3GA;AAEA;AAEA;;AAJA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;AyB2IA;AAAA;AAAA;;;;AAsGA;;AAtEA;AAyEA;;AAAA;;;;;;;;;;ApC/HA;ADg+BA;ACh+BA;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADk9BA;ACt9BA;AAAA;;;;;;AARA;AAAA;;AQzEA;;;AAw5CA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAAA;;;;;;AR90CA;AAAA;AAAA;;;;AD6vCA;AAAA;AAAA;AAAA;AACA;;AAEA;AAHA;;;;;;ACrwCA;A2BwYA;AAKA;AAAA;AADA;AAAA;AAEA;;;;;;;AAGA;AAZA;;;;;;;;AbpKA;AAAA;;;;AAMA;;;;AAOA;AAAA;AAEA;AACA;;;;;;AAtGA;AGgJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AH/GA;;;;AGgHA;AAAA;;;;;;;;;AZ1LA;AAAA;AACA;;;;;;AAcA;AAAA;AACA;AAAA;;;;;;;;;AgCofA;AAAA;AACA;;;;;;;AD/oBA;AAAA;ACopBA;;;;;;AjBtRA;AACA;AAGA;;;;;;;AAGA;AAAA;AAAA;AAAA;;;AAjBA;AACA;;;;;;AyBnRA;AAAA;AAKA;;;;;AAWA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;AASA;AAGA;;;;;;;;;A9C65CA;AAxzCA;;;;;;;;;;;;;;;;;AAgoBA;AAAA;AAyqBA;AAAA;;AC3+CA;AAAA;AAAA;;AAAA;;ADi/CA;ACz+CA;AAAA;AAAA;ADy+CA;;;;;;;;;AA2fA;AC5+DA;AAYA;AAAA;AAAA;AAAA;;AARA;AAAA;AAAA;AAAA;ADyzBA;AACA;;;;;;;;;AC1zBA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A2BwJA;A3BxJA;;;;;;;A2B0QA;AAEA;AvB9RA;AAAA;AuB8RA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;ASwKA;;;AAnIA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;ACnZA;;AA22BA;AAguBA;AACA;AAAA;;AA5uBA;AAEA;;;;;ADkdA;;;;;;;ATzuBA;AvBjiBA;AAxEA;AuBscA;AAAA;;AAmKA;A3BvfA;AAIA;A2BwVA;A3BxVA;AAAA;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;;A2CyVA;;;;;;;;;A3CjWA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADohCA;AACA;AAEA;ACvhCA;;;;;;;;;A8BgiEA;AAAA;;;;;;;;;AASA;;;;;;;AAv5CA;AAzCA;;;AAkDA;AAMA;AAAA;AAAA;AAAA;AA6BA;AAEA;AACA;AAMA;;;;;;Ac7eA;A5C1NA;A4C4NA;AAiFA;A5C7SA;AAAA;AAAA;AGmxCA;AAAA;AAAA;AAAA;AAhBA;;;;;;;;;AJulBA;AC91DA;AAYA;AAAA;AAAA;AAAA;ADo1DA;ACh2DA;AAAA;;ADq2DA;AAAA;AArvDA;AAwvDA;AAAA;;;;;;;AAoHA;AC59DA;;AAwBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAxBA;AAAA;;;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;AAAA;AAAA;AqB0OA;ArB1NA;AAAA;;;;AAhBA;AqB+OA;ArB/NA;AAAA;AAAA;AAAA;;AqBmOA;;;;;;ArB/NA;AmBmdA;AAAA;AAAA;AnBndA;AAAA;AAAA;AmBmdA;AACA;AAAA;AnBpdA;AAAA;AAAA;AmBodA;AACA;;;;;;;;AoBUA;AAGA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6BA;AAIA;AAEA;;;;;;;;;ANtZA;;;AAvBA;;;;;;;;;;;;;;AD6GA;;AhCpMA;AAAA;AgCuMA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;AhC7NA;AAAA;;A2BsXA;AAAA;AAAA;AAAA;;AAGA;AADA;AAAA;;;;;;;;;;AqB9ZA;AAAA;Ac4jBA;Ad3jBA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AL0PA;;;A3ClNA;;;A2C0NA;A3C1NA;AAAA;A2C8NA;AA+BA;;A3C7PA;;;;;;AiCoEA;AACA;AAGA;AAlLA;AAuLA;;;;;;;;AAiEA;AA9FA;AAEA;;;;;;AjC1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;A2BwLA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;;;;;;;APiKA;;AAYA;;;;;AAUA;ApBlYA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAoBA;;;;;;A6CkFA;;;;;;AAUA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;;;;;;;AL0/BA;;;;;;;;;;;;;;;;;;AH74BA;;AA3PA;;;AD2TA;AADA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AYpTA;;;;AAGA;AACA;AAAA;AAAA;AAAA;;;AAGA;AAWA;;;;;;AeyoCA;A9BmuBA;AAMA;;AAEA;;ADrwDA;;;;;AAiGA;;AhC9MA;AAAA;;;;;;AqBhHA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAPA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AUgeA;AAAA;AAAA;AAnBA;;;AAPA;;;;;;;;;AhC7KA;AA0EA;AAGA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;;;;;;AC9OA;A6CqNA;AAIA;AAAA;A7CzNA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;A6C4NA;A7C5NA;AAAA;AAAA;;;;;;AAJA;AAAA;AAAA;;;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;;;;;;A2BoGA;;AAgEA;;;A3BhJA;AAAA;AAAA;AAAA;AAAA;AAAA;AC/HA;AW2tCA;;;;;;AZpnCA;AAAA;;;;;AD49DA;;AC59DA;;;ADizDA;AAGA;AAAA;AC5xDA;AAAA;;;;;;AAxBA;AAAA;;AD8sDA;;;;;;;;;AC9sDA;AAAA;AAwBA;;;;;;AoBuLA;ApB/LA;AAAA;AAAA;AoBkMA;ApBlMA;AAAA;AoBmMA;AAAA;AAAA;AAAA;AACA;AAAA;;AAGA;;;;;;;AX6aA;AAAA;AAAA;AACA;AAFA;;;;;;;;;;;;;;;ALjpBA;AQ60CA;;;;;Ae30CA;AvBFA;AuBEA;AAAA;AAAA;AAAA;;;;;;;;;;;A5B6XA;AAAA;ACjWA;ADoWA;ACpWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADsWA;ACtWA;;;;;;AqCg5CA;AAKA;ADvoCA;AAAA;;;;;;AC2oCA;AA50CA;AAGA;AACA;AACA;;;;;;ADrEA;AAmHA;AAIA;;AAGA;AAEA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;AACA;AAFA;;;;;;;;;ATwMA;A3BjWA;AAAA;AAAA;AAoBA;AAAA;AApBA;A2BmWA;;AAGA;;;;;;AM8gBA;AA42CA;A8Bt7DA;;;;A9Bs7DA;;;;;;;AA5jDA;;;;;;;AjCppBA;AmBmBA;;;;;;;AAqBA;AACA;AAAA;AAAA;AACA;;;;;;AnB9DA;;;;;;;;;;;;;;;;;;;;;A6ClGA;;;;;;;;;;;;;AA2BA;AACA;AAIA;;;;;;AxC0MA;AAAA;;;;AAvEA;AAAA;AACA;AACA;AACA;AAAA;;AAEA;;;;;;;;;A+B0PA;AACA;AACA;AAHA;;AAKA;;;;;;;;;;;;;;;;;AAAA;;;ACy8BA;;AAdA;;;;ADtcA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;ApCzzBA;AAAA;AAIA;AAAA;ADyzBA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AC/zBA;AAAA;ADgoDA;;;;;;ACpnDA;AoBqIA;ApBjIA;AAAA;AAAA;AAAA;AoBoIA;ApBpIA;AAAA;AAAA;AAAA;AAAA;AAAA;AoBsIA;AAuEA;;;;;;ADkaA;AnB3mBA;AAAA;AAAA;AAAA;AmB0pBA;;AnB9pBA;;;AmB8pBA;;;;;;;;AXpxBA;AAAA;;AAEA;;;;AA6kDA;AA3hBA;;AApjCA;AAAA;AAAA;;AADA;;;;;;;;;AI2uCA;;AehnCA;AACA;;;A3BTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;ADu2DA;AAAA;;;AA1uDA;AAAA;AAAA;;;;;;;AADA;;;;;;;;AAodA;;AAAA;AAxBA;ACpkBA;AAwBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAZA;AAAA;ADglBA;;;;;;;;;AoEnVA;AAAA;AADA;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AlC9CA;AAAA;;AA9TA;;;;;;;;AA+YA;AAjOA;AAEA;AAseA;;;;;;;;;ADzYA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AKkpCA;;;;;;ADjwCA;AA+DA;;;AACA;AAAA;;;;;;;;AVyNA;AAAA;;AAAA;;AAEA;AAAA;AAAA;;;;;;AAUA;AV5TA;;;AU+TA;ATvEA;;;ASyEA;;;;;;;AwB9KA;AACA;AAEA;;;AASA;AAIA;AAEA;AAAA;AAAA;;AAGA;AACA;;;;;;;;AlDjMA;ADsdA;AAyEA;;AC/hBA;AAAA;AAAA;AAAA;ADydA;AAAA;AAAA;AAAA;ACzdA;AAAA;AAAA;AAAA;;;;;;;AG0PA;AAAA;;;;;;AAzBA;AUlMA;AVgOA;AAAA;AAAA;AAAA;;;AAAA;;;;;;AH/PA;AAIA;A4CyVA;;AAlSA;A5C3DA;AAAA;AAAA;AAAA;AAAA;AAAA;;;A4C4WA;;;;;;A5C5XA;;;;;A2CqTA;A3CzSA;AAAA;;;;A2C4RA;A3C5RA;;;;;;;;AQw2CA;AA36CA;ARuDA;AQvDA;;;;;;;AAQA;;;;;;;;AR+DA;AAAA;AAJA;AAAA;A2BgvBA;;;A3B5uBA;AAAA;A2BylBA;A3BrlBA;AAAA;AAAA;AAAA;;;;;;AQhEA;AAAA;AAAA;AACA;;;;;AAOA;AAAA;AAAA;AACA;AAEA;;;;;;;;;AE2/CA;AACA;;A6C+rFA;ApDnyFA;AAAA;;A+CvoCA;AAtBA;AAYA;AAAA;;AAsBA;;;;;;;;;;;;;;;;;;A3C+/BA;;;;;;;;;;;;A8BldA;;ADreA;;;;;;AAAA;;;ACqeA;;;;;;;;;AlC/hBA;AA1BA;AAAA;;;AA0BA;AAAA;AAAA;AAAA;;;AAzBA;;;;;;;;AQtWA;AAeA;AAeA;AADA;AACA;AADA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AACA;AAKA;;;;;;AXkGA;AmBgcA;AAAA;AnB5bA;AAAA;AAAA;AAAA;AmB6bA;AAAA;AAAA;AAAA;AnB7bA;AAAA;AmB8bA;AAAA;AAAA;;;;;;ARxkBA;AAAA;AADA;AAAA;AAEA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;AHooBA;AAOA;AAGA;AAEA;ARniBA;AAAA;AQoiBA;ARpiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AG8cA;A+CpbA;A/Co2CA;;;AAMA;;;;AAAA;;A+Ct2CA;A/Cg2CA;AASA;;;;;;;;ACz/CA;A0Bo+CA;AAAA;AAl8BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAk8BA;AAAA;;;;;;;;A9Bl2CA;AAAA;AAAA;AAAA;AAAA;AAAA;ADwYA;AAAA;;;;;AAuJA;;AC/hBA;AAAA;;;;;;AQpHA;;ARoGA;AAAA;AAAA;AAAA;;;;;;AQ7EA;AR6EA;AAAA;AAAA;;;;;;;AKwKA;AAAA;;AAlKA;;;;;AAQA;AAAA;;AAEA;AA9BA;;;;;;;;AsDtFA;;;;;;;;;;;;;;;;;;;;A5D83BA;AC1xBA;AAQA;;;;;;;;;;;AD0yBA;;;;;;;AwC6BA;;AAsHA;;;;AAKA;;;;;;;;;AAQA;;;;;;;AnBh6BA;AAAA;;;;;;;;;;;;;;;;;;;;;AW6TA;;AAsFA;;;;;;;AAAA;;AA/CA;;AAnEA;;;AA2BA;AACA;AAAA;;;;;;;AiBhfA;;AAIA;AAwBA;AAAA;;;;AAKA;Ac0nBA;AdznBA;AAGA;;;;;;AjDmJA;AAIA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;AAEA;;AC9DA;AAYA;;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAJA;AAwBA;;;;;;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;AD8dA;AACA;AAAA;AAAA;AAAA;AAAA;;AAiEA;AChiBA;ADieA;;;;;;;ACjfA;AAQA;;ADijEA;AA5XA;AC7rDA;AAAA;AAAA;AAAA;AAAA;AAYA;AAAA;AD6iEA;ACrjEA;;;;;;;AkBq3BA;AAAA;AAAA;;;;;;;;;;AHqPA;AACA;AAAA;;;;;;Af/lCA;AAAA;AAAA;AAAA;AAAA;AAAA;AD8fA;ACtfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAZA;AAAA;;;;;;A2CrBA;;AAEA;AA7FA;AxCk+CA;AASA;;AAHA;AwCn5CA;;;;;;;;;;;;;AX0KA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;ArBnPA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;;;;;;AADA;AACA;AAAA;AAAA;AAAA;AARA;AACA;AAAA;AACA;AAFA;AAAA;AACA;AACA;AAHA;;;;;;AS0DA;;AAxCA;AAEA;AAAA;;;AjBohBA;AHxbA;AAAA;AoBxFA;ApBoFA;;;;;;AAAA;AAAA;;;AAZA;AAAA;AAAA;AG+wCA;AAAA;;;AwB1yCA;Af+pCA;;;;;;;;;;;;;;AelnBA;A3BlgBA;AAAA;A2BmgBA;A3BngBA;;;;;;;AI3GA;;;;;;;;;;AuBiJA;AAAA;AAEA;A3BpDA;;;;;;AQhDA;;AAQA;AAAA;AAGA;;;;;;;;AARA;;;;;;;AIw2CA;;AThDA;;AwBnhBA;;;AAvxBA;Af+pCA;AA2LA;;;;;;;;;A2C21FA;ADp/HA;;AnDitCA;;AAhGA;AAhBA;AwC/vCA;;A/B4nCA;AA2LA;;;;;;;;;;ATjjBA;AAAA;;AAEA;A2DtPA;ARnZA;;;AMnFA;;;;;ANqFA;AnD4uCA;;;;;;;;;AiC39BA;;;;AAIA;AAAA;AAAA;AAAA;;;;;;;;;;ApC9ZA;;;;AoBqTA;AAAA;;ApBrTA;AoByTA;ApBzTA;AAAA;AAAA;;;;;;AIdA;;;AuBqgBA;;;;AAtBA;AAsBA;;A3BnfA;AAAA;;;;;;;A2B/CA;;;;;;;;;;;AA1CA;AAAA;AAAA;;;;;;A3BiGA;AAAA;AD8tCA;AC9tCA;AAAA;AAAA;ADsuCA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAIA;AC5uCA;;;;;;AGoOA;;AC7QA;;AD4yCA;AAgBA;ASgCA;AAAA;AAAA;AAAA;;;;Ae12CA;;;;;;;;;;AGqkBA;AAIA;;AACA;;AAkBA;;AACA;AAAA;AAAA;AAAA;AArgBA;AAugBA;;AAKA;;AAsBA;;;AArBA;AACA;AAoBA;;;;;;A9BnkBA;AAAA;AAAA;AAYA;AAAA;AAAA;AAAA;ADw3CA;AA/uCA;;;AAEA;;;;;;;;;;;ACvJA;AoEnJA;ApEuIA;;AoEtIA;ApEkJA;AAAA;;;AAZA;AAYA;AAAA;;;;;;;;;AiBoRA;AAAA;AAAA;;AO8bA;;AAAA;;AA2BA;;;APzdA;AAAA;AAAA;AOicA;;AAwBA;;;;;;;;AxBzuBA;AD4YA;AC5YA;AAAA;AD6YA;AC7YA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD8YA;AC9YA;AAAA;AAAA;;;;;;;;;;;AAAA;;;AmDsIA;AAAA;;AARA;AACA;AnD/HA;AmDmIA;AACA;;AAEA;AAAA;;;;;AZ40BA;AAEA;;AAKA;AAAA;AAAA;AAAA;AAEA;;;;;;;AA4dA;AAEA;AACA;;;;;;AxCzhCA;ACjaA;AAAA;AAAA;AAAA;AAAA;ADoaA;ACpaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AeunBA;AA4hBA;;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AJtwCA;AACA;AAAA;AACA;;AAKA;AACA;AADA;AACA;AADA;AAAA;AACA;AAAA;AADA;AACA;;;;;;;AGiXA;;;;;;AA0EA;;;;;AAMA;;;;;;AElUA;AAAA;ADykCA;AACA;;AAyCA;AAAA;;;;;;;AACA;;;;;;;;Af5oCA;AAAA;AoB1GA;ApBsGA;AAAA;AAZA;AGwcA;AAAA;;;;;;;AAg2BA;AiB/3CA;AAAA;;;;;;ApB2GA;AAAA;;ADitBA;AACA;AC9tBA;AAAA;AAAA;AAAA;AAAA;AAAA;AD8tBA;AAEA;ACxtBA;;;;;;;AoCgTA;;;;;;;;;;;;;;;;;;;AYvcA;AAGA;AAAA;;;AAJA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;;;;;;;AjBkfA;AAAA;;AA3BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AhCg+BA;;;;;;AevjCA;;;AAOA;AAEA;AACA;;;;AAKA;AAAA;AACA;AACA;;;;;;AGkBA;;;AH3JA;AG4JA;AAAA;AAAA;AAAA;AH3JA;;;;AAKA;AAAA;;;;;;AXsGA;;AC7QA;;;AD4yCA;AAAA;AAAA;AAAA;AAAA;AAgBA;ASgCA;;;;;;;;;;A2B9pCA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;ARiOA;;AA3CA;AAkBA;;AAuFA;;;AAAA;;;;AAAA;AAAA;;;AA/CA;;;;;;;AAvWA;AAMA;AACA;AAEA;AACA;AAAA;AAEA;;AAqCA;AA/BA;AACA;AAlGA;;;;;;;AawFA;AAAA;AAAA;AAKA;;;;;AAkKA;A5C3NA;AAAA;AAAA;A4C2NA;A5C/MA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD8XA;AC9XA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADgYA;;;;;;;;AqDxaA;;;;AAIA;;;;;;;AAKA;AAAA;;;;;;AJpFA;AASA;;;;;;;;;;;;AA/BA;AAoBA;;;;;;;AjDs6CA;AACA;AC1zCA;;;;;;;;;;;;;;;;AARA;AAAA;A6CkRA;A7ClRA;A6CqRA;AAdA;AAAA;;;A7C3PA;AAAA;AAAA;AAAA;;;;;;;AW5GA;AAAA;AACA;AAAA;AAEA;AAFA;AACA;AAAA;AACA;AAHA;AACA;AACA;AADA;;;;;;AAQA;AAAA;AADA;AAAA;AACA;AAAA;AADA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;;;;;;AyB+GA;AAqGA;;;;;;AAgDA;AAPA;AAAA;AAKA;AACA;AACA;;AAOA;;;;;;ApCvKA;AAZA;AAAA;AAAA;;ADyjEA;;;;;AApYA;ACjrDA;AAAA;ADyzBA;;;;;;AqBloBA;ApB3KA;;AAAA;AAAA;AoB+KA;ApB/KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;A2CqPA;;;AAjDA;AAAA;A3C5MA;AAAA;A2C+MA;;AA8CA;;;AA3CA;;;;;;;;;;;;;AnCwuBA;;;;;;;;AAtiCA;;;;;;;ALs9CA;AApmBA;AO6vCA;A4Cp4DA;;;;;;;;;AAEA;A5CwtCA;;;AAyHA;;;;;;;AV98CA;AAAA;AD0wCA;ACtwCA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AD4wCA;AAAA;AC5wCA;AAIA;;;;;;AAZA;;AAJA;AAAA;;;;;;;;;AQs2CA;AACA;AAEA;;;;;AOpXA;AACA;Af99BA;AgBMA;AAAA;AACA;ADy9BA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AACA;;;;;;AsBxjBA;AA1BA;;;AAMA;AA+4BA;AACA;AAEA;;AAAA;;AA2KA;;;;;;;ADprCA;AAHA;;;AAKA;;;;;;;;AAAA;ACqeA;;;;;;;;ADgBA;;;;;ACkXA;;;ADzuBA;AAAA;ACojCA;AAEA;AArTA;;;;;;;;AJloCA;AA+RA;AAgNA;AA1NA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AA3QA;;;;;;;;AjCjEA;AAAA;;;;;;;;;;;;;;;;;AqC4oBA;AACA;AA/LA;AAGA;AAUA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;ArC3dA;AAAA;AAAA;AAAA;AAAA;AAAA;ADudA;AAAA;;;;ACvdA;AAAA;AAAA;AAAA;;;;;;;;;AqC+iBA;AAAA;AAAA;ADnQA;;AAGA;;;;AAAA;;;;;;;;;ACoHA;AAMA;;;AAQA;AAEA;AAAA;;AACA;;;;;;;;;;;A7BpfA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AG5EA;AAEA;AAAA;AAAA;AACA;;;;;;;AAaA;AAAA;AAEA;AACA;;;;;;AXqGA;AAAA;AAwBA;AAAA;AAAA;AAAA;ADi6DA;ACz7DA;AAYA;AAAA;AAAA;AAAA;;;AD6iEA;;;;;;;;;;;;AsC9oEA;;;;;;AACA;;;;;ADuDA;ACxBA;;;;;;;;ArC6EA;;ADqtDA;;AAQA;;;;;;AAnjDA;;;;;;;;;;;;;;AsD3PA;;;;;;;AAaA;;AAeA;;;;;;;AjBiWA;;;AAAA;;;;;;;ACuDA;AA0BA;AAzBA;;;;;;;;;;;;;;;A5BpMA;;;;;;;;;;;;;AAYA;;AACA;AAAA;;;;;;AE3SA;AAAA;AACA;AAAA;AAnBA;AAEA;AAAA;AAAA;AACA;AAKA;AACA;AACA;AADA;;;;;;;A0BipBA;AAAA;;;;;AAEA;;;AAFA;;;;AASA;;;;;;AAqQA;AAAA;;;;;;;;AAv2BA;;;AAIA;;;;;;;;ArCmEA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD+6BA;AC/6BA;AAAA;;;;;;;;;AqCiwCA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AAKA;AAAA;;AACA;;;;;;AtCxkBA;;;AAlqBA;;;;;;AAAA;;;;;;;;;;;;;;ASoDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;;;;;;;AHjDA;;;;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;;;;;;;;;ALlDA;AAAA;;A6CqOA;A7CzPA;A6C2PA;A7C3PA;AAAA;AAAA;A6C6PA;AAAA;AACA;AAIA;AAlFA;;;;;;A7CxJA;AAxBA;AAAA;AD8pDA;;;;;;;;;;;;;;;;;;;;;AqC5uCA;;AAGA;;;;;;;;;;;;;;;;ApCraA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AoBmKA;ApBnKA;AAAA;AAAA;;;;;;AiC0QA;AAAA;AACA;AA9MA;AACA;AAseA;;AApeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAlLA;;;;;;;;AeEA;AACA;AAGA;AAEA;AAIA;AAEA;AANA;;;;;;;;;;;;;;;ARyrCA;AAu5EA;;AAzsEA;;AAtQA;AAAA;AAAA;AAAA;AAAA;AEx/BA;;;A7BRA;;;;;;;AmC/FA;;;AAGA;AAAA;;;;;;;AAKA;AAEA;;;;;;AhBgQA;ACybA;;AA7uBA;;AAkpBA;AAlpBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AjC8GA;AAAA;AAAA;AAAA;;AARA;AAYA;AiDoBA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AzCgsCA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;;;A+BvsBA;;;;;;;;;;;;;;;;;;;;;AF+GA;AD/MA;AAAA;;;AAnIA;;;;;;;AAAA;;;;;;;ATlIA;A3BzKA;A2B6KA;A3BzLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AAAA;AAAA;AAAA;;;;;;AWjHA;AAAA;AAHA;AAAA;AACA;AAEA;AAHA;AAAA;AACA;AACA;AACA;AAHA;AAGA;;;;;;;;;AiC6dA;;;AzCu5BA;AAhBA;;AyCv4BA;;;;;;AAxUA;;AAGA;AACA;AACA;AACA;;AhCskCA;;AgCpwBA;;;;;;A5ChXA;AAAA;AAAA;AD2bA;;AAqGA;;;;;;AChiBA;AAAA;AAAA;;;;;;;AoD2CA;AAAA;AACA;AAEA;AACA;AAAA;AACA;;AAPA;AAkBA;AAjBA;AAEA;;;;;;;;;;AfkxBA;;;;;;;;AD5YA;;AC7CA;AAAA;;AAk+BA;AA58CA;AAIA;AAQA;;;;;;ArCyEA;AQpEA;;;AAq5CA;AAEA;AAGA;AAAA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AACA;;;;;;AR70CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AoCsCA;;;AAyEA;;AADA;AAAA;;;;AAxGA;AAAA;;;;;;;ALsgBA;;;;;;;;AA4CA;AAyGA;;;;;;;;;;;;;;;;;;;A/BjrBA;;;;;;;AWxFA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;;;;;;AH6CA;;;AACA;;;;;;;;;;;;;;;;AuBiaA;;AAVA;AACA;;AAmFA;;;;AAAA;AAAA;AA3DA;;;;;;;AhCsiDA;AAAA;AAAA;AAAA;AACA;AC96DA;ADi7DA;AAAA;AACA;;;;;;AAGA;ACz6DA;;;;;;AAYA;AAAA;AAAA;AC/HA;AF2gEA;;;;;;;;;;ACp6DA;AAIA;;;;;;;AoCyJA;AAAA;AAAA;AACA;AAAA;AAHA;AAEA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;;;;;AAnBA;;;;;;;;;;;;;ArCshDA;AAAA;AAAA;AAAA;AAAA;AAAA;ACrpDA;AAAA;AAAA;;;;;;AoB0KA;ApBtKA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AoB4KA;ApBxKA;AAAA;AAAA;;;;;;AiC0CA;;AA0fA;AAxfA;AAAA;AA9JA;AAAA;AAkKA;AAHA;AAAA;AAAA;AAAA;;AAufA;;AAlRA;;;;;;AjClRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD6VA;AC7VA;AAAA;AAAA;;;;;;AAZA;ADwkBA;AC5kBA;ADmlBA;ACnlBA;AAAA;AAAA;ADmlBA;AAAA;AAAA;AAAA;AACA;AAQA;;;;;;;;AgCjgBA;;;;AAgQA;;;AACA;;;;;;;;;AAmBA;;;;;;;ADoMA;;;AAsNA;AAAA;AAGA;AAAA;AAAA;AAAA;;;AA+BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;A9B3xBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADuUA;ACvUA;ADyUA;;;;;;;;;;;AKhXA;AOxEA;AAAA;AAAA;AACA;AACA;AAAA;AAHA;AAGA;;;;;;AyB8OA;;;AAMA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;;;;;;;ArCiBA;AACA;AAGA;;;AAJA;;AAQA;AAAA;AAAA;AAAA;;;;AAxFA;AAAA;;;;;;AC/EA;;AgC8DA;;;;;;;;AASA;AhCnFA;AgC2FA;;;;;;;;AoBrJA;;;AAiBA;;;;;AAAA;;AAXA;;AAWA;;;;;AAAA;;AALA;;AAKA;;;;;;;;;AhB4DA;;;AA2IA;;;AAGA;AAAA;AAKA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AhBtEA;;;;;;;AZ1MA;;AAAA;AAAA;;AA+vCA;;;AAgVA;;;;AAzUA;;;;;;;;A4CrsCA;;AANA;AAIA;AAEA;;;;;;AAaA;;;;;;AtBiMA;A3BqtCA;;A2BvKA;;;;A3B/wBA;AAAA;;;;AAqUA;;;;AAjlBA;;;;;;;AHxLA;;AD25DA;AC/4DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADk5DA;AAAA;ACl6DA;;;;;;AAgBA;AAAA;AoBwQA;ApBxQA;AAAA;AAAA;AoByQA;AAAA;ApB7QA;AoB8QA;ApB9QA;AAAA;AAAA;;;;;;;A2B2eA;A3B/eA;AAAA;A2BucA;AAEA;;AAsCA;;A3BnfA;A2BmdA;A3BvdA;AAAA;;;;;;AAgBA;ADgcA;AChcA;AAAA;AAAA;AAAA;ADmcA;ACncA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AgC4MA;AAAA;;AACA;AAAA;AhCrMA;AC/HA;A+BqUA;AACA;AACA;AACA;;;;;;ArBtVA;AAKA;AAGA;AAAA;AAZA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;AH+BA;ARsFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;AoCmLA;AApHA;AAgEA;;;AADA;;;;;;AAvGA;AA0GA;;;;;;AjCsvCA;AUx0CA;;;AiBqsCA;AAIA;;AAAA;AAAA;;;;;;;;AAkBA;;;;;;;;;;;;;;;ACxtCA;;;;;AAGA;;;AAGA;;;;;;;A/BxDA;AAAA;AAAA;AAIA;AAAA;AAAA;A2CoJA;A3CxJA;AAAA;AAAA;;A2C0JA;;;;;;;;;;;;;AS1GA;AAAA;;AAXA;AACA;;;AAUA;AAAA;;AATA;AAEA;AACA;AACA;;AAKA;AAAA;;;;;;ApB5CA;AAEA;;;AAWA;;;;;;AA+BA;AAGA;;;;;;;AkB2ZA;;AlDlcA;AAAA;AkD8cA;AAVA;AAAA;AAAA;AACA;AAAA;AASA;;;;;;;AnBGA;AAAA;;AAtFA;;;;;;;;;AAxBA;AAAA;;;;;;;;;;;;;;;AhCxTA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;;AoEgQA;AAEA;AA6FA;AAGA;AAAA;AAAA;AAAA;;AAEA;AACA;;AAKA;AAAA;;;AAAA;AAAA;;;;;;;;;;ApEhXA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;;;;;;;;AC9DA;;;AQ8HA;;AA9IA;AAAA;AAAA;;AAEA;;ARcA;;;AAAA;AQZA;ARYA;;AAAA;;;;;;;;;AAAA;AAAA;;;;;AAYA;AAAA;AoBiRA;ApBjRA;AAAA;AAAA;AAAA;AoBoRA;AAAA;AAGA;AACA;ApBpSA;AAAA;;;;;;A2B6dA;A3BzdA;A2BydA;;AA0BA;;AAvBA;AAAA;AAAA;;AxB+zBA;AAhBA;;;;;;;;AH/vCA;;;;;;;AAAA;AAAA;;;;;;;;AY+yCA;ARz1CA;;;;;;;;;AuBshBA;AASA;;;;;;AnBqYA;AAEA;AAGA;AAEA;AAAA;AACA;AAEA;AAEA;AAAA;AAGA;AAAA;;;;;;;;;;AIsaA;;;;;;;;Ae3yCA;;;;;;;;;;;AUiNA;AAvBA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;A9B8iBA;;;AAYA;AATA;AASA;;;;;;;AuBoMA;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAmGA;AAGA;;;;;;;AUqBA;AAVA;;;AEzhCA;;;;;;AF05GA;AA57EA;A3B99BA;;;;;;AoBjJA;AA+JA;AAiMA;AAMA;AAAA;;AACA;;AAAA;;AAEA;;;;;;Ab2DA;AAEA;;AAkCA;;;;;;;;ApBtWA;AAAA;AAAA;AAAA;;;;;;A6CsCA;AACA;AAAA;AAAA;AAYA;;AATA;AASA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AmB5HA;AAAA;;;;;;;;;;AhEqFA;AAZA;ADyjEA;;AA9oCA;AAAA;AC36BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwBA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AoCuSA;AAAA;AAAA;;;;;;;;;;;;;;;ApCnTA;AAAA;AAAA;;;;;;;;;;;AG4bA;;;;;;AAu0BA;;;AwB3xCA;AAAA;AvBFA;;;;;AuBqgBA;;;;;;AkCxhBA;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAIA;;AAeA;;;;;;;;;A9BkZA;AA3CA;;;;;;;;AAmBA;AAAA;;;AAuCA;;;;;;;;;AMmZA;;AD1eA;;;;;;;;AAAA;;;;;;;;;AtBgFA;;;;;;AAMA;AAAA;;;;;;;;;;;AiBlUA;;AAaA;AAPA;;AACA;AAMA;;;;;;;;;AMqsCA;AACA;AD3qCA;AA3GA;AAEA;AAFA;AAEA;AAyGA;AA3GA;AAAA;AACA;AAAA;AADA;AACA;;;;;;AA+vCA;AAAA;AChHA;;AD3WA;;ACyMA;;ADzMA;AAzfA;;;AAGA;;;;;;;;AYjWA;;;;;AAKA;AAEA;AAAA;AAAA;AAAA;;AAIA;;;;;;;;A7C+dA;;;AUjaA;AVssBA;AO6xCA;AP5xCA;AAAA;AAAA;AAAA;AAmRA;AOubA;AAAA;;;;;;;AVh7CA;AD8gDA;;;AC1gDA;AAAA;ADuhDA;AAAA;AAAA;AAAA;AAAA;ACvhDA;AAAA;AAAA;;;;;;AARA;ADi5DA;AAAA;;AAoKA;;ACzjEA;ADo1DA;AAMA;AAGA;AAAA;ACr0DA;AAAA;AAAA;;;;;;ADqqDA;AC7rDA;ADyjEA;AArXA;AChsDA;AAAA;ADgsDA;AAAA;AAAA;AAAA;AAAA;;ACpsDA;ADssDA;;;;;;ACtrDA;AAAA;AAAA;AoB2LA;ApB3LA;AAAA;AoB4LA;AAAA;AAAA;AAAA;ApB5LA;AAAA;AoB6LA;ApB7LA;;;;;;AAJA;AQ+hBA;AAAA;AR/hBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AQgiBA;;AAOA;AAAA;;;;;;;;AwDnnBA;;AAEA;AAHA;AAAA;;;;;;;;;;;;;;A3BwfA;AAAA;;;AAg5BA;AAAA;AAEA;AAEA;AAAA;AAAA;AA2EA;AAIA;;;;;;;AD93CA;AAoDA;;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;ApCpEA;ADoXA;AAEA;ACtXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADuXA;AACA;AAAA;AAwKA;;;;;;AiChVA;AACA;;;;AhCzMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AgCiOA;;;;;;AoB/SA;;;AAMA;AAWA;;AANA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;;;;;;ArBmXA;AAsnBA;;AA3jBA;;;;;AAokBA;;AA7lBA;;;;;;;AjBlLA;;AAMA;AG+FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AjBjRA;AAAA;;;;AAAA;AAAA;AD2ZA;AAAA;AAAA;AAAA;AC3ZA;AAAA;AAAA;AD4ZA;;;;;;;;;;;;;;;;;;AqBxUA;ApBhGA;;;;;;;AAgBA;AAAA;ADweA;ACxeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AD8eA;;;;;;AA7IA;ACjWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;A2B6sBA;A3B7sBA;AAAA;AAAA;AAAA;AAAA;A2B+sBA;AAAA;AAAA;AAAA;A3BntBA;AAAA;AAAA;AAAA;;;;;;AoDtGA;AAIA;ApDkGA;AAAA;AoDjGA;ApDiGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;;;Ae4hCA;AAAA;AACA;AADA;AAKA;;;AA2BA;AAEA;AAKA;AAAA;AAAA;AAAA;;;;;;;;AkBthCA;AAIA;;AA2DA;AAEA;AAjDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAueA;AApeA;AAlLA;;;;;;;A2BsJA;;ANqFA;A5Ci1CA;AAAA;;AAEA;AAAA;;;;A4CtzCA;;;;AnDitCA;;;;;;;;;;;AkC97BA;;AAUA;AAAA;;AACA;AACA;;AAEA;;;;;;;;ADvIA;AAEA;;;;;AAEA;;;;;;;;;;;;;ApChTA;;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AmBskBA;;;;;;;;AcmhDA;;AAEA;AAEA;ApBlkEA;AAAA;AAAA;AAAA;;;Ab/CA;AAAA;;;;;;;;AiC2UA;;AAjDA;AA7MA;AACA;;AAGA;AAmeA;;;;;;AlCzZA;AADA;;;;AC9IA;ADw6BA;AAAA;AAAA;AAAA;AAAA;AAAA;ACx6BA;AAAA;AAAA;;;;;;;;;;;;;Ae0tBA;;;;;;AC9rBA;AAAA;;;;;;ACyPA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AHvSA;AGwSA;AAAA;;;;;;;AAFA;AAAA;ADlRA;AQouBA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AY5rBA;AAwEA;;;;;AAxGA;AAAA;AACA;AADA;;AACA;;;;;;;ApCPA;AAJA;AAIA;AAAA;AAJA;AD07BA;AC17BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;A6DuBA;;;AAaA;;AAPA;AAAA;AAAA;AAAA;;AAGA;;AAIA;;AAFA;;AAEA;;;;;;;AxBpIA;;;AA2kDA;AACA;AAhrBA;;;;;;;;ADzLA;;;;;;;ACyMA;AAMA;;AAt5BA;;;;;;;;;;;;;;;;;;AjBsGA;;;AjB0ZA;AAAA;AAAA;AAAA;AAAA;AiBtZA;;;;;;;;ApBlCA;AAAA;AoBkLA;ApBlLA;AAAA;AAAA;AoBoLA;AAAA;AAAA;AAAA;ApBpLA;AAAA;AAAA;AAAA;;;;;;;;;AI1CA;AuBzEA;AfuuCA;;;;;;AA2LA;;;Ae9zBA;;;;;;AV/NA;AHnFA;AAAA;;AAgFA;AAAA;;;;AA1EA;AAEA;;;;;;;;;;AdvNA;AAAA;;A6C+JA;AAKA;AACA;AACA;AACA;AAAA;AAIA;;;;;;AlC7PA;AAAA;AAAA;AAEA;AAAA;AARA;AAAA;AACA;AADA;AAAA;AACA;;;;;;AXmGA;AAAA;AAAA;;;;;;;;;;AoB1DA;ApB8DA;;;;;;AiC6CA;AAIA;AA+eA;AApeA;AACA;AAueA;AApeA;AAlLA;AAkcA;;;;;;;AjChVA;AAAA;AAAA;AAAA;AD+ZA;AC/ZA;AAAA;ADgaA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;AM3WA;;;;;AA/IA;;;;;;;AA8KA;;;;;;AUyzBA;AAAA;AAAA;AACA;;AA0EA;;AAtEA;;;;;;AAsEA;;;;;;;;;;;;;;;;;;;;;;;;;Afz9BA;AAAA;AAAA;ADkdA;ACldA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADmdA;ACndA;AAAA;;;;;;;;;AoC+CA;;;AAgEA;;;;;;;;;;;ApC/GA;AAAA;ADmbA;AACA;AA2GA;;;;;;AC/hBA;AAAA;AAAA;ADsbA;;;;;;AgCnHA;;;;;AAyMA;;;;;;;;;;;AAHA;;;;;;;;;AO1pBA;;;;AAGA;AAAA;AAHA;;;;;;AAsKA;AAAA;AACA;AAAA;;;;;;AXstBA;AAjKA;A3BvkBA;AAAA;AAAA;A2BwuBA;;AA5JA;A3BhlBA;AAAA;A2BilBA;A3BrlBA;;;;;;;AeyrBA;AAAA;;;;;AA4XA;AAAA;AAKA;AAAA;AAAA;AAAA;;;;;;;;;;AgBhsBA;AAnDA;;;;;;;;;AA4BA;AAAA;;;AA+EA;;;;;;;AMzCA;AAAA;AACA;AAiXA;AAumBA;AAn8CA;;;;;;AAIA;;AAQA;AACA;;AAEA;AACA;AAw2BA;;;;;;;A1B33BA;AACA;AAAA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;;;;;;;;AZyoBA;;AA7PA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AASA;AAAA;;;;;;;;;A+CvZA;AAKA;AAKA;AACA;AAGA;AAAA;AAIA;AAlBA;AAIA;AAMA;;;;;;A/CgbA;AClVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADqVA;ACrVA;ADuVA;;;;;;;A4BmBA;;;AAIA;AADA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAEA;;;;;;;;;AS/FA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;;;;;;;ACi3BA;;;ADv2BA;;;;;;ArCkGA;;AChYA;AAAA;AAAA;AAAA;ADkYA;AAAA;AAAA;AAAA;AClYA;AAAA;AAAA;AAAA;;;;;;A6C8LA;A7C9LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AARA;AAAA;AAYA;;A6CqNA;;;;;;AlCjUA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AAAA;AADA;AACA;AADA;AACA;;;;;;AFkTA;AAAA;AAAA;;;;;;;;;;;;;;;AkB2KA;;;AAEA;;;;AAEA;AAAA;AAAA;AAAA;A3BtYA;AAAA;AAAA;AAAA;;;;;;;AAQA;;;;;;;AAAA;AAAA;;;;;AAAA;;;;;;;AeimCA;AAAA;AGnQA;;AAgBA;AAAA;;;;;;;AAAA;;;;;;;;;;;ATz3BA;;;;AACA;AAAA;;;;;;;;;;;;;;;;AEhGA;AAAA;AACA;AAHA;AAAA;AAEA;AACA;AAHA;AAGA;AAHA;;;;;;;AyBkiBA;;;AAlIA;AACA;AAAA;AAAA;AAAA;AACA;AAHA;;;;;;;;AgBzZA;AAGA;ApDuGA;AAAA;AAAA;AoDtGA;ApDkGA;AoDjGA;ApDiGA;AAAA;AAIA;AAAA;;;;;;;AK+DA;AApBA;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;;;;;;;;;A0BkTA;AAAA;;;;;;;AAVA;;;;;;;;;;;;;;;AKmhBA;ACt9BA;;;AACA;;AAAA;;;AAEA;AACA;AACA;AALA;;;AACA;;AAAA;;;AAEA;AACA;AACA;;;;;;AL6LA;;AAqGA;;;ACkhEA;;;;;;;;ACv1EA;;;;;;;;AHmMA;AAAA;;AAMA;;AARA;;;;;;;;;AAKA;;;;;;;A/BnEA;AAAA;AAJA;AD+2BA;AC32BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;ADq2BA;;;;;;ACr2BA;AAAA;AAAA;;AAxBA;AAAA;AAwBA;AAAA;;AkD0TA;AAAA;;AACA;AAAA;;;;;;AvCnbA;AACA;AAAA;AAAA;AACA;AACA;AAFA;AAAA;AACA;AACA;AADA;AACA;;;;;;AAKA;AACA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AuCsnBA;;;;AAiBA;;;;;;AAgBA;;;;;;ApB8nDA;AA2BA;AA8KA;AA1XA;AAKA;AAAA;AAAA;AAAA;AAAA;AAKA;;;AACA;;;;;;AA+RA;AACA;AAuEA;AAQA;AAPA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAnNA;AAMA;;;;;;A9B1rEA;AAAA;AAAA;AAAA;A2B2PA;A3B/OA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAZA;;;;;;;;AWtGA;AACA;AAAA;AAjBA;AACA;AAKA;AACA;AACA;AADA;AACA;;;;;;AZsRA;AA8jCA;ACttCA;ADutCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACntCA;ADotCA;ACptCA;;;;;;;;;;;;;;;;ADqiEA;ACzjEA;AAAA;;;;;;AgCvFA;AAqEA;;AAEA;AADA;AAhEA;AAIA;AACA;;AAMA;AAGA;AACA;;;;;;ArB3BA;AAAA;AAHA;AACA;AACA;AACA;AAAA;AAHA;AAAA;AAEA;AADA;AACA;;;;;;;;;;;AI0sCA;AGlQA;;;;;;;AAgBA;;;;;;;AlB92BA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AoD7FA;ApDyFA;AAAA;AAIA;AAAA;;;;;;AwCs+GA;AA5sEA;AACA;AAEA;AAtQA;AAAA;;;;;;;;A3BhgCA;A2B2iCA;;;;;;;;;AHp8BA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAsEA;;;;AArGA;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;AtC0iCA;;;;;;;;;;;ACroCA;AgBMA;AAAA;AACA;AQw1BA;;;;;;;;;AAKA;AxBp2BA;AgBMA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AL9HA;AACA;AAAA;AACA;AAAA;AAFA;AACA;AACA;AAAA;AAFA;AAEA;AAHA;;;;;;A0BskCA;AACA;AAAA;;AAKA;AANA;;;;;;AAEA;AACA;AAAA;AAAA;AACA;;AAEA;AANA;;;;;;ArC19BA;AAAA;;AoB1DA;AAAA;ApB8DA;AAAA;AAAA;;;;;;;;;;;A2BiiBA;AAIA;A3BriBA;AAAA;AAAA;AAAA;A2BsiBA;A3BtiBA;A2BuiBA;AAPA;;;;;;;AHyLA;AAgBA;;;;;;;ARjtBA;;AQosBA;AP5cA;;;;AO6cA;;;;;;;;;;;;;;AxB7tBA;ADsVA;AAyMA;;AC/hBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADyVA;ACzVA;AAAA;AAAA;;;;;;;;;;;AoDzIA;;AAuDA;AAAA;AAAA;AAAA;;AA/CA;AAAA;AACA;;;;;;AXwEA;;A8B3FA;;;;;;;;AAUA;;;;;;;;;;AvBsBA;;;AAFA;;;;;;AAGA;AAEA;Ac0nBA;;;;;;A1B9ZA;AA7DA;;;;;;;AA+DA;;;;;;;;;;;;;ACw3CA;;;;AAvEA;AAAA;;;;;;;;;;;;;;;ArC/5CA;A2BiHA;A3BjHA;AAAA;AAAA;A2BkHA;AAAA;AAAA;AAAA;AAAA;A3BlHA;AAAA;AAAA;;;;;;AWhHA;AAAA;AACA;AACA;AACA;AAHA;AAAA;AACA;AAAA;AAEA;AAFA;AACA;;;;;;;AVXA;AiD+bA;AAAA;AACA;;;AAWA;AAsFA;;;AA/EA;;;;;;;;;;AlD7VA;AAAA;A2BgvBA;;;;;;;A3BhvBA;AGmxCA;;;;;;;A6Bx1CA;AAAA;;;;;;;;AAMA;;;;;;;AK41BA;;AAAA;AAAA;AAAA;AD7eA;AC6eA;AD1eA;AAAA;;;AAAA;AAAA;;;;;;AzB/aA;AACA;AACA;AAFA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAMA;AACA;;;;;;AX2HA;AAAA;AAAA;AAAA;AAAA;AApBA;AAAA;AAAA;A6CiMA;A7CjMA;A6CiMA;;;;;;AlC9RA;AAAA;AADA;AADA;AACA;AAFA;AAAA;AAEA;AADA;AACA;;;;;;;;AHukDA;;AA/kDA;AAAA;;;;;;AAEA;;;;;;;;;AHsKA;;;;;;;;AAmCA;;;;;;;AcsCA;;AAUA;AAAA;;;AP++BA;;;AOj+BA;;;;;;;;AXmtBA;AAMA;AAEA;AAAA;AAAA;AACA;AAIA;AACA;AAAA;AAGA;;;;;;;;;;;AgBsTA;;;AAGA;AAGA;;AACA;AAAA;;;;;AxBpsCA;;A6BhEA;;AACA;;ALywCA;;;;;;AOpmBA;AAAA;;;AA/EA;AAEA;AACA;;;AAEA;AAAA;;;;;;;;AW7eA;;AAjBA;AFygCA;AAAA;AEx/BA;AAjBA;AFolCA;AAAA;AAAA;AAAA;AArGA;AA8DA;AAgCA;;;;;;;;ADtxBA;;;;AATA;;;;;;;AAcA;AACA;;;;;;ANlCA;;AAKA;AAAA;;;;AArEA;AAjMA;AAEA;;;;;;;AFyRA;;;;;AA4BA;AAAA;;;;;;;;;;A/B/VA;AAAA;AAAA;AAAA;AAAA;AD6VA;AC7VA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD8VA;AC9VA;;;;;;AoD3HA;AACA;AAGA;AAAA;ApD2GA;AAAA;AoD3GA;AAAA;AAAA;AAAA;AAAA;AACA;;AAoCA;AA9BA;;;;;;;;;A3CkZA;AAAA;AAGA;AAGA;;AAKA;;;AAFA;;;;;;;;;;;;;AuD5XA;AAAA;;;;AAMA;;;;;;;;;;;ArD3CA;AAAA;AAjBA;AACA;AACA;AAKA;AACA;AACA;AADA;AACA;;;;;;;;;;;;;AyBoIA;AAAA;AACA;AADA;;AAsGA;AAEA;;;;;;ArC+PA;AC7WA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAJA;AAAA;AoDnFA;ApDuFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AoDrFA;;;;;;;;;;;AjD6gBA;AAAA;AAAA;AAAA;;;AA5QA;AAolBA;;;AyD5tBA;AAAA;;;;;;ArB26CA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAUA;;;;;;;;AFpiDA;;AAIA;AALA;;;AA7BA;AAAA;AAAA;;;;ADuDA;;;;;;;AC0wCA;;AACA;;AAqGA;AAAA;AA77BA;AACA;AD1bA;ACqgCA;AADA;AAmXA;AAr6CA;AAEA;;;;;;ArCgGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADmXA;ACnXA;AAAA;;;;;;;;;;;;;;;;AS6IA;;AAGA;AAAA;;;;AASA;AAAA;;;;;AsBmcA;;AAHA;;AAKA;;;;;;;;;;;;;;AK7eA;AALA;AA7DA;;;AATA;;;;AAyEA;;AADA;;;;;;;;;;;;;;ATyXA;A3BvfA;A2BiaA;;;;;;;;;;;;;;;;;;;;;;;;;;A3BrZA;AAAA;AAAA;AD23BA;ACv4BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD84BA;AAKA;;;;;;AAnFA;ACh0BA;;AAAA;AAAA;ADkhDA;AAAA;AAAA;AAAA;;;AClhDA;AAAA;;;;;;;;AAoBA;AAJA;AAAA;;;;AAIA;;;;;;;;;;AoC0GA;AAAA;;;;;;;;AAxGA;;;;;;;;;ApCVA;AARA;AGmxCA;AAhBA;;;;ASnIA;;;;;;;;AyBvrCA;AALA;;;;AA7BA;AAAA;;;;;ADuDA;ACvBA;;;;;;AAoDA;;;;AAnBA;;;;AD8TA;AAAA;AAAA;;AANA;;;;;;;;AhBkEA;;ApBtWA;;;;;;;;;;;;;;;;AoCuBA;AADA;AA2GA;;;AAlEA;AA+DA;;;AAxEA;AAyEA;AAAA;;;;;;;ApC/GA;;;;AAhBA;AAAA;AAAA;AAAA;AAAA;AAwBA;AAAA;AAAA;AApBA;AAAA;;;;;;AGocA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AiBxiBA;AAEA;AACA;;;;;;;AnBVA;;A0C4cA;;;AAAA;;AAAA;;;AAHA;;;;;;;;AP3UA;AA0GA;;;;AAiCA;AAUA;;AAPA;AAKA;AAEA;;;;;;AzB5QA;AAAA;AACA;;AACA;AAAA;AACA;AAAA;;;AA+WA;AAcA;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;AsBtBA;;AAWA;AAyCA;;;;;;;AtBvZA;AADA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;;;;;;;;;;;;;;AJwmBA;AAAA;AAAA;AACA;AAniBA;AAEA;;;;;;;;;;;AP+BA;AAAA;AAJA;AgCsDA;AhClDA;AgCmDA;AhCnDA;AAAA;AAAA;AgCqDA;;;;;;;AZiSA;AArFA;AAAA;;AAqFA;AAjFA;ApBzQA;AoB0QA;AAAA;ApB1QA;;;;;;AI9HA;;;AuBymBA;;;A3B/eA;A2B8bA;;AAiDA;;;;;;;;AAvkBA;;;;;;;;AAqCA;Af+qCA;;;;;;;;;;AZxnCA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AwBi6BA;AxBj6BA;AAAA;;AAAA;AAAA;;AwBg7BA;;;;;;;;;;;AjBxgBA;;;;;;AAjFA;AACA;AAqFA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AP1aA;;AQ+lBA;;AAEA;;;;ARjnBA;;;AAYA;AAAA;;AAIA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;AoCMA;;AAsGA;AAKA;;;AAGA;;;AAwCA;;;;;;A/BtEA;;;AAyBA;;;AAjEA;AAIA;AAAA;AACA;AAAA;;;;;;AwCmIA;AAEA;;;;AAkEA;AACA;A7CvPA;AAAA;AAAA;;;;;;AiCqCA;AA2fA;AAtpBA;AA+JA;;;AAqOA;AAzOA;;;;;;;AtBnIA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AA9CA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;;AADA;AACA;AACA;AAAA;AAaA;AAAA;;;;;;AXwGA;A4C0KA;AAOA;;A5CrKA;AAAA;AAAA;;A4CmLA;;;;;;AA3DA;AACA;AACA;AAAA;A5ClHA;A4CoHA;AAKA;AACA;;AhCirCA;;;;;;;;;;;AJr6CA;AAAA;;;;;;;;;;;;;;AAuhCA;;;;;;;;;;;AmCpuBA;A3CzMA;AAAA;AAAA;AGmxCA;;;;;;AwC31CA;;;;;;;AAiIA;AACA;AACA;;A/BgwCA;;;A+BznCA;A3ClMA;AAAA;AAAA;AAAA;AAAA;AAYA;;;;;;;;A0B8XA;AAAA;AAAA;AACA;;AAAA;AACA;AAAA;AAAA;;AAEA;AAGA;;;;;;;;;ArB5cA;;;AATA;;AAiBA;;;;;;;;AM/CA;AACA;AAAA;AAAA;AAFA;AACA;AACA;AADA;AACA;;;;;;AIylBA;AA6iBA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AACA;;;;;;AfzhCA;AAAA;A6C6NA;A7C7NA;A6C8NA;AAAA;A7C9NA;AAAA;A6CkOA;A7ClOA;;;;;;;;;;AwBw6BA;;;;;;;;;;;;;AAWA;;;AR/5BA;AAAA;;;AhBhBA;;;AAAA;;;;;AQrBA;ARHA;;AAAA;AQoGA;;;;;;AADA;;;;;;;;AHxCA;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;;;;;;;;;;AwCgIA;;;;;;;;;;;;;;;;;;;ATyHA;AAAA;;;;;;;;ACyhBA;ADphBA;;;;;;;;;;;;A7B8HA;AAOA;AAcA;AAAA;;;;AAKA;AA0DA;AAAA;AAAA;AAAA;AAGA;;;;;;;;;AQqMA;;;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;AgBvGA;;;;;;;;AAgDA;;;;;;;;;AA7IA;;;;;;;;AAwDA;;;;;;;;A/BhlBA;AAAA;AAYA;AAAA;AGuwCA;ASwCA;;AgClwCA;AhCukCA;;;;;;Abq7BA;;;ACzjEA;AAAA;ADwpDA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ACxoDA;;AD+hBA;AACA;;AChiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AoB6JA;ApB7JA;AAAA;AAAA;;;;;;AARA;AQXA;;ARWA;AAAA;AAAA;AAAA;AAAA;AAAA;AQPA;AROA;AAAA;;;;;;;;;AgCsRA;AAAA;AACA;;AACA;AAUA;;;AAPA;AACA;AACA;;AAAA;;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AoCzXA;;;AAIA;AAAA;;;AAHA;;;;;;;;;A/Bw/CA;;;AAAA;;;;AA6EA;AAtEA;;;;;;AJjnCA;;;;;AAzCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AmBjPA;;AACA;AAEA;AAEA;AA8BA;AAhBA;;;;;;;;;A/CyGA;;;;;;;;;;;;;;;;;;;;AAAA;;;AAAA;;;;;;;;ANqjDA;AC3sDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD4sDA;AC5sDA;;;;;;AWtFA;AAAA;AAAA;;AAEA;AAAA;;;;;AAfA;AAAA;AAAA;AAAA;AAAA;AAYA;;;;;;AA1CA;AAAA;AAAA;;AAHA;AAAA;AACA;AAAA;;;AAEA;AAHA;AAEA;AAAA;AAAA;AAAA;;;;;;AAyBA;AAAA;AAHA;;AACA;AAAA;AAAA;AACA;;;AADA;AAEA;AAFA;AAAA;AACA;AAAA;;;;;;AAYA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAEA;AARA;AACA;AAAA;AAAA;AAAA;;;;;;;AX+GA;AAAA;AAAA;AAAA;ACjIA;AkCkBA;AAAA;AAAA;AAAA;AACA;;;AHgPA;;;;;;ArBvPA;AAHA;AAGA;AA3BA;AACA;AAAA;AACA;AAcA;AACA;;;;;;AamfA;AAAA;;AACA;AAAA;AAAA;;AAEA;;;;;AxBnYA;;;AAAA;;;;AAAA;;AAAA;;;;;AkBy2BA;AAAA;;;;;;;;;AAEA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AlB52BA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AmBmyBA;;;;;;ARv4BA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;AARA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AAAA;AAFA;AAEA;AAAA;AAAA;AA5BA;;;;;;AAUA;AACA;AAAA;;AACA;AAAA;AAHA;AAAA;;;AAGA;AAMA;AAlBA;AAAA;AACA;AAAA;;;;;;AA0BA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;;;AAAA;AAEA;AAFA;AAAA;AAAA;AACA;;;;;;AC02CA;;AgCzmCA;;A5C9IA;AAAA;AApBA;AAwBA;AAxBA;;;;;;AqCshCA;AAAA;;AACA;AAGA;;;;;;AA6QA;AANA;;;;;;;;;;;;;;;;;ADjaA;AC6RA;;;;;;ADz1BA;;;AAAA;AAAA;;;;;;;AARA;AAGA;AAAA;;;;;;;;;;;;;;;;;AAAA;;AACA;;;;;;;;;A/BrJA;;;;;;;;;;;;;;;;;;;;AAAA;;;AAAA;;;;;AM7PA;AACA;AACA;;AAFA;AAAA;AAAA;AAAA;;;;;;AHy/CA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AR96CA;;;;;;AoCgFA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ACgmCA;;;;AAkUA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;ArCx+CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AqCs9BA;AACA;AAAA;;AAKA;;;;;;AAJA;AACA;AAAA;AAAA;AACA;;AAEA;;;;A/B3kCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AAGA;;;;;;APweA;ACnZA;ADoZA;ACpZA;AAAA;ADqZA;AAAA;AAAA;AAAA;ACrZA;AAAA;AAAA;ADsZA;;;;;;;;AqBxhBA;;;;;;;;;;;;;;;;AgC0CA;ApDoFA;;;;;AoDlEA;AAIA;AACA;;;;;;;AToOA;;;;AAlCA;A3CzIA;AAAA;A2C2KA;A3CnLA;AAAA;AAAA;;;;;;AqC6nBA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;;;;;;AApBA;AAAA;AAAA;AACA;AD2vBA;AAAA;;;;;ACwIA;AAEA;;AA73BA;;;;;;ArC/mBA;AAAA;;;AAIA;AAAA;;;;;;;;;AC1HA;;A6C6JA;A9CnCA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A8C/CA;AA2FA;AACA;;;;;;;;Af+lBA;AAAA;;;;;;;;;AAIA;;;;;;;;;;AAhIA;;AAFA;AAkBA;;;;;;;;;;;;;A/B5hBA;AAAA;AAAA;AoB4KA;AACA;AAAA;AAAA;AAAA;AAAA;;;ApB7KA;AAAA;;;;;;AQ+pCA;AAAA;AACA;;AACA;AAAA;;;AAEA;;;;AAzxCA;;;;;;;;;AmBkyBA;;;;;;;AACA;A3B7rBA;AAYA;AAAA;AAAA;;;;;;ASoIA;;;;AAwCA;AAAA;AAAA;AAAA;;;;;;;;;AViGA;AACA;AACA;;;;;;;;;;;;;;;AmB4lBA;;;;;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;;AfjbA;AiBlgBA;;;;;;;AjBkgBA;AAAA;AHxbA;AAAA;;;;;;;AG+vCA;AAgBA;;;AwBr0CA;;;;;;;;;;Af0qCA;;;;;;;;Ae1qCA;;;;;;;A3BsCA;AQ6GA;ARrGA;AAJA;AAAA;AQ+EA;AAAA;AAAA;AAAA;AR/EA;AAAA;AAAA;;;;;;AgCjDA;AAEA;AAWA;AACA;;AAKA;;;;;;;;;AxB5DA;ARsFA;AAAA;AAAA;;;AQ7EA;AAAA;AAAA;AAAA;AAAA;AR6EA;AQ3EA;AR2EA;;;;;;AWrHA;AAHA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;A6CoHA;;AAEA;AxDuBA;AAAA;AwD1BA;;;;;;;;;;;;;;;;AnB0mBA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AD/oBA;ACopBA;;;;;;;;;;;;;;;;ANxLA;AAAA;;;;;;;;;;AtBpPA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;AqChTA;AAoRA;AAzRA;AACA;AAAA;AACA;AACA;AAAA;AADA;;AAGA;;;;;;A9CsHA;AAZA;AAAA;AoBpDA;;;;;;;;;AACA;AAAA;;;;;;AjB2fA;AAAA;;AiBndA;;;;;;;AAGA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;ATpHA;AACA;AAEA;AAAA;AAcA;AAAA;AACA;AACA;AACA;AAKA;;;;;;;;;;;;;;AN4JA;;;;;;AAIA;;;;;;AAEA;;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;AI4IA;;;;;;;;;;A4BmMA;AAAA;AACA;AAs8BA;AAAA;;AA56CA;AAOA;AACA;AAAA;AAEA;AACA;AAyzBA;;;;;;;AA4eA;AAAA;;;;;;;AA1PA;AACA;;AAKA;;AAJA;;;;;;AtB1TA;AAAA;;AAYA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AACA;;;;;;;;;AR5rBA;;AA4iBA;AAAA;AACA;AAAA;AAEA;AAAA;;AA3QA;AACA;;AAGA;AAAA;;;;;;;A2CsKA;;AAOA;AlDzcA;AkD4cA;AAEA;;;AAVA;AAAA;AACA;AACA;AAMA;AAEA;;;;;;;;;;;AkBpgBA;AAGA;AAAA;AAEA;AAMA;AAAA;;;;ATjFA;AAAA;ADIA;AACA;AAAA;AChCA;AACA;AA0BA;AACA;AAAA;ADGA;AACA;AAAA;AChCA;AACA;AA2BA;;;;;;;;;;;ApD6TA;;;;;;;;;;;;;;;;;;AP9MA;AkDoUA;AAAA;AAEA;AAAA;AAEA;;;AAIA;;;;;;;;;A3CyBA;AAAA;AAyHA;AACA;AACA;AACA;AACA;;AAEA;AAKA;AAEA;AAAA;AAGA;AAAA;AAAA;;;;;AQ+MA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AACA;;;;;;;;;;AfprBA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;ADylDA;ACrmDA;ADqmDA;AAodA;;;;;AAhdA;;;;;;AA19BA;AAAA;AC/oBA;ADmpBA;;;;;;AA0BA;AAzBA;ACppBA;ADopBA;;;;;;;AChpBA;AAAA;AAAA;A2B6TA;A3BrTA;AAAA;AARA;;;A2BkUA;;;;;;A3BtTA;AAAA;AAAA;AmB+xBA;;;;AA1GA;AnBzrBA;AAAA;;;;;;;AKsDA;;;;;AAuDA;;;;;;;;;;;;;;;;;;;A+BQA;;;;;;;;AzB9NA;AAAA;AAAA;AAAA;AAFA;AACA;AACA;AADA;AACA;;;;;;AkC6QA;;AAMA;AAAA;A7ClKA;AAAA;A6CmKA;A7CnKA;AAAA;A6CoKA;;;;;;;A9C0/BA;;AClrCA;;;;AAAA;AAAA;ADgsCA;;;;;;;;;;AIuFA;;;AgBloCA;AAAA;AP++BA;;;;;;AZpnCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;A6CqQA;AAdA;;;;;;;;;A7C3PA;AAAA;AAAA;;;;;;;AeyhCA;AAxiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;AyB0nBA;AAtCA;AAAA;AAVA;AAAA;AAAA;AAAA;AAAA;AA3DA;;;AAqGA;;;;;;;;ATjgBA;;;AAAA;;;;;;;;;;;;;;;;;AMwzBA;AAx0CA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;AtB60BA;;AAIA;;;;;;;AACA;AAqDA;;;;;;AwBvqBA;AC8UA;AD7UA;AAEA;;;;;;;;;;;;;AH4jBA;ACt9BA;;;AACA;;AAAA;;;AAEA;AACA;AACA;;ADi9BA;;;ACr9BA;;ADq9BA;;;ACr9BA;ADq9BA;;;;;;;ApBz1BA;;;;;;;;;ADirBA;;;;;;AfzsBA;AAAA;AD4cA;AC5cA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD6cA;AC7cA;AD+cA;;;;;;AC/cA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD0cA;;;;;;AYllBA;AAAA;AAEA;AACA;AAKA;AACA;AACA;AADA;AACA;;;;;;;;;AQ+qBA;AnBzjBA;AAAA;;AmBgkBA;AACA;;;;;;;;AJyHA;AACA;AAAA;;;;;;AAAA;;;;;;;Af3rBA;AAJA;AAJA;AAAA;AQCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AkBiaA;AAAA;;;;;AAAA;;AACA;AAAA;;;;;;AAKA;;;;;;;;;;AKoHA;;AAAA;AAAA;;;AAFA;AAkBA;;;;;;;;A/BxhBA;AAAA;AAAA;ADq8CA;ACz8CA;AAAA;AAAA;AAhBA;AAAA;AAYA;;;;;;;AGqOA;;AA8BA;;AgB5JA;;AAWA;;;;;;;;;AXpOA;AAAA;AAAA;;AAAA;AAAA;;;;;AA+kDA;;;;;;;ARz+CA;AQRA;ARQA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AARA;ADouCA;AC5sCA;AD6sCA;AAAA;AAAA;AAAA;AAAA;AApkCA;AAAA;;;;;;;;;;;;;;;;;;AA+jCA;;;;;;;AAr1BA;AC3XA;AAAA;AAAA;AAAA;AD4XA;AAAA;AAAA;AAAA;AC5XA;AAAA;AAAA;AAAA;;;;;;AAAA;ADsXA;ACtXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADuXA;AACA;;ACxXA;;;;;;AqBjIA;AAAA;AAAA;AAAA;;AAkBA;;;AAUA;;AAAA;;ApBrBA;;;;;;AmD6FA;AAPA;;;;;ApDwBA;AoDHA;;;;;;;;;;;AhBqBA;;AACA;;AAqGA;AAAA;;;;;;;;;AGiEA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;;;;;AxCyNA;AAGA;AC3YA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AsC8EA;;AAEA;;;AAQA;;AAMA;;AAAA;;AAQA;;;;;;;;;;Ad68BA;;AAk0BA;AAAA;AAAA;;;;AA5yBA;;;AAgBA;;;AInoCA;;;;AJsoCA;;;;;AxB5lCA;;AoDVA;ApDcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AckRA;AACA;;;AGRA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AGhQA;AAIA;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AOwiBA;A3BxjBA;AAAA;AAAA;A2BwuBA;;AA3KA;A3B7jBA;AAAA;AAAA;;;;;;;AAJA;AAAA;AAAA;AAAA;;;A2BojBA;A3BxjBA;A2ByjBA;A3BjkBA;AAAA;;;;;;;;;;ASkSA;AAMA;;AAGA;AAAA;;;;;;AuBxPA;AAAA;AhC3CA;AAAA;AAIA;AAAA;AgC2CA;AACA;AhChDA;;;;;;AAQA;AARA;AAAA;;;;;;;A4C+PA;AAAA;A5C/PA;;;;;;AqCyNA;;;;AAAA;AAnBA;AAAA;;;AAGA;;;;;;;;AlBjIA;AACA;AACA;;;AAIA;;AAGA;;;;;;;;;;;;;;ADwxBA;AAAA;;;;;;;;AkBzvBA;;AAtEA;AAyEA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ArBw/BA;Af/lCA;AgBMA;AACA;AhB3BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ASVA;;;AACA;;;AAEA;;;;;;AAEA;;;;;;;AkB+OA;;AAkBA;AAhBA;A3BpOA;AAAA;AAAA;AAAA;AAAA;A2BqOA;A3BjPA;A2BoPA;;;;;;;;;;AX5MA;AAAA;AqCqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AjCqBA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;ApBlFA;;;;;;;AG2QA;;AA/BA;;;;;;;;AUjMA;;;;;;;AgC1BA;AAEA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AACA;AAEA;;;;;;;ArCwEA;AAAA;;;;;;;;AAEA;;;;;;;A6BkuCA;;;AAAA;;AACA;AA2DA;;AAMA;;;;;;;;;;AmBj8CA;AACA;AxD2EA;AwD3EA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AnByGA;AAAA;AAAA;AAEA;AAIA;;;;;;;;;;;;;;;;;;;;;;ArC7CA;AAAA;;;;;;AAAA;AAAA;AAAA;A2BirBA;A3BjrBA;AAAA;AAAA;AAAA;AAAA;AAAA;A2BkrBA;A3BlrBA;AAAA;;;;;;AmB8pBA;;;;;AAAA;;AA/IA;AnBvhBA;AAAA;;;;;;;;A6DjEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAJA;;;;;;AlD5BA;AAbA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AACA;;;;;;AAPA;AADA;AACA;AAFA;AACA;AAEA;AAHA;;;;;;ANmKA;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;AmB2QA;AAAA;AACA;AACA;;AACA;;AACA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;AAAA;;;;;AbrbA;AACA;AAAA;AAAA;AAMA;AAAA;AADA;AAAA;AACA;;;;;;AXuFA;AQ5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;A2CyIA;AACA;;;;AANA;AACA;;;;;;;;AAOA;;;;;;;AHxOA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAHA;;;;;;;;;AA0LA;;AASA;AAAA;AAAA;AAAA;;AAAA;AAnMA;AACA;;;;;;A3CsSA;AAAA;AA/JA;;;;AAsGA;AAAA;AAAA;;;;;;;;AsBAA;AAEA;;AAGA;;;;;;;A3B3FA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AS4FA;;;;;;;;ADiiBA;AAAA;AAAA;AAAA;AAAA;;AAOA;;;;;;;;;;;;AOqIA;AAAA;AAEA;AAEA;AAkGA;;;;;AA9FA;AAAA;AAAA;;;;;;AJt5BA;AAKA;AAAA;AAAA;AACA;AAEA;AAXA;AAAA;AAiBA;;;;;;ANyEA;AACA;AAAA;AACA;;;;;AAkDA;AACA;AACA;;;;;;;;A+CpDA;ApDgCA;AoD5BA;;;AAWA;;;;AAAA;;;AAAA;;;;;;;APgEA;;;;;;;AAxCA;AAGA;AACA;AAEA;;;;;;A9BqxBA;AAAA;;;;;;;;;AAiHA;AASA;;;;;;;;A+Bv1BA;A9C7DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;A+B4jBA;;;;;;AAjDA;AAAA;;;;;;;;AhB8dA;ACv9BA;AD89BA;AAOA;AACA;AAAA;AAAA;AAAA;AAAA;AAmBA;;;;;;;AKlgCA;AAAA;;;AADA;;;;;;;AAEA;;;;;;;;AWudA;;AAAA;;;;;;;AAEA;AAAA;;;;;;;;;;AclbA;;AAGA;;AAFA;AAOA;;;AAqBA;;;;;;;;;;;AtC+gBA;;AATA;;;AASA;;AALA;;;AAKA;;;AAAA;;;;;;AanOA;;;;AAYA;ApB1XA;;AoBkYA;;;;;AAAA;;;;;AAAA;;;;;;;AjB63BA;AAhBA;;;;;;;A2BrCA;AAeA;AAGA;AACA;AAGA;;AAAA;;AACA;AlBrHA;;;;;;;;;;AG/eA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;ADtSA;AA4BA;;;;AAEA;;;;;;;;;;;APmMA;;AATA;;;AASA;;AALA;;;AAKA;;;AAAA;;;;;A8Bs6BA;AAAA;;AAhrBA;;;AAbA;AACA;;AD7KA;;AAGA;;;;;;AtBjpBA;;;AAIA;;;AG0RA;AAAA;;;;;Adw/BA;AAhBA;;;;;;;AgBrzCA;APkrCA;;;;;;;ATn5BA;;;;;;;;AiBqHA;;;ApBlWA;AoBkPA;;AAgHA;;;;;;;AAAA;;;AApIA;AAAA;;;AAGA;;AAQA;;;;;;ApBjOA;AAAA;A2B2aA;AfqsBA;AevsBA;;;AAKA;AACA;AAPA;;;;;;;;AfwsBA;Ae1sBA;AAAA;AAEA;AAFA;AADA;;AAIA;;;;;;;;;;;;;;;;;;;;;AUo2BA;;;;;ArCzwCA;AD+hBA;;AC/hBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADidA;ACjdA;;;;;;AARA;AAAA;ADqvBA;;;;;;;AATA;;AAEA;;;;;;;AC9uBA;AAAA;;;;;;;ADirBA;AACA;AAEA;;ACxrBA;;;;;;;AgCiGA;AAAA;AAAA;;AA6GA;AAAA;AAAA;AAAA;;AAAA;AAxGA;AhCtGA;;;;;;;;AKlEA;;AACA;AADA;;;;;;;;;;;AeoBA;ApBsDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AG2wCA;AAhBA;;;;;;;AwCz2CA;A/BsuCA;;;;;;;ATn5BA;;;;;;;;;;;;;;;;;AwBlJA;;;;;;;AG01CA;AAvNA;AAeA;AAGA;AACA;AAGA;;AAAA;;AACA;AAkMA;AACA;;AAGA;AACA;;;;;;;;ArB5xCA;;AAEA;;;;AAMA;;;;;;;;;;;;;;;AoCvLA;;;;;;;;;;;;AxCgHA;;AAmCA;AAAA;;;AA5EA;;;;;;;;AgCyVA;;AA/BA;AA+BA;AA0kBA;AACA;;;;;;ArC58BA;A2B6KA;A3B7KA;AAAA;AAAA;A2B+KA;AAEA;;;;;;;;;AZ+bA;AAEA;AACA;AAAA;AAAA;AAAA;AA4gBA;AACA;;;;;;;;AYpuCA;AAAA;;Af+4CA;AAAA;AAAA;AAAA;;;;AA3LA;;;;;;;AiC7/BA;AACA;AAAA;AAGA;AAAA;AAAA;AAIA;;;;;;;;;;;;A/B2NA;AACA;AAAA;AACA;AAAA;AAiCA;;;;;;AHvdA;AACA;AACA;AACA;AAAA;AAjBA;AACA;AADA;AACA;;;;;;;;;;AJm8BA;;;AAmJA;;;;;;;;;;;;;;;AgBv+BA;;AAFA;AAAA;AAAA;;ADiVA;AAAA;AAAA;AAAA;;AAGA;;;;;;;AGzYA;;;;;AYkxCA;;;;AD1bA;AA0QA;ACxpCA;AAAA;;;;;;;;;;;;;ALmYA;AAAA;AACA;;;;AAEA;AACA;;;;AAKA;;;AAFA;AAEA;;;;;;AO+dA;AACA;;AAwBA;AASA;;;;;AAKA;AAJA;AAIA;AAHA;;;;;;ArBgEA;;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;;;;;;;;;;;;;;;AqB9hBA;AAEA;AACA;AAAA;;;;;;AvChVA;ADsqCA;;;;;;;;;;;AwDg/FA;;ApC/gIA;AAzLA;AAAA;;;;;;;;;;AYwqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AA9FA;;;;;A5B2vBA;AAhBA;;;;;;;AyCv0CA;AhCosCA;;;;;;;ATn5BA;;;;;;;;AYu6BA;AAAA;;AA7DA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0BA;;;;;;ARtHA;;;;;;;;;;;;;;;;;AsDxmCA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;;;;;;AlDHA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AApBA;AACA;AACA;AACA;;;;;;;;;AN4NA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;AG7MA;;;;AAg3CA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AA/2CA;;;;;;;;;;;;;;A6BiGA;AAXA;;;;;;;;;AEqUA;AAKA;AACA;AAAA;AAGA;AAAA;AACA;;;;;;Aa1aA;AAAA;AACA;ApD8GA;AAAA;AoD1GA;AAOA;AACA;;;;;;AzCFA;AAAA;AACA;AAEA;AAAA;AAFA;AADA;AACA;;;;;;;;;AoBwtBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AM3OA;;;;;AS3fA;;;;;;;;A9CqIA;AClIA;;;;;;;;;;;;A8BgwBA;;AAAA;AACA;;;;;;;AA/EA;AAAA;AAAA;AAAA;AAAA;AAsDA;;;;;;;;;;;;AhBmjBA;AEj5BA;AFq5BA;AC7iCA;AAAA;;AACA;;;;;AD+iCA;;;;;;;;;;;AkBhUA;A8BjQA;;;A9Bk+BA;;;;;;;;AnBn/CA;;AAUA;;;AAaA;AGkKA;;;;;;Ad+KA;;AS8qBA;Ae52BA;AAAA;AACA;AAAA;;;;;;A5BdA;AAGA;;AAOA;AAAA;AAAA;AAAA;;AANA;AAEA;;;;;;;AAtBA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;AACA;AAEA;AAGA;AAEA;;;;;;AY/VA;AACA;AACA;AAHA;AACA;AACA;AADA;AACA;;;;;;AUsfA;ArBhYA;AAxBA;AqB8UA;AAAA;AA0EA;;;;;;;;;;;;;Ab2LA;AAEA;AAAA;ARzkBA;;;;;;;AOhBA;AAijBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAzQA;AACA;;;;;;;;;A0BozCA;AACA;ApB3iDA;;;;;;;;;AmCwDA;;;AA5FA;;AAmCA;;;;;;AxCijBA;ARnlBA;;AAIA;;AAAA;;;;AAAA;AAAA;AQolBA;;;AACA;AAAA;;AAGA;;;;;;;;A6ChhBA;;;;;AvC1JA;;;;;;;;;;AmB8IA;AACA;AAueA;AAheA;AAoOA;AAAA;;;;;;;;;;;;;;AzBxWA;;;;;;;;;A6BwOA;;AAJA;AAAA;;;;;;;;AlBmYA;;AnBnjBA;AmBujBA;AAAA;;AA5eA;;;;;;;;AjB3KA;AACA;AACA;AAAA;AACA;;;AAMA;;;;;AmCFA;AAAA;AAAA;;AACA;;AAEA;AAEA;AALA;;AACA;;;;;;ADsmDA;AYhgDA;AAAA;;;;AA8EA;AAnEA;;;;;;;;;;;AH9FA;AAUA;AAAA;;;;;;AlC3BA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;;A2BuQA;;;;AAxTA;;AAmDA;;;;;;A3BTA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AFyZA;;;;;;;;;;;AExbA;AAAA;AACA;AAAA;AACA;AAHA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AmCwFA;;AAyJA;;;;;;;;;;;;A1BuWA;;;ArB/TA;AAAA;;;;;;;AqCuTA;AAAA;;;ACgkBA;;;;AAAA;;ADhkBA;;ACgkBA;;;;;;A5Br+BA;AAAA;AAAA;;;AAKA;;;;;;;AEjLA;AAAA;AAAA;AACA;AAHA;AACA;AACA;AACA;;;;;;;;;;;;;AUUA;;AAAA;AAAA;;;;;;ArB4HA;AD+YA;AC/YA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADgZA;AACA;;;;;;AYnfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;A2ByQA;AAAA;;;AAhHA;;AAEA;;AA1MA;;;;;;;;AOkFA;AAAA;AACA;AAAA;AAiGA;;AA7FA;;;;;;;ATyWA;;AACA;;;;;;;;ATxRA;AA8IA;AAGA;AACA;AAGA;AAGA;;;;;;AzBvLA;AAEA;;;;AA4EA;;;;;;;;A6By2BA;;AA1jBA;;;;;;;;;;;AAxBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjBuCA;;;;;;;;AdrZA;AAAA;AoBwVA;ApBxVA;AoB0VA;ApB1VA;AAAA;AoB2VA;;;;;;ApB3UA;AAhBA;AAAA;AAYA;AAAA;;;;;;;AGkwBA;AAIA;;;AmDzoBA;AnD4uCA;;;;;;AHr2CA;AAhBA;;AAAA;;AqBqOA;;AAAA;ArBrNA;;;;;;AS0HA;AAMA;;AAGA;;;;;;;;ATnJA;AQmnBA;ARnmBA;AAAA;AAAA;AAAA;AQsmBA;;;;;;A6BoXA;AAHA;AAAA;;;;AAKA;;;;AALA;;;;;;ACl7BA;;;;;AAkIA;;;;;AAxTA;;;;;;A3ByCA;AAAA;AACA;AAAA;AADA;AAAA;AACA;AADA;;;;;;;;AXwFA;AAAA;AAYA;AD48CA;;;;;;AazJA;;;;ATrjCA;AAKA;;;;;;AkBlDA;;;ArBzNA;;AAAA;;AAJA;AAwBA;;;;;;;AqC+ZA;;;AAAA;;AAg5BA;AAAA;;AAKA;;;;;;;AhBx5CA;AACA;;AAKA;;ArBsEA;;AqBrEA;AAAA;;;;;;;;AZ4HA;;;;AAKA;;;;;;;AqBqtBA;;;;AAzZA;;;;;;;;;;AAVA;;;AAEA;AACA;;;AAqaA;;;;;;;;;;;;AhBjYA;;;;;;;AuCrYA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AdwQA;;AAkBA;AACA;;;;;;;;;;;;;AYnQA;;AAOA;AACA;;;;AANA;AACA;;;;;;;;;AAOA;;;;;;;;;;;A3CxJA;AAAA;;;;;AyCiOA;AjD3GA;;;AAhBA;AiDmIA;;;;;;;;;;;;;A5B9OA;AACA;;AAPA;;AAAA;;AAAA;AAAA;;;;;;AiBwSA;AAAA;;;;;;;AA7CA;;;;;;;AC6CA;AAAA;AAAA;AAIA;AAAA;AAAA;;;;;;;;;;;;;AD3TA;;;;;;;;;;;A7BqQA;AAAA;;;;;;AMsrBA;AAEA;;;;;;AA5CA;AAKA;;;;;;;ARdA;;;AAeA;AAoEA;;;;;;;;;;AuC59BA;;;;;;;;AAkBA;;;;;;AfurBA;;;AAjDA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;;;;;;;;;AtBreA;;AAGA;;;;;;ATlCA;;A8CuDA;AAAA;AAAA;AAAA;;;;AAVA;;;;;;;AfudA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAAA;;AAAA;;;;;;;ApBtmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AA5CA;AAAA;AAAA;AACA;APuGA;AO4DA;AAvKA;AAEA;;;;;;AAuBA;AAAA;AACA;AAAA;AADA;AAAA;AACA;AA1BA;;;;;;AA0BA;AACA;AAAA;AACA;AAFA;AACA;AAAA;AADA;;;;;;;AI0wBA;;;;;;;AACA;;;;;;;Af5qBA;AqB+SA;;;AAKA;AAEA;;;;;;;AUiaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AA3LA;;;;;;;AAAA;AAAA;;AAgBA;;;;;;ADkPA;;;;AAtaA;;;;;;;;AAVA;;;AAEA;AACA;;;AAkbA;;;;;;;AuB9wBA;;;ArDLA;AAAA;AAQA;AAAA;AAAA;AgBMA;AqCHA;;;;;;;A1CxIA;AAAA;AAAA;AAKA;AAEA;AACA;AAAA;AAlBA;;;;;;AAqCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AArCA;AACA;AAAA;AAAA;AAMA;AACA;AAAA;AADA;;;;;;AAmBA;AAAA;AAAA;AAHA;AAEA;AACA;AAAA;AADA;;;;;;A0B4/CA;;AAyFA;;;AAlFA;;;;;;;;;;;;;;AgBrgDA;;;;;;;;;;;;;;;;;;;;;;AA0BA;;;;AAVA;AAGA;;AAOA;;;;;AvC2TA;AAAA;;;;;;;AAMA;AACA;AACA;AAAA;;;;;;;;;AfrIA;;;;;;;;;;;;;AAGA;AAXA;;;;;;;;AkBgLA;;AHvMA;AAAA;AAAA;;;;;;;AdzFA;AAAA;AAYA;AAAA;AAAA;AAZA;;;;;;;AAQA;AAAA;AAAA;;;AQVA;ARUA;AAAA;AAAA;AAAA;;;;;;;;;AK4BA;;;;;;;;;;;;;;;;;;;;;;;AyB0qCA;AAAA;AAAA;AAAA;;;;;;;AO/iCA;;;AAkBA;;;;;;;;;ArCzKA;AAJA;AmBijBA;AnBrjBA;AAAA;;;;;;;AgB8BA;;;AqCSA;AAAA;AAEA;AAAA;AAAA;;;;;;;;;;;A7Ck9BA;;AACA;;;;;;;;;AR5/BA;;;AAAA;AAYA;AAIA;AAAA;AQ6iBA;;;;;;;;A6B6LA;;AAAA;ADxTA;AAAA;;ACwTA;;;;;;;;;;AAtsBA;;AACA;;;;;;;AlBwCA;;;;AACA;AACA;;;;;;;;;;;;;;;;AJy9BA;;;;;;;;;;;;;;;;APiIA;AACA;;AAAA;;AACA;;;;;;;;;AOtiBA;AAEA;AAAA;AAAA;AAAA;AAAA;AAFA;;;;;;;;;;;;;AsB3MA;AAnBA;AAAA;;;;;;;;;ArCvaA;AAAA;AD+UA;AC/UA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AoBgJA;ApBhJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;A6C4PA;A7C5PA;AAAA;AAAA;AAAA;AAAA;AAAA;A6C6PA;A7CjRA;;;;;;AiCoNA;AAgWA;AAxVA;AA9TA;AAAA;;;;;;AlB+uCA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AACA;;;;;;;;;AR4GA;;AAcA;;;;ACjvBA;;AAIA;;;;;AA4YA;;AA/gCA;;;AAglDA;;;;;;;A0C1rCA;AAAA;AAEA;;;AAGA;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AhCijBA;;;;;;;;AAGA;;;;;;;;AY9VA;AAEA;AAyGA;AAGA;;;;;;;AdlmBA;;;AqC6CA;ArDnDA;AqD8DA;AAAA;AAEA;;;;;;;;;;;;;;;;ArD5EA;;;AAZA;AAAA;AmDzCA;;;;;;AV5BA;AAZA;;ACwHA;AF2xCA;AAAA;AAAA;AAAA;;;AAGA;AA9RA;;;;;;;;AjClZA;;;;AAAA;;;AAHA;;AAGA;;;AAAA;;;;;;;AIvuBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AXkFA;;;;;;;;AmDjCA;AnD6CA;AmD3CA;AADA;;;;;;AnDoDA;A4CyGA;A5CzGA;AAAA;A4C6GA;;;;;;AjCxOA;AACA;AAjBA;AADA;AACA;;;;;;;;AkD0LA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;A9Dy4CA;AARA;ACj8CA;;;;;;;;;;;AAQA;A2CyVA;;;;;;;;;;AnClbA;AAAA;AACA;AR4EA;AAAA;AAAA;AQ1EA;AR8EA;;;;;;AAAA;;;;;;;;;;AiDmHA;;;;;;;;;A5CxHA;AAuGA;;AADA;;;;;;;;AMrLA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;;;;AR0UA;AACA;AOyvDA;AU1nEA;AjBgYA;AACA;AOyvDA;AUznEA;AjB+XA;AACA;AOyvDA;AUxnEA;;;;;;A4B4QA;;AAlRA;AAoRA;;;;;;;AT85BA;;AA/BA;;AAiDA;AAtFA;AAAA;AAwGA;;;;;;AM7iCA;AAAA;AASA;;;;;;;;AI2CA;;AAAA;AAAA;AAAA;;;AACA;AAAA;;;;;;;;;;;;;;;;A7BtLA;ApBoHA;;;;;;;;;;;;;;AoBhFA;ApB4EA;AAAA;;;;;;ADy8CA;ACr9CA;AAAA;AAAA;AAAA;AAwBA;AAAA;;;;;;;A2CyBA;A3CzCA;AAAA;A2CyCA;;;;;;;;;;;;;;;;;AwBwNA;AADA;;;;;;;;;;;;;AnExQA;AAAA;AAYA;AAAA;AAZA;AAAA;;;;;;AG83CA;AgBrwCA;;;;;;;;;;;AyBdA;AASA;A5ChGA;AAAA;;;;;;;AQ1HA;AAAA;AAAA;;;;AAAA;AAAA;;;;;ARkHA;AAAA;;AqB5FA;;ArB4FA;;AqBzFA;ArB6EA;;;;;;;;AuCk+BA;AAAA;AA0GA;AAv5BA;;AAAA;;;;;;;;;;;;;;;;;;AMvKA;AASA;AAGA;;;;;;ANsKA;AAMA;AACA;AACA;;;;;;;;;ADjFA;AAEA;;AAEA;;AAAA;;AACA;AACA;;;;;;;;ApBqvBA;;;;;;;AACA;;;;;;;AJ/fA;;;;;;;;;;;;;A+BlZA;;AASA;;;;;;;;;ACdA;;;;AA4HA;;AAEA;;AACA;;;;;AzC5HA;;AAQA;;;;;;;AANA;AACA;AACA;AACA;;AAGA;;;;;;AI0IA;AAKA;AAEA;AAEA;;;;;;;;AKuJA;AAOA;AAAA;AACA;;;;;;;;;;;;;;ATpIA;;;;;;AL1IA;AAIA;AQ2lBA;AR3lBA;AQ8lBA;AACA;;;;;A0C/XA;AAtBA;AAYA;;AACA;AACA;;AAGA;;AAkBA;AACA;;AAIA;;;;AACA;AACA;;;;;;AnD/JA;AA9CA;AAIA;AAAA;AAAA;AACA;AACA;;;;;;AoB4dA;AAAA;;;AARA;;AAlcA;;;;;;;;;;AkBoWA;AAMA;;;AAUA;;;;;;;;;AjBzCA;ApBtZA;AoBodA;ApBhcA;;;;;;;;;;;;;;;;;;;;A0BsZA;AT9IA;;ADxPA;;AAAA;;ACwPA;;ADlRA;;AUmaA;;;;;;;;;AmC1eA;AAAA;AACA;AAAA;AAAA;;;;AAEA;AACA;;;;;;;AzBsEA;;;AA0GA;AAAA;AA3GA;AAAA;AAAA;AACA;;;;;;;AU9FA;;AAiPA;AAAA;AAlRA;AAAA;;;;;;;;;;;;;;;AeMA;AAAA;;;;;;;ARuKA;;;AAAA;AAGA;AAEA;AAAA;ArDxDA;;;;;;;;;;;;A8B2zEA;;;;;;;;A+Bx2EA;AAAA;AACA;AAAA;AAAA;;;;AAEA;AACA;;;;;;;;AxBiFA;AAAA;;AACA;;;;;;;;;AlB+BA;AACA;AAAA;AAAA;AACA;;;;;;;AkBHA;;;;;;;;;;ArCnFA;;;AmBwiBA;;;;;;;;;AnBpiBA;AAAA;;;;AAJA;AAAA;AAAA;AAAA;AmD7DA;;;;;;;;AA6JA;;;;;;;AAeA;;;;;;;;;;;AlCgLA;AAAA;AAAA;AAAA;AAAA;AAAA;AS4GA;AAAA;AAAA;;;;;;;;;A1BnXA;AgBMA;AAAA;AACA;AQ00BA;;;;;;;;;;AAGA;;;;;;;;AxBp2BA;A0BoYA;AAAA;A1BpYA;AAAA;AAAA;A0BoYA;AAAA;AAAA;;;;;;;;;;AWwDA;AACA;;AAGA;;;;;;;AYnWA;;AAAA;AAAA;AAAA;;;AA7BA;AjDxEA;AAAA;;;;;;;AiB+RA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AjBnRA;;AmB+vBA;;;;AnBnvBA;AAAA;AAAA;AAAA;AC/HA;;;;;;;AkBs3BA;AAAA;AnB/vBA;;;;;;AmBmwBA;AA4BA;AnB/xBA;AAAA;;;;;;;;;AwCwmCA;AA2NA;AAjOA;AArGA;;;;;;A7BrmCA;AACA;AADA;AAMA;AAAA;;;;;;;;;AFuIA;;;;;;;;AsB4QA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyTA;;;;;;;AvBhuBA;;;;AAygCA;;;;;;AH5zBA;;;;;AAyBA;;;;;;;;AyBu3BA;;;;;;;A/B/tBA;;;;;AAEA;AACA;;AAAA;;AACA;;;AAGA;AAAA;;;;;;AYMA;AAAA;;AAGA;;;;;;;;;ARtDA;;;;AQjTA;;;;;;;;;;;ANgCA;;;;;;;;AE4yBA;;;;AAAA;;;;AAAA;;;AAJA;;;AAIA;;;;;;;;;;;;;;;;;;;;;;A4CrrBA;AAAA;AAAA;;;AACA;;;;;;AA3EA;AAAA;AASA;;;;AAJA;AACA;;;AAaA;;;;;;;AhC4xBA;;;;;;AnBpzBA;AAAA;AAAA;AmB4KA;;AACA;;;;;;AA8mBA;AnBvxBA;AAAA;;;;AmBmyBA;;AnB/xBA;AAAA;AmBwxBA;AnBxxBA;;;;;;;;AemkCA;;;;;;;;;;;;;;;;;;AV5iCA;AAHA;AAAA;AAAA;;;;;;;;;;;A2CkDA;;;;;;;;;AGvCA;;;;;;;;;;;;;;;;AhC6IA;AAAA;AAGA;;;;;;;;AgCjMA;AACA;;;;;;;;AhC6yBA;;;;;;;;AAYA;AAAA;;;;;;;;AnBxyBA;;;;AAAA;;;AAAA;AAAA;AAAA;;;;;;AGu2CA;;AOuMA;;AC7xCA;AACA;;;;;;;AAQA;AAAA;AACA;;;;;;;;;AX3RA;AAAA;;;;;;;;AqBwYA;ArBxZA;AAIA;;;;;;AWjHA;AAAA;AAVA;AAAA;AAgBA;AACA;;;;;;AoB8hBA;AAAA;AAAA;;;AAqEA;AAoBA;;;;;AxBuPA;AAIA;;;;;AA8DA;;;;;;;;APtzBA;;;;;;;;;;;;ADgEA;AA5BA;;;;;;;AkDiCA;AAAA;AAAA;AAAA;;;;AAbA;;AACA;;;;;;AX3FA;;;;;;;;;A3BhFA;AADA;;;;;;;;;;;;;;;;;;AA0YA;;;;;;;;;AAxYA;AAAA;AAKA;AAAA;;;;;;;;;;;;;;;;;AkC2IA;;AAjDA;AAEA;;;;;;;AlC5HA;AAAA;AAAA;AACA;AAOA;AACA;;;;;;AJgqBA;AAIA;AACA;AAWA;AAiBA;;;;;;AuCxfA;AAGA;;AAoBA;AAFA;;;;;;AnCvMA;AACA;AADA;AAAA;AAAA;AACA;;;;;;;;;;AG4eA;;;;;;;;;;;;;;;;;AVlbA;ADuSA;;A2BhGA;;;A3BsEA;AAAA;;AACA;;AUlMA;AiB2HA;;;;;;;ATxEA;AAIA;;;;;;;AVxLA;AACA;AAZA;AAKA;;;;;;AACA;AAAA;AAKA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AoBwkBA;AAAA;;;AAEA;;;;;;A3BrhBA;ADuSA;;ACvSA;;;AD6QA;AAAA;;AACA;;AUlMA;AT5EA;;;;;;AO1DA;AADA;AAAA;AACA;AAAA;AADA;;;;;;AZoJA;AACA;AACA;AACA;AAEA;;;;;;;AAiIA;;;;;;;;;AY1RA;AACA;AAAA;AAjCA;;;;;;AA8CA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AA9CA;AAAA;AACA;AAAA;AAEA;AA8JA;;;;;;AAzIA;AAAA;AACA;AACA;AADA;AACA;;;;;;AADA;AAAA;AAEA;AAAA;AADA;AACA;;;;;;;AUqfA;AAAA;;;;;;;AA9PA;AAIA;;AAIA;;;;;;AAsPA;AAlRA;AAIA;AAAA;;;;;;;AA8QA;AAtSA;;;;;;;AVzMA;AADA;AAAA;AACA;;;;;;;;AX+GA;AAAA;;;;;;;;;;;;;;AKyLA;AAAA;;;;;;;;;;AegHA;ApBjUA;AoBoUA;;;;;;;ApBpUA;AAAA;AAAA;AAgBA;AAAA;AmBmvBA;AnBvvBA;AAAA;AAAA;;;;;;;;;;;A+B6gBA;AACA;AAkBA;;;;;;;;;AkChpBA;AAAA;AAAA;;AAIA;;;AAHA;AACA;AAEA;;;;;;AhCwJA;;AA1JA;AAspBA;AAtTA;;;;;;AtBvUA;AACA;AAAA;AAFA;AAAA;AAAA;;;;;;AA9CA;AACA;AAAA;AACA;AACA;;;;;;;AAwBA;AAHA;AAAA;AACA;AADA;AACA;;;;;;AAAA;AAAA;AAAA;AAEA;AADA;AACA;;;;;;AA1BA;AACA;AAAA;AACA;AAFA;AAAA;;;;;;AAAA;AACA;AACA;AAAA;AAeA;AACA;;;;;;AAnBA;AAAA;AACA;AAAA;AAEA;AAKA;;;;;;AAkBA;AACA;AAHA;AAAA;AAGA;AAHA;;;;;;AoBinBA;;;;;;AAAA;;;;;;;;;;;;AX7fA;;;;;;;;;;AC8KA;;;;;;;AV1RA;AACA;AAAA;AADA;;;;;;AU8PA;;AAIA;;;;;;;;AVjRA;;;;;;;;AUqPA;AAIA;AAIA;AAAA;;;;;;;AVrPA;AAAA;AACA;;;;;;;AUwNA;AAIA;AA0RA;;;;;;AVtfA;AADA;AAEA;AAHA;;;;;;;;;AHoyCA;AAAA;AACA;AAAA;AAAA;AACA;;;;;AGhxCA;AAAA;AAAA;AAAA;;;;;;AA7CA;AAEA;AAJA;AACA;;;;;;AAyBA;AAAA;AADA;AACA;;;;;;AAEA;AADA;AADA;AACA;;;;;;;;;;AsBJA;;;;;;AzB6mCA;AAAA;AACA;AAAA;;;AAIA;;;;;AGtoCA;AACA;AAAA;AAaA;AAGA;AAnBA;;;;;;AAEA;AAAA;AAAA;AACA;AADA;AACA;;;;;;AAKA;AAAA;AAAA;AAEA;AAOA;AACA;;;;;;AAQA;AAAA;AACA;AAHA;AAGA;AAHA;;;;;;;AIm5BA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;AAvCA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;Af7wBA;;;ADq8CA;AACA;;;;;;A4CxqCA;A3CtRA;;A2CiRA;A3CrRA;;;;;;AW7HA;;AADA;AACA;;;;;;AAmCA;AAAA;;AAEA;;;;;;AArCA;AAOA;AAMA;AACA;;;;;;AAUA;AADA;AAFA;AACA;;;;;;Aa6yBA;AACA;AACA;;;;;AAQA;;;AAiCA;;;;;;;;;;;;;;AhBlqBA;;;;;;;;;;;;;AQ/CA;;;;;;ALhKA;AAQA;AAGA;AAHA;;;;;;AAyBA;AAAA;AAKA;AAAA;;;;;;AA9BA;AAGA;AAOA;AACA;;;;;;AAKA;AAAA;AAGA;AAHA;;;;;;;;;;A2BPA;;;;;;;;;ApCkLA;AACA;AACA;;;;;;;;AuCtIA;AACA;AACA;AACA;AAaA;AACA;AAKA;;;;;;AzCmCA;AAAA;AsEuGA;AjD6NA;AAoFA;;;;;;;AD1UA;AAEA;AAAA;AAEA;AACA;;;;;;;;;;AkBjNA;;;AAgLA;;;;;;;;A7B8FA;;;;;;;;A8BiCA;AAAA;AAAA;AAg4BA;AAlBA;AvCnhCA;;;;;;;;AyC/HA;ADkqCA;A9Bi8BA;A8B9qBA;AACA;;;;;;;;;;AxB3xCA;AAAA;AUmXA;AT3HA;AAAA;;;;;;;;;;;;AF02BA;;;;;;;AClmCA;AAAA;AAAA;AAAA;AAAA;AAAA;ADyhCA;AAAA;AAkBA;;;;;;;AC3iCA;;;AqC1BA;AAAA;AAAA;AAAA;;;;;;;;;;;;A7C63BA;;;;;;;;AHz5BA;;AACA;AAAA;AAAA;;;;;;;;;;;;AWqDA;AAAA;;;;;;AqBwvCA;;;AAEA;AACA;ADxqCA;AA3GA;;;;;;;;;;;;;;;AyBIA;;;;;;;ArD8xCA;AACA;AACA;AAAA;;;;;;;;;AwCnxCA;;;;;;;;;A3B/CA;;AAEA;;;;;;;;;;;;;;;;;;;;;AhBkKA;AAAA;;;AAyHA;AAAA;AAAA;;;;;AMjWA;AAAA;AAAA;AAAA;AAEA;AAFA;;;;;;;;;AJisCA;;;AA4BA;;;;;;;;AchlCA;AAMA;;;;;;;;;;;;;;;;;;;;;ArB7DA;AAAA;AwB+gBA;AAAA;;;;;;;;;AqBndA;;;AAFA;;;;AAKA;AACA;;;;;;A9C2BA;;;;;;;;;;;;;ACvFA;AAAA;;;;;;AGgPA;AACA;AAAA;AQhVA;AAAA;AAKA;;;;;;AHpBA;;AAgBA;ARsFA;;;;;;;A6DXA;AAAA;;;AAKA;;;AAAA;;;;;;;;;AvB3HA;;;;;;;A3ByCA;AACA;AANA;AAHA;;;;;;AAcA;AAAA;AAAA;AAAA;;;;;;AHlBA;AAo6CA;ARh0CA;AQtFA;;;;;;;;AsC2CA;AAAA;;AAgIA;;;;;;;AAxKA;AADA;AAUA;AAdA;;;;;;;;;;;;;;;;;AnCMA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ANwLA;;;;;;AAAA;;;;AADA;;;;;AMvLA;AAAA;AAAA;AAAA;;;;;;AR4VA;;;;AA1BA;AAAA;;AACA;;AUlMA;;;;;;;;;;A+BuMA;AAAA;A5C9OA;AAAA;;;;;;;;A8C/CA;;ACjDA;ADIA;AAqBA;AAAA;;;;;;;A1BkeA;AAKA;;;;ApBhZA;;;;;;;;;;;;;;;;;AGkPA;;;;AA1BA;AAAA;;AACA;;AUlMA;;;;;;AgCsEA;AAGA;AAAA;AAAA;AAAA;AAAA;AAGA;;;;;;AlCrMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AARA;AAAA;;AAEA;;;;;;;;AXoFA;;AiDuHA;;;AAAA;;;AAAA;;AAAA;;;;;;;AxC0dA;;;AAIA;AAAA;AAAA;;;;;ALtnBA;ADuSA;;;;AA1BA;AAAA;;AACA;;AUlMA;;;;;;AwBwKA;;AAvGA;;;;;;;AlBpBA;AAIA;;AA8kBA;;;;;;ARrwBA;AADA;AAAA;AACA;;;;;;;;AmB+jEA;AAAA;;;;;;;AnB1jEA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AkCyNA;AAAA;AACA;AAGA;AAAA;AAGA;AACA;;;;;;;;AAtOA;;;;;;;;;AzBwaA;AAGA;;;;;;AjB1EA;;;;AA1BA;AAAA;;AACA;;AUlMA;;;;;;AiBoyEA;;;AAnCA;AACA;;AAAA;;AACA;AAiCA;;;;;;;;;;;;AtB39BA;AACA;AACA;;;;;;;AAvxCA;;;;;;;;;AAIA;;;;;AAAA;;;;;AGjLA;;AAdA;AACA;;;;;;AA9BA;AAJA;AAGA;AAAA;;;;;;AADA;AAeA;AAGA;AAAA;;;;;;AAKA;AAGA;AADA;AACA;;;;;;;;;;;;;AoB2ZA;AAEA;;;;;;A5BtDA;;;;AA1BA;AAAA;;AACA;;AUlMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AgCqEA;AAAA;AACA;AAGA;AAAA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AuBvLA;;;;;;;;;AAKA;;;;;;ArC4jBA;;AA9EA;;;;;;A5B9KA;;;;AA1BA;AAAA;;AACA;;AUlMA;;;;;;AFpKA;;AAHA;AACA;;;;;;AAqCA;AAAA;AAAA;AAAA;;;;;;AA3BA;AAOA;AAjBA;AAAA;;;;;;AAwBA;AADA;AAGA;AAHA;;;;;;;;;;;;;;;;;;AFi0BA;AAAA;AAAA;AAAA;AAAA;;;;;;AK5dA;;;AAMA;AACA;;;;;;AH5WA;AACA;AAAA;AACA;AAFA;AACA;;;;;;;;;;AyClBA;AACA;;;;;;;;;Ad+RA;;AAAA;AAEA;AACA;;;;;;A3BjRA;AACA;AAAA;AACA;AAHA;AACA;;;;;;;;;Ae6XA;AAAA;AADA;AACA;AACA;AAAA;AAAA;;;;;A0BjOA;AAAA;AAaA;AAZA;AAYA;;;;;;;;Ad3MA;;;;;;;;;;;;AnC0YA;;;;AA1BA;AAAA;;AACA;;AUlMA;;;;;;AV2NA;;;;AA1BA;AAAA;;AACA;;AUlMA;;;;A2BmkCA;AAAA;AAAA;AC/uCA;AD+uCA;AAAA;AAAA;AC9uCA;;;;;;;;AF0VA;AAEA;AAAA;AAQA;AACA;AACA;;;;;;;;;AhC29BA;;;;;;;;;;;;;;;;;;;;;AP7rCA;AAAA;AAAA;A0BuZA;AAAA;A1BvZA;AAAA;;;;;AW1FA;AAAA;;AAEA;;;;;;;;;;A0BumCA;AAAA;AAGA;;;;;;;;;ApB1vBA;;;AAAA;AHnTA;AAAA;AAAA;;;;;;;AdmBA;ADgpDA;AAAA;;AAyaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A+CvlEA;;;AA+IA;;AALA;AAGA;;AAEA;;;;;A9CjHA;AAAA;AAAA;AQCA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;ARDA;AAAA;AAAA;AAAA;AwBq+BA;AAAA;AAAA;;;;;;;;;;;;;;;AzB37BA;;AAypCA;;;;;;;;AoBziCA;AnBtIA;AAAA;;;;;;;;;;AQu6BA;;;;;;;;;;A0CjuBA;AAYA;;AACA;AACA;;AAGA;AAkQA;AACA;AAAA;;;;;AApRA;AAYA;;AACA;AACA;;AAGA;AA2PA;AACA;AAAA;;;;;;;;;;A7CjaA;AAAA;;;;;;;;;ANQA;;;;;;AmD4IA;AAYA;;AACA;AACA;;AAGA;AAyQA;AACA;AAAA;;;;;ApBu0BA;AAkoCA;;;;;;;;AtBr1DA;AAAA;AR7lBA;AAAA;AAAA;AAAA;AAAA;;;;;;;A+B0fA;;;;;;AhC5RA;;;;;;;;;;AM5KA;AACA;AACA;;;;;;;;;;AAzIA;;AA8KA;;;;;;;;;;;A+BgEA;AAAA;AAKA;AAAA;AACA;;;;;;;;;;AANA;AAAA;AAKA;AAAA;AACA;;;;;;;;;;AANA;AAAA;AAKA;AAAA;AACA;;;;;;;;;;AANA;AAAA;AAKA;AAAA;AACA;;;;;;;AerJA;;AANA;AACA;AACA;AACA;AACA;;AAEA;;;;;AGkHA;A5Cm1CA;AACA;;;;;;;ACtrCA;;;;;;AgD3YA;;AAAA;;AACA;;;;AAAA;;;;;;Ab8BA;AAiBA;;AAIA;;;;;;AfkXA;AAoLA;;;;;;;AiB7nBA;AACA;;AACA;;AACA;AACA;AAJA;;;;;;;;;;;;;;;;AFyBA;;;AAEA;AACA;;;AAEA;;;;;;AnCKA;AAjBA;AAAA;;;;ATmKA;AAGA;AAGA;AAGA;AASA;AAGA;AAIA;AAKA;AACA;AACA;;;;;;AAUA;;;;AAAA;;AACA;;;;;;;ASlKA;AAAA;;;;;;;;;ARkhBA;;;;;;;A8CrWA;;;;;;AjD/FA;AiDkCA;;;;;;AjDtCA;;;;;;;AW1EA;AAAA;AAAA;;;;;;AArCA;AAEA;AP+FA;;;;;;AOjFA;AADA;AACA;;;;;;AAOA;AACA;AADA;;;;AsBytDA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AHz3BA;;;AAFA;;;;;;;;AbxeA;AAAA;AAAA;AAAA;AAAA;;;;;;AIkFA;ArBnXA;;;;;;AWxFA;AAhCA;AACA;;;;;;AACA;AAHA;AACA;;;;;;AAEA;AAMA;AACA;;;;;;AAeA;AAGA;AAHA;;;;;;;A4B4aA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;AvC/TA;;;;;;;AAAA;;;;;;;;;;;AsChJA;;;;AAEA;;;;;;;AA0RA;;;;AAMA;;;;;;;;;;;;;;;;;AU1SA;AACA;;AACA;;AACA;AACA;;;;;;;A/BqaA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AepSA;AACA;AACA;;;AAKA;;;;;;;;;;;;;AiBdA;;;;;;;;AgB1FA;;;;;;;AGqEA;;;;;;;;;;;;;;ApEmCA;;;;;;AqBqYA;;;;;;;ArBzYA;AqB8YA;;;;;;;;Abi1BA;AACA;;;;;;;;;;;;A6CpuCA;AAAA;;;;;;;;;A7CwpCA;AAAA;;AA1vCA;AAAA;;;;;ASsYA;AAAA;;AAAA;;AS6HA;AAAA;;AACA;;;;;;AT7HA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;A+B1OA;;;;;;;;AxCivCA;AACA;;;;;;A8B5xCA;;;AACA;;;;;;;AA9IA;;;;;;;;;;AA8HA;;;;;;;;;;A3BtFA;;;AACA;;;;;;;AA4EA;;;AA7EA;;;;;;;AAPA;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;A4B+nBA;AAEA;;;;;;;AADA;;;AAAA;;;;;;;;;;;;;;;;AAzCA;AA6BA;AAGA;;;;;;AAo9BA;;;;;;;;;;;AAVA;;;;;;;AA/jCA;;;AAoBA;;;;;;;;AAlEA;AACA;;;;;;AA5BA;AAyBA;;;;;;;;;;;;;;;;;;AAjCA;;;;;;;;AvCnVA;ADk0BA;;;;;;;;;AC9zBA;;;;;;AAYA;A2CqVA;;;;;;;;A3CrVA;;;;;;;AuCusBA;;;;;;;;;A5BpzBA;AAFA;AACA;;;;;AsB8qDA;;;;;;;;;;;;;;;;AM7nBA;;;;;;;;AApIA;;;;;;;;;;;AA8pBA;AAEA;;;;;;AAlrBA;AAkqBA;AAEA;AACA;;;;;;AA3sBA;;AAkCA;AAIA;;;;;;AAnlBA;AA+fA;AAKA;AAsCA;;;;;;;AA9OA;AACA;;;;;;;;;AO/nBA;AAKA;;;;;;;AoBuIA;;;AAmDA;;;AAAA;;;;;AvDtMA;AACA;AACA;;;;;;;;;;;;;;;AAWA;;;AAAA;;;;;;;AAXA;;;AAMA;;;;;;;AA9BA;;;AAeA;;;;;;;AA4BA;;;AAAA;;;;;;;AAbA;;;AAAA;;;;;;;AADA;;;AACA;;;;;;;AAhCA;AAAA;AACA;;;;;;;AZqSA;AAQA;;;;;;AARA;;;;;;;;;AoBjFA;AACA;;;;;;AAFA;AAAA;;;;;;;ARpNA;AAAA;AACA;;;;;;AXsHA;;;;;;;AAYA;;;;;;;AiD3FA;;;;;;;AzC0zBA;;;;;AAsDA;;;;;AAh1BA;;;;;;;;AAcA;;;;;;;;AAorCA;AACA;AA1vCA;;;;;;AA8jCA;;;;;;;;;;;;;AHp5BA;;;;;;;;;AmC8iCA;;;;;;ADwVA;AAAA;AACA;AAAA;;;;;;AvC38CA;AAAA;;;;;;AW1EA;AAAA;AAAA;;;;;AqB0NA;;AAkEA;;;;;AjB0SA;;;;;;AJ5lBA;;;AACA;;;;;;;AANA;;;AAlBA;;;;;;;AAAA;;;AAEA;;;;;;;AA8BA;;;AADA;;;;;;;AAAA;;;AACA;;;;;;;AAAA;;;AADA;;;;;;;AAAA;;;AAAA;;;;;;;AACA;;;AAAA;;;;;;;AAPA;;;AAMA;;;;;;;AAMA;;;AAAA;;;;;;;AAAA;;;AAAA;;;;;;;AANA;;;AACA;;;;;;;AA/BA;;;AACA;;;;;;;AAFA;;;AAEA;;;;;;;AAHA;;;AAEA;;;;;;;AAcA;;;AAEA;;;;;;;AATA;;;AAEA;;;;;;;AAXA;;;AACA;;;;;;;AA0BA;;;AADA;;;;;;;AAFA;;;AAGA;;;;;;;AAFA;;;AADA;;;;;;;AAGA;;;AAHA;;;;;;;AAAA;;;AACA;;;;;;;AAAA;;;AACA;;;;;;;;;;ANlBA;;;;;;;;AAVA;;;;;;;;;;;AYyZA;AHjKA;;;;;AGiKA;AHzQA;;;;;AOkYA;ArBxZA;;;;;AQ41CA;AAEA;AACA;AAAA;;;;;;AG16CA;AACA;AAAA;;;;;;AAnCA;AAXA;AACA;;;;;;AAyBA;AACA;AAHA;;;;;;AAcA;AAAA;AAAA;;;;;;;;;;AHwlCA;AACA;AAAA;;;;;ASxuBA;AH/GA;;;;;;;AUiVA;;AAEA;;AxBngBA;;;;;AWxFA;AACA;AADA;;;;;;AsCSA;;;;;;;AgBjBA;;;;;;;AGiEA;ACxFA;;;;;;;;;;;;;ArEuHA;AoEtHA;;;;;;ApEkIA;AAAA;;;;;;AqBkYA;AACA;;;;;;ArB3YA;;;;;;;AW5FA;AAAA;AACA;;;;;;;AARA;AACA;;;;;;AAzBA;AACA;AACA;;;;;;AAqBA;AAEA;AACA;;;;;;AkDmPA;AACA;;;;;;;;;AVvCA;;AAFA;;AAEA;;;;;;;;;;;;;;;AlC+KA;AHlNA;;;;;AGkNA;AH9TA;;;;;AUsdA;AAAA;;;;;;;;;;AE9QA;;;;;A1B7JA;AAAA;AAAA;AAAA;;;;AW9FA;AAAA;;;;;;;AI4iBA;AAIA;;;;;;;;;;;;;;;;;ANvRA;;;;;AJjLA;AACA;AACA;AACA;AACA;;;;;;AmCm/BA;;;;AAAA;;;;;;;AAqEA;;;;;;;;;;;AA2NA;;;AE9vCA;;;;;;;;AFoyCA;;;AAxQA;AAAA;;;;;;;AAHA;;;;;;;;;;;AAjCA;;;;;;;;;;;AA1BA;;;AAhUA;AAkZA;;;;;;;AANA;;;AAjBA;AA3DA;;;;;;;A1B1xBA;AACA;AACA;;;;;;;;A0BkzBA;AEx/BA;;;;;;;AFgjCA;;;AChrCA;;;;;;;;ADuzBA;;;AAuSA;AAkFA;;;;;;;AA4NA;;;AA9SA;;;;;;;;AA2GA;;;AAtCA;AAAA;;;;;;;;;;;AA3CA;;;;;;;;AK/7BA;AAEA;;;;;;;AfisBA;AAAA;AACA;;;;;Ae/4BA;AACA;AAAA;AACA;;;;;;;A5BmYA;AAAA;AAAA;;;;;;;;A4B3LA;AACA;AAAA;;;;;;;;;;;;;;;;;;ArC+oCA;;;;;AAoCA;AAIA;;;;;;;;AM3hCA;AACA;;;;;;AdrPA;;;;;;;;AiBkRA;AAAA;AAAA;;;;;AjBlSA;ADoqBA;;;;;ACxpBA;ADmpBA;;;;AkCjIA;AvB09CA;AuBpuBA;ADr3CA;;;;;AxB8uBA;AAAA;AAOA;;;AL5ZA;AACA;AOyvDA;AoBrlEA;;;;;;;AbqYA;AAAA;AAAA;;;;Ad1CA;AACA;AOyvDA;AiBlnEA;;;;AxBwXA;AACA;AOyvDA;AS3gEA;;;;;;;;AZ+wBA;;;AAAA;;;AJ9fA;AACA;AOyvDA;AkCviEA;;;;AzC6SA;AACA;AOyvDA;AiCvkEA;;;;;;AZmZA;;;;;;;;;;;AXzRA;;;;;;;;;;AZouCA;;;;;;AyCn2CA;AA8EA;;;;;;;;AA9EA;AAyDA;;;;;;;AIgGA;;;AAAA;;;;;;;AAFA;;;AAAA;;;;;;;;;;ArCrBA;;;;;;;AqCCA;;;AAAA;;;;;;;AAFA;;;AAAA;;;;;;;AARA;;;ArDPA;;;;;;;AARA;;;AAQA;;;;;;;AqDLA;;;ArDHA;;;;;;;AqDAA;;;AAAA;;;;;;;AAFA;;;AAAA;;;;;;;ArC0BA;;;AqC1BA;;;;;;;;;;;;;;;;;;;;AAjCA;;;;;;;;;;;;;;;;;;;;AAnDA;;;;;;;;;;AAzBA;;;;;;;;;;;;;;;;;AZwCA;;;AAqBA;;;;;;;ADioCA;;;AC7sCA;;;;;;;;;;A5B6JA;;;;;;;;;;ALy9BA;AACA;;;;;;;;;;A2C14BA;;;;;AlCiKA;AH3JA;;;;;AG2JA;AHnQA;;;;;;;ANgpBA;;AAAA;;;;AH5YA;AACA;;;;;;AA7PA;;;;;;;;;;;;;;;;;;;;AG9BA;;;;;;;A6ByyBA;;;;;;;;;;;;;;;;;;;;AA8CA;;;;;AA9FA;;;;;ApBheA;AHzGA;;;;;;;AdvLA;;AuBoBA;;;;;;AsB3GA;;;;AACA;AACA;;;;;;ARuyBA;;;;;ArC9sBA;;;;;;;;;;;;AyDhGA;;;AN0FA;AACA;AACA;AACA;AACA;;;;;AfiLA;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;AAAA;;;;;;AnB6GA;AH5MA;;;;;AG4MA;AHxTA;;;;;;;APmxCA;AAAA;;;;;;A0C10CA;;;;;AjD2FA;;;;;;;;AQyuCA;;;;;AMx/BA;AAAA;;;;AdzPA;;;;;;;A0B2ZA;AACA;;;;;;;;;;;AmBlVA;AACA;AACA;;;;;;;;;;;AtC+hCA;;;;AsCrhCA;AACA;AACA;;;;;;;;A5BoMA;AAAA;;;;;;;AOydA;;;;;;;AnBppBA;;;;AACA;;;;;ASgHA;AACA;;;;AdvMA;;;;;AqD+CA;AAAA;;;;;;;;A7CrKA;;;;;;;;;;;;;;;AyC0FA;;;;;;;;;;;;;;;;;;;;AjDwBA;;;;;AqB6XA;;;;;AAZA;;;;;;;;;;;;Ab2mBA;AAAA;;;;;;AM5tBA;;;;;;AP0fA;AAAA;AAMA;;;;;;;;;;;ACp1BA;;;;;ARwEA;;;;;;;;;;;;AkE8GA;;;;;;;;;;;;;;AlEtGA;AAAA;AAAA;;;;;Ac6NA;;;;;AZlOA;AACA;;;;;;;;;;;;;;AsBwYA;;;;;;;;;;;;;;AhBnfA;;;;;AMiYA;;;;AP1JA;AACA;;;;;;;AuBuVA;;;;;;A+BnjBA;;;;;;;AMzCA;;;;;AX6FA;AACA;AACA;;;;;;AhDmyCA;;;;A6B+CA;AAAA;;;;;AvB1iCA;AAAA;;;;;;;;;;;;;ANlQA;;;;AsBmzCA;AAQA;AACA;;;;;A+B5qCA;AACA;;;;;AAJA;AAAA;;;;;AA1EA;AAAA;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;;AApBA;;;;;;;;;;;ArD2uCA;;;;A6B/gBA;AAAA;;;;;;AvBvtBA;;;;;;;AP4fA;;;;;;;;AA3LA;;;;;;;;AA81BA;;;;;AOx+BA;;;;;AuB+kBA;AAAA;;;;;AA7FA;AAAA;;;;;APiKA;AAAA;;;;;AtBwUA;;;;;AMx/BA;;;;;AsBqdA;AAAA;;;;;ACtQA;AAAA;;;;;;;;;;;AR3fA;;;;;;;;AwCxCA;AAGA;;;;;;;;;;;;AH4TA;;AAMA;;;;;ApB3EA;;;;;;;;;;;A/Bs6BA;AACA;;;;;;APuOA;;;;;;AsCnnCA;;;;;AhChJA;;;;;;;AgCqIA;;;;;AVowCA;;;;AtB/vCA;;;;AAxGA;;;;;;;;ANgvCA;;;;;;;;;;;;;;;AwCn5CA;;;;AlC+VA;;;;;;;APu+BA;;;;;AmBp6BA;AAEA;;;;;;;;;;;AZvGA;;;;;ANgkCA;;;;;;;;;;;AMz+BA;;;;;;ATjNA;;;;;A+Bo0CA;;;;A5BzxCA;;;;AR7GA;;;;;;;;;;A8BmxCA;AACA;;;;;A+Bh2CA;;;;;;AtB8hCA;;;;;;AAuBA;;;;;A5B/lCA;;;;;AAHA;;;;;;;;;;;;;;;AGkNA;;;;AA5GA;;;;AAkKA;;;;AArFA;;;;;;;;;;;;;;;;;;;;AyBw6BA;;;;;ArC34BA;;;;AmD3HA;AAMA;;;;;;A7B+DA;;;;AwBjKA;;;;AlCsaA;AACA;;;;;AgC7KA;;;;;AVkmBA;;;;;;;;;;AAHA;;;;;;;;;ApCztBA;;;;;;;;;;AoCguCA;;;;AAHA;;;;AtB97BA;;;;A+CvYA;;;;;;ArDu4CA;AAAA;;;;;;;;AR/xCA;;;;AoC4vBA;;;;AA0KA;;;;AAhPA;;;;;;;;;;AAljBA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAqnBA;;;;AA0KA;;;;AAhPA;;;;AtBnkBA;;;;AA3GA;;;AuCxBA;;;;;;A9CwlCA;;;;AAhVA;;;;AAcA;;;;;AkD12BA;;;;;AD8BA;;;;AxDyFA;;;;AoCkaA;;;;A7BwZA;;;AsDr6BA;;;;;;;;AzByfA;;;;AUzMA;;;;AANA;;;;;AvCgzBA;;;;;;;;;;;;;;;;;Aa7hBA;;;;;;;AboFA;;;;;;;;A6B4FA;;;;AAnOA;;;;;;;;;;;AhB/DA;;;;AgB+RA;;;;AArPA;;;;AA2BA;;;;AAfA;;;;AAMA;;;;AAVA;;;;AApBA;;;;AAQA;;;AiBpcA;;;;;AjBudA;;;;AuB/iBA;;;;;AvBwhBA;;;;A7B4UA;;;AiDrvBA;;;;;;;;;AtD0EA;AAGA;;;;AuDvKA;;;AN4RA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A3CsdA;;;;;;;;;;;;;;;;;;;AgDptBA;;;;AAVA;;;;;;;;;;;;;;;;;AjDwhBA;;;;AA3cA;;;;AoDxBA;;;;;;;;;;;ANoCA;;;;;;;;;ArDIA;;;AAQA;;;AiBwRA;;;ASNA;;;AV5QA;;;APeA;;;AyCugBA;;;;AMnmBA;;;;;;;;;;;;;;;;;;;;;;;AKwQA;;;;;;ArD/SA;;;;;;;;;;;;;;;;ARsGA;;;;AyD7IA;;;;AP6pBA;;;A9BnoBA;;;;;;;;;;;;;;;;;;;;;;;;ANyCA;;;;AARA;;;;AAgBA;;;AyBugCA;;;;AhCmOA;;;AE7lBA;;;;ADjeA;;;;;ADiiCA;;;;AElxBA;;;;;;;A4DhfA;;;;AhB8DA;;;;AFyNA;;;;;;;;;;;AjDpFA;;;;;;;;AgDycA;;;;;;;;;;;;;;;;;;;;;;;;;;;AApBA;;;;;;;;;;;;;;;;;;;;;;;;;AzCpeA;;;;;;;A+D3KA;;;AhBqBA;;;;;;;;;;;AUoJA","file":"./BasiliskII.js","sourcesContent":["/*\n *  extfs.cpp - MacOS file system for native file system access\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/*\n *  SEE ALSO\n *    Guide to the File System Manager (from FSM 1.2 SDK)\n *\n *  TODO\n *    LockRng\n *    UnlockRng\n *    (CatSearch)\n *    (MakeFSSpec)\n *    (GetVolMountInfoSize)\n *    (GetVolMountInfo)\n *    (GetForeignPrivs)\n *    (SetForeignPrivs)\n */\n\n#include \"sysdeps.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#ifndef WIN32\n#include <unistd.h>\n#include <dirent.h>\n#endif\n\n#if defined __APPLE__ && defined __MACH__\n#include <sys/attr.h>\n#endif\n\n#include \"cpu_emulation.h\"\n#include \"emul_op.h\"\n#include \"main.h\"\n#include \"disk.h\"\n#include \"prefs.h\"\n#include \"user_strings.h\"\n#include \"extfs.h\"\n#include \"extfs_defs.h\"\n\n#ifdef WIN32\n# include \"posix_emu.h\"\n#endif\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n// File system global data and 68k routines\nenum {\n\tfsCommProcStub = 0,\n\tfsHFSProcStub = 6,\n\tfsDrvStatus = 12,\t\t\t\t// Drive Status record\n\tfsFSD = 42,\t\t\t\t\t\t// File system descriptor\n\tfsPB = 238,\t\t\t\t\t\t// IOParam (for mounting and renaming), also used for temporary storage\n\tfsVMI = 288,\t\t\t\t\t// VoumeMountInfoHeader (for mounting)\n\tfsParseRec = 296,\t\t\t\t// ParsePathRec struct\n\tfsReturn = 306,\t\t\t\t\t// Area for return data of 68k routines\n\tfsAllocateVCB = 562,\t\t\t// UTAllocateVCB(uint16 *sysVCBLength{a0}, uint32 *vcb{a1})\n\tfsAddNewVCB = 578,\t\t\t\t// UTAddNewVCB(int drive_number{d0}, int16 *vRefNum{a1}, uint32 vcb{a1})\n\tfsDetermineVol = 594,\t\t\t// UTDetermineVol(uint32 pb{a0}, int16 *status{a1}, int16 *more_matches{a2}, int16 *vRefNum{a3}, uint32 *vcb{a4})\n\tfsResolveWDCB = 614,\t\t\t// UTResolveWDCB(uint32 procID{d0}, int16 index{d1}, int16 vRefNum{d0}, uint32 *wdcb{a0})\n\tfsGetDefaultVol = 632,\t\t\t// UTGetDefaultVol(uint32 wdpb{a0})\n\tfsGetPathComponentName = 644,\t// UTGetPathComponentName(uint32 rec{a0})\n\tfsParsePathname = 656,\t\t\t// UTParsePathname(uint32 *start{a0}, uint32 name{a1})\n\tfsDisposeVCB = 670,\t\t\t\t// UTDisposeVCB(uint32 vcb{a0})\n\tfsCheckWDRefNum = 682,\t\t\t// UTCheckWDRefNum(int16 refNum{d0})\n\tfsSetDefaultVol = 694,\t\t\t// UTSetDefaultVol(uint32 dummy{d0}, int32 dirID{d1}, int16 refNum{d2})\n\tfsAllocateFCB = 710,\t\t\t// UTAllocateFCB(int16 *refNum{a0}, uint32 *fcb{a1})\n\tfsReleaseFCB = 724,\t\t\t\t// UTReleaseFCB(int16 refNum{d0})\n\tfsIndexFCB = 736,\t\t\t\t// UTIndexFCB(uint32 vcb{a0}, int16 *refNum{a1}, uint32 *fcb{a2})\n\tfsResolveFCB = 752,\t\t\t\t// UTResolveFCB(int16 refNum{d0}, uint32 *fcb{a0})\n\tfsAdjustEOF = 766,\t\t\t\t// UTAdjustEOF(int16 refNum{d0})\n\tfsAllocateWDCB = 778,\t\t\t// UTAllocateWDCB(uint32 pb{a0})\n\tfsReleaseWDCB = 790,\t\t\t// UTReleaseWDCB(int16 vRefNum{d0})\n\tSIZEOF_fsdat = 802\n};\n\nstatic uint32 fs_data = 0;\t\t// Mac address of global data\n\n\n// File system and volume name\nstatic char FS_NAME[32], VOLUME_NAME[32];\n\n// This directory is our root (read from prefs)\nstatic const char *RootPath;\nstatic bool ready = false;\nstatic struct stat root_stat;\n\n// File system ID/media type\nconst int16 MY_FSID = EMULATOR_ID_2;\nconst uint32 MY_MEDIA_TYPE = EMULATOR_ID_4;\n\n// CNID of root and root's parent\nconst uint32 ROOT_ID = 2;\nconst uint32 ROOT_PARENT_ID = 1;\n\n// File system stack size\nconst int STACK_SIZE = 0x10000;\n\n// Allocation block and clump size as reported to MacOS (these are of course\n// not the real values and have no meaning on the host OS)\nconst int AL_BLK_SIZE = 0x4000;\nconst int CLUMP_SIZE = 0x4000;\n\n// Drive number of our pseudo-drive\nstatic int drive_number;\n\n\n// Disk/drive icon\nconst uint8 ExtFSIcon[256] = {\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xfe,\n\t0x80, 0x00, 0x00, 0x91, 0x80, 0x00, 0x00, 0x91, 0x80, 0x00, 0x01, 0x21, 0x80, 0x00, 0x01, 0x21,\n\t0x80, 0x00, 0x02, 0x41, 0x8c, 0x00, 0x02, 0x41, 0x80, 0x00, 0x04, 0x81, 0x80, 0x00, 0x04, 0x81,\n\t0x7f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xfe,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0x7f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\n\n// These objects are used to map CNIDs to path names\nstruct FSItem {\n\tFSItem *next;\t\t\t// Pointer to next FSItem in list\n\tuint32 id;\t\t\t\t// CNID of this file/dir\n\tuint32 parent_id;\t\t// CNID of parent file/dir\n\tFSItem *parent;\t\t\t// Pointer to parent\n\tchar *name;\t\t\t\t// Object name (C string) - Host OS\n\tchar guest_name[32];\t// Object name (C string) - Guest OS\n\ttime_t mtime;\t\t\t// Modification time for get_cat_info caching\n\tint cache_dircount;\t\t// Cached number of files in directory\n};\n\nstatic FSItem *first_fs_item, *last_fs_item;\n\nstatic uint32 next_cnid = fsUsrCNID;\t// Next available CNID\n\n\n/*\n *  Get object creation time\n */\n\n#if defined __APPLE__ && defined __MACH__\nstruct crtimebuf {\n\tunsigned long length;\n\tstruct timespec crtime;\n};\n\nstatic uint32 do_get_creation_time(const char *path)\n{\n\tstruct attrlist attr;\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.bitmapcount = ATTR_BIT_MAP_COUNT;\n\tattr.commonattr = ATTR_CMN_CRTIME;\n\n\tcrtimebuf buf;\n\tif (getattrlist(path, &attr, &buf, sizeof(buf), FSOPT_NOFOLLOW) < 0)\n\t\treturn 0;\n\treturn TimeToMacTime(buf.crtime.tv_sec);\n}\n\nstatic uint32 get_creation_time(const char *path)\n{\n\tif (path == NULL)\n\t\treturn 0;\n\tif (path == RootPath) {\n\t\tstatic uint32 root_crtime = UINT_MAX;\n\t\tif (root_crtime == UINT_MAX)\n\t\t\troot_crtime = do_get_creation_time(path);\n\t\treturn root_crtime;\n\t}\n\treturn do_get_creation_time(path);\n}\n#endif\n\n\n/*\n *  Find FSItem for given CNID\n */\n\nstatic FSItem *find_fsitem_by_id(uint32 cnid)\n{\n\tFSItem *p = first_fs_item;\n\twhile (p) {\n\t\tif (p->id == cnid)\n\t\t\treturn p;\n\t\tp = p->next;\n\t}\n\treturn NULL;\n}\n\n/*\n *  Create FSItem with the given parameters\n */\n\nstatic FSItem *create_fsitem(const char *name, const char *guest_name, FSItem *parent)\n{\n\tFSItem *p = new FSItem;\n\tlast_fs_item->next = p;\n\tp->next = NULL;\n\tlast_fs_item = p;\n\tp->id = next_cnid++;\n\tp->parent_id = parent->id;\n\tp->parent = parent;\n\tp->name = new char[strlen(name) + 1];\n\tstrcpy(p->name, name);\n\tstrncpy(p->guest_name, guest_name, 31);\n\tp->guest_name[31] = 0;\n\tp->mtime = 0;\n\treturn p;\n}\n\n/*\n *  Find FSItem for given name and parent, construct new FSItem if not found\n */\n\nstatic FSItem *find_fsitem(const char *name, FSItem *parent)\n{\n\tFSItem *p = first_fs_item;\n\twhile (p) {\n\t\tif (p->parent == parent && !strcmp(p->name, name))\n\t\t\treturn p;\n\t\tp = p->next;\n\t}\n\n\t// Not found, construct new FSItem\n\treturn create_fsitem(name, host_encoding_to_macroman(name), parent);\n}\n\n/*\n *  Find FSItem for given guest_name and parent, construct new FSItem if not found\n */\n\nstatic FSItem *find_fsitem_guest(const char *guest_name, FSItem *parent)\n{\n\tFSItem *p = first_fs_item;\n\twhile (p) {\n\t\tif (p->parent == parent && !strcmp(p->guest_name, guest_name))\n\t\t\treturn p;\n\t\tp = p->next;\n\t}\n\n\t// Not found, construct new FSItem\n\treturn create_fsitem(macroman_to_host_encoding(guest_name), guest_name, parent);\n}\n\n/*\n *  Get full path (->full_path) for given FSItem\n */\n\nstatic char full_path[MAX_PATH_LENGTH];\n\nstatic void add_path_comp(const char *s)\n{\n\tadd_path_component(full_path, s);\n}\n\nstatic void get_path_for_fsitem(FSItem *p)\n{\n\tif (p->id == ROOT_PARENT_ID) {\n\t\tfull_path[0] = 0;\n\t} else if (p->id == ROOT_ID) {\n\t\tstrncpy(full_path, RootPath, MAX_PATH_LENGTH-1);\n\t\tfull_path[MAX_PATH_LENGTH-1] = 0;\n\t} else {\n\t\tget_path_for_fsitem(p->parent);\n\t\tadd_path_comp(p->name);\n\t}\n}\n\n\n/*\n *  Exchange parent CNIDs in all FSItems\n */\n\nstatic void swap_parent_ids(uint32 parent1, uint32 parent2)\n{\n\tFSItem *p = first_fs_item;\n\twhile (p) {\n\t\tif (p->parent_id == parent1)\n\t\t\tp->parent_id = parent2;\n\t\telse if (p->parent_id == parent2)\n\t\t\tp->parent_id = parent1;\n\t\tp = p->next;\n\t}\n}\n\n\n/*\n *  String handling functions\n */\n\n// Copy pascal string\nstatic void pstrcpy(char *dst, const char *src)\n{\n\tint size = *dst++ = *src++;\n\twhile (size--)\n\t\t*dst++ = *src++;\n}\n\n// Convert C string to pascal string\nstatic void cstr2pstr(char *dst, const char *src)\n{\n\t*dst++ = strlen(src);\n\tchar c;\n\twhile ((c = *src++) != 0) {\n\t\t// Note: we are converting host ':' characters to Mac '/' characters here\n\t\t// '/' is not a path separator as this function is only used on object names\n\t\tif (c == ':')\n\t\t\tc = '/';\n\t\t*dst++ = c;\n\t}\n}\n\n// Convert string (no length byte) to C string, length given separately\nstatic void strn2cstr(char *dst, const char *src, int size)\n{\n\twhile (size--) {\n\t\tchar c = *src++;\n\t\t// Note: we are converting Mac '/' characters to host ':' characters here\n\t\t// '/' is not a path separator as this function is only used on object names\n\t\tif (c == '/')\n\t\t\tc = ':';\n\t\t*dst++ = c;\n\t}\n\t*dst = 0;\n}\n\n\n/*\n *  Convert errno to MacOS error code\n */\n\nstatic int16 errno2oserr(void)\n{\n\tD(bug(\" errno %08x\\n\", errno));\n\tswitch (errno) {\n\t\tcase 0:\n\t\t\treturn noErr;\n\t\tcase ENOENT:\n\t\tcase EISDIR:\n\t\t\treturn fnfErr;\n\t\tcase EACCES:\n\t\tcase EPERM:\n\t\t\treturn permErr;\n\t\tcase EEXIST:\n\t\t\treturn dupFNErr;\n\t\tcase EBUSY:\n\t\tcase ENOTEMPTY:\n\t\t\treturn fBsyErr;\n\t\tcase ENOSPC:\n\t\t\treturn dskFulErr;\n\t\tcase EROFS:\n\t\t\treturn wPrErr;\n\t\tcase EMFILE:\n\t\t\treturn tmfoErr;\n\t\tcase ENOMEM:\n\t\t\treturn -108;\n\t\tcase EIO:\n\t\tdefault:\n\t\t\treturn ioErr;\n\t}\n}\n\n\n/*\n *  Initialization\n */\n\nvoid ExtFSInit(void)\n{\n\t// System specific initialization\n\textfs_init();\n\n\t// Get file system and volume name\n\tcstr2pstr(FS_NAME, GetString(STR_EXTFS_NAME));\n\tcstr2pstr(VOLUME_NAME, GetString(STR_EXTFS_VOLUME_NAME));\n\n\t// Create root's parent FSItem\n\tFSItem *p = new FSItem;\n\tfirst_fs_item = last_fs_item = p;\n\tp->next = NULL;\n\tp->id = ROOT_PARENT_ID;\n\tp->parent_id = 0;\n\tp->parent = NULL;\n\tp->name = new char[1];\n\tp->name[0] = 0;\n\tp->guest_name[0] = 0;\n\n\t// Create root FSItem\n\tp = new FSItem;\n\tlast_fs_item->next = p;\n\tp->next = NULL;\n\tlast_fs_item = p;\n\tp->id = ROOT_ID;\n\tp->parent_id = ROOT_PARENT_ID;\n\tp->parent = first_fs_item;\n\tconst char *volume_name = GetString(STR_EXTFS_VOLUME_NAME);\n\tp->name = new char[strlen(volume_name) + 1];\n\tstrcpy(p->name, volume_name);\n\tstrncpy(p->guest_name, host_encoding_to_macroman(p->name), 32);\n\tp->guest_name[31] = 0;\n\n\t// Find path for root\n\tif ((RootPath = PrefsFindString(\"extfs\")) != NULL) {\n\t\tif (stat(RootPath, &root_stat))\n\t\t\treturn;\n\t\tif (!S_ISDIR(root_stat.st_mode))\n\t\t\treturn;\n\t\tready = true;\n\t}\n}\n\n\n/*\n *  Deinitialization\n */\n\nvoid ExtFSExit(void)\n{\n\t// Delete all FSItems\n\tFSItem *p = first_fs_item, *next;\n\twhile (p) {\n\t\tnext = p->next;\n\t\tdelete[] p->name;\n\t\tdelete p;\n\t\tp = next;\n\t}\n\tfirst_fs_item = last_fs_item = NULL;\n\n\t// System specific deinitialization\n\textfs_exit();\n}\n\n\n/*\n *  Install file system\n */\n\nvoid InstallExtFS(void)\n{\n\tint num_blocks = 0xffff;\t// Fake number of blocks of our drive\n\tM68kRegisters r;\n\n\tD(bug(\"InstallExtFS\\n\"));\n\tif (!ready)\n\t\treturn;\n\n\t// FSM present?\n\tr.d[0] = gestaltFSAttr;\n\tExecute68kTrap(0xa1ad, &r);\t// Gestalt()\n\tD(bug(\"FSAttr %d, %08x\\n\", r.d[0], r.a[0]));\n\tif ((r.d[0] & 0xffff) || !(r.a[0] & (1 << gestaltHasFileSystemManager))) {\n\t\tprintf(\"WARNING: No FSM present, disabling ExtFS\\n\");\n\t\treturn;\n\t}\n\n\t// Yes, version >=1.2?\n\tr.d[0] = gestaltFSMVersion;\n\tExecute68kTrap(0xa1ad, &r);\t// Gestalt()\n\tD(bug(\"FSMVersion %d, %08x\\n\", r.d[0], r.a[0]));\n\tif ((r.d[0] & 0xffff) || (r.a[0] < 0x0120)) {\n\t\tprintf(\"WARNING: FSM <1.2 found, disabling ExtFS\\n\");\n\t\treturn;\n\t}\n\n\tD(bug(\"FSM present\\n\"));\n\n\t// Yes, allocate file system stack\n\tr.d[0] = STACK_SIZE;\n\tExecute68kTrap(0xa71e, &r);\t\t// NewPtrSysClear()\n\tif (r.a[0] == 0)\n\t\treturn;\n\tuint32 fs_stack = r.a[0];\n\n\t// Allocate memory for our data structures and 68k code\n\tr.d[0] = SIZEOF_fsdat;\n\tExecute68kTrap(0xa71e, &r);\t\t// NewPtrSysClear()\n\tif (r.a[0] == 0)\n\t\treturn;\n\tfs_data = r.a[0];\n\n\t// Set up 68k code fragments\n\tint p = fs_data + fsCommProcStub;\n\tWriteMacInt16(p, M68K_EMUL_OP_EXTFS_COMM); p += 2;\n\tWriteMacInt16(p, M68K_RTD); p += 2;\n\tWriteMacInt16(p, 10); p += 2;\n\tif (p - fs_data != fsHFSProcStub)\n\t\tgoto fsdat_error;\n\tWriteMacInt16(p, M68K_EMUL_OP_EXTFS_HFS); p += 2;\n\tWriteMacInt16(p, M68K_RTD); p += 2;\n\tWriteMacInt16(p, 16);\n\tp = fs_data + fsAllocateVCB;\n\tWriteMacInt16(p, 0x4267); p+= 2;\t// clr.w -(sp)\n\tWriteMacInt16(p, 0x2f08); p+= 2;\t// move.l a0,-(sp)\n\tWriteMacInt16(p, 0x2f09); p+= 2;\t// move.l a1,-(sp)\n\tWriteMacInt16(p, 0x4267); p+= 2;\t// clr.w -(sp)\n\tWriteMacInt16(p, 0x7006); p+= 2;\t// UTAllocateVCB\n\tWriteMacInt16(p, 0xa824); p+= 2;\t// FSMgr\n\tWriteMacInt16(p, 0x301f); p+= 2;\t// move.w (sp)+,d0\n\tWriteMacInt16(p, M68K_RTS); p+= 2;\n\tif (p - fs_data != fsAddNewVCB)\n\t\tgoto fsdat_error;\n\tWriteMacInt16(p, 0x4267); p+= 2;\t// clr.w -(sp)\n\tWriteMacInt16(p, 0x3f00); p+= 2;\t// move.w d0,-(sp)\n\tWriteMacInt16(p, 0x2f08); p+= 2;\t// move.l a0,-(a7)\n\tWriteMacInt16(p, 0x2f09); p+= 2;\t// move.l a1,-(a7)\n\tWriteMacInt16(p, 0x7007); p+= 2;\t// UTAddNewVCB\n\tWriteMacInt16(p, 0xa824); p+= 2;\t// FSMgr\n\tWriteMacInt16(p, 0x301f); p+= 2;\t// move.w (sp)+,d0\n\tWriteMacInt16(p, M68K_RTS); p+= 2;\n\tif (p - fs_data != fsDetermineVol)\n\t\tgoto fsdat_error;\n\tWriteMacInt16(p, 0x4267); p+= 2;\t// clr.w -(sp)\n\tWriteMacInt16(p, 0x2f08); p+= 2;\t// move.l a0,-(sp)\n\tWriteMacInt16(p, 0x2f09); p+= 2;\t// move.l a1,-(sp)\n\tWriteMacInt16(p, 0x2f0a); p+= 2;\t// move.l a2,-(sp)\n\tWriteMacInt16(p, 0x2f0b); p+= 2;\t// move.l a3,-(sp)\n\tWriteMacInt16(p, 0x2f0c); p+= 2;\t// move.l a4,-(sp)\n\tWriteMacInt16(p, 0x701d); p+= 2;\t// UTDetermineVol\n\tWriteMacInt16(p, 0xa824); p+= 2;\t// FSMgr\n\tWriteMacInt16(p, 0x301f); p+= 2;\t// move.w (sp)+,d0\n\tWriteMacInt16(p, M68K_RTS); p+= 2;\n\tif (p - fs_data != fsResolveWDCB)\n\t\tgoto fsdat_error;\n\tWriteMacInt16(p, 0x4267); p+= 2;\t// clr.w -(sp)\n\tWriteMacInt16(p, 0x2f00); p+= 2;\t// move.l d0,-(sp)\n\tWriteMacInt16(p, 0x3f01); p+= 2;\t// move.w d1,-(sp)\n\tWriteMacInt16(p, 0x3f02); p+= 2;\t// move.w d2,-(sp)\n\tWriteMacInt16(p, 0x2f08); p+= 2;\t// move.l a0,-(sp)\n\tWriteMacInt16(p, 0x700e); p+= 2;\t// UTResolveWDCB\n\tWriteMacInt16(p, 0xa824); p+= 2;\t// FSMgr\n\tWriteMacInt16(p, 0x301f); p+= 2;\t// move.w (sp)+,d0\n\tWriteMacInt16(p, M68K_RTS); p+= 2;\n\tif (p - fs_data != fsGetDefaultVol)\n\t\tgoto fsdat_error;\n\tWriteMacInt16(p, 0x4267); p+= 2;\t// clr.w -(sp)\n\tWriteMacInt16(p, 0x2f08); p+= 2;\t// move.l a0,-(sp)\n\tWriteMacInt16(p, 0x7012); p+= 2;\t// UTGetDefaultVol\n\tWriteMacInt16(p, 0xa824); p+= 2;\t// FSMgr\n\tWriteMacInt16(p, 0x301f); p+= 2;\t// move.w (sp)+,d0\n\tWriteMacInt16(p, M68K_RTS); p+= 2;\n\tif (p - fs_data != fsGetPathComponentName)\n\t\tgoto fsdat_error;\n\tWriteMacInt16(p, 0x4267); p+= 2;\t// clr.w -(sp)\n\tWriteMacInt16(p, 0x2f08); p+= 2;\t// move.l a0,-(sp)\n\tWriteMacInt16(p, 0x701c); p+= 2;\t// UTGetPathComponentName\n\tWriteMacInt16(p, 0xa824); p+= 2;\t// FSMgr\n\tWriteMacInt16(p, 0x301f); p+= 2;\t// move.w (sp)+,d0\n\tWriteMacInt16(p, M68K_RTS); p+= 2;\n\tif (p - fs_data != fsParsePathname)\n\t\tgoto fsdat_error;\n\tWriteMacInt16(p, 0x4267); p+= 2;\t// clr.w -(sp)\n\tWriteMacInt16(p, 0x2f08); p+= 2;\t// move.l a0,-(sp)\n\tWriteMacInt16(p, 0x2f09); p+= 2;\t// move.l a1,-(sp)\n\tWriteMacInt16(p, 0x701b); p+= 2;\t// UTParsePathname\n\tWriteMacInt16(p, 0xa824); p+= 2;\t// FSMgr\n\tWriteMacInt16(p, 0x301f); p+= 2;\t// move.w (sp)+,d0\n\tWriteMacInt16(p, M68K_RTS); p+= 2;\n\tif (p - fs_data != fsDisposeVCB)\n\t\tgoto fsdat_error;\n\tWriteMacInt16(p, 0x4267); p+= 2;\t// clr.w -(sp)\n\tWriteMacInt16(p, 0x2f08); p+= 2;\t// move.l a0,-(sp)\n\tWriteMacInt16(p, 0x7008); p+= 2;\t// UTDisposeVCB\n\tWriteMacInt16(p, 0xa824); p+= 2;\t// FSMgr\n\tWriteMacInt16(p, 0x301f); p+= 2;\t// move.w (sp)+,d0\n\tWriteMacInt16(p, M68K_RTS); p+= 2;\n\tif (p - fs_data != fsCheckWDRefNum)\n\t\tgoto fsdat_error;\n\tWriteMacInt16(p, 0x4267); p+= 2;\t// clr.w -(sp)\n\tWriteMacInt16(p, 0x3f00); p+= 2;\t// move.w d0,-(sp)\n\tWriteMacInt16(p, 0x7013); p+= 2;\t// UTCheckWDRefNum\n\tWriteMacInt16(p, 0xa824); p+= 2;\t// FSMgr\n\tWriteMacInt16(p, 0x301f); p+= 2;\t// move.w (sp)+,d0\n\tWriteMacInt16(p, M68K_RTS); p+= 2;\n\tif (p - fs_data != fsSetDefaultVol)\n\t\tgoto fsdat_error;\n\tWriteMacInt16(p, 0x4267); p+= 2;\t// clr.w -(sp)\n\tWriteMacInt16(p, 0x2f00); p+= 2;\t// move.l d0,-(sp)\n\tWriteMacInt16(p, 0x2f01); p+= 2;\t// move.l d1,-(sp)\n\tWriteMacInt16(p, 0x3f02); p+= 2;\t// move.w d2,-(sp)\n\tWriteMacInt16(p, 0x7011); p+= 2;\t// UTSetDefaultVol\n\tWriteMacInt16(p, 0xa824); p+= 2;\t// FSMgr\n\tWriteMacInt16(p, 0x301f); p+= 2;\t// move.w (sp)+,d0\n\tWriteMacInt16(p, M68K_RTS); p+= 2;\n\tif (p - fs_data != fsAllocateFCB)\n\t\tgoto fsdat_error;\n\tWriteMacInt16(p, 0x4267); p+= 2;\t// clr.w -(sp)\n\tWriteMacInt16(p, 0x2f08); p+= 2;\t// move.l a0,-(sp)\n\tWriteMacInt16(p, 0x2f09); p+= 2;\t// move.l a1,-(sp)\n\tWriteMacInt16(p, 0x7000); p+= 2;\t// UTAllocateFCB\n\tWriteMacInt16(p, 0xa824); p+= 2;\t// FSMgr\n\tWriteMacInt16(p, 0x301f); p+= 2;\t// move.w (sp)+,d0\n\tWriteMacInt16(p, M68K_RTS); p+= 2;\n\tif (p - fs_data != fsReleaseFCB)\n\t\tgoto fsdat_error;\n\tWriteMacInt16(p, 0x4267); p+= 2;\t// clr.w -(sp)\n\tWriteMacInt16(p, 0x3f00); p+= 2;\t// move.w d0,-(sp)\n\tWriteMacInt16(p, 0x7001); p+= 2;\t// UTReleaseFCB\n\tWriteMacInt16(p, 0xa824); p+= 2;\t// FSMgr\n\tWriteMacInt16(p, 0x301f); p+= 2;\t// move.w (sp)+,d0\n\tWriteMacInt16(p, M68K_RTS); p+= 2;\n\tif (p - fs_data != fsIndexFCB)\n\t\tgoto fsdat_error;\n\tWriteMacInt16(p, 0x4267); p+= 2;\t// clr.w -(sp)\n\tWriteMacInt16(p, 0x2f08); p+= 2;\t// move.l a0,-(sp)\n\tWriteMacInt16(p, 0x2f09); p+= 2;\t// move.l a1,-(sp)\n\tWriteMacInt16(p, 0x2f0a); p+= 2;\t// move.l a2,-(sp)\n\tWriteMacInt16(p, 0x7004); p+= 2;\t// UTIndexFCB\n\tWriteMacInt16(p, 0xa824); p+= 2;\t// FSMgr\n\tWriteMacInt16(p, 0x301f); p+= 2;\t// move.w (sp)+,d0\n\tWriteMacInt16(p, M68K_RTS); p+= 2;\n\tif (p - fs_data != fsResolveFCB)\n\t\tgoto fsdat_error;\n\tWriteMacInt16(p, 0x4267); p+= 2;\t// clr.w -(sp)\n\tWriteMacInt16(p, 0x3f00); p+= 2;\t// move.w d0,-(sp)\n\tWriteMacInt16(p, 0x2f08); p+= 2;\t// move.l a0,-(sp)\n\tWriteMacInt16(p, 0x7005); p+= 2;\t// UTResolveFCB\n\tWriteMacInt16(p, 0xa824); p+= 2;\t// FSMgr\n\tWriteMacInt16(p, 0x301f); p+= 2;\t// move.w (sp)+,d0\n\tWriteMacInt16(p, M68K_RTS); p+= 2;\n\tif (p - fs_data != fsAdjustEOF)\n\t\tgoto fsdat_error;\n\tWriteMacInt16(p, 0x4267); p+= 2;\t// clr.w -(sp)\n\tWriteMacInt16(p, 0x3f00); p+= 2;\t// move.w d0,-(sp)\n\tWriteMacInt16(p, 0x7010); p+= 2;\t// UTAdjustEOF\n\tWriteMacInt16(p, 0xa824); p+= 2;\t// FSMgr\n\tWriteMacInt16(p, 0x301f); p+= 2;\t// move.w (sp)+,d0\n\tWriteMacInt16(p, M68K_RTS); p+= 2;\n\tif (p - fs_data != fsAllocateWDCB)\n\t\tgoto fsdat_error;\n\tWriteMacInt16(p, 0x4267); p+= 2;\t// clr.w -(sp)\n\tWriteMacInt16(p, 0x2f08); p+= 2;\t// move.l a0,-(sp)\n\tWriteMacInt16(p, 0x700c); p+= 2;\t// UTAllocateWDCB\n\tWriteMacInt16(p, 0xa824); p+= 2;\t// FSMgr\n\tWriteMacInt16(p, 0x301f); p+= 2;\t// move.w (sp)+,d0\n\tWriteMacInt16(p, M68K_RTS); p+= 2;\n\tif (p - fs_data != fsReleaseWDCB)\n\t\tgoto fsdat_error;\n\tWriteMacInt16(p, 0x4267); p+= 2;\t// clr.w -(sp)\n\tWriteMacInt16(p, 0x3f00); p+= 2;\t// move.w d0,-(sp)\n\tWriteMacInt16(p, 0x700d); p+= 2;\t// UTReleaseWDCB\n\tWriteMacInt16(p, 0xa824); p+= 2;\t// FSMgr\n\tWriteMacInt16(p, 0x301f); p+= 2;\t// move.w (sp)+,d0\n\tWriteMacInt16(p, M68K_RTS); p+= 2;\n\tif (p - fs_data != SIZEOF_fsdat)\n\t\tgoto fsdat_error;\n\n\t// Set up drive status\n\tWriteMacInt8(fs_data + fsDrvStatus + dsDiskInPlace, 8);\t// Fixed disk\n\tWriteMacInt8(fs_data + fsDrvStatus + dsInstalled, 1);\n\tWriteMacInt16(fs_data + fsDrvStatus + dsQType, hard20);\n\tWriteMacInt16(fs_data + fsDrvStatus + dsDriveSize, num_blocks & 0xffff);\n\tWriteMacInt16(fs_data + fsDrvStatus + dsDriveS1, num_blocks >> 16);\n\tWriteMacInt16(fs_data + fsDrvStatus + dsQFSID, MY_FSID);\n\n\t// Add drive to drive queue\n\tdrive_number = FindFreeDriveNumber(1);\n\tD(bug(\" adding drive %d\\n\", drive_number));\n\tr.d[0] = (drive_number << 16) | (DiskRefNum & 0xffff);\n\tr.a[0] = fs_data + fsDrvStatus + dsQLink;\n\tExecute68kTrap(0xa04e, &r);\t// AddDrive()\n\n\t// Init FSDRec and install file system\n\tD(bug(\" installing file system\\n\"));\n\tWriteMacInt16(fs_data + fsFSD + fsdLength, SIZEOF_FSDRec);\n\tWriteMacInt16(fs_data + fsFSD + fsdVersion, fsdVersion1);\n\tWriteMacInt16(fs_data + fsFSD + fileSystemFSID, MY_FSID);\n\tHost2Mac_memcpy(fs_data + fsFSD + fileSystemName, FS_NAME, 32);\n\tWriteMacInt32(fs_data + fsFSD + fileSystemCommProc, fs_data + fsCommProcStub);\n\tWriteMacInt32(fs_data + fsFSD + fsdHFSCI + compInterfProc, fs_data + fsHFSProcStub);\n\tWriteMacInt32(fs_data + fsFSD + fsdHFSCI + stackTop, fs_stack + STACK_SIZE);\n\tWriteMacInt32(fs_data + fsFSD + fsdHFSCI + stackSize, STACK_SIZE);\n\tWriteMacInt32(fs_data + fsFSD + fsdHFSCI + idSector, (uint32)-1);\n\tr.a[0] = fs_data + fsFSD;\n\tr.d[0] = 0;\t\t\t\t\t// InstallFS\n\tExecute68kTrap(0xa0ac, &r);\t// FSMDispatch()\n\tD(bug(\" InstallFS() returned %d\\n\", r.d[0]));\n\n\t// Enable HFS component\n\tD(bug(\" enabling HFS component\\n\"));\n\tWriteMacInt32(fs_data + fsFSD + fsdHFSCI + compInterfMask, ReadMacInt32(fs_data + fsFSD + fsdHFSCI + compInterfMask) | (fsmComponentEnableMask | hfsCIResourceLoadedMask | hfsCIDoesHFSMask));\n\tr.a[0] = fs_data + fsFSD;\n\tr.d[3] = SIZEOF_FSDRec;\n\tr.d[4] = MY_FSID;\n\tr.d[0] = 5;\t\t\t\t\t// SetFSInfo\n\tExecute68kTrap(0xa0ac, &r);\t// FSMDispatch()\n\tD(bug(\" SetFSInfo() returned %d\\n\", r.d[0]));\n\n\t// Mount volume\n\tD(bug(\" mounting volume\\n\"));\n\tWriteMacInt32(fs_data + fsPB + ioBuffer, fs_data + fsVMI);\n\tWriteMacInt16(fs_data + fsVMI + vmiLength, SIZEOF_VolumeMountInfoHeader);\n\tWriteMacInt32(fs_data + fsVMI + vmiMedia, MY_MEDIA_TYPE);\n\tr.a[0] = fs_data + fsPB;\n\tr.d[0] = 0x41;\t\t\t\t// PBVolumeMount\n\tExecute68kTrap(0xa260, &r);\t// HFSDispatch()\n\tD(bug(\" PBVolumeMount() returned %d\\n\", r.d[0]));\n\treturn;\n\nfsdat_error:\n\tprintf(\"FATAL: ExtFS data block initialization error\\n\");\n\tQuitEmulator();\n}\n\n\n/*\n *  FS communications function\n */\n\nint16 ExtFSComm(uint16 message, uint32 paramBlock, uint32 globalsPtr)\n{\n\tD(bug(\"ExtFSComm(%d, %08lx, %08lx)\\n\", message, paramBlock, globalsPtr));\n\n\tswitch (message) {\n\t\tcase ffsNopMessage:\n\t\tcase ffsLoadMessage:\n\t\tcase ffsUnloadMessage:\n\t\t\treturn noErr;\n\n\t\tcase ffsGetIconMessage: {\t\t// Get disk/drive icon\n\t\t\tif (ReadMacInt8(paramBlock + iconType) == kLargeIcon && ReadMacInt32(paramBlock + requestSize) >= sizeof(ExtFSIcon)) {\n\t\t\t\tHost2Mac_memcpy(ReadMacInt32(paramBlock + iconBufferPtr), ExtFSIcon, sizeof(ExtFSIcon));\n\t\t\t\tWriteMacInt32(paramBlock + actualSize, sizeof(ExtFSIcon));\n\t\t\t\treturn noErr;\n\t\t\t} else\n\t\t\t\treturn -5012;\t// afpItemNotFound\n\t\t}\n\n\t\tcase ffsIDDiskMessage: {\t\t// Check if volume is handled by our FS\n\t\t\tif ((int16)ReadMacInt16(paramBlock + ioVRefNum) == drive_number)\n\t\t\t\treturn noErr;\n\t\t\telse\n\t\t\t\treturn extFSErr;\n\t\t}\n\n\t\tcase ffsIDVolMountMessage: {\t// Check if volume can be mounted by our FS\n\t\t\tif (ReadMacInt32(ReadMacInt32(paramBlock + ioBuffer) + vmiMedia) == MY_MEDIA_TYPE)\n\t\t\t\treturn noErr;\n\t\t\telse\n\t\t\t\treturn extFSErr;\n\t\t}\n\n\t\tdefault:\n\t\t\treturn fsmUnknownFSMMessageErr;\n\t}\n}\n\n\n/*\n *  Get current directory specified by given ParamBlock/dirID\n */\n\nstatic int16 get_current_dir(uint32 pb, uint32 dirID, uint32 &current_dir, bool no_vol_name = false)\n{\n\tM68kRegisters r;\n\tint16 result;\n\n\t// Determine volume\n\tD(bug(\"  determining volume, dirID %d\\n\", dirID));\n\tr.a[0] = pb;\n\tr.a[1] = fs_data + fsReturn;\n\tr.a[2] = fs_data + fsReturn + 2;\n\tr.a[3] = fs_data + fsReturn + 4;\n\tr.a[4] = fs_data + fsReturn + 6;\n\tuint32 name_ptr = 0;\n\tif (no_vol_name) {\n\t\tname_ptr = ReadMacInt32(pb + ioNamePtr);\n\t\tWriteMacInt32(pb + ioNamePtr, 0);\n\t}\n\tExecute68k(fs_data + fsDetermineVol, &r);\n\tif (no_vol_name)\n\t\tWriteMacInt32(pb + ioNamePtr, name_ptr);\n\tint16 status = ReadMacInt16(fs_data + fsReturn);\n\tD(bug(\"  UTDetermineVol() returned %d, status %d\\n\", r.d[0], status));\n\tresult = (int16)(r.d[0] & 0xffff);\n\n\tif (result == noErr) {\n\t\tswitch (status) {\n\t\t\tcase dtmvFullPathname:\t// Determined by full pathname\n\t\t\t\tcurrent_dir = ROOT_ID;\n\t\t\t\tbreak;\n\n\t\t\tcase dtmvVRefNum:\t\t// Determined by refNum or by drive number\n\t\t\tcase dtmvDriveNum:\n\t\t\t\tcurrent_dir = dirID ? dirID : ROOT_ID;\n\t\t\t\tbreak;\n\n\t\t\tcase dtmvWDRefNum:\t\t// Determined by working directory refNum\n\t\t\t\tif (dirID) {\n\t\t\t\t\tcurrent_dir = dirID;\n\t\t\t\t} else {\n\t\t\t\t\tD(bug(\"  resolving WDCB\\n\"));\n\t\t\t\t\tr.d[0] = 0;\n\t\t\t\t\tr.d[1] = 0;\n\t\t\t\t\tr.d[2] = ReadMacInt16(pb + ioVRefNum);\n\t\t\t\t\tr.a[0] = fs_data + fsReturn;\n\t\t\t\t\tExecute68k(fs_data + fsResolveWDCB, &r);\n\t\t\t\t\tuint32 wdcb = ReadMacInt32(fs_data + fsReturn);\n\t\t\t\t\tD(bug(\"  UTResolveWDCB() returned %d, dirID %d\\n\", r.d[0], ReadMacInt32(wdcb + wdDirID)));\n\t\t\t\t\tresult = (int16)(r.d[0] & 0xffff);\n\t\t\t\t\tif (result == noErr)\n\t\t\t\t\t\tcurrent_dir = ReadMacInt32(wdcb + wdDirID);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase dtmvDefault:\t\t// Determined by default volume\n\t\t\t\tif (dirID) {\n\t\t\t\t\tcurrent_dir = dirID;\n\t\t\t\t} else {\n\t\t\t\t\tuint32 wdpb = fs_data + fsReturn;\n\t\t\t\t\tWriteMacInt32(wdpb + ioNamePtr, 0);\n\t\t\t\t\tD(bug(\"  getting default volume\\n\"));\n\t\t\t\t\tr.a[0] = wdpb;\n\t\t\t\t\tExecute68k(fs_data + fsGetDefaultVol, &r);\n\t\t\t\t\tD(bug(\"  UTGetDefaultVol() returned %d, dirID %d\\n\", r.d[0], ReadMacInt32(wdpb + ioWDDirID)));\n\t\t\t\t\tresult = (int16)(r.d[0] & 0xffff);\n\t\t\t\t\tif (result == noErr)\n\t\t\t\t\t\tcurrent_dir = ReadMacInt32(wdpb + ioWDDirID);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tresult = paramErr;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\n\n/*\n *  Get path component name\n */\n\nstatic int16 get_path_component_name(uint32 rec)\n{\n//\tD(bug(\"  getting path component\\n\"));\n\tM68kRegisters r;\n\tr.a[0] = rec;\n\tExecute68k(fs_data + fsGetPathComponentName, &r);\n//\tD(bug(\"  UTGetPathComponentName returned %d\\n\", r.d[0]));\n\treturn (int16)(r.d[0] & 0xffff);\n}\n\n\n/*\n *  Get FSItem and full path (->full_path) for file/dir specified in ParamBlock\n */\n\nstatic int16 get_item_and_path(uint32 pb, uint32 dirID, FSItem *&item, bool no_vol_name = false)\n{\n\tM68kRegisters r;\n\n\t// Find FSItem for parent directory\n\tint16 result;\n\tuint32 current_dir;\n\tif ((result = get_current_dir(pb, dirID, current_dir, no_vol_name)) != noErr)\n\t\treturn result;\n\tD(bug(\"  current dir %08x\\n\", current_dir));\n\tFSItem *p = find_fsitem_by_id(current_dir);\n\tif (p == NULL)\n\t\treturn dirNFErr;\n\n\t// Start parsing\n\tuint32 parseRec = fs_data + fsParseRec;\n\tWriteMacInt32(parseRec + ppNamePtr, ReadMacInt32(pb + ioNamePtr));\n\tWriteMacInt16(parseRec + ppStartOffset, 0);\n\tWriteMacInt16(parseRec + ppComponentLength, 0);\n\tWriteMacInt8(parseRec + ppMoreName, false);\n\tWriteMacInt8(parseRec + ppFoundDelimiter, false);\n\n\t// Get length of volume name\n\tD(bug(\"  parsing pathname\\n\"));\n\tr.a[0] = parseRec + ppStartOffset;\n\tr.a[1] = ReadMacInt32(parseRec + ppNamePtr);\n\tExecute68k(fs_data + fsParsePathname, &r);\n\tD(bug(\"  UTParsePathname() returned %d, startOffset %d\\n\", r.d[0], ReadMacInt16(parseRec + ppStartOffset)));\n\tresult = (int16)(r.d[0] & 0xffff);\n\tif (result == noErr) {\n\n\t\t// Check for leading delimiter of the partial pathname\n\t\tresult = get_path_component_name(parseRec);\n\t\tif (result == noErr) {\n\t\t\tif (ReadMacInt16(parseRec + ppComponentLength) == 0 && ReadMacInt8(parseRec + ppFoundDelimiter)) {\n\t\t\t\t// Get past initial delimiter\n\t\t\t\tWriteMacInt16(parseRec + ppStartOffset, ReadMacInt16(parseRec + ppStartOffset) + 1);\n\t\t\t}\n\n\t\t\t// Parse until there is no more pathname to parse\n\t\t\twhile ((result == noErr) && ReadMacInt8(parseRec + ppMoreName)) {\n\n\t\t\t\t// Search for the next delimiter from startOffset\n\t\t\t\tresult = get_path_component_name(parseRec);\n\t\t\t\tif (result == noErr) {\n\t\t\t\t\tif (ReadMacInt16(parseRec + ppComponentLength) == 0) {\n\n\t\t\t\t\t\t// Delimiter immediately following another delimiter, get parent\n\t\t\t\t\t\tif (current_dir != ROOT_ID) {\n\t\t\t\t\t\t\tp = p->parent;\n\t\t\t\t\t\t\tcurrent_dir = p->id;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tresult = bdNamErr;\n\n\t\t\t\t\t\t// startOffset = start of next component\n\t\t\t\t\t\tWriteMacInt16(parseRec + ppStartOffset, ReadMacInt16(parseRec + ppStartOffset) + 1);\n\n\t\t\t\t\t} else if (ReadMacInt8(parseRec + ppMoreName)) {\n\n\t\t\t\t\t\t// Component found and isn't the last, so it must be a directory, enter it\n\t\t\t\t\t\tchar name[32];\n\t\t\t\t\t\tstrn2cstr(name, (char *)Mac2HostAddr(ReadMacInt32(parseRec + ppNamePtr)) + ReadMacInt16(parseRec + ppStartOffset) + 1, ReadMacInt16(parseRec + ppComponentLength));\n\t\t\t\t\t\tD(bug(\"  entering %s\\n\", name));\n\t\t\t\t\t\tp = find_fsitem_guest(name, p);\n\t\t\t\t\t\tcurrent_dir = p->id;\n\n\t\t\t\t\t\t// startOffset = start of next component\n\t\t\t\t\t\tWriteMacInt16(parseRec + ppStartOffset, ReadMacInt16(parseRec + ppStartOffset) + ReadMacInt16(parseRec + ppComponentLength) + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (result == noErr) {\n\n\t\t\t\t// There is no more pathname to parse\n\t\t\t\tif (ReadMacInt16(parseRec + ppComponentLength) == 0) {\n\n\t\t\t\t\t// Pathname ended with '::' or was simply a volume name, so current directory is the object\n\t\t\t\t\titem = p;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Pathname ended with 'name:' or 'name', so name is the object\n\t\t\t\t\tchar name[32];\n\t\t\t\t\tstrn2cstr(name, (char *)Mac2HostAddr(ReadMacInt32(parseRec + ppNamePtr)) + ReadMacInt16(parseRec + ppStartOffset) + 1, ReadMacInt16(parseRec + ppComponentLength));\n\t\t\t\t\tD(bug(\"  object is %s\\n\", name));\n\t\t\t\t\titem = find_fsitem_guest(name, p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t} else {\n\n\t\t// Default to bad name\n\t\tresult = bdNamErr;\n\n\t\tif (ReadMacInt32(pb + ioNamePtr) == 0 || ReadMacInt8(ReadMacInt32(pb + ioNamePtr)) == 0) {\n\n\t\t\t// Pathname was NULL or a zero length string, so we found a directory at the end of the string\n\t\t\titem = p;\n\t\t\tresult = noErr;\n\t\t}\n\t}\n\n\t// Eat the path\n\tif (result == noErr) {\n\t\tget_path_for_fsitem(item);\n\t\tD(bug(\"  path %s\\n\", full_path));\n\t}\n\treturn result;\n}\n\n\n/*\n *  Find FCB for given file RefNum\n */\n\nstatic uint32 find_fcb(int16 refNum)\n{\n\tD(bug(\"  finding FCB\\n\"));\n\tM68kRegisters r;\n\tr.d[0] = refNum;\n\tr.a[0] = fs_data + fsReturn;\n\tExecute68k(fs_data + fsResolveFCB, &r);\n\tuint32 fcb = ReadMacInt32(fs_data + fsReturn);\n\tD(bug(\"  UTResolveFCB() returned %d, fcb %08lx\\n\", r.d[0], fcb));\n\tif (r.d[0] & 0xffff)\n\t\treturn 0;\n\telse\n\t\treturn fcb;\n}\n\n\n/*\n *  HFS interface functions\n */\n\n// Check if volume belongs to our FS\nstatic int16 fs_mount_vol(uint32 pb)\n{\n\tD(bug(\" fs_mount_vol(%08lx), vRefNum %d\\n\", pb, ReadMacInt16(pb + ioVRefNum)));\n\tif ((int16)ReadMacInt16(pb + ioVRefNum) == drive_number)\n\t\treturn noErr;\n\telse\n\t\treturn extFSErr;\n}\n\n// Mount volume\nstatic int16 fs_volume_mount(uint32 pb)\n{\n\tD(bug(\" fs_volume_mount(%08lx)\\n\", pb));\n\tM68kRegisters r;\n\n\t// Create new VCB\n\tD(bug(\"  creating VCB\\n\"));\n\tr.a[0] = fs_data + fsReturn;\n\tr.a[1] = fs_data + fsReturn + 2;\n\tExecute68k(fs_data + fsAllocateVCB, &r);\n#if DEBUG\n\tuint16 sysVCBLength = ReadMacInt16(fs_data + fsReturn);\n#endif\n\tuint32 vcb = ReadMacInt32(fs_data + fsReturn + 2);\n\tD(bug(\"  UTAllocateVCB() returned %d, vcb %08lx, size %d\\n\", r.d[0], vcb, sysVCBLength));\n\tif (r.d[0] & 0xffff)\n\t\treturn (int16)r.d[0];\n\n\t// Init VCB\n\tWriteMacInt16(vcb + vcbSigWord, 0x4244);\n#if defined(__BEOS__) || defined(WIN32)\n\tWriteMacInt32(vcb + vcbCrDate, TimeToMacTime(root_stat.st_crtime));\n#elif defined __APPLE__ && defined __MACH__\n\tWriteMacInt32(vcb + vcbCrDate, get_creation_time(RootPath));\n#else\n\tWriteMacInt32(vcb + vcbCrDate, 0);\n#endif\n\tWriteMacInt32(vcb + vcbLsMod, TimeToMacTime(root_stat.st_mtime));\n\tWriteMacInt32(vcb + vcbVolBkUp, 0);\n\tWriteMacInt16(vcb + vcbNmFls, 1);\t\t\t//!!\n\tWriteMacInt16(vcb + vcbNmRtDirs, 1);\t\t//!!\n\tWriteMacInt16(vcb + vcbNmAlBlks, 0xffff);\t//!!\n\tWriteMacInt32(vcb + vcbAlBlkSiz, AL_BLK_SIZE);\n\tWriteMacInt32(vcb + vcbClpSiz, CLUMP_SIZE);\n\tWriteMacInt32(vcb + vcbNxtCNID, next_cnid);\n\tWriteMacInt16(vcb + vcbFreeBks, 0xffff);\t//!!\n\tHost2Mac_memcpy(vcb + vcbVN, VOLUME_NAME, 28);\n\tWriteMacInt16(vcb + vcbFSID, MY_FSID);\n\tWriteMacInt32(vcb + vcbFilCnt, 1);\t\t\t//!!\n\tWriteMacInt32(vcb + vcbDirCnt, 1);\t\t\t//!!\n\n\t// Add VCB to VCB queue\n\tD(bug(\"  adding VCB to queue\\n\"));\n\tr.d[0] = drive_number;\n\tr.a[0] = fs_data + fsReturn;\n\tr.a[1] = vcb;\n\tExecute68k(fs_data + fsAddNewVCB, &r);\n\tint16 vRefNum = (int16)ReadMacInt32(fs_data + fsReturn);\n\tD(bug(\"  UTAddNewVCB() returned %d, vRefNum %d\\n\", r.d[0], vRefNum));\n\tif (r.d[0] & 0xffff)\n\t\treturn (int16)r.d[0];\n\n\t// Post diskInsertEvent\n\tD(bug(\"  posting diskInsertEvent\\n\"));\n\tr.d[0] = drive_number;\n\tr.a[0] = 7;\t// diskEvent\n\tExecute68kTrap(0xa02f, &r);\t\t// PostEvent()\n\n\t// Return volume RefNum\n\tWriteMacInt16(pb + ioVRefNum, vRefNum);\n\treturn noErr;\n}\n\n// Unmount volume\nstatic int16 fs_unmount_vol(uint32 vcb)\n{\n\tD(bug(\" fs_unmount_vol(%08lx), vRefNum %d\\n\", vcb, ReadMacInt16(vcb + vcbVRefNum)));\n\tM68kRegisters r;\n\n\t// Remove and free VCB\n\tD(bug(\"  freeing VCB\\n\"));\n\tr.a[0] = vcb;\n\tExecute68k(fs_data + fsDisposeVCB, &r);\n\tD(bug(\"  UTDisposeVCB() returned %d\\n\", r.d[0]));\n\treturn (int16)r.d[0];\n}\n\n// Get information about a volume (HVolumeParam)\nstatic int16 fs_get_vol_info(uint32 pb, bool hfs)\n{\n//\tD(bug(\" fs_get_vol_info(%08lx)\\n\", pb));\n\n\t// Fill in struct\n\tif (ReadMacInt32(pb + ioNamePtr))\n\t\tpstrcpy((char *)Mac2HostAddr(ReadMacInt32(pb + ioNamePtr)), VOLUME_NAME);\n#if defined(__BEOS__) || defined(WIN32)\n\tWriteMacInt32(pb + ioVCrDate, TimeToMacTime(root_stat.st_crtime));\n#elif defined __APPLE__ && defined __MACH__\n\tWriteMacInt32(pb + ioVCrDate, get_creation_time(RootPath));\n#else\n\tWriteMacInt32(pb + ioVCrDate, 0);\n#endif\n\tWriteMacInt32(pb + ioVLsMod, TimeToMacTime(root_stat.st_mtime));\n\tWriteMacInt16(pb + ioVAtrb, 0);\n\tWriteMacInt16(pb + ioVNmFls, 1);\t\t\t//!!\n\tWriteMacInt16(pb + ioVBitMap, 0);\n\tWriteMacInt16(pb + ioAllocPtr, 0);\n\tWriteMacInt16(pb + ioVNmAlBlks, 0xffff);\t//!!\n\tWriteMacInt32(pb + ioVAlBlkSiz, AL_BLK_SIZE);\n\tWriteMacInt32(pb + ioVClpSiz, CLUMP_SIZE);\n\tWriteMacInt16(pb + ioAlBlSt, 0);\n\tWriteMacInt32(pb + ioVNxtCNID, next_cnid);\n\tWriteMacInt16(pb + ioVFrBlk, 0xffff);\t\t//!!\n\tif (hfs) {\n\t\tWriteMacInt16(pb + ioVDrvInfo, drive_number);\n\t\tWriteMacInt16(pb + ioVDRefNum, ReadMacInt16(fs_data + fsDrvStatus + dsQRefNum));\n\t\tWriteMacInt16(pb + ioVFSID, MY_FSID);\n\t\tWriteMacInt32(pb + ioVBkUp, 0);\n\t\tWriteMacInt16(pb + ioVSeqNum, 0);\n\t\tWriteMacInt32(pb + ioVWrCnt, 0);\n\t\tWriteMacInt32(pb + ioVFilCnt, 1);\t\t\t//!!\n\t\tWriteMacInt32(pb + ioVDirCnt, 1);\t\t\t//!!\n\t\tMac_memset(pb + ioVFndrInfo, 0, 32);\n\t}\n\treturn noErr;\n}\n\n// Change volume information (HVolumeParam)\nstatic int16 fs_set_vol_info(uint32 pb)\n{\n\tD(bug(\" fs_set_vol_info(%08lx)\\n\", pb));\n\n\t//!! times\n\treturn noErr;\n}\n\n// Get volume parameter block\nstatic int16 fs_get_vol_parms(uint32 pb)\n{\n//\tD(bug(\" fs_get_vol_parms(%08lx)\\n\", pb));\n\n\t// Return parameter block\n\tuint32 actual = ReadMacInt32(pb + ioReqCount);\n\tif (actual > SIZEOF_GetVolParmsInfoBuffer)\n\t\tactual = SIZEOF_GetVolParmsInfoBuffer;\n\tWriteMacInt32(pb + ioActCount, actual);\n\tuint32 p = ReadMacInt32(pb + ioBuffer);\n\tif (actual > vMVersion) WriteMacInt16(p + vMVersion, 2);\n\tif (actual > vMAttrib) WriteMacInt32(p + vMAttrib, kNoMiniFndr | kNoVNEdit | kNoLclSync | kTrshOffLine | kNoSwitchTo | kNoBootBlks | kNoSysDir | kHasExtFSVol);\n\tif (actual > vMLocalHand) WriteMacInt32(p + vMLocalHand, 0);\n\tif (actual > vMServerAdr) WriteMacInt32(p + vMServerAdr, 0);\n\tif (actual > vMVolumeGrade) WriteMacInt32(p + vMVolumeGrade, 0);\n\tif (actual > vMForeignPrivID) WriteMacInt16(p + vMForeignPrivID, 0);\n\treturn noErr;\n}\n\n// Get default volume (WDParam)\nstatic int16 fs_get_vol(uint32 pb)\n{\n\tD(bug(\" fs_get_vol(%08lx)\\n\", pb));\n\tM68kRegisters r;\n\n\t// Getting default volume\n\tD(bug(\"  getting default volume\\n\"));\n\tr.a[0] = pb;\n\tExecute68k(fs_data + fsGetDefaultVol, &r);\n\tD(bug(\"  UTGetDefaultVol() returned %d\\n\", r.d[0]));\n\treturn (int16)r.d[0];\n}\n\n// Set default volume (WDParam)\nstatic int16 fs_set_vol(uint32 pb, bool hfs, uint32 vcb)\n{\n\tD(bug(\" fs_set_vol(%08lx), vRefNum %d, name %.31s, dirID %d\\n\", pb, ReadMacInt16(pb + ioVRefNum), Mac2HostAddr(ReadMacInt32(pb + ioNamePtr) + 1), ReadMacInt32(pb + ioWDDirID)));\n\tM68kRegisters r;\n\n\t// Determine parameters\n\tuint32 dirID;\n\tint16 refNum;\n\tif (hfs) {\n\n\t\t// Find FSItem for given dir\n\t\tFSItem *fs_item;\n\t\tint16 result = get_item_and_path(pb, ReadMacInt32(pb + ioWDDirID), fs_item);\n\t\tif (result != noErr)\n\t\t\treturn result;\n\n\t\t// Is it a directory?\n\t\tstruct stat st;\n\t\tif (stat(full_path, &st))\n\t\t\treturn dirNFErr;\n\t\tif (!S_ISDIR(st.st_mode))\n\t\t\treturn dirNFErr;\n\n\t\t// Get dirID and refNum\n\t\tdirID = fs_item->id;\n\t\trefNum = ReadMacInt16(vcb + vcbVRefNum);\n\n\t} else {\n\n\t\t// Is the given vRefNum a working directory number?\n\t\tD(bug(\"  checking for WDRefNum\\n\"));\n\t\tr.d[0] = ReadMacInt16(pb + ioVRefNum);\n\t\tExecute68k(fs_data + fsCheckWDRefNum, &r);\n\t\tD(bug(\"  UTCheckWDRefNum() returned %d\\n\", r.d[0]));\n\t\tif (r.d[0] & 0xffff) {\n\t\t\t// Volume refNum\n\t\t\tdirID = ROOT_ID;\n\t\t\trefNum = ReadMacInt16(vcb + vcbVRefNum);\n\t\t} else {\n\t\t\t// WD refNum\n\t\t\tdirID = 0;\n\t\t\trefNum = ReadMacInt16(pb + ioVRefNum);\n\t\t}\n\t}\n\n\t// Setting default volume\n\tD(bug(\"  setting default volume\\n\"));\n\tr.d[0] = 0;\n\tr.d[1] = dirID;\n\tr.d[2] = refNum;\n\tExecute68k(fs_data + fsSetDefaultVol, &r);\n\tD(bug(\"  UTSetDefaultVol() returned %d\\n\", r.d[0]));\n\treturn (int16)r.d[0];\n}\n\n// Query file attributes (HFileParam)\nstatic int16 fs_get_file_info(uint32 pb, bool hfs, uint32 dirID)\n{\n\tD(bug(\" fs_get_file_info(%08lx), vRefNum %d, name %.31s, idx %d, dirID %d\\n\", pb, ReadMacInt16(pb + ioVRefNum), Mac2HostAddr(ReadMacInt32(pb + ioNamePtr) + 1), ReadMacInt16(pb + ioFDirIndex), dirID));\n\n\tFSItem *fs_item;\n\tint16 dir_index = ReadMacInt16(pb + ioFDirIndex);\n\tif (dir_index <= 0) {\t\t// Query item specified by ioDirID and ioNamePtr\n\n\t\t// Find FSItem for given file\n\t\tint16 result = get_item_and_path(pb, dirID, fs_item);\n\t\tif (result != noErr)\n\t\t\treturn result;\n\n\t} else {\t\t\t\t\t// Query item in directory specified by ioDirID by index\n\n\t\t// Find FSItem for parent directory\n\t\tint16 result;\n\t\tuint32 current_dir;\n\t\tif ((result = get_current_dir(pb, dirID, current_dir, true)) != noErr)\n\t\t\treturn result;\n\t\tFSItem *p = find_fsitem_by_id(current_dir);\n\t\tif (p == NULL)\n\t\t\treturn dirNFErr;\n\t\tget_path_for_fsitem(p);\n\n\t\t// Look for nth item in directory and add name to path\n\t\tDIR *d = opendir(full_path);\n\t\tif (d == NULL)\n\t\t\treturn dirNFErr;\n\t\tstruct dirent *de = NULL;\n\t\tfor (int i=0; i<dir_index; i++) {\nread_next_de:\n\t\t\tde = readdir(d);\n\t\t\tif (de == NULL) {\n\t\t\t\tclosedir(d);\n\t\t\t\treturn fnfErr;\n\t\t\t}\n\t\t\tif (de->d_name[0] == '.')\n\t\t\t\tgoto read_next_de;\t// Suppress names beginning with '.' (MacOS could interpret these as driver names)\n\t\t\t//!! suppress directories\n\t\t}\n\t\tadd_path_comp(de->d_name);\n\n\t\t// Get FSItem for queried item\n\t\tfs_item = find_fsitem(de->d_name, p);\n\t\tclosedir(d);\n\t}\n\n\t// Get stats\n\tstruct stat st;\n\tif (stat(full_path, &st))\n\t\treturn fnfErr;\n\tif (S_ISDIR(st.st_mode))\n\t\treturn fnfErr;\n\n\t// Fill in struct from fs_item and stats\n\tif (ReadMacInt32(pb + ioNamePtr))\n\t\tcstr2pstr((char *)Mac2HostAddr(ReadMacInt32(pb + ioNamePtr)), fs_item->guest_name);\n\tWriteMacInt16(pb + ioFRefNum, 0);\n\tWriteMacInt8(pb + ioFlAttrib, access(full_path, W_OK) == 0 ? 0 : faLocked);\n\tWriteMacInt32(pb + ioDirID, fs_item->id);\n\n#if defined(__BEOS__) || defined(WIN32)\n\tWriteMacInt32(pb + ioFlCrDat, TimeToMacTime(st.st_crtime));\n#elif defined __APPLE__ && defined __MACH__\n\tWriteMacInt32(pb + ioFlCrDat, get_creation_time(full_path));\n#else\n\tWriteMacInt32(pb + ioFlCrDat, 0);\n#endif\n\tWriteMacInt32(pb + ioFlMdDat, TimeToMacTime(st.st_mtime));\n\n\tget_finfo(full_path, pb + ioFlFndrInfo, hfs ? pb + ioFlXFndrInfo : 0, false);\n\n\tWriteMacInt16(pb + ioFlStBlk, 0);\n\tWriteMacInt32(pb + ioFlLgLen, st.st_size);\n\tWriteMacInt32(pb + ioFlPyLen, (st.st_size | (AL_BLK_SIZE - 1)) + 1);\n\tWriteMacInt16(pb + ioFlRStBlk, 0);\n\tuint32 rf_size = get_rfork_size(full_path);\n\tWriteMacInt32(pb + ioFlRLgLen, rf_size);\n\tWriteMacInt32(pb + ioFlRPyLen, (rf_size | (AL_BLK_SIZE - 1)) + 1);\n\n\tif (hfs) {\n\t\tWriteMacInt32(pb + ioFlBkDat, 0);\n\t\tWriteMacInt32(pb + ioFlParID, fs_item->parent_id);\n\t\tWriteMacInt32(pb + ioFlClpSiz, 0);\n\t}\n\treturn noErr;\n}\n\n// Set file attributes (HFileParam)\nstatic int16 fs_set_file_info(uint32 pb, bool hfs, uint32 dirID)\n{\n\tD(bug(\" fs_set_file_info(%08lx), vRefNum %d, name %.31s, idx %d, dirID %d\\n\", pb, ReadMacInt16(pb + ioVRefNum), Mac2HostAddr(ReadMacInt32(pb + ioNamePtr) + 1), ReadMacInt16(pb + ioFDirIndex), dirID));\n\n\t// Find FSItem for given file/dir\n\tFSItem *fs_item;\n\tint16 result = get_item_and_path(pb, dirID, fs_item);\n\tif (result != noErr)\n\t\treturn result;\n\n\t// Get stats\n\tstruct stat st;\n\tif (stat(full_path, &st) < 0)\n\t\treturn errno2oserr();\n\tif (S_ISDIR(st.st_mode))\n\t\treturn fnfErr;\n\n\t// Set Finder info\n\tset_finfo(full_path, pb + ioFlFndrInfo, hfs ? pb + ioFlXFndrInfo : 0, false);\n\n\t//!! times\n\treturn noErr;\n}\n\n// Query file/directory attributes\nstatic int16 fs_get_cat_info(uint32 pb)\n{\n\tD(bug(\" fs_get_cat_info(%08lx), vRefNum %d, name %.31s, idx %d, dirID %d\\n\", pb, ReadMacInt16(pb + ioVRefNum), Mac2HostAddr(ReadMacInt32(pb + ioNamePtr) + 1), ReadMacInt16(pb + ioFDirIndex), ReadMacInt32(pb + ioDirID)));\n\n\tFSItem *fs_item;\n\tint16 dir_index = ReadMacInt16(pb + ioFDirIndex);\n\tif (dir_index < 0) {\t\t\t// Query directory specified by ioDirID\n\n\t\t// Find FSItem for directory\n\t\tfs_item = find_fsitem_by_id(ReadMacInt32(pb + ioDrDirID));\n\t\tif (fs_item == NULL)\n\t\t\treturn dirNFErr;\n\t\tget_path_for_fsitem(fs_item);\n\n\t} else if (dir_index == 0) {\t// Query item specified by ioDirID and ioNamePtr\n\n\t\t// Find FSItem for given file/dir\n\t\tint16 result = get_item_and_path(pb, ReadMacInt32(pb + ioDirID), fs_item);\n\t\tif (result != noErr)\n\t\t\treturn result;\n\n\t} else {\t\t\t\t\t\t\t// Query item in directory specified by ioDirID by index\n\n\t\t// Find FSItem for parent directory\n\t\tint16 result;\n\t\tuint32 current_dir;\n\t\tif ((result = get_current_dir(pb, ReadMacInt32(pb + ioDirID), current_dir, true)) != noErr)\n\t\t\treturn result;\n\t\tFSItem *p = find_fsitem_by_id(current_dir);\n\t\tif (p == NULL)\n\t\t\treturn dirNFErr;\n\t\tget_path_for_fsitem(p);\n\n\t\t// Look for nth item in directory and add name to path\n\t\tDIR *d = opendir(full_path);\n\t\tif (d == NULL)\n\t\t\treturn dirNFErr;\n\t\tstruct dirent *de = NULL;\n\t\tfor (int i=0; i<dir_index; i++) {\nread_next_de:\n\t\t\tde = readdir(d);\n\t\t\tif (de == NULL) {\n\t\t\t\tclosedir(d);\n\t\t\t\treturn fnfErr;\n\t\t\t}\n\t\t\tif (de->d_name[0] == '.')\n\t\t\t\tgoto read_next_de;\t// Suppress names beginning with '.' (MacOS could interpret these as driver names)\n\t\t}\n\t\tadd_path_comp(de->d_name);\n\n\t\t// Get FSItem for queried item\n\t\tfs_item = find_fsitem(de->d_name, p);\n\t\tclosedir(d);\n\t}\n\tD(bug(\"  path %s\\n\", full_path));\n\n\t// Get stats\n\tstruct stat st;\n\tif (stat(full_path, &st) < 0)\n\t\treturn errno2oserr();\n\tif (dir_index == -1 && !S_ISDIR(st.st_mode))\n\t\treturn dirNFErr;\n\n\t// Fill in struct from fs_item and stats\n\tif (ReadMacInt32(pb + ioNamePtr))\n\t\tcstr2pstr((char *)Mac2HostAddr(ReadMacInt32(pb + ioNamePtr)), fs_item->guest_name);\n\tWriteMacInt16(pb + ioFRefNum, 0);\n\tWriteMacInt8(pb + ioFlAttrib, (S_ISDIR(st.st_mode) ? faIsDir : 0) | (access(full_path, W_OK) == 0 ? 0 : faLocked));\n\tWriteMacInt8(pb + ioACUser, 0);\n\tWriteMacInt32(pb + ioDirID, fs_item->id);\n\tWriteMacInt32(pb + ioFlParID, fs_item->parent_id);\n#if defined(__BEOS__) || defined(WIN32)\n\tWriteMacInt32(pb + ioFlCrDat, TimeToMacTime(st.st_crtime));\n#elif defined __APPLE__ && defined __MACH__\n\tWriteMacInt32(pb + ioFlCrDat, get_creation_time(full_path));\n#else\n\tWriteMacInt32(pb + ioFlCrDat, 0);\n#endif\n\ttime_t mtime = st.st_mtime;\n\tbool cached = true;\n\tif (mtime > fs_item->mtime) {\n\t\tfs_item->mtime = mtime;\n\t\tcached = false;\n\t}\n\tWriteMacInt32(pb + ioFlMdDat, TimeToMacTime(mtime));\n\tWriteMacInt32(pb + ioFlBkDat, 0);\n\n\tget_finfo(full_path, pb + ioFlFndrInfo, pb + ioFlXFndrInfo, S_ISDIR(st.st_mode));\n\n\tif (S_ISDIR(st.st_mode)) {\n\n\t\t// Determine number of files in directory (cached)\n\t\tint count;\n\t\tif (cached)\n\t\t\tcount = fs_item->cache_dircount;\n\t\telse {\n\t\t\tcount = 0;\n\t\t\tDIR *d = opendir(full_path);\n\t\t\tif (d) {\n\t\t\t\tstruct dirent *de;\n\t\t\t\tfor (;;) {\n\t\t\t\t\tde = readdir(d);\n\t\t\t\t\tif (de == NULL)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (de->d_name[0] == '.')\n\t\t\t\t\t\tcontinue;\t// Suppress names beginning with '.'\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tclosedir(d);\n\t\t\t}\n\t\t\tfs_item->cache_dircount = count;\n\t\t}\n\t\tWriteMacInt16(pb + ioDrNmFls, count);\n\t} else {\n\t\tWriteMacInt16(pb + ioFlStBlk, 0);\n\t\tWriteMacInt32(pb + ioFlLgLen, st.st_size);\n\t\tWriteMacInt32(pb + ioFlPyLen, (st.st_size | (AL_BLK_SIZE - 1)) + 1);\n\t\tWriteMacInt16(pb + ioFlRStBlk, 0);\n\t\tuint32 rf_size = get_rfork_size(full_path);\n\t\tWriteMacInt32(pb + ioFlRLgLen, rf_size);\n\t\tWriteMacInt32(pb + ioFlRPyLen, (rf_size | (AL_BLK_SIZE - 1)) + 1);\n\t\tWriteMacInt32(pb + ioFlClpSiz, 0);\n\t}\n\treturn noErr;\n}\n\n// Set file/directory attributes\nstatic int16 fs_set_cat_info(uint32 pb)\n{\n\tD(bug(\" fs_set_cat_info(%08lx), vRefNum %d, name %.31s, idx %d, dirID %d\\n\", pb, ReadMacInt16(pb + ioVRefNum), Mac2HostAddr(ReadMacInt32(pb + ioNamePtr) + 1), ReadMacInt16(pb + ioFDirIndex), ReadMacInt32(pb + ioDirID)));\n\n\t// Find FSItem for given file/dir\n\tFSItem *fs_item;\n\tint16 result = get_item_and_path(pb, ReadMacInt32(pb + ioDirID), fs_item);\n\tif (result != noErr)\n\t\treturn result;\n\n\t// Get stats\n\tstruct stat st;\n\tif (stat(full_path, &st) < 0)\n\t\treturn errno2oserr();\n\n\t// Set Finder info\n\tset_finfo(full_path, pb + ioFlFndrInfo, pb + ioFlXFndrInfo, S_ISDIR(st.st_mode));\n\n\t//!! times\n\treturn noErr;\n}\n\n// Open file\nstatic int16 fs_open(uint32 pb, uint32 dirID, uint32 vcb, bool resource_fork)\n{\n\tD(bug(\" fs_open(%08lx), %s, vRefNum %d, name %.31s, dirID %d, perm %d\\n\", pb, resource_fork ? \"rsrc\" : \"data\", ReadMacInt16(pb + ioVRefNum), Mac2HostAddr(ReadMacInt32(pb + ioNamePtr) + 1), dirID, ReadMacInt8(pb + ioPermssn)));\n\tM68kRegisters r;\n\n\t// Find FSItem for given file\n\tFSItem *fs_item;\n\tint16 result = get_item_and_path(pb, dirID, fs_item);\n\tif (result != noErr)\n\t\treturn result;\n\n\t// Convert ioPermssn to open() flag\n\tint flag = 0;\n\tbool write_ok = (access(full_path, W_OK) == 0);\n\tswitch (ReadMacInt8(pb + ioPermssn)) {\n\t\tcase fsCurPerm:\t\t// Whatever is currently allowed\n\t\t\tif (write_ok)\n\t\t\t\tflag = O_RDWR;\n\t\t\telse\n\t\t\t\tflag = O_RDONLY;\n\t\t\tbreak;\n\t\tcase fsRdPerm:\t\t// Exclusive read\n\t\t\tflag = O_RDONLY;\n\t\t\tbreak;\n\t\tcase fsWrPerm:\t\t// Exclusive write\n\t\t\tflag = O_WRONLY;\n\t\t\tbreak;\n\t\tcase fsRdWrPerm:\t// Exclusive read/write\n\t\tcase fsRdWrShPerm:\t// Shared read/write\n\t\tdefault:\n\t\t\tflag = O_RDWR;\n\t\t\tbreak;\n\t}\n\n\t// Try to open and stat the file\n\tint fd = -1;\n\tstruct stat st;\n\tif (resource_fork) {\n\t\tif (access(full_path, F_OK))\n\t\t\treturn fnfErr;\n\t\tfd = open_rfork(full_path, flag);\n\t\tif (fd >= 0) {\n\t\t\tif (fstat(fd, &st) < 0) {\n\t\t\t\tclose(fd);\n\t\t\t\treturn errno2oserr();\n\t\t\t}\n\t\t} else {\t// Resource fork not supported, silently ignore it (\"pseudo\" resource fork)\n\t\t\tst.st_size = 0;\n\t\t\tst.st_mode = 0;\n\t\t}\n\t} else {\n\t\tfd = open(full_path, flag);\n\t\tif (fd < 0)\n\t\t\treturn errno2oserr();\n\t\tif (fstat(fd, &st) < 0) {\n\t\t\tclose(fd);\n\t\t\treturn errno2oserr();\n\t\t}\n\t}\n\n\t// File open, allocate FCB\n\tD(bug(\"  allocating FCB\\n\"));\n\tr.a[0] = pb + ioRefNum;\n\tr.a[1] = fs_data + fsReturn;\n\tExecute68k(fs_data + fsAllocateFCB, &r);\n\tuint32 fcb = ReadMacInt32(fs_data + fsReturn);\n\tD(bug(\"  UTAllocateFCB() returned %d, fRefNum %d, fcb %08lx\\n\", r.d[0], ReadMacInt16(pb + ioRefNum), fcb));\n\tif (r.d[0] & 0xffff) {\n\t\tclose(fd);\n\t\treturn (int16)r.d[0];\n\t}\n\n\t// Initialize FCB, fd is stored in fcbCatPos\n\tWriteMacInt32(fcb + fcbFlNm, fs_item->id);\n\tWriteMacInt8(fcb + fcbFlags, ((flag == O_WRONLY || flag == O_RDWR) ? fcbWriteMask : 0) | (resource_fork ? fcbResourceMask : 0) | (write_ok ? 0 : fcbFileLockedMask));\n\tWriteMacInt32(fcb + fcbEOF, st.st_size);\n\tWriteMacInt32(fcb + fcbPLen, (st.st_size | (AL_BLK_SIZE - 1)) + 1);\n\tWriteMacInt32(fcb + fcbCrPs, 0);\n\tWriteMacInt32(fcb + fcbVPtr, vcb);\n\tWriteMacInt32(fcb + fcbClmpSize, CLUMP_SIZE);\n\n\tget_finfo(full_path, fs_data + fsPB, 0, false);\n\tWriteMacInt32(fcb + fcbFType, ReadMacInt32(fs_data + fsPB + fdType));\n\n\tWriteMacInt32(fcb + fcbCatPos, fd);\n\tWriteMacInt32(fcb + fcbDirID, fs_item->parent_id);\n\tcstr2pstr((char *)Mac2HostAddr(fcb + fcbCName), fs_item->guest_name);\n\treturn noErr;\n}\n\n// Close file\nstatic int16 fs_close(uint32 pb)\n{\n\tD(bug(\" fs_close(%08lx), refNum %d\\n\", pb, ReadMacInt16(pb + ioRefNum)));\n\tM68kRegisters r;\n\n\t// Find FCB and fd for file\n\tuint32 fcb = find_fcb(ReadMacInt16(pb + ioRefNum));\n\tif (fcb == 0)\n\t\treturn rfNumErr;\n\tif (ReadMacInt32(fcb + fcbFlNm) == 0)\n\t\treturn fnOpnErr;\n\tint fd = ReadMacInt32(fcb + fcbCatPos);\n\n\t// Close file\n\tif (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask) {\n\t\tFSItem *item = find_fsitem_by_id(ReadMacInt32(fcb + fcbFlNm));\n\t\tif (item) {\n\t\t\tget_path_for_fsitem(item);\n\t\t\tclose_rfork(full_path, fd);\n\t\t}\n\t} else\n\t\tclose(fd);\n\tWriteMacInt32(fcb + fcbCatPos, (uint32)-1);\n\n\t// Release FCB\n\tD(bug(\"  releasing FCB\\n\"));\n\tr.d[0] = ReadMacInt16(pb + ioRefNum);\n\tExecute68k(fs_data + fsReleaseFCB, &r);\n\tD(bug(\"  UTReleaseFCB() returned %d\\n\", r.d[0]));\n\treturn (int16)r.d[0];\n}\n\n// Query information about FCB (FCBPBRec)\nstatic int16 fs_get_fcb_info(uint32 pb, uint32 vcb)\n{\n\tD(bug(\" fs_get_fcb_info(%08lx), vRefNum %d, refNum %d, idx %d\\n\", pb, ReadMacInt16(pb + ioVRefNum), ReadMacInt16(pb + ioRefNum), ReadMacInt16(pb + ioFCBIndx)));\n\tM68kRegisters r;\n\n\tuint32 fcb = 0;\n\tif (ReadMacInt16(pb + ioFCBIndx) == 0) {\t// Get information about single file\n\n\t\t// Find FCB for file\n\t\tfcb = find_fcb(ReadMacInt16(pb + ioRefNum));\n\n\t} else {\t\t\t\t\t// Get information about file specified by index\n\n\t\t// Find FCB by index\n\t\tWriteMacInt16(pb + ioRefNum, 0);\n\t\tfor (int i=0; i<(int)ReadMacInt16(pb + ioFCBIndx); i++) {\n\t\t\tD(bug(\"  indexing FCBs\\n\"));\n\t\t\tr.a[0] = vcb;\n\t\t\tr.a[1] = pb + ioRefNum;\n\t\t\tr.a[2] = fs_data + fsReturn;\n\t\t\tExecute68k(fs_data + fsIndexFCB, &r);\n\t\t\tfcb = ReadMacInt32(fs_data + fsReturn);\n\t\t\tD(bug(\"  UTIndexFCB() returned %d, fcb %p\\n\", r.d[0], fcb));\n\t\t\tif (r.d[0] & 0xffff)\n\t\t\t\treturn (int16)r.d[0];\n\t\t}\n\t}\n\tif (fcb == 0)\n\t\treturn rfNumErr;\n\n\t// Copy information from FCB\n\tif (ReadMacInt32(pb + ioNamePtr))\n\t\tpstrcpy((char *)Mac2HostAddr(ReadMacInt32(pb + ioNamePtr)), (char *)Mac2HostAddr(fcb + fcbCName));\n\tWriteMacInt32(pb + ioFCBFlNm, ReadMacInt32(fcb + fcbFlNm));\n\tWriteMacInt8(pb + ioFCBFlags, ReadMacInt8(fcb + fcbFlags));\n\tWriteMacInt16(pb + ioFCBStBlk, ReadMacInt16(fcb + fcbSBlk));\n\tWriteMacInt32(pb + ioFCBEOF, ReadMacInt32(fcb + fcbEOF));\n\tWriteMacInt32(pb + ioFCBPLen, ReadMacInt32(fcb + fcbPLen));\n\tWriteMacInt32(pb + ioFCBCrPs, ReadMacInt32(fcb + fcbCrPs));\n\tWriteMacInt16(pb + ioFCBVRefNum, ReadMacInt16(ReadMacInt32(fcb + fcbVPtr) + vcbVRefNum));\n\tWriteMacInt32(pb + ioFCBClpSiz, ReadMacInt32(fcb + fcbClmpSize));\n\tWriteMacInt32(pb + ioFCBParID, ReadMacInt32(fcb + fcbDirID));\n\treturn noErr;\n}\n\n// Obtain logical size of an open file\nstatic int16 fs_get_eof(uint32 pb)\n{\n\tD(bug(\" fs_get_eof(%08lx), refNum %d\\n\", pb, ReadMacInt16(pb + ioRefNum)));\n\tM68kRegisters r;\n\n\t// Find FCB and fd for file\n\tuint32 fcb = find_fcb(ReadMacInt16(pb + ioRefNum));\n\tif (fcb == 0)\n\t\treturn rfNumErr;\n\tif (ReadMacInt32(fcb + fcbFlNm) == 0)\n\t\treturn fnOpnErr;\n\tint fd = ReadMacInt32(fcb + fcbCatPos);\n\tif (fd < 0) {\n\t\tif (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask) {\t// \"pseudo\" resource fork\n\t\t\tWriteMacInt32(pb + ioMisc, 0);\n\t\t\treturn noErr;\n\t\t} else\n\t\t\treturn fnOpnErr;\n\t}\n\n\t// Get file size\n\tstruct stat st;\n\tif (fstat(fd, &st) < 0)\n\t\treturn errno2oserr();\n\n\t// Adjust FCBs\n\tWriteMacInt32(fcb + fcbEOF, st.st_size);\n\tWriteMacInt32(fcb + fcbPLen, (st.st_size | (AL_BLK_SIZE - 1)) + 1);\n\tWriteMacInt32(pb + ioMisc, st.st_size);\n\tD(bug(\"  adjusting FCBs\\n\"));\n\tr.d[0] = ReadMacInt16(pb + ioRefNum);\n\tExecute68k(fs_data + fsAdjustEOF, &r);\n\tD(bug(\"  UTAdjustEOF() returned %d\\n\", r.d[0]));\n\treturn noErr;\n}\n\n// Truncate file\nstatic int16 fs_set_eof(uint32 pb)\n{\n\tD(bug(\" fs_set_eof(%08lx), refNum %d, size %d\\n\", pb, ReadMacInt16(pb + ioRefNum), ReadMacInt32(pb + ioMisc)));\n\tM68kRegisters r;\n\n\t// Find FCB and fd for file\n\tuint32 fcb = find_fcb(ReadMacInt16(pb + ioRefNum));\n\tif (fcb == 0)\n\t\treturn rfNumErr;\n\tif (ReadMacInt32(fcb + fcbFlNm) == 0)\n\t\treturn fnOpnErr;\n\tint fd = ReadMacInt32(fcb + fcbCatPos);\n\tif (fd < 0) {\n\t\tif (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask)\t// \"pseudo\" resource fork\n\t\t\treturn noErr;\n\t\telse\n\t\t\treturn fnOpnErr;\n\t}\n\n\t// Truncate file\n\tuint32 size = ReadMacInt32(pb + ioMisc);\n\tif (ftruncate(fd, size) < 0)\n\t\treturn errno2oserr();\n\n\t// Adjust FCBs\n\tWriteMacInt32(fcb + fcbEOF, size);\n\tWriteMacInt32(fcb + fcbPLen, (size | (AL_BLK_SIZE - 1)) + 1);\n\tD(bug(\"  adjusting FCBs\\n\"));\n\tr.d[0] = ReadMacInt16(pb + ioRefNum);\n\tExecute68k(fs_data + fsAdjustEOF, &r);\n\tD(bug(\"  UTAdjustEOF() returned %d\\n\", r.d[0]));\n\treturn noErr;\n}\n\n// Query current file position\nstatic int16 fs_get_fpos(uint32 pb)\n{\n\tD(bug(\" fs_get_fpos(%08lx), refNum %d\\n\", pb, ReadMacInt16(pb + ioRefNum)));\n\n\tWriteMacInt32(pb + ioReqCount, 0);\n\tWriteMacInt32(pb + ioActCount, 0);\n\tWriteMacInt16(pb + ioPosMode, 0);\n\n\t// Find FCB and fd for file\n\tuint32 fcb = find_fcb(ReadMacInt16(pb + ioRefNum));\n\tif (fcb == 0)\n\t\treturn rfNumErr;\n\tif (ReadMacInt32(fcb + fcbFlNm) == 0)\n\t\treturn fnOpnErr;\n\tint fd = ReadMacInt32(fcb + fcbCatPos);\n\tif (fd < 0) {\n\t\tif (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask) {\t// \"pseudo\" resource fork\n\t\t\tWriteMacInt32(pb + ioPosOffset, 0);\n\t\t\treturn noErr;\n\t\t} else\n\t\t\treturn fnOpnErr;\n\t}\n\n\t// Get file position\n\tuint32 pos = lseek(fd, 0, SEEK_CUR);\n\tWriteMacInt32(fcb + fcbCrPs, pos);\n\tWriteMacInt32(pb + ioPosOffset, pos);\n\treturn noErr;\n}\n\n// Set current file position\nstatic int16 fs_set_fpos(uint32 pb)\n{\n\tD(bug(\" fs_set_fpos(%08lx), refNum %d, posMode %d, offset %d\\n\", pb, ReadMacInt16(pb + ioRefNum), ReadMacInt16(pb + ioPosMode), ReadMacInt32(pb + ioPosOffset)));\n\n\t// Find FCB and fd for file\n\tuint32 fcb = find_fcb(ReadMacInt16(pb + ioRefNum));\n\tif (fcb == 0)\n\t\treturn rfNumErr;\n\tif (ReadMacInt32(fcb + fcbFlNm) == 0)\n\t\treturn fnOpnErr;\n\tint fd = ReadMacInt32(fcb + fcbCatPos);\n\tif (fd < 0) {\n\t\tif (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask) {\t// \"pseudo\" resource fork\n\t\t\tWriteMacInt32(pb + ioPosOffset, 0);\n\t\t\treturn noErr;\n\t\t} else\n\t\t\treturn fnOpnErr;\n\t}\n\n\t// Set file position\n\tswitch (ReadMacInt16(pb + ioPosMode) & 3) {\n\t\tcase fsFromStart:\n\t\t\tif (lseek(fd, ReadMacInt32(pb + ioPosOffset), SEEK_SET) < 0)\n\t\t\t\treturn posErr;\n\t\t\tbreak;\n\t\tcase fsFromLEOF:\n\t\t\tif (lseek(fd, (int32)ReadMacInt32(pb + ioPosOffset), SEEK_END) < 0)\n\t\t\t\treturn posErr;\n\t\t\tbreak;\n\t\tcase fsFromMark:\n\t\t\tif (lseek(fd, (int32)ReadMacInt32(pb + ioPosOffset), SEEK_CUR) < 0)\n\t\t\t\treturn posErr;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\tuint32 pos = lseek(fd, 0, SEEK_CUR);\n\tWriteMacInt32(fcb + fcbCrPs, pos);\n\tWriteMacInt32(pb + ioPosOffset, pos);\n\treturn noErr;\n}\n\n// Read from file\nstatic int16 fs_read(uint32 pb)\n{\n\tD(bug(\" fs_read(%08lx), refNum %d, buffer %p, count %d, posMode %d, posOffset %d\\n\", pb, ReadMacInt16(pb + ioRefNum), ReadMacInt32(pb + ioBuffer), ReadMacInt32(pb + ioReqCount), ReadMacInt16(pb + ioPosMode), ReadMacInt32(pb + ioPosOffset)));\n\n\t// Check parameters\n\tif ((int32)ReadMacInt32(pb + ioReqCount) < 0)\n\t\treturn paramErr;\n\n\t// Find FCB and fd for file\n\tuint32 fcb = find_fcb(ReadMacInt16(pb + ioRefNum));\n\tif (fcb == 0)\n\t\treturn rfNumErr;\n\tif (ReadMacInt32(fcb + fcbFlNm) == 0)\n\t\treturn fnOpnErr;\n\tint fd = ReadMacInt32(fcb + fcbCatPos);\n\tif (fd < 0) {\n\t\tif (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask) {\t// \"pseudo\" resource fork\n\t\t\tWriteMacInt32(pb + ioActCount, 0);\n\t\t\treturn eofErr;\n\t\t} else\n\t\t\treturn fnOpnErr;\n\t}\n\n\t// Seek\n\tswitch (ReadMacInt16(pb + ioPosMode) & 3) {\n\t\tcase fsFromStart:\n\t\t\tif (lseek(fd, ReadMacInt32(pb + ioPosOffset), SEEK_SET) < 0)\n\t\t\t\treturn posErr;\n\t\t\tbreak;\n\t\tcase fsFromLEOF:\n\t\t\tif (lseek(fd, (int32)ReadMacInt32(pb + ioPosOffset), SEEK_END) < 0)\n\t\t\t\treturn posErr;\n\t\t\tbreak;\n\t\tcase fsFromMark:\n\t\t\tif (lseek(fd, (int32)ReadMacInt32(pb + ioPosOffset), SEEK_CUR) < 0)\n\t\t\t\treturn posErr;\n\t\t\tbreak;\n\t}\n\n\t// Read\n\tssize_t actual = extfs_read(fd, Mac2HostAddr(ReadMacInt32(pb + ioBuffer)), ReadMacInt32(pb + ioReqCount));\n\tint16 read_err = errno2oserr();\n\tD(bug(\"  actual %d\\n\", actual));\n\tWriteMacInt32(pb + ioActCount, actual >= 0 ? actual : 0);\n\tuint32 pos = lseek(fd, 0, SEEK_CUR);\n\tWriteMacInt32(fcb + fcbCrPs, pos);\n\tWriteMacInt32(pb + ioPosOffset, pos);\n\tif (actual != (ssize_t)ReadMacInt32(pb + ioReqCount))\n\t\treturn actual < 0 ? read_err : eofErr;\n\telse\n\t\treturn noErr;\n}\n\n// Write to file\nstatic int16 fs_write(uint32 pb)\n{\n\tD(bug(\" fs_write(%08lx), refNum %d, buffer %p, count %d, posMode %d, posOffset %d\\n\", pb, ReadMacInt16(pb + ioRefNum), ReadMacInt32(pb + ioBuffer), ReadMacInt32(pb + ioReqCount), ReadMacInt16(pb + ioPosMode), ReadMacInt32(pb + ioPosOffset)));\n\n\t// Check parameters\n\tif ((int32)ReadMacInt32(pb + ioReqCount) < 0)\n\t\treturn paramErr;\n\n\t// Find FCB and fd for file\n\tuint32 fcb = find_fcb(ReadMacInt16(pb + ioRefNum));\n\tif (fcb == 0)\n\t\treturn rfNumErr;\n\tif (ReadMacInt32(fcb + fcbFlNm) == 0)\n\t\treturn fnOpnErr;\n\tint fd = ReadMacInt32(fcb + fcbCatPos);\n\tif (fd < 0) {\n\t\tif (ReadMacInt8(fcb + fcbFlags) & fcbResourceMask) {\t// \"pseudo\" resource fork\n\t\t\tWriteMacInt32(pb + ioActCount, ReadMacInt32(pb + ioReqCount));\n\t\t\treturn noErr;\n\t\t} else\n\t\t\treturn fnOpnErr;\n\t}\n\n\t// Seek\n\tswitch (ReadMacInt16(pb + ioPosMode) & 3) {\n\t\tcase fsFromStart:\n\t\t\tif (lseek(fd, ReadMacInt32(pb + ioPosOffset), SEEK_SET) < 0)\n\t\t\t\treturn posErr;\n\t\t\tbreak;\n\t\tcase fsFromLEOF:\n\t\t\tif (lseek(fd, (int32)ReadMacInt32(pb + ioPosOffset), SEEK_END) < 0)\n\t\t\t\treturn posErr;\n\t\t\tbreak;\n\t\tcase fsFromMark:\n\t\t\tif (lseek(fd, (int32)ReadMacInt32(pb + ioPosOffset), SEEK_CUR) < 0)\n\t\t\t\treturn posErr;\n\t\t\tbreak;\n\t}\n\n\t// Write\n\tssize_t actual = extfs_write(fd, Mac2HostAddr(ReadMacInt32(pb + ioBuffer)), ReadMacInt32(pb + ioReqCount));\n\tint16 write_err = errno2oserr();\n\tD(bug(\"  actual %d\\n\", actual));\n\tWriteMacInt32(pb + ioActCount, actual >= 0 ? actual : 0);\n\tuint32 pos = lseek(fd, 0, SEEK_CUR);\n\tWriteMacInt32(fcb + fcbCrPs, pos);\n\tWriteMacInt32(pb + ioPosOffset, pos);\n\tif (actual != (ssize_t)ReadMacInt32(pb + ioReqCount))\n\t\treturn write_err;\n\telse\n\t\treturn noErr;\n}\n\n// Create file\nstatic int16 fs_create(uint32 pb, uint32 dirID)\n{\n\tD(bug(\" fs_create(%08lx), vRefNum %d, name %.31s, dirID %d\\n\", pb, ReadMacInt16(pb + ioVRefNum), Mac2HostAddr(ReadMacInt32(pb + ioNamePtr) + 1), dirID));\n\n\t// Find FSItem for given file\n\tFSItem *fs_item;\n\tint16 result = get_item_and_path(pb, dirID, fs_item);\n\tif (result != noErr)\n\t\treturn result;\n\n\t// Does the file already exist?\n\tif (access(full_path, F_OK) == 0)\n\t\treturn dupFNErr;\n\n\t// Create file\n\tint fd = creat(full_path, 0666);\n\tif (fd < 0)\n\t\treturn errno2oserr();\n\telse {\n\t\tclose(fd);\n\t\treturn noErr;\n\t}\n}\n\n// Create directory\nstatic int16 fs_dir_create(uint32 pb)\n{\n\tD(bug(\" fs_dir_create(%08lx), vRefNum %d, name %.31s, dirID %d\\n\", pb, ReadMacInt16(pb + ioVRefNum), Mac2HostAddr(ReadMacInt32(pb + ioNamePtr) + 1), ReadMacInt32(pb + ioDirID)));\n\n\t// Find FSItem for given directory\n\tFSItem *fs_item;\n\tint16 result = get_item_and_path(pb, ReadMacInt32(pb + ioDirID), fs_item);\n\tif (result != noErr)\n\t\treturn result;\n\n\t// Does the directory already exist?\n\tif (access(full_path, F_OK) == 0)\n\t\treturn dupFNErr;\n\n\t// Create directory\n\tif (mkdir(full_path, 0777) < 0)\n\t\treturn errno2oserr();\n\telse {\n\t\tWriteMacInt32(pb + ioDirID, fs_item->id);\n\t\treturn noErr;\n\t}\n}\n\n// Delete file/directory\nstatic int16 fs_delete(uint32 pb, uint32 dirID)\n{\n\tD(bug(\" fs_delete(%08lx), vRefNum %d, name %.31s, dirID %d\\n\", pb, ReadMacInt16(pb + ioVRefNum), Mac2HostAddr(ReadMacInt32(pb + ioNamePtr) + 1), dirID));\n\n\t// Find FSItem for given file/dir\n\tFSItem *fs_item;\n\tint16 result = get_item_and_path(pb, dirID, fs_item);\n\tif (result != noErr)\n\t\treturn result;\n\n\t// Delete file\n\tif (!extfs_remove(full_path))\n\t\treturn errno2oserr();\n\telse\n\t\treturn noErr;\n}\n\n// Rename file/directory\nstatic int16 fs_rename(uint32 pb, uint32 dirID)\n{\n\tD(bug(\" fs_rename(%08lx), vRefNum %d, name %.31s, dirID %d, new name %.31s\\n\", pb, ReadMacInt16(pb + ioVRefNum), Mac2HostAddr(ReadMacInt32(pb + ioNamePtr) + 1), dirID, Mac2HostAddr(ReadMacInt32(pb + ioMisc) + 1)));\n\n\t// Find path of given file/dir\n\tFSItem *fs_item;\n\tint16 result = get_item_and_path(pb, dirID, fs_item);\n\tif (result != noErr)\n\t\treturn result;\n\n\t// Save path of existing item\n\tchar old_path[MAX_PATH_LENGTH];\n\tstrcpy(old_path, full_path);\n\n\t// Find path for new name\n\tMac2Mac_memcpy(fs_data + fsPB, pb, SIZEOF_IOParam);\n\tWriteMacInt32(fs_data + fsPB + ioNamePtr, ReadMacInt32(pb + ioMisc));\n\tFSItem *new_item;\n\tresult = get_item_and_path(fs_data + fsPB, dirID, new_item);\n\tif (result != noErr)\n\t\treturn result;\n\n\t// Does the new name already exist?\n\tif (access(full_path, F_OK) == 0)\n\t\treturn dupFNErr;\n\n\t// Rename item\n\tD(bug(\"  renaming %s -> %s\\n\", old_path, full_path));\n\tif (!extfs_rename(old_path, full_path))\n\t\treturn errno2oserr();\n\telse {\n\t\t// The ID of the old file/dir has to stay the same, so we swap the IDs of the FSItems\n\t\tswap_parent_ids(fs_item->id, new_item->id);\n\t\tuint32 t = fs_item->id;\n\t\tfs_item->id = new_item->id;\n\t\tnew_item->id = t;\n\t\treturn noErr;\n\t}\n}\n\n// Move file/directory (CMovePBRec)\nstatic int16 fs_cat_move(uint32 pb)\n{\n\tD(bug(\" fs_cat_move(%08lx), vRefNum %d, name %.31s, dirID %d, new name %.31s, new dirID %d\\n\", pb, ReadMacInt16(pb + ioVRefNum), Mac2HostAddr(ReadMacInt32(pb + ioNamePtr) + 1), ReadMacInt32(pb + ioDirID), Mac2HostAddr(ReadMacInt32(pb + ioNewName) + 1), ReadMacInt32(pb + ioNewDirID)));\n\n\t// Find path of given file/dir\n\tFSItem *fs_item;\n\tint16 result = get_item_and_path(pb, ReadMacInt32(pb + ioDirID), fs_item);\n\tif (result != noErr)\n\t\treturn result;\n\n\t// Save path of existing item\n\tchar old_path[MAX_PATH_LENGTH];\n\tstrcpy(old_path, full_path);\n\n\t// Find path for new directory\n\tMac2Mac_memcpy(fs_data + fsPB, pb, SIZEOF_IOParam);\n\tWriteMacInt32(fs_data + fsPB + ioNamePtr, ReadMacInt32(pb + ioNewName));\n\tFSItem *new_dir_item;\n\tresult = get_item_and_path(fs_data + fsPB, ReadMacInt32(pb + ioNewDirID), new_dir_item);\n\tif (result != noErr)\n\t\treturn result;\n\n\t// Append old file/dir name\n\tadd_path_comp(fs_item->name);\n\n\t// Does the new name already exist?\n\tif (access(full_path, F_OK) == 0)\n\t\treturn dupFNErr;\n\n\t// Move item\n\tD(bug(\"  moving %s -> %s\\n\", old_path, full_path));\n\tif (!extfs_rename(old_path, full_path))\n\t\treturn errno2oserr();\n\telse {\n\t\t// The ID of the old file/dir has to stay the same, so we swap the IDs of the FSItems\n\t\tFSItem *new_item = find_fsitem(fs_item->name, new_dir_item);\n\t\tif (new_item) {\n\t\t\tswap_parent_ids(fs_item->id, new_item->id);\n\t\t\tuint32 t = fs_item->id;\n\t\t\tfs_item->id = new_item->id;\n\t\t\tnew_item->id = t;\n\t\t}\n\t\treturn noErr;\n\t}\n}\n\n// Open working directory (WDParam)\nstatic int16 fs_open_wd(uint32 pb)\n{\n\tD(bug(\" fs_open_wd(%08lx), vRefNum %d, name %.31s, dirID %d\\n\", pb, ReadMacInt16(pb + ioVRefNum), Mac2HostAddr(ReadMacInt32(pb + ioNamePtr) + 1), ReadMacInt32(pb + ioWDDirID)));\n\tM68kRegisters r;\n\n\t// Allocate WDCB\n\tD(bug(\"  allocating WDCB\\n\"));\n\tr.a[0] = pb;\n\tExecute68k(fs_data + fsAllocateWDCB, &r);\n\tD(bug(\"  UTAllocateWDCB returned %d, refNum is %d\\n\", r.d[0], ReadMacInt16(pb + ioVRefNum)));\n\treturn (int16)r.d[0];\n}\n\n// Close working directory (WDParam)\nstatic int16 fs_close_wd(uint32 pb)\n{\n\tD(bug(\" fs_close_wd(%08lx), vRefNum %d\\n\", pb, ReadMacInt16(pb + ioVRefNum)));\n\tM68kRegisters r;\n\n\t// Release WDCB\n\tD(bug(\"  releasing WDCB\\n\"));\n\tr.d[0] = ReadMacInt16(pb + ioVRefNum);\n\tExecute68k(fs_data + fsReleaseWDCB, &r);\n\tD(bug(\"  UTReleaseWDCB returned %d\\n\", r.d[0]));\n\treturn (int16)r.d[0];\n}\n\n// Query information about working directory (WDParam)\nstatic int16 fs_get_wd_info(uint32 pb, uint32 vcb)\n{\n\tD(bug(\" fs_get_wd_info(%08lx), vRefNum %d, idx %d, procID %d\\n\", pb, ReadMacInt16(pb + ioVRefNum), ReadMacInt16(pb + ioWDIndex), ReadMacInt32(pb + ioWDProcID)));\n\tM68kRegisters r;\n\n\t// Querying volume?\n\tif (ReadMacInt16(pb + ioWDIndex) == 0 && ReadMacInt16(pb + ioVRefNum) == ReadMacInt16(vcb + vcbVRefNum)) {\n\t\tWriteMacInt32(pb + ioWDProcID, 0);\n\t\tWriteMacInt16(pb + ioWDVRefNum, ReadMacInt16(vcb + vcbVRefNum));\n\t\tif (ReadMacInt32(pb + ioNamePtr))\n\t\t\tMac2Mac_memcpy(ReadMacInt32(pb + ioNamePtr), vcb + vcbVN, 28);\n\t\tWriteMacInt32(pb + ioWDDirID, ROOT_ID);\n\t\treturn noErr;\n\t}\n\n\t// Resolve WDCB\n\tD(bug(\"  resolving WDCB\\n\"));\n\tr.d[0] = ReadMacInt32(pb + ioWDProcID);\n\tr.d[1] = ReadMacInt16(pb + ioWDIndex);\n\tr.d[2] = ReadMacInt16(pb + ioVRefNum);\n\tr.a[0] = fs_data + fsReturn;\n\tExecute68k(fs_data + fsResolveWDCB, &r);\n\tuint32 wdcb = ReadMacInt32(fs_data + fsReturn);\n\tD(bug(\"  UTResolveWDCB() returned %d, dirID %d\\n\", r.d[0], ReadMacInt32(wdcb + wdDirID)));\n\tif (r.d[0] & 0xffff)\n\t\treturn (int16)r.d[0];\n\n\t// Return information\n\tWriteMacInt32(pb + ioWDProcID, ReadMacInt32(wdcb + wdProcID));\n\tWriteMacInt16(pb + ioWDVRefNum, ReadMacInt16(ReadMacInt32(wdcb + wdVCBPtr) + vcbVRefNum));\n\tif (ReadMacInt32(pb + ioNamePtr))\n\t\tMac2Mac_memcpy(ReadMacInt32(pb + ioNamePtr), ReadMacInt32(wdcb + wdVCBPtr) + vcbVN, 28);\n\tWriteMacInt32(pb + ioWDDirID, ReadMacInt32(wdcb + wdDirID));\n\treturn noErr;\n}\n\n// Main dispatch routine\nint16 ExtFSHFS(uint32 vcb, uint16 selectCode, uint32 paramBlock, uint32 globalsPtr, int16 fsid)\n{\n\tuint16 trapWord = selectCode & 0xf0ff;\n\tbool hfs = selectCode & kHFSMask;\n\tswitch (trapWord) {\n\t\tcase kFSMOpen:\n\t\t\treturn fs_open(paramBlock, hfs ? ReadMacInt32(paramBlock + ioDirID) : 0, vcb, false);\n\n\t\tcase kFSMClose:\n\t\t\treturn fs_close(paramBlock);\n\n\t\tcase kFSMRead:\n\t\t\treturn fs_read(paramBlock);\n\n\t\tcase kFSMWrite:\n\t\t\treturn fs_write(paramBlock);\n\n\t\tcase kFSMGetVolInfo:\n\t\t\treturn fs_get_vol_info(paramBlock, hfs);\n\n\t\tcase kFSMCreate:\n\t\t\treturn fs_create(paramBlock, hfs ? ReadMacInt32(paramBlock + ioDirID) : 0);\n\n\t\tcase kFSMDelete:\n\t\t\treturn fs_delete(paramBlock, hfs ? ReadMacInt32(paramBlock + ioDirID) : 0);\n\n\t\tcase kFSMOpenRF:\n\t\t\treturn fs_open(paramBlock, hfs ? ReadMacInt32(paramBlock + ioDirID) : 0, vcb, true);\n\n\t\tcase kFSMRename:\n\t\t\treturn fs_rename(paramBlock, hfs ? ReadMacInt32(paramBlock + ioDirID) : 0);\n\n\t\tcase kFSMGetFileInfo:\n\t\t\treturn fs_get_file_info(paramBlock, hfs, hfs ? ReadMacInt32(paramBlock + ioDirID) : 0);\n\n\t\tcase kFSMSetFileInfo:\n\t\t\treturn fs_set_file_info(paramBlock, hfs, hfs ? ReadMacInt32(paramBlock + ioDirID) : 0);\n\n\t\tcase kFSMUnmountVol:\n\t\t\treturn fs_unmount_vol(vcb);\n\n\t\tcase kFSMMountVol:\n\t\t\treturn fs_mount_vol(paramBlock);\n\n\t\tcase kFSMAllocate:\n\t\t\tD(bug(\" allocate\\n\"));\n\t\t\tWriteMacInt32(paramBlock + ioActCount, ReadMacInt32(paramBlock + ioReqCount));\n\t\t\treturn noErr;\n\n\t\tcase kFSMGetEOF:\n\t\t\treturn fs_get_eof(paramBlock);\n\n\t\tcase kFSMSetEOF:\n\t\t\treturn fs_set_eof(paramBlock);\n\n\t\tcase kFSMGetVol:\n\t\t\treturn fs_get_vol(paramBlock);\n\n\t\tcase kFSMSetVol:\n\t\t\treturn fs_set_vol(paramBlock, hfs, vcb);\n\n\t\tcase kFSMEject:\n\t\t\tD(bug(\" eject\\n\"));\n\t\t\treturn noErr;\n\n\t\tcase kFSMGetFPos:\n\t\t\treturn fs_get_fpos(paramBlock);\n\n\t\tcase kFSMOffline:\n\t\t\tD(bug(\" offline\\n\"));\n\t\t\treturn noErr;\n\n\t\tcase kFSMSetFilLock:\n\t\t\treturn noErr;\t//!!\n\n\t\tcase kFSMRstFilLock:\n\t\t\treturn noErr;\t//!!\n\n\t\tcase kFSMSetFPos:\n\t\t\treturn fs_set_fpos(paramBlock);\n\n\t\tcase kFSMOpenWD:\n\t\t\treturn fs_open_wd(paramBlock);\n\n\t\tcase kFSMCloseWD:\n\t\t\treturn fs_close_wd(paramBlock);\n\n\t\tcase kFSMCatMove:\n\t\t\treturn fs_cat_move(paramBlock);\n\n\t\tcase kFSMDirCreate:\n\t\t\treturn fs_dir_create(paramBlock);\n\n\t\tcase kFSMGetWDInfo:\n\t\t\treturn fs_get_wd_info(paramBlock, vcb);\n\n\t\tcase kFSMGetFCBInfo:\n\t\t\treturn fs_get_fcb_info(paramBlock, vcb);\n\n\t\tcase kFSMGetCatInfo:\n\t\t\treturn fs_get_cat_info(paramBlock);\n\n\t\tcase kFSMSetCatInfo:\n\t\t\treturn fs_set_cat_info(paramBlock);\n\n\t\tcase kFSMSetVolInfo:\n\t\t\treturn fs_set_vol_info(paramBlock);\n\n\t\tcase kFSMGetVolParms:\n\t\t\treturn fs_get_vol_parms(paramBlock);\n\n\t\tcase kFSMVolumeMount:\n\t\t\treturn fs_volume_mount(paramBlock);\n\n\t\tcase kFSMFlushVol:\n\t\tcase kFSMFlushFile:\n\t\t\tD(bug(\" flush_vol/flush_file\\n\"));\n\t\t\treturn noErr;\n\n\t\tdefault:\n\t\t\tD(bug(\"ExtFSHFS(%08lx, %04x, %08lx, %08lx, %d)\\n\", vcb, selectCode, paramBlock, globalsPtr, fsid));\n\t\t\treturn paramErr;\n\t}\n}\n","/*\n * UAE - The Un*x Amiga Emulator\n *\n * memory management\n *\n * Copyright 1995 Bernd Schmidt\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef UAE_MEMORY_H\n#define UAE_MEMORY_H\n\n#if !DIRECT_ADDRESSING && !REAL_ADDRESSING\n\n/* Enabling this adds one additional native memory reference per 68k memory\n * access, but saves one shift (on the x86). Enabling this is probably\n * better for the cache. My favourite benchmark (PP2) doesn't show a\n * difference, so I leave this enabled. */\n\n#if 1 || defined SAVE_MEMORY\n#define SAVE_MEMORY_BANKS\n#endif\n\ntypedef uae_u32 (REGPARAM2 *mem_get_func)(uaecptr) REGPARAM;\ntypedef void (REGPARAM2 *mem_put_func)(uaecptr, uae_u32) REGPARAM;\ntypedef uae_u8 *(REGPARAM2 *xlate_func)(uaecptr) REGPARAM;\n\n#undef DIRECT_MEMFUNCS_SUCCESSFUL\n\n#ifndef CAN_MAP_MEMORY\n#undef USE_COMPILER\n#endif\n\n#if defined(USE_COMPILER) && !defined(USE_MAPPED_MEMORY)\n#define USE_MAPPED_MEMORY\n#endif\n\ntypedef struct {\n    /* These ones should be self-explanatory... */\n    mem_get_func lget, wget, bget;\n    mem_put_func lput, wput, bput;\n    /* Use xlateaddr to translate an Amiga address to a uae_u8 * that can\n     * be used to address memory without calling the wget/wput functions.\n     * This doesn't work for all memory banks, so this function may call\n     * abort(). */\n    xlate_func xlateaddr;\n} addrbank;\n\nextern uae_u8 filesysory[65536];\n\nextern addrbank ram_bank;\t// Mac RAM\nextern addrbank rom_bank;\t// Mac ROM\nextern addrbank frame_bank;\t// Frame buffer\n\n/* Default memory access functions */\n\nextern uae_u8 *REGPARAM2 default_xlate(uaecptr addr) REGPARAM;\n\n#define bankindex(addr) (((uaecptr)(addr)) >> 16)\n\n#ifdef SAVE_MEMORY_BANKS\nextern addrbank *mem_banks[65536];\n#define get_mem_bank(addr) (*mem_banks[bankindex(addr)])\n#define put_mem_bank(addr, b) (mem_banks[bankindex(addr)] = (b))\n#else\nextern addrbank mem_banks[65536];\n#define get_mem_bank(addr) (mem_banks[bankindex(addr)])\n#define put_mem_bank(addr, b) (mem_banks[bankindex(addr)] = *(b))\n#endif\n\nextern void memory_init(void);\nextern void map_banks(addrbank *bank, int first, int count);\n\n#ifndef NO_INLINE_MEMORY_ACCESS\n\n#define longget(addr) (call_mem_get_func(get_mem_bank(addr).lget, addr))\n#define wordget(addr) (call_mem_get_func(get_mem_bank(addr).wget, addr))\n#define byteget(addr) (call_mem_get_func(get_mem_bank(addr).bget, addr))\n#define longput(addr,l) (call_mem_put_func(get_mem_bank(addr).lput, addr, l))\n#define wordput(addr,w) (call_mem_put_func(get_mem_bank(addr).wput, addr, w))\n#define byteput(addr,b) (call_mem_put_func(get_mem_bank(addr).bput, addr, b))\n\n#else\n\nextern uae_u32 longget(uaecptr addr);\nextern uae_u32 wordget(uaecptr addr);\nextern uae_u32 byteget(uaecptr addr);\nextern void longput(uaecptr addr, uae_u32 l);\nextern void wordput(uaecptr addr, uae_u32 w);\nextern void byteput(uaecptr addr, uae_u32 b);\n\n#endif\n\n#ifndef MD_HAVE_MEM_1_FUNCS\n\n#define longget_1 longget\n#define wordget_1 wordget\n#define byteget_1 byteget\n#define longput_1 longput\n#define wordput_1 wordput\n#define byteput_1 byteput\n\n#endif\n\n#endif /* !DIRECT_ADDRESSING && !REAL_ADDRESSING */\n\n#if REAL_ADDRESSING\nconst uintptr_t MEMBaseDiff = 0;\n#elif DIRECT_ADDRESSING\nextern uintptr_t MEMBaseDiff;\n#endif\n\n#if REAL_ADDRESSING || DIRECT_ADDRESSING\nstatic __inline__ uae_u8 *do_get_real_address(uaecptr addr)\n{\n\treturn (uae_u8 *)MEMBaseDiff + addr;\n}\nstatic __inline__ uae_u32 do_get_virtual_address(uae_u8 *addr)\n{\n\treturn (uintptr_t)addr - MEMBaseDiff;\n}\nstatic __inline__ uae_u32 get_long(uaecptr addr)\n{\n    uae_u32 * const m = (uae_u32 *)do_get_real_address(addr);\n    return do_get_mem_long(m);\n}\nstatic __inline__ uae_u32 get_word(uaecptr addr)\n{\n    uae_u16 * const m = (uae_u16 *)do_get_real_address(addr);\n    return do_get_mem_word(m);\n}\nstatic __inline__ uae_u32 get_byte(uaecptr addr)\n{\n    uae_u8 * const m = (uae_u8 *)do_get_real_address(addr);\n    return do_get_mem_byte(m);\n}\nstatic __inline__ void put_long(uaecptr addr, uae_u32 l)\n{\n    uae_u32 * const m = (uae_u32 *)do_get_real_address(addr);\n    do_put_mem_long(m, l);\n}\nstatic __inline__ void put_word(uaecptr addr, uae_u32 w)\n{\n    uae_u16 * const m = (uae_u16 *)do_get_real_address(addr);\n    do_put_mem_word(m, w);\n}\nstatic __inline__ void put_byte(uaecptr addr, uae_u32 b)\n{\n    uae_u8 * const m = (uae_u8 *)do_get_real_address(addr);\n    do_put_mem_byte(m, b);\n}\nstatic __inline__ uae_u8 *get_real_address(uaecptr addr)\n{\n\treturn do_get_real_address(addr);\n}\nstatic __inline__ uae_u32 get_virtual_address(uae_u8 *addr)\n{\n\treturn do_get_virtual_address(addr);\n}\n#else\nstatic __inline__ uae_u32 get_long(uaecptr addr)\n{\n    return longget_1(addr);\n}\nstatic __inline__ uae_u32 get_word(uaecptr addr)\n{\n    return wordget_1(addr);\n}\nstatic __inline__ uae_u32 get_byte(uaecptr addr)\n{\n    return byteget_1(addr);\n}\nstatic __inline__ void put_long(uaecptr addr, uae_u32 l)\n{\n    longput_1(addr, l);\n}\nstatic __inline__ void put_word(uaecptr addr, uae_u32 w)\n{\n    wordput_1(addr, w);\n}\nstatic __inline__ void put_byte(uaecptr addr, uae_u32 b)\n{\n    byteput_1(addr, b);\n}\nstatic __inline__ uae_u8 *get_real_address(uaecptr addr)\n{\n    return get_mem_bank(addr).xlateaddr(addr);\n}\n/* gb-- deliberately not implemented since it shall not be used... */\nextern uae_u32 get_virtual_address(uae_u8 *addr);\n#endif /* DIRECT_ADDRESSING || REAL_ADDRESSING */\n\n#endif /* MEMORY_H */\n\n","/*\n *  cpu_emulation.h - Definitions for Basilisk II CPU emulation module (UAE 0.8.10 version)\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef CPU_EMULATION_H\n#define CPU_EMULATION_H\n\n#include <string.h>\n\n\n/*\n *  Memory system\n */\n\n// RAM and ROM pointers (allocated and set by main_*.cpp)\nextern uint32 RAMBaseMac;\t\t// RAM base (Mac address space), does not include Low Mem when != 0\nextern uint8 *RAMBaseHost;\t\t// RAM base (host address space)\nextern uint32 RAMSize;\t\t\t// Size of RAM\n\nextern uint32 ROMBaseMac;\t\t// ROM base (Mac address space)\nextern uint8 *ROMBaseHost;\t\t// ROM base (host address space)\nextern uint32 ROMSize;\t\t\t// Size of ROM\n\n#if !REAL_ADDRESSING && !DIRECT_ADDRESSING\n// If we are not using real or direct addressing, the Mac frame buffer gets\n// mapped to this location. The memory must be allocated by VideoInit().\n// If multiple monitors are used, they must share the frame buffer\nconst uint32 MacFrameBaseMac = 0xa0000000;\nextern uint8 *MacFrameBaseHost;\t// Frame buffer base (host address space)\nextern uint32 MacFrameSize;\t\t// Size of frame buffer\n#endif\nextern int MacFrameLayout;\t\t// Frame buffer layout (see defines below)\n\n// Possible frame buffer layouts\nenum {\n\tFLAYOUT_NONE,\t\t\t\t// No frame buffer\n\tFLAYOUT_DIRECT,\t\t\t\t// Frame buffer is in MacOS layout, no conversion needed\n\tFLAYOUT_HOST_555,\t\t\t// 16 bit, RGB 555, host byte order\n\tFLAYOUT_HOST_565,\t\t\t// 16 bit, RGB 565, host byte order\n\tFLAYOUT_HOST_888\t\t\t// 32 bit, RGB 888, host byte order\n};\n\n// Mac memory access functions\n#include \"memory.h\"\nstatic inline uint32 ReadMacInt32(uint32 addr) {return get_long(addr);}\nstatic inline uint32 ReadMacInt16(uint32 addr) {return get_word(addr);}\nstatic inline uint32 ReadMacInt8(uint32 addr) {return get_byte(addr);}\nstatic inline void WriteMacInt32(uint32 addr, uint32 l) {put_long(addr, l);}\nstatic inline void WriteMacInt16(uint32 addr, uint32 w) {put_word(addr, w);}\nstatic inline void WriteMacInt8(uint32 addr, uint32 b) {put_byte(addr, b);}\nstatic inline uint8 *Mac2HostAddr(uint32 addr) {return get_real_address(addr);}\nstatic inline uint32 Host2MacAddr(uint8 *addr) {return get_virtual_address(addr);}\n\nstatic inline void *Mac_memset(uint32 addr, int c, size_t n) {return memset(Mac2HostAddr(addr), c, n);}\nstatic inline void *Mac2Host_memcpy(void *dest, uint32 src, size_t n) {return memcpy(dest, Mac2HostAddr(src), n);}\nstatic inline void *Host2Mac_memcpy(uint32 dest, const void *src, size_t n) {return memcpy(Mac2HostAddr(dest), src, n);}\nstatic inline void *Mac2Mac_memcpy(uint32 dest, uint32 src, size_t n) {return memcpy(Mac2HostAddr(dest), Mac2HostAddr(src), n);}\n\n\n/*\n *  680x0 emulation\n */\n\n// Initialization\nextern bool Init680x0(void);\t// This routine may want to look at CPUType/FPUType to set up the apropriate emulation\nextern void Exit680x0(void);\nextern void InitFrameBufferMapping(void);\n\n// 680x0 dynamic recompilation activation flag\n#if USE_JIT\nextern bool UseJIT;\n#else\nconst bool UseJIT = false;\n#endif\n\n// 680x0 emulation functions\nstruct M68kRegisters;\nextern void Start680x0(void);\t\t\t\t\t\t\t\t\t// Reset and start 680x0\nextern \"C\" void Execute68k(uint32 addr, M68kRegisters *r);\t\t// Execute 68k code from EMUL_OP routine\nextern \"C\" void Execute68kTrap(uint16 trap, M68kRegisters *r);\t// Execute MacOS 68k trap from EMUL_OP routine\n\n// Interrupt functions\nextern void TriggerInterrupt(void);\t\t\t\t\t\t\t\t// Trigger interrupt level 1 (InterruptFlag must be set first)\nextern void TriggerNMI(void);\t\t\t\t\t\t\t\t\t// Trigger interrupt level 7\n\n#endif\n","/*\n *  main.cpp - Startup/shutdown code\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"sysdeps.h\"\n\n#include \"cpu_emulation.h\"\n#include \"xpram.h\"\n#include \"timer.h\"\n#include \"sony.h\"\n#include \"disk.h\"\n#include \"cdrom.h\"\n#include \"scsi.h\"\n#include \"extfs.h\"\n#include \"audio.h\"\n#include \"video.h\"\n#include \"serial.h\"\n#include \"ether.h\"\n#include \"clip.h\"\n#include \"adb.h\"\n#include \"rom_patches.h\"\n#include \"user_strings.h\"\n#include \"prefs.h\"\n#include \"main.h\"\n\n#define DEBUG 0\n#include \"debug.h\"\n\n#if ENABLE_MON\n#include \"mon.h\"\n\nstatic uint32 mon_read_byte_b2(uintptr adr)\n{\n\treturn ReadMacInt8(adr);\n}\n\nstatic void mon_write_byte_b2(uintptr adr, uint32 b)\n{\n\tWriteMacInt8(adr, b);\n}\n#endif\n\n\n/*\n *  Initialize everything, returns false on error\n */\n\nbool InitAll(const char *vmdir)\n{\n\t// Check ROM version\n\tif (!CheckROM()) {\n\t\tErrorAlert(STR_UNSUPPORTED_ROM_TYPE_ERR);\n\t\treturn false;\n\t}\n\n#if EMULATED_68K\n\t// Set CPU and FPU type (UAE emulation)\n\tswitch (ROMVersion) {\n\t\tcase ROM_VERSION_64K:\n\t\tcase ROM_VERSION_PLUS:\n\t\tcase ROM_VERSION_CLASSIC:\n\t\t\tCPUType = 0;\n\t\t\tFPUType = 0;\n\t\t\tTwentyFourBitAddressing = true;\n\t\t\tbreak;\n\t\tcase ROM_VERSION_II:\n\t\t\tCPUType = PrefsFindInt32(\"cpu\");\n\t\t\tif (CPUType < 2) CPUType = 2;\n\t\t\tif (CPUType > 4) CPUType = 4;\n\t\t\tFPUType = PrefsFindBool(\"fpu\") ? 1 : 0;\n\t\t\tif (CPUType == 4) FPUType = 1;\t// 68040 always with FPU\n\t\t\tTwentyFourBitAddressing = true;\n\t\t\tbreak;\n\t\tcase ROM_VERSION_32:\n\t\t\tCPUType = PrefsFindInt32(\"cpu\");\n\t\t\tif (CPUType < 2) CPUType = 2;\n\t\t\tif (CPUType > 4) CPUType = 4;\n\t\t\tFPUType = PrefsFindBool(\"fpu\") ? 1 : 0;\n\t\t\tif (CPUType == 4) FPUType = 1;\t// 68040 always with FPU\n\t\t\tTwentyFourBitAddressing = false;\n\t\t\tbreak;\n\t}\n\tCPUIs68060 = false;\n#endif\n\n\t// Load XPRAM\n\tXPRAMInit(vmdir);\n\n\t// Load XPRAM default values if signature not found\n\tif (XPRAM[0x0c] != 0x4e || XPRAM[0x0d] != 0x75\n\t || XPRAM[0x0e] != 0x4d || XPRAM[0x0f] != 0x63) {\n\t\tD(bug(\"Loading XPRAM default values\\n\"));\n\t\tmemset(XPRAM, 0, 0x100);\n\t\tXPRAM[0x0c] = 0x4e;\t// \"NuMc\" signature\n\t\tXPRAM[0x0d] = 0x75;\n\t\tXPRAM[0x0e] = 0x4d;\n\t\tXPRAM[0x0f] = 0x63;\n\t\tXPRAM[0x01] = 0x80;\t// InternalWaitFlags = DynWait (don't wait for SCSI devices upon bootup)\n\t\tXPRAM[0x10] = 0xa8;\t// Standard PRAM values\n\t\tXPRAM[0x11] = 0x00;\n\t\tXPRAM[0x12] = 0x00;\n\t\tXPRAM[0x13] = 0x22;\n\t\tXPRAM[0x14] = 0xcc;\n\t\tXPRAM[0x15] = 0x0a;\n\t\tXPRAM[0x16] = 0xcc;\n\t\tXPRAM[0x17] = 0x0a;\n\t\tXPRAM[0x1c] = 0x00;\n\t\tXPRAM[0x1d] = 0x02;\n\t\tXPRAM[0x1e] = 0x63;\n\t\tXPRAM[0x1f] = 0x00;\n\t\tXPRAM[0x08] = 0x13;\n\t\tXPRAM[0x09] = 0x88;\n\t\tXPRAM[0x0a] = 0x00;\n\t\tXPRAM[0x0b] = 0xcc;\n\t\tXPRAM[0x76] = 0x00;\t// OSDefault = MacOS\n\t\tXPRAM[0x77] = 0x01;\n\t}\n\n\t// Set boot volume\n\tint16 i16 = PrefsFindInt32(\"bootdrive\");\n\tXPRAM[0x78] = i16 >> 8;\n\tXPRAM[0x79] = i16 & 0xff;\n\ti16 = PrefsFindInt32(\"bootdriver\");\n\tXPRAM[0x7a] = i16 >> 8;\n\tXPRAM[0x7b] = i16 & 0xff;\n\n\t// Init drivers\n\tSonyInit();\n\tDiskInit();\n\tCDROMInit();\n\tSCSIInit();\n\n#if SUPPORTS_EXTFS\n\t// Init external file system\n\tExtFSInit();\n#endif\n\n\t// Init serial ports\n\tSerialInit();\n\n\t// Init network\n\tEtherInit();\n\n\t// Init Time Manager\n\tTimerInit();\n\n\t// Init clipboard\n\tClipInit();\n\n\t// Init ADB\n\tADBInit();\n\n\t// Init audio\n\tAudioInit();\n\n\tputs(\"VideoInit\");\n\t// Init video\n\tif (!VideoInit(ROMVersion == ROM_VERSION_64K || ROMVersion == ROM_VERSION_PLUS || ROMVersion == ROM_VERSION_CLASSIC))\n\t\treturn false;\n\n\t// Set default video mode in XPRAM\n\tXPRAM[0x56] = 0x42;\t// 'B'\n\tXPRAM[0x57] = 0x32;\t// '2'\n\tconst monitor_desc &main_monitor = *VideoMonitors[0];\n\tXPRAM[0x58] = main_monitor.depth_to_apple_mode(main_monitor.get_current_mode().depth);\n\tXPRAM[0x59] = 0;\n\n#if EMULATED_68K\n\tputs(\"Init680x0\");\n\t// Init 680x0 emulation (this also activates the memory system which is needed for PatchROM())\n\tif (!Init680x0())\n\t\treturn false;\n#endif\n\n\tputs(\"PatchROM\");\n\t// Install ROM patches\n\tif (!PatchROM()) {\n\t\tErrorAlert(STR_UNSUPPORTED_ROM_TYPE_ERR);\n\t\treturn false;\n\t}\n\n#if ENABLE_MON\n\t// Initialize mon\n\tmon_init();\n\tmon_read_byte = mon_read_byte_b2;\n\tmon_write_byte = mon_write_byte_b2;\n#endif\n\n\treturn true;\n}\n\n\n/*\n *  Deinitialize everything\n */\n\nvoid ExitAll(void)\n{\n#if ENABLE_MON\n\t// Deinitialize mon\n\tmon_exit();\n#endif\n\n\t// Save XPRAM\n\tXPRAMExit();\n\n\t// Exit video\n\tVideoExit();\n\n\t// Exit audio\n\tAudioExit();\n\n\t// Exit ADB\n\tADBExit();\n\n\t// Exit clipboard\n\tClipExit();\n\n\t// Exit Time Manager\n\tTimerExit();\n\n\t// Exit serial ports\n\tSerialExit();\n\n\t// Exit network\n\tEtherExit();\n\n#if SUPPORTS_EXTFS\n\t// Exit external file system\n\tExtFSExit();\n#endif\n\n\t// Exit drivers\n\tSCSIExit();\n\tCDROMExit();\n\tDiskExit();\n\tSonyExit();\n}\n\n\n/*\n *  Display error/warning alert given the message string ID\n */\n\nvoid ErrorAlert(int string_id)\n{\n\tErrorAlert(GetString(string_id));\n}\n\nvoid WarningAlert(int string_id)\n{\n\tWarningAlert(GetString(string_id));\n}\n","// -*- C++ -*-\n//===------------------------------ vector --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_VECTOR\n#define _LIBCPP_VECTOR\n\n/*\n    vector synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Allocator = allocator<T> >\nclass vector\n{\npublic:\n    typedef T                                        value_type;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n);\n    explicit vector(size_type n, const allocator_type&); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value); // C++17\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    value_type*       data() noexcept;\n    const value_type* data() const noexcept;\n\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        reference emplace_back(Args&&... args); // reference in C++17\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(vector&)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator = allocator<T> >\nclass vector<bool, Allocator>\n{\npublic:\n    typedef bool                                     value_type;\n    typedef Allocator                                allocator_type;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef iterator                                 pointer;\n    typedef const_iterator                           const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class reference\n    {\n    public:\n        reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        reference& operator=(const bool x) noexcept;\n        reference& operator=(const reference& x) noexcept;\n        iterator operator&() const noexcept;\n        void flip() noexcept;\n    };\n\n    class const_reference\n    {\n    public:\n        const_reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        const_iterator operator&() const noexcept;\n    };\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n, const allocator_type& a = allocator_type()); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value); // C++17\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    void push_back(const value_type& x);\n    template <class... Args> reference emplace_back(Args&&... args);  // C++14; reference in C++17\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);  // C++14\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, value_type x);\n\n    void swap(vector&)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n    void flip() noexcept;\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator> struct hash<std::vector<bool, Allocator>>;\n\ntemplate <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\n\ntemplate <class T, class Allocator>\nvoid swap(vector<T,Allocator>& x, vector<T,Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd> // for forward declaration of vector\n#include <__bit_reference>\n#include <type_traits>\n#include <climits>\n#include <limits>\n#include <initializer_list>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n#include <cstring>\n#include <__split_buffer>\n#include <__functional_base>\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __vector_base_common\n{\nprotected:\n    _LIBCPP_ALWAYS_INLINE __vector_base_common() {}\n    _LIBCPP_NORETURN void __throw_length_error() const;\n    _LIBCPP_NORETURN void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_length_error() const\n{\n    _VSTD::__throw_length_error(\"vector\");\n}\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_out_of_range() const\n{\n    _VSTD::__throw_out_of_range(\"vector\");\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __vector_base_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\ntemplate <class _Tp, class _Allocator>\nclass __vector_base\n    : protected __vector_base_common<true>\n{\nprotected:\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer& __end_cap() _NOEXCEPT\n        {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const pointer& __end_cap() const _NOEXCEPT\n        {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY __vector_base(const allocator_type& __a);\n    ~__vector_base();\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return static_cast<size_type>(__end_cap() - __begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n            {\n                clear();\n                __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n                __begin_ = __end_ = __end_cap() = nullptr;\n            }\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base&, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base&, false_type)\n        _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), _VSTD::__to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__vector_base<_Tp, _Allocator>::~__vector_base()\n{\n    if (__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n    }\n}\n\ntemplate <class _Tp, class _Allocator /* = allocator<_Tp> */>\nclass _LIBCPP_TEMPLATE_VIS vector\n    : private __vector_base<_Tp, _Allocator>\n{\nprivate:\n    typedef __vector_base<_Tp, _Allocator>           __base;\n    typedef allocator<_Tp>                           __default_allocator_type;\npublic:\n    typedef vector                                   __self;\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef typename __base::__alloc_traits          __alloc_traits;\n    typedef typename __base::reference               reference;\n    typedef typename __base::const_reference         const_reference;\n    typedef typename __base::size_type               size_type;\n    typedef typename __base::difference_type         difference_type;\n    typedef typename __base::pointer                 pointer;\n    typedef typename __base::const_pointer           const_pointer;\n    typedef __wrap_iter<pointer>                     iterator;\n    typedef __wrap_iter<const_pointer>               const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n        : __base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const_reference __x);\n    vector(size_type __n, const_reference __x, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value,\n                                 _InputIterator>::type __last);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value,\n                                 _ForwardIterator>::type __last);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    ~vector()\n    {\n        __get_db()->__erase_c(this);\n    }\n#endif\n\n    vector(const vector& __x);\n    vector(const vector& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(const vector& __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __x)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const_reference __u);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return this->__alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY iterator               begin() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         begin()   const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY iterator               end() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         end()     const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return static_cast<size_type>(this->__end_ - this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __base::capacity();}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return this->__begin_ == this->__end_;}\n    size_type max_size() const _NOEXCEPT;\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n);\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const;\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY reference       back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    value_type*       data() _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_STD_VER > 14\n        reference emplace_back(_Args&&... __args);\n#else\n        void      emplace_back(_Args&&... __args);\n#endif\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n\n    iterator insert(const_iterator __position, const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        iterator emplace(const_iterator __position, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n    {\n        size_type __old_size = size();\n        __base::clear();\n        __annotate_shrink(__old_size);\n        __invalidate_all_iterators();\n    }\n\n    void resize(size_type __sz);\n    void resize(size_type __sz, const_reference __x);\n\n    void swap(vector&)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG;\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(pointer __new_last);\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type __recommend(size_type __new_size) const;\n    void __construct_at_end(size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n);\n    void __append(size_type __n);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       __make_iter(pointer __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(const_pointer __p) const _NOEXCEPT;\n    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);\n    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);\n    void __move_range(pointer __from_s, pointer __from_e, pointer __to);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    void __move_assign(vector& __c, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n    {\n        __invalidate_iterators_past(__new_last);\n        size_type __old_size = size();\n        __base::__destruct_at_end(__new_last);\n        __annotate_shrink(__old_size);\n    }\n    template <class _Up>\n        void\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        __push_back_slow_path(_Up&& __x);\n#else\n        __push_back_slow_path(_Up& __x);\n#endif\n#if !defined(_LIBCPP_HAS_NO_VARIADICS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class... _Args>\n        void\n        __emplace_back_slow_path(_Args&&... __args);\n#endif\n    // The following functions are no-ops outside of AddressSanitizer mode.\n    // We call annotatations only for the default Allocator because other allocators\n    // may not meet the AddressSanitizer alignment constraints.\n    // See the documentation for __sanitizer_annotate_contiguous_container for more details.\n#ifndef _LIBCPP_HAS_NO_ASAN\n    void __annotate_contiguous_container(const void *__beg, const void *__end,\n                                         const void *__old_mid,\n                                         const void *__new_mid) const\n    {\n\n      if (__beg && is_same<allocator_type, __default_allocator_type>::value)\n        __sanitizer_annotate_contiguous_container(__beg, __end, __old_mid, __new_mid);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_contiguous_container(const void*, const void*, const void*,\n                                         const void*) const {}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_new(size_type __current_size) const {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + capacity(), data() + __current_size);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_delete() const {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + capacity());\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_increase(size_type __n) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + size() + __n);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __annotate_shrink(size_type __old_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + __old_size, data() + size());\n    }\n#ifndef _LIBCPP_HAS_NO_ASAN\n    // The annotation for size increase should happen before the actual increase,\n    // but if an exception is thrown after that the annotation has to be undone.\n    struct __RAII_IncreaseAnnotator {\n      __RAII_IncreaseAnnotator(const vector &__v, size_type __n = 1)\n        : __commit(false), __v(__v), __old_size(__v.size() + __n) {\n        __v.__annotate_increase(__n);\n      }\n      void __done() { __commit = true; }\n      ~__RAII_IncreaseAnnotator() {\n        if (__commit) return;\n        __v.__annotate_shrink(__old_size);\n      }\n      bool __commit;\n      const vector &__v;\n      size_type __old_size;\n    };\n#else\n    struct __RAII_IncreaseAnnotator {\n      _LIBCPP_INLINE_VISIBILITY\n      __RAII_IncreaseAnnotator(const vector &, size_type = 1) {}\n      _LIBCPP_INLINE_VISIBILITY void __done() {}\n    };\n#endif\n\n};\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)\n{\n    __annotate_delete();\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::pointer\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)\n{\n    __annotate_delete();\n    pointer __r = __v.__begin_;\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, __p, __v.__begin_);\n    __alloc_traits::__construct_forward(this->__alloc(), __p, this->__end_, __v.__end_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n    return __r;\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __end_cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);\n    this->__end_cap() = this->__begin_ + __n;\n    __annotate_new(0);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());\n        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::max_size() const _NOEXCEPT\n{\n    return _VSTD::min<size_type>(__alloc_traits::max_size(this->__alloc()),\n                                 numeric_limits<difference_type>::max());\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max<size_type>(2*__cap, __new_size);\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    __RAII_IncreaseAnnotator __annotator(*this, __n);\n    __alloc_traits::__construct_range_forward(__a, __first, __last, this->__end_);\n    __annotator.__done();\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n, __x);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n, __x);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n#endif\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value,\n                          _InputIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value,\n                                                   _ForwardIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x)\n    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_, __n);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_, __n);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#endif\n    : __base(_VSTD::move(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__x);\n#endif\n    this->__begin_ = __x.__begin_;\n    this->__end_ = __x.__end_;\n    this->__end_cap() = __x.__end_cap();\n    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __x.__alloc())\n    {\n        this->__begin_ = __x.__begin_;\n        this->__end_ = __x.__end_;\n        this->__end_cap() = __x.__end_cap();\n        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->swap(this, &__x);\n#endif\n    }\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__x.begin()), _Ip(__x.end()));\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end(), __il.size());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end(), __il.size());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(vector&& __x)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__x, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__base::__alloc() != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __base::__move_assign_alloc(__c); // this can throw\n    this->__begin_ = __c.__begin_;\n    this->__end_ = __c.__end_;\n    this->__end_cap() = __c.__end_cap();\n    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__c);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(const vector& __x)\n{\n    if (this != &__x)\n    {\n        __base::__copy_assign_alloc(__x);\n        assign(__x.__begin_, __x.__end_);\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __new_size = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__new_size <= capacity())\n    {\n        _ForwardIterator __mid = __last;\n        bool __growing = false;\n        if (__new_size > size())\n        {\n            __growing = true;\n            __mid =  __first;\n            _VSTD::advance(__mid, size());\n        }\n        pointer __m = _VSTD::copy(__first, __mid, this->__begin_);\n        if (__growing)\n            __construct_at_end(__mid, __last, __new_size - size());\n        else\n            this->__destruct_at_end(__m);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(__new_size));\n        __construct_at_end(__first, __last, __new_size);\n    }\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)\n{\n    if (__n <= capacity())\n    {\n        size_type __s = size();\n        _VSTD::fill_n(this->__begin_, _VSTD::min(__n, __s), __u);\n        if (__n > __s)\n            __construct_at_end(__n - __s, __u);\n        else\n            this->__destruct_at_end(this->__begin_ + __n);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__n)));\n        __construct_at_end(__n, __u);\n    }\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::__make_iter(pointer __p) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p);\n#else\n    return iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::__make_iter(const_pointer __p) const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(this, __p);\n#else\n    return const_iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::begin() _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::begin() const _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::end() _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::end() const _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::operator[](size_type __n)\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::operator[](size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);\n            __swap_out_circular_buffer(__v);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _Up>\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)\n#else\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up& __x)\n#endif\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n    // __v.push_back(_VSTD::forward<_Up>(__x));\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Up>(__x));\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (this->__end_ != this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_), __x);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(__x);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(__x));\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(_VSTD::move(__x));\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\nvector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n//    __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Args>(__args)...);\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ninline\n#if _LIBCPP_STD_VER > 14\ntypename vector<_Tp, _Allocator>::reference\n#else\nvoid\n#endif\nvector<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::forward<_Args>(__args)...);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __emplace_back_slow_path(_VSTD::forward<_Args>(__args)...);\n#if _LIBCPP_STD_VER > 14\n    return this->back();\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\nvector<_Tp, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"vector::pop_back called for empty vector\");\n    this->__destruct_at_end(this->__end_ - 1);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __position)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::erase(iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__position != end(),\n        \"vector::erase(iterator) called with a non-dereferenceable iterator\");\n    difference_type __ps = __position - cbegin();\n    pointer __p = this->__begin_ + __ps;\n    this->__destruct_at_end(_VSTD::move(__p + 1, this->__end_, __p));\n    this->__invalidate_iterators_past(__p-1);\n    iterator __r = __make_iter(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__last) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"vector::erase(first, last) called with invalid range\");\n    pointer __p = this->__begin_ + (__first - begin());\n    if (__first != __last) {\n        this->__destruct_at_end(_VSTD::move(__p + (__last - __first), this->__end_, __p));\n        this->__invalidate_iterators_past(__p - 1);\n    }\n    iterator __r = __make_iter(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)\n{\n    pointer __old_last = this->__end_;\n    difference_type __n = __old_last - __to;\n    for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(*__i));\n    _VSTD::move_backward(__from_s, __from_s + __n, __old_last);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_), __x);\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n            if (__p <= __xr && __xr < this->__end_)\n                ++__xr;\n            *__p = *__xr;\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(__x);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::move(__x));\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__x);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(_VSTD::move(__x));\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::emplace(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::forward<_Args>(__args)...);\n            ++this->__end_;\n        }\n        else\n        {\n            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), _VSTD::forward<_Args>(__args)...);\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__tmp.get());\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (__n > 0)\n    {\n        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            if (__n > static_cast<size_type>(this->__end_ - __p))\n            {\n                size_type __cx = __n - (this->__end_ - __p);\n                __construct_at_end(__cx, __x);\n                __n -= __cx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n                if (__p <= __xr && __xr < this->__end_)\n                    __xr += __old_n;\n                _VSTD::fill_n(__p, __n, *__xr);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__n, __x);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    difference_type __off = __position - begin();\n    pointer __p = this->__begin_ + __off;\n    allocator_type& __a = this->__alloc();\n    pointer __old_last = this->__end_;\n    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_),\n                                  *__first);\n        ++this->__end_;\n        __annotator.__done();\n    }\n    __split_buffer<value_type, allocator_type&> __v(__a);\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.__construct_at_end(__first, __last);\n            difference_type __old_size = __old_last - this->__begin_;\n            difference_type __old_p = __p - this->__begin_;\n            reserve(__recommend(size() + __v.size()));\n            __p = this->__begin_ + __old_p;\n            __old_last = this->__begin_ + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__make_iter(__old_last), end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_last, this->__end_);\n    insert(__make_iter(__p), make_move_iterator(__v.begin()),\n                                    make_move_iterator(__v.end()));\n    return begin() + __off;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n > 0)\n    {\n        if (__n <= this->__end_cap() - this->__end_)\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            _ForwardIterator __m = __last;\n            difference_type __dx = this->__end_ - __p;\n            if (__n > __dx)\n            {\n                __m = __first;\n                difference_type __diff = this->__end_ - __p;\n                _VSTD::advance(__m, __diff);\n                __construct_at_end(__m, __last, __n - __diff);\n                __n = __dx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                _VSTD::copy(__first, __m, __p);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__first, __last);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs, __x);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::swap(vector& __x)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT_DEBUG\n#else\n    _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__alloc() == __x.__alloc(),\n                   \"vector::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__end_, __x.__end_);\n    _VSTD::swap(this->__end_cap(), __x.__end_cap());\n    __swap_allocator(this->__alloc(), __x.__alloc(), \n        integral_constant<bool,__alloc_traits::propagate_on_container_swap::value>());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__x);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__end_ != nullptr || this->__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (this->__begin_ > this->__end_)\n            return false;\n        if (this->__begin_ == this->__end_cap())\n            return false;\n        if (this->__end_ > this->__end_cap())\n            return false;\n    }\n    return true;\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->__begin_ <= __i->base() && __i->base() < this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->__begin_ < __i->base() && __i->base() <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p < this->__end_;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_iterators_past(pointer __new_last) {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n  __c_node* __c = __get_db()->__find_c_and_lock(this);\n  for (__i_node** __p = __c->end_; __p != __c->beg_; ) {\n    --__p;\n    const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n    if (__i->base() > __new_last) {\n      (*__p)->__c_ = nullptr;\n      if (--__c->end_ != __p)\n        memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n    }\n  }\n  __get_db()->unlock();\n#else\n  ((void)__new_last);\n#endif\n}\n\n// vector<bool>\n\ntemplate <class _Allocator> class vector<bool, _Allocator>;\n\ntemplate <class _Allocator> struct hash<vector<bool, _Allocator> >;\n\ntemplate <class _Allocator>\nstruct __has_storage_type<vector<bool, _Allocator> >\n{\n    static const bool value = true;\n};\n\ntemplate <class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS vector<bool, _Allocator>\n    : private __vector_base_common<true>\n{\npublic:\n    typedef vector                                   __self;\n    typedef bool                                     value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef size_type __storage_type;\n    typedef __bit_iterator<vector, false>            pointer;\n    typedef __bit_iterator<vector, true>             const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\nprivate:\n    typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type __storage_allocator;\n    typedef allocator_traits<__storage_allocator>    __storage_traits;\n    typedef typename __storage_traits::pointer       __storage_pointer;\n    typedef typename __storage_traits::const_pointer __const_storage_pointer;\n\n    __storage_pointer                                      __begin_;\n    size_type                                              __size_;\n    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;\npublic:\n    typedef __bit_reference<vector>                  reference;\n    typedef __bit_const_reference<vector>            const_reference;\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& __cap() _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __cap() const _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    __storage_allocator& __alloc() _NOEXCEPT\n        {return __cap_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __storage_allocator& __alloc() const _NOEXCEPT\n        {return __cap_alloc_.second();}\n\n    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __internal_cap_to_external(size_type __n) _NOEXCEPT\n        {return __n * __bits_per_word;}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __external_cap_to_internal(size_type __n) _NOEXCEPT\n        {return (__n - 1) / __bits_per_word + 1;}\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n    ~vector();\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const value_type& __v);\n    vector(size_type __n, const value_type& __v, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n\n    vector(const vector& __v);\n    vector(const vector& __v, const allocator_type& __a);\n    vector& operator=(const vector& __v);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    vector(initializer_list<value_type> __il);\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __v)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#endif\n    vector(vector&& __v, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __v)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value &&\n           !__is_forward_iterator<_InputIterator>::value,\n           void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n           void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const value_type& __x);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(this->__alloc());}\n\n    size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __internal_cap_to_external(__cap());}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return __size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return __size_ == 0;}\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT\n        {return __make_iter(__size_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n)       {return __make_ref(__n);}\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const {return __make_ref(__n);}\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()       {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY reference       back()        {return __make_ref(__size_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const {return __make_ref(__size_ - 1);}\n\n    void push_back(const value_type& __x);\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY reference emplace_back(_Args&&... __args)\n#else\n    _LIBCPP_INLINE_VISIBILITY void      emplace_back(_Args&&... __args)\n#endif\n    {\n        push_back ( value_type ( _VSTD::forward<_Args>(__args)... ));\n#if _LIBCPP_STD_VER > 14\n        return this->back();\n#endif\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {--__size_;}\n\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n   _LIBCPP_INLINE_VISIBILITY iterator emplace(const_iterator position, _Args&&... __args)\n        { return insert ( position, value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    iterator insert(const_iterator __position, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__size_ = 0;}\n\n    void swap(vector&)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n    static void swap(reference __x, reference __y) _NOEXCEPT { _VSTD::swap(__x, __y); }\n\n    void resize(size_type __sz, value_type __x = false);\n    void flip() _NOEXCEPT;\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __align_it(size_type __new_size) _NOEXCEPT\n        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);};\n    _LIBCPP_INLINE_VISIBILITY  size_type __recommend(size_type __new_size) const;\n    _LIBCPP_INLINE_VISIBILITY void __construct_at_end(size_type __n, bool __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    reference __make_ref(size_type __pos) _NOEXCEPT\n        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference __make_ref(size_type __pos) const _NOEXCEPT\n        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __make_iter(size_type __pos) _NOEXCEPT\n        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(size_type __pos) const _NOEXCEPT\n        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __const_iterator_cast(const_iterator __p) _NOEXCEPT\n        {return begin() + (__p - cbegin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __v)\n        {__copy_assign_alloc(__v, integral_constant<bool,\n                      __storage_traits::propagate_on_container_copy_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n                deallocate();\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector&, false_type)\n        {}\n\n    void __move_assign(vector& __c, false_type);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __storage_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector&, false_type)\n        _NOEXCEPT\n        {}\n\n    size_t __hash_code() const _NOEXCEPT;\n\n    friend class __bit_reference<vector>;\n    friend class __bit_const_reference<vector>;\n    friend class __bit_iterator<vector, false>;\n    friend class __bit_iterator<vector, true>;\n    friend struct __bit_array<vector>;\n    friend struct _LIBCPP_TEMPLATE_VIS hash<vector>;\n};\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__invalidate_all_iterators()\n{\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    __n = __external_cap_to_internal(__n);\n    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);\n    this->__size_ = 0;\n    this->__cap() = __n;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());\n        __invalidate_all_iterators();\n        this->__begin_ = nullptr;\n        this->__size_ = this->__cap() = 0;\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __amax = __storage_traits::max_size(__alloc());\n    size_type __nmax = numeric_limits<size_type>::max() / 2;  // end() >= begin(), always\n    if (__nmax / __bits_per_word <= __amax)\n        return __nmax;\n    return __internal_cap_to_external(__amax);\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max(2*__cap, __align_it(__new_size));\n}\n\n//  Default constructs __n objects starting at __end_\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += __n;\n    _VSTD::fill_n(__make_iter(__old_size), __n, __x);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += _VSTD::distance(__first, __last);\n    _VSTD::copy(__first, __last, __make_iter(__old_size));\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n#endif\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::~vector()\n{\n    if (__begin_ != nullptr)\n        __storage_traits::deallocate(__alloc(), __begin_, __cap());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(const vector& __v)\n{\n    if (this != &__v)\n    {\n        __copy_assign_alloc(__v);\n        if (__v.__size_)\n        {\n            if (__v.__size_ > capacity())\n            {\n                deallocate();\n                allocate(__v.__size_);\n            }\n            _VSTD::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);\n        }\n        __size_ = __v.__size_;\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(vector&& __v)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT\n#else\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#endif\n    : __begin_(__v.__begin_),\n      __size_(__v.__size_),\n      __cap_alloc_(__v.__cap_alloc_)\n{\n    __v.__begin_ = nullptr;\n    __v.__size_ = 0;\n    __v.__cap() = 0;\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__a == allocator_type(__v.__alloc()))\n    {\n        this->__begin_ = __v.__begin_;\n        this->__size_ = __v.__size_;\n        this->__cap() = __v.__cap();\n        __v.__begin_ = nullptr;\n        __v.__cap() = __v.__size_ = 0;\n    }\n    else if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(vector&& __v)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__v, integral_constant<bool,\n          __storage_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__alloc() != __c.__alloc())\n        assign(__c.begin(), __c.end());\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __move_assign_alloc(__c);\n    this->__begin_ = __c.__begin_;\n    this->__size_ = __c.__size_;\n    this->__cap() = __c.__cap();\n    __c.__begin_ = nullptr;\n    __c.__cap() = __c.__size_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::assign(size_type __n, const value_type& __x)\n{\n    __size_ = 0;\n    if (__n > 0)\n    {\n        size_type __c = capacity();\n        if (__n <= __c)\n            __size_ = __n;\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__n));\n            __v.__size_ = __n;\n            swap(__v);\n        }\n        _VSTD::fill_n(begin(), __n, __x);\n    }\n  __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_forward_iterator<_InputIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    clear();\n    difference_type __ns = _VSTD::distance(__first, __last);\n    _LIBCPP_ASSERT(__ns >= 0, \"invalid range specified\");\n    const size_t __n = static_cast<size_type>(__ns);\n    if (__n)\n    {\n        if (__n > capacity())\n        {\n            deallocate();\n            allocate(__n);\n        }\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        vector __v(this->__alloc());\n        __v.allocate(__n);\n        __v.__construct_at_end(this->begin(), this->end());\n        swap(__v);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (__external_cap_to_internal(size()) > __cap())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            vector(*this, allocator_type(__alloc())).swap(*this);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::reference\nvector<bool, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::const_reference\nvector<bool, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::push_back(const value_type& __x)\n{\n    if (this->__size_ == this->capacity())\n        reserve(__recommend(this->__size_ + 1));\n    ++this->__size_;\n    back() = __x;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)\n{\n    iterator __r;\n    if (size() < capacity())\n    {\n        const_iterator __old_end = end();\n        ++__size_;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + 1));\n        __v.__size_ = __size_ + 1;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    *__r = __x;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)\n{\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::fill_n(__r, __n, __x);\n    return __r;\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n    difference_type __off = __position - begin();\n    iterator __p = __const_iterator_cast(__position);\n    iterator __old_end = end();\n    for (; size() != capacity() && __first != __last; ++__first)\n    {\n        ++this->__size_;\n        back() = *__first;\n    }\n    vector __v(__alloc());\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.assign(__first, __last);\n            difference_type __old_size = static_cast<difference_type>(__old_end - begin());\n            difference_type __old_p = __p - begin();\n            reserve(__recommend(size() + __v.size()));\n            __p = begin() + __old_p;\n            __old_end = begin() + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__old_end, end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_end, end());\n    insert(__p, __v.begin(), __v.end());\n    return begin() + __off;\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n    const difference_type __n_signed = _VSTD::distance(__first, __last);\n    _LIBCPP_ASSERT(__n_signed >= 0, \"invalid range specified\");\n    const size_type __n = static_cast<size_type>(__n_signed);\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::copy(__first, __last, __r);\n    return __r;\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __position)\n{\n    iterator __r = __const_iterator_cast(__position);\n    _VSTD::copy(__position + 1, this->cend(), __r);\n    --__size_;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n    iterator __r = __const_iterator_cast(__first);\n    difference_type __d = __last - __first;\n    _VSTD::copy(__last, this->cend(), __r);\n    __size_ -= __d;\n    return __r;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::swap(vector& __x)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__size_, __x.__size_);\n    _VSTD::swap(this->__cap(), __x.__cap());\n    __swap_allocator(this->__alloc(), __x.__alloc(), \n        integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::resize(size_type __sz, value_type __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n    {\n        iterator __r;\n        size_type __c = capacity();\n        size_type __n = __sz - __cs;\n        if (__n <= __c && __cs <= __c - __n)\n        {\n            __r = end();\n            __size_ += __n;\n        }\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__size_ + __n));\n            __v.__size_ = __size_ + __n;\n            __r = _VSTD::copy(cbegin(), cend(), __v.begin());\n            swap(__v);\n        }\n        _VSTD::fill_n(__r, __n, __x);\n    }\n    else\n        __size_ = __sz;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::flip() _NOEXCEPT\n{\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        *__p = ~*__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = *__p & __m;\n        *__p &= ~__m;\n        *__p |= ~__b & __m;\n    }\n}\n\ntemplate <class _Allocator>\nbool\nvector<bool, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__size_ != 0 || this->__cap() != 0)\n            return false;\n    }\n    else\n    {\n        if (this->__cap() == 0)\n            return false;\n        if (this->__size_ > this->capacity())\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Allocator>\nsize_t\nvector<bool, _Allocator>::__hash_code() const _NOEXCEPT\n{\n    size_t __h = 0;\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        __h ^= *__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __h ^= *__p & __m;\n    }\n    return __h;\n}\n\ntemplate <class _Allocator>\nstruct _LIBCPP_TEMPLATE_VIS hash<vector<bool, _Allocator> >\n    : public unary_function<vector<bool, _Allocator>, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const vector<bool, _Allocator>& __vec) const _NOEXCEPT\n        {return __vec.__hash_code();}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();\n    return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_VECTOR\n","/*\n *  video.h - Video/graphics emulation\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef VIDEO_H\n#define VIDEO_H\n\n#include <vector>\n\n#ifndef NO_STD_NAMESPACE\nusing std::vector;\n#endif\n\n\n/*\n   Some of the terminology here is completely frelled. In Basilisk II, a\n   \"video mode\" refers to a combination of resolution and color depth, and\n   this information is stored in a video_mode structure. In Apple\n   documentation, a \"mode\" historically refers to the color depth only\n   (because old Macs had fixed-frequency monitors and could not change the\n   resolution). These \"modes\" are assigned a number (0x80, 0x81, etc.),\n   which we here call \"Apple mode\". When Macs learned how to deal with\n   multiscan monitors, Apple introduced another type of \"mode\", also having\n   numbers starting from 0x80 but refrerring to the resolution and/or video\n   timing of the display (it's possible to have two modes with the same\n   dimension but different refresh rates). We call this a \"resolution ID\". \n   The combination of \"Apple mode\" and \"ID\" corresponds to a Basilisk II\n   \"video mode\". To make the confusion worse, the video driver control call\n   that sets the color depth is called \"SetMode\" while the one that sets\n   both depth and resolution is \"SwitchMode\"...\n*/\n\n// Color depth codes\nenum video_depth {\n\tVDEPTH_1BIT,  // 2 colors\n\tVDEPTH_2BIT,  // 4 colors\n\tVDEPTH_4BIT,  // 16 colors\n\tVDEPTH_8BIT,  // 256 colors\n\tVDEPTH_16BIT, // \"Thousands\"\n\tVDEPTH_32BIT  // \"Millions\"\n};\n\n// 1, 2, 4 and 8 bit depths use a color palette\ninline bool IsDirectMode(video_depth depth)\n{\n\treturn depth == VDEPTH_16BIT || depth == VDEPTH_32BIT;\n}\n\n// Return the depth code that corresponds to the specified bits-per-pixel value\ninline video_depth DepthModeForPixelDepth(int depth)\n{\n\tswitch (depth) {\n\t\tcase 1: return VDEPTH_1BIT;\n\t\tcase 2: return VDEPTH_2BIT;\n\t\tcase 4: return VDEPTH_4BIT;\n\t\tcase 8: return VDEPTH_8BIT;\n\t\tcase 15: case 16: return VDEPTH_16BIT;\n\t\tcase 24: case 32: return VDEPTH_32BIT;\n\t\tdefault: return VDEPTH_1BIT;\n\t}\n}\n\n// Return a bytes-per-row value (assuming no padding) for the specified depth and pixel width\ninline uint32 TrivialBytesPerRow(uint32 width, video_depth depth)\n{\n\tswitch (depth) {\n\t\tcase VDEPTH_1BIT: return width / 8;\n\t\tcase VDEPTH_2BIT: return width / 4;\n\t\tcase VDEPTH_4BIT: return width / 2;\n\t\tcase VDEPTH_8BIT: return width;\n\t\tcase VDEPTH_16BIT: return width * 2;\n\t\tcase VDEPTH_32BIT: return width * 4;\n\t\tdefault: return width;\n\t}\n}\n\n\n/*\n   You are not completely free in your selection of depth/resolution\n   combinations:\n     1) the lowest supported color depth must be available in all\n        resolutions\n     2) if one resolution provides a certain color depth, it must also\n        provide all lower supported depths\n\n   For example, it is possible to have this set of modes:\n     640x480 @ 8 bit\n     640x480 @ 32 bit\n     800x600 @ 8 bit\n     800x600 @ 32 bit\n     1024x768 @ 8 bit\n\n   But this is not possible (violates rule 1):\n     640x480 @ 8 bit\n     800x600 @ 8 bit\n     1024x768 @ 1 bit\n\n   And neither is this (violates rule 2, 640x480 @ 16 bit is missing):\n     640x480 @ 8 bit\n     640x480 @ 32 bit\n     800x600 @ 8 bit\n     800x600 @ 16 bit\n     1024x768 @ 8 bit\n*/\n\n// Description of a video mode\nstruct video_mode {\n\tuint32 x;\t\t\t\t// X size of screen (pixels)\n\tuint32 y;\t\t\t\t// Y size of screen (pixels)\n\tuint32 resolution_id;\t// Resolution ID (should be >= 0x80 and uniquely identify the sets of modes with the same X/Y size)\n\tvideo_depth depth;\t\t// Color depth (see definitions above)\n\tuint32 bytes_per_row;\t// Bytes per row of frame buffer\n\tuint32 user_data;\t\t// Free for use by platform-specific code\n};\n\ninline bool IsDirectMode(const video_mode &mode)\n{\n\treturn IsDirectMode(mode.depth);\n}\n\n\n// Mac video driver per-display private variables (opaque)\nstruct video_locals;\n\n\n// Abstract base class representing one (possibly virtual) monitor\n// (\"monitor\" = rectangular display with a contiguous frame buffer)\nclass monitor_desc {\npublic:\n\tmonitor_desc(const vector<video_mode> &available_modes, video_depth default_depth, uint32 default_id);\n\tvirtual ~monitor_desc() {}\n\n\t// Get Mac slot ID number\n\tuint8 get_slot_id(void) const {return slot_id;}\n\n\t// Get current Mac frame buffer base address\n\tuint32 get_mac_frame_base(void) const {return mac_frame_base;}\n\n\t// Set Mac frame buffer base address (called from switch_to_mode())\n\tvoid set_mac_frame_base(uint32 base) {mac_frame_base = base;}\n\n\t// Get current video mode\n\tconst video_mode &get_current_mode(void) const {return *current_mode;}\n\n\t// Get Apple mode id for given depth\n\tuint16 depth_to_apple_mode(video_depth depth) const {return apple_mode_for_depth[depth];}\n\n\t// Get current color depth\n\tuint16 get_apple_mode(void) const {return depth_to_apple_mode(current_mode->depth);}\n\n\t// Get bytes-per-row value for specified resolution/depth\n\t// (if the mode isn't supported, make a good guess)\n\tuint32 get_bytes_per_row(video_depth depth, uint32 id) const;\n\n\t// Check whether a mode with the specified depth exists on this display\n\tbool has_depth(video_depth depth) const;\n\n\t// Mac video driver functions\n\tint16 driver_open(void);\n\tint16 driver_control(uint16 code, uint32 param, uint32 dce);\n\tint16 driver_status(uint16 code, uint32 param);\n\nprotected:\n\tvector<video_mode> modes;                         // List of supported video modes\n\tvector<video_mode>::const_iterator current_mode;  // Currently selected video mode\n\n\tuint32 mac_frame_base;  // Mac frame buffer address for current mode\n\n// Mac video driver per-display private variables/functions\nprivate:\n\t// Check whether the specified resolution ID is one of the supported resolutions\n\tbool has_resolution(uint32 id) const;\n\n\t// Return iterator signifying \"invalid mode\"\n\tvector<video_mode>::const_iterator invalid_mode(void) const {return modes.end();}\n\n\t// Find specified mode (depth/resolution) (or invalid_mode() if not found)\n\tvector<video_mode>::const_iterator find_mode(uint16 apple_mode, uint32 id) const;\n\n\t// Find maximum supported depth for given resolution ID\n\tvideo_depth max_depth_of_resolution(uint32 id) const;\n\n\t// Get X/Y size of specified resolution\n\tvoid get_size_of_resolution(uint32 id, uint32 &x, uint32 &y) const;\n\n\t// Set palette to 50% gray\n\tvoid set_gray_palette(void);\n\n\t// Load gamma-corrected black-to-white ramp to palette for direct-color mode\n\tvoid load_ramp_palette(void);\n\n\t// Allocate gamma table of specified size\n\tbool allocate_gamma_table(int size);\n\n\t// Set gamma table (0 = build linear ramp)\n\tbool set_gamma_table(uint32 user_table);\n\n\t// Switch video mode\n\tvoid switch_mode(vector<video_mode>::const_iterator it, uint32 param, uint32 dce);\n\n\tuint8 slot_id;               // NuBus slot ID number\n\tstatic uint8 next_slot_id;   // Next available slot ID\n\n\tuint8 palette[256 * 3];      // Color palette, 256 entries, RGB\n\n\tbool luminance_mapping;      // Luminance mapping on/off\n\tbool interrupts_enabled;     // VBL interrupts on/off\n\tbool dm_present;             // We received a GetVideoParameters call, so the Display Manager seems to be present\n\n\tuint32 gamma_table;          // Mac address of gamma table\n\tint alloc_gamma_table_size;  // Allocated size of gamma table\n\n\tuint16 current_apple_mode;   // Currently selected depth/resolution\n\tuint32 current_id;\n\tuint16 preferred_apple_mode; // Preferred depth/resolution\n\tuint32 preferred_id;\n\n\tuint32 slot_param;           // Mac address of Slot Manager parameter block\n\n\t// For compatibility reasons with older (pre-Display Manager) versions of\n\t// MacOS, the Apple modes must start at 0x80 and be contiguous. Therefore\n\t// we maintain an array to map the depth codes to the corresponding Apple\n\t// mode.\n\tuint16 apple_mode_for_depth[6];\n\n// The following functions are implemented by platform-specific code\npublic:\n\n\t// Called by the video driver to switch the video mode on this display\n\t// (must call set_mac_frame_base())\n\tvirtual void switch_to_current_mode(void) = 0;\n\n\t// Called by the video driver to set the color palette (in indexed modes)\n\t// or the gamma table (in direct modes)\n\tvirtual void set_palette(uint8 *pal, int num) = 0;\n};\n\n// Vector of pointers to available monitor descriptions, filled by VideoInit()\nextern vector<monitor_desc *> VideoMonitors;\n\n\nextern int16 VideoDriverOpen(uint32 pb, uint32 dce);\nextern int16 VideoDriverControl(uint32 pb, uint32 dce);\nextern int16 VideoDriverStatus(uint32 pb, uint32 dce);\n\n\n// System specific and internal functions/data\nextern bool VideoInit(bool classic);\nextern void VideoExit(void);\n\nextern void VideoQuitFullScreen(void);\n\nextern void VideoInterrupt(void);\nextern void VideoRefresh(void);\n\n#endif\n","/*\n *  prefs.cpp - Preferences handling\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"sysdeps.h\"\n#include \"sys.h\"\n#include \"prefs.h\"\n\n\n// Prefs items are stored in a linked list of these nodes\nstruct prefs_node {\n\tprefs_node *next;\n\tconst char *name;\n\tprefs_type type;\n\tvoid *data;\n};\n\n// List of prefs nodes\nstatic prefs_node *the_prefs = NULL;\n\n// Prototypes\nstatic const prefs_desc *find_prefs_desc(const char *name);\n\n\n/*\n *  Initialize preferences\n */\n\nvoid PrefsInit(const char *vmdir, int &argc, char **&argv)\n{\n\t// Set defaults\n\tAddPrefsDefaults();\n\tAddPlatformPrefsDefaults();\n\n\t// Load preferences from settings file\n\tLoadPrefs(vmdir);\n\n\t// Override prefs with command line options\n\tfor (int i=1; i<argc; i++) {\n\n\t\t// Options are of the form '--keyword'\n\t\tconst char *option = argv[i];\n\t\tif (!option || strlen(option) < 3 || option[0] != '-' || option[1] != '-')\n\t\t\tcontinue;\n\t\tconst char *keyword = option + 2;\n\n\t\t// Find descriptor for keyword\n\t\tconst prefs_desc *d = find_prefs_desc(keyword);\n\t\tif (d == NULL)\n\t\t\tcontinue;\n\t\targv[i] = NULL;\n\n\t\t// Get value\n\t\ti++;\n\t\tif (i >= argc) {\n\t\t\tfprintf(stderr, \"Option '%s' must be followed by a value\\n\", option);\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *value = argv[i];\n\t\targv[i] = NULL;\n\n\t\t// Add/replace prefs item\n\t\tswitch (d->type) {\n\t\t\tcase TYPE_STRING:\n\t\t\t\tif (d->multiple)\n\t\t\t\t\tPrefsAddString(keyword, value);\n\t\t\t\telse\n\t\t\t\t\tPrefsReplaceString(keyword, value);\n\t\t\t\tbreak;\n\n\t\t\tcase TYPE_BOOLEAN: {\n\t\t\t\tif (!strcmp(value, \"true\") || !strcmp(value, \"on\") || !strcmp(value, \"yes\"))\n\t\t\t\t\tPrefsReplaceBool(keyword, true);\n\t\t\t\telse if (!strcmp(value, \"false\") || !strcmp(value, \"off\") || !strcmp(value, \"no\"))\n\t\t\t\t\tPrefsReplaceBool(keyword, false);\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \"Value for option '%s' must be 'true' or 'false'\\n\", option);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase TYPE_INT32:\n\t\t\t\tPrefsReplaceInt32(keyword, atoi(value));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Remove processed arguments\n\tfor (int i=1; i<argc; i++) {\n\t\tint k;\n\t\tfor (k=i; k<argc; k++)\n\t\t\tif (argv[k] != NULL)\n\t\t\t\tbreak;\n\t\tif (k > i) {\n\t\t\tk -= i;\n\t\t\tfor (int j=i+k; j<argc; j++)\n\t\t\t\targv[j-k] = argv[j];\n\t\t\targc -= k;\n\t\t}\n\t}\n\n#ifdef SHEEPSHAVER\n\t// System specific initialization\n\tprefs_init();\n#endif\n}\n\n\n/*\n *  Deinitialize preferences\n */\n\nvoid PrefsExit(void)\n{\n#ifdef SHEEPSHAVER\n\t// System specific deinitialization\n\tprefs_exit();\n#endif\n\n\t// Free prefs list\n\tprefs_node *p = the_prefs, *next;\n\twhile (p) {\n\t\tnext = p->next;\n\t\tfree((void *)p->name);\n\t\tfree(p->data);\n\t\tdelete p;\n\t\tp = next;\n\t}\n\tthe_prefs = NULL;\n}\n\n\n/*\n *  Print preferences options help\n */\n\nstatic void print_options(const prefs_desc *list)\n{\n\twhile (list->type != TYPE_END) {\n\t\tif (list->help) {\n\t\t\tconst char *typestr, *defstr;\n\t\t\tchar numstr[32];\n\t\t\tswitch (list->type) {\n\t\t\t\tcase TYPE_STRING:\n\t\t\t\t\ttypestr = \"STRING\";\n\t\t\t\t\tdefstr = PrefsFindString(list->name);\n\t\t\t\t\tif (defstr == NULL)\n\t\t\t\t\t\tdefstr = \"none\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE_BOOLEAN:\n\t\t\t\t\ttypestr = \"BOOL\";\n\t\t\t\t\tif (PrefsFindBool(list->name))\n\t\t\t\t\t\tdefstr = \"true\";\n\t\t\t\t\telse\n\t\t\t\t\t\tdefstr = \"false\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE_INT32:\n\t\t\t\t\ttypestr = \"NUMBER\";\n\t\t\t\t\tsprintf(numstr, \"%d\", PrefsFindInt32(list->name));\n\t\t\t\t\tdefstr = numstr;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttypestr = \"<unknown>\";\n\t\t\t\t\tdefstr = \"none\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintf(\"  --%s %s\\n    %s [default=%s]\\n\", list->name, typestr, list->help, defstr);\n\t\t}\n\t\tlist++;\n\t}\n}\n\nvoid PrefsPrintUsage(void)\n{\n\tprintf(\"\\nGeneral options:\\n\");\n\tprint_options(common_prefs_items);\n\tprintf(\"\\nPlatform-specific options:\\n\");\n\tprint_options(platform_prefs_items);\n\tprintf(\"\\nBoolean options are specified as '--OPTION true|on|yes' or\\n'--OPTION false|off|no'.\\n\");\n}\n\n\n/*\n *  Find preferences descriptor by keyword\n */\n\nstatic const prefs_desc *find_prefs_desc(const char *name, const prefs_desc *list)\n{\n\twhile (list->type != TYPE_ANY) {\n\t\tif (strcmp(list->name, name) == 0)\n\t\t\treturn list;\n\t\tlist++;\n\t}\n\treturn NULL;\n}\n\nstatic const prefs_desc *find_prefs_desc(const char *name)\n{\n\tconst prefs_desc *d = find_prefs_desc(name, common_prefs_items);\n\tif (d == NULL)\n\t\td = find_prefs_desc(name, platform_prefs_items);\n\treturn d;\n}\n\n\n/*\n *  Set prefs items\n */\n\nstatic void add_data(const char *name, prefs_type type, void *data, int size)\n{\n\tvoid *d = malloc(size);\n\tif (d == NULL)\n\t\treturn;\n\tmemcpy(d, data, size);\n\tprefs_node *p = new prefs_node;\n\tp->next = 0;\n\tp->name = strdup(name);\n\tp->type = type;\n\tp->data = d;\n\tif (the_prefs) {\n\t\tprefs_node *prev = the_prefs;\n\t\twhile (prev->next)\n\t\t\tprev = prev->next;\n\t\tprev->next = p;\n\t} else\n\t\tthe_prefs = p;\n}\n\nvoid PrefsAddString(const char *name, const char *s)\n{\n\tadd_data(name, TYPE_STRING, (void *)s, strlen(s) + 1);\n}\n\nvoid PrefsAddBool(const char *name, bool b)\n{\n\tadd_data(name, TYPE_BOOLEAN, &b, sizeof(bool));\n}\n\nvoid PrefsAddInt32(const char *name, int32 val)\n{\n\tadd_data(name, TYPE_INT32, &val, sizeof(int32));\n}\n\n\n/*\n *  Replace prefs items\n */\n\nstatic prefs_node *find_node(const char *name, prefs_type type, int index = 0)\n{\n\tprefs_node *p = the_prefs;\n\tint i = 0;\n\twhile (p) {\n\t\tif ((type == TYPE_ANY || p->type == type) && !strcmp(p->name, name)) {\n\t\t\tif (i == index)\n\t\t\t\treturn p;\n\t\t\telse\n\t\t\t\ti++;\n\t\t}\n\t\tp = p->next;\n\t}\n\treturn NULL;\n}\n\nvoid PrefsReplaceString(const char *name, const char *s, int index)\n{\n\tprefs_node *p = find_node(name, TYPE_STRING, index);\n\tif (p) {\n\t\tfree(p->data);\n\t\tp->data = strdup(s);\n\t} else\n\t\tadd_data(name, TYPE_STRING, (void *)s, strlen(s) + 1);\n}\n\nvoid PrefsReplaceBool(const char *name, bool b)\n{\n\tprefs_node *p = find_node(name, TYPE_BOOLEAN);\n\tif (p)\n\t\t*(bool *)(p->data) = b;\n\telse\n\t\tadd_data(name, TYPE_BOOLEAN, &b, sizeof(bool));\n}\n\nvoid PrefsReplaceInt32(const char *name, int32 val)\n{\n\tprefs_node *p = find_node(name, TYPE_INT32);\n\tif (p)\n\t\t*(int32 *)(p->data) = val;\n\telse\n\t\tadd_data(name, TYPE_INT32, &val, sizeof(int32));\n}\n\n\n/*\n *  Get prefs items\n */\n\nconst char *PrefsFindString(const char *name, int index)\n{\n\tprefs_node *p = find_node(name, TYPE_STRING, index);\n\tif (p)\n\t\treturn (char *)(p->data);\n\telse\n\t\treturn NULL;\n}\n\nbool PrefsFindBool(const char *name)\n{\n\tprefs_node *p = find_node(name, TYPE_BOOLEAN, 0);\n\tif (p)\n\t\treturn *(bool *)(p->data);\n\telse\n\t\treturn false;\n}\n\nint32 PrefsFindInt32(const char *name)\n{\n\tprefs_node *p = find_node(name, TYPE_INT32, 0);\n\tif (p)\n\t\treturn *(int32 *)(p->data);\n\telse\n\t\treturn 0;\n}\n\n\n/*\n *  Remove prefs items\n */\n\nvoid PrefsRemoveItem(const char *name, int index)\n{\n\tprefs_node *p = find_node(name, TYPE_ANY, index);\n\tif (p) {\n\t\tfree((void *)p->name);\n\t\tfree(p->data);\n\t\tprefs_node *q = the_prefs;\n\t\tif (q == p) {\n\t\t\tthe_prefs = NULL;\n\t\t\tdelete p;\n\t\t\treturn;\n\t\t}\n\t\twhile (q) {\n\t\t\tif (q->next == p) {\n\t\t\t\tq->next = p->next;\n\t\t\t\tdelete p;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tq = q->next;\n\t\t}\n\t}\n}\n\n\n/*\n *  Load prefs from stream (utility function for LoadPrefs() implementation)\n */\n\nvoid LoadPrefsFromStream(FILE *f)\n{\n\tchar line[256];\n\twhile(fgets(line, 255, f)) {\n\t\t// Read line\n\t\tint len = strlen(line);\n\t\tif (len == 0)\n\t\t\tcontinue;\n\t\tline[len-1] = 0;\n\n\t\t// Comments begin with \"#\" or \";\"\n\t\tif (line[0] == '#' || line[0] == ';')\n\t\t\tcontinue;\n\n\t\t// Terminate string after keyword\n\t\tchar *p = line;\n\t\twhile (!isspace(*p)) p++;\n\t\t*p++ = 0;\n\n\t\t// Skip whitespace until value\n\t\twhile (isspace(*p)) p++;\n\t\tchar *keyword = line;\n\t\tchar *value = p;\n\t\tint32 i = atol(value);\n\n\t\t// Look for keyword first in prefs item list\n\t\tconst prefs_desc *desc = find_prefs_desc(keyword);\n\t\tif (desc == NULL) {\n\t\t\tprintf(\"WARNING: Unknown preferences keyword '%s'\\n\", keyword);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Add item to prefs\n\t\tswitch (desc->type) {\n\t\t\tcase TYPE_STRING:\n\t\t\t\tif (desc->multiple)\n\t\t\t\t\tPrefsAddString(keyword, value);\n\t\t\t\telse\n\t\t\t\t\tPrefsReplaceString(keyword, value);\n\t\t\t\tbreak;\n\t\t\tcase TYPE_BOOLEAN:\n\t\t\t\tPrefsReplaceBool(keyword, !strcmp(value, \"true\"));\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INT32:\n\t\t\t\tPrefsReplaceInt32(keyword, i);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\n/*\n *  Save settings to stream (utility function for SavePrefs() implementation)\n */\n\nstatic void write_prefs(FILE *f, const prefs_desc *list)\n{\n\twhile (list->type != TYPE_ANY) {\n\t\tswitch (list->type) {\n\t\t\tcase TYPE_STRING: {\n\t\t\t\tint index = 0;\n\t\t\t\tconst char *str;\n\t\t\t\twhile ((str = PrefsFindString(list->name, index++)) != NULL)\n\t\t\t\t\tfprintf(f, \"%s %s\\n\", list->name, str);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase TYPE_BOOLEAN:\n\t\t\t\tfprintf(f, \"%s %s\\n\", list->name, PrefsFindBool(list->name) ? \"true\" : \"false\");\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INT32:\n\t\t\t\tfprintf(f, \"%s %d\\n\", list->name, PrefsFindInt32(list->name));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tlist++;\n\t}\n}\n\nvoid SavePrefsToStream(FILE *f)\n{\n\twrite_prefs(f, common_prefs_items);\n\twrite_prefs(f, platform_prefs_items);\n}\n","/*\n *  prefs_items.cpp - Common preferences items\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"sysdeps.h\"\n\n#include \"sys.h\"\n#include \"prefs.h\"\n\n\n// Common preferences items (those which exist on all platforms)\n// Except for \"disk\", \"floppy\", \"cdrom\", \"scsiX\", \"screen\", \"rom\" and \"ether\",\n// these are guaranteed to be in the prefs.\nprefs_desc common_prefs_items[] = {\n\t{\"disk\", TYPE_STRING, true,       \"device/file name of Mac volume\"},\n\t{\"floppy\", TYPE_STRING, true,     \"device/file name of Mac floppy drive\"},\n\t{\"cdrom\", TYPE_STRING, true,      \"device/file names of Mac CD-ROM drive\"},\n\t{\"extfs\", TYPE_STRING, false,     \"root path of ExtFS\"},\n\t{\"scsi0\", TYPE_STRING, false,     \"SCSI target for Mac SCSI ID 0\"},\n\t{\"scsi1\", TYPE_STRING, false,     \"SCSI target for Mac SCSI ID 1\"},\n\t{\"scsi2\", TYPE_STRING, false,     \"SCSI target for Mac SCSI ID 2\"},\n\t{\"scsi3\", TYPE_STRING, false,     \"SCSI target for Mac SCSI ID 3\"},\n\t{\"scsi4\", TYPE_STRING, false,     \"SCSI target for Mac SCSI ID 4\"},\n\t{\"scsi5\", TYPE_STRING, false,     \"SCSI target for Mac SCSI ID 5\"},\n\t{\"scsi6\", TYPE_STRING, false,     \"SCSI target for Mac SCSI ID 6\"},\n\t{\"screen\", TYPE_STRING, false,    \"video mode\"},\n\t{\"seriala\", TYPE_STRING, false,   \"device name of Mac serial port A\"},\n\t{\"serialb\", TYPE_STRING, false,   \"device name of Mac serial port B\"},\n\t{\"ether\", TYPE_STRING, false,     \"device name of Mac ethernet adapter\"},\n\t{\"etherconfig\", TYPE_STRING, false,\"path of network config script\"},\n\t{\"udptunnel\", TYPE_BOOLEAN, false, \"tunnel all network packets over UDP\"},\n\t{\"udpport\", TYPE_INT32, false,    \"IP port number for tunneling\"},\n\t{\"redir\", TYPE_STRING, true,      \"port forwarding for slirp\"},\n\t{\"rom\", TYPE_STRING, false,       \"path of ROM file\"},\n\t{\"bootdrive\", TYPE_INT32, false,  \"boot drive number\"},\n\t{\"bootdriver\", TYPE_INT32, false, \"boot driver number\"},\n\t{\"ramsize\", TYPE_INT32, false,    \"size of Mac RAM in bytes\"},\n\t{\"frameskip\", TYPE_INT32, false,  \"number of frames to skip in refreshed video modes\"},\n\t{\"modelid\", TYPE_INT32, false,    \"Mac Model ID (Gestalt Model ID minus 6)\"},\n\t{\"cpu\", TYPE_INT32, false,        \"CPU type (0 = 68000, 1 = 68010 etc.)\"},\n\t{\"fpu\", TYPE_BOOLEAN, false,      \"enable FPU emulation\"},\n\t{\"nocdrom\", TYPE_BOOLEAN, false,  \"don't install CD-ROM driver\"},\n\t{\"nosound\", TYPE_BOOLEAN, false,  \"don't enable sound output\"},\n\t{\"noclipconversion\", TYPE_BOOLEAN, false, \"don't convert clipboard contents\"},\n\t{\"nogui\", TYPE_BOOLEAN, false,    \"disable GUI\"},\n\t{\"jit\", TYPE_BOOLEAN, false,         \"enable JIT compiler\"},\n\t{\"jitfpu\", TYPE_BOOLEAN, false,      \"enable JIT compilation of FPU instructions\"},\n\t{\"jitdebug\", TYPE_BOOLEAN, false,    \"enable JIT debugger (requires mon builtin)\"},\n\t{\"jitcachesize\", TYPE_INT32, false,  \"translation cache size in KB\"},\n\t{\"jitlazyflush\", TYPE_BOOLEAN, false, \"enable lazy invalidation of translation cache\"},\n\t{\"jitinline\", TYPE_BOOLEAN, false,   \"enable translation through constant jumps\"},\n\t{\"jitblacklist\", TYPE_STRING, false, \"blacklist opcodes from translation\"},\n\t{\"keyboardtype\", TYPE_INT32, false, \"hardware keyboard type\"},\n\t{NULL, TYPE_END, false, NULL} // End of list\n};\n\n\n/*\n *  Set default values for preferences items\n */\n\nvoid AddPrefsDefaults(void)\n{\n\tSysAddSerialPrefs();\n\tPrefsAddBool(\"udptunnel\", false);\n\tPrefsAddInt32(\"udpport\", 6066);\n\tPrefsAddInt32(\"bootdriver\", 0);\n\tPrefsAddInt32(\"bootdrive\", 0);\n\tPrefsAddInt32(\"ramsize\", 8 * 1024 * 1024);\n\tPrefsAddInt32(\"frameskip\", 6);\n\tPrefsAddInt32(\"modelid\", 5);\t// Mac IIci\n\tPrefsAddInt32(\"cpu\", 3);\t\t// 68030\n\tPrefsAddBool(\"fpu\", false);\n\tPrefsAddBool(\"nocdrom\", false);\n\tPrefsAddBool(\"nosound\", false);\n\tPrefsAddBool(\"noclipconversion\", false);\n\tPrefsAddBool(\"nogui\", false);\n\t\n#if USE_JIT\n\t// JIT compiler specific options\n\tPrefsAddBool(\"jit\", true);\n\tPrefsAddBool(\"jitfpu\", true);\n\tPrefsAddBool(\"jitdebug\", false);\n\tPrefsAddInt32(\"jitcachesize\", 8192);\n\tPrefsAddBool(\"jitlazyflush\", true);\n\tPrefsAddBool(\"jitinline\", true);\n#else\n\tPrefsAddBool(\"jit\", false);\n#endif\n\n    PrefsAddInt32(\"keyboardtype\", 5);\n}\n","/*\n *  sys_unix.cpp - System dependent routines, Unix implementation\n *\n *  Basilisk II (C) Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"sysdeps.h\"\n\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <errno.h>\n\n#ifdef HAVE_AVAILABILITYMACROS_H\n#include <AvailabilityMacros.h>\n#endif\n\n#ifdef __linux__\n#include <sys/mount.h>\n#include <linux/cdrom.h>\n#include <linux/fd.h>\n#include <linux/major.h>\n#include <linux/kdev_t.h>\n#include <dirent.h>\n#include <limits.h>\n#endif\n\n#if defined(__FreeBSD__) || defined(__NetBSD__)\n#include <sys/cdio.h>\n#endif\n\n#if defined __APPLE__ && defined __MACH__\n#include <sys/disk.h>\n#if (defined AQUA || defined HAVE_FRAMEWORK_COREFOUNDATION)\n#ifndef __MACOSX__\n#define __MACOSX__ MAC_OS_X_VERSION_MIN_REQUIRED\n#endif\n#endif\n#endif\n#undef __MACOSX__\n\n#include \"main.h\"\n#include \"macos_util.h\"\n#include \"prefs.h\"\n#include \"user_strings.h\"\n#include \"sys.h\"\n#include \"disk_unix.h\"\n\n#if defined(BINCUE)\n#include \"bincue_unix.h\"\n#endif\n\n\n\n#define DEBUG 0\n#include \"debug.h\"\n\nstatic disk_factory *disk_factories[] = {\n#ifndef STANDALONE_GUI\n\tdisk_sparsebundle_factory,\n#if defined(HAVE_LIBVHD)\n\tdisk_vhd_factory,\n#endif\n#endif\n\tNULL\n};\n\n// File handles are pointers to these structures\nstruct mac_file_handle {\n\tchar *name;\t        // Copy of device/file name\n\tint fd;\n\n\tbool is_file;\t\t// Flag: plain file or /dev/something?\n\tbool is_floppy;\t\t// Flag: floppy device\n\tbool is_cdrom;\t\t// Flag: CD-ROM device\n\tbool read_only;\t\t// Copy of Sys_open() flag\n\n\tloff_t start_byte;\t// Size of file header (if any)\n\tloff_t file_size;\t// Size of file data (only valid if is_file is true)\n\n\tbool is_media_present;\t\t// Flag: media is inserted and available\n\tdisk_generic *generic_disk;\n\n#if defined(__linux__)\n\tint cdrom_cap;\t\t// CD-ROM capability flags (only valid if is_cdrom is true)\n#elif defined(__FreeBSD__)\n\tstruct ioc_capability cdrom_cap;\n#elif defined(__APPLE__) && defined(__MACH__)\n\tchar *ioctl_name;\t// For CDs on OS X - a device for special ioctls\n\tint ioctl_fd;\n#endif\n\n#if defined(BINCUE)\n\tbool is_bincue;\t\t// Flag: BIN CUE file\n\tvoid *bincue_fd;\n#endif\n};\n\n// Open file handles\nstruct open_mac_file_handle {\n\tmac_file_handle *fh;\n\topen_mac_file_handle *next;\n};\nstatic open_mac_file_handle *open_mac_file_handles = NULL;\n\n// File handle of first floppy drive (for SysMountFirstFloppy())\nstatic mac_file_handle *first_floppy = NULL;\n\n// Prototypes\nstatic void cdrom_close(mac_file_handle *fh);\nstatic bool cdrom_open(mac_file_handle *fh, const char *path = NULL);\n\n\n/*\n *  Initialization\n */\n\nvoid SysInit(void)\n{\n#if defined __MACOSX__\n\textern void DarwinSysInit(void);\n\tDarwinSysInit();\n#endif\n}\n\n\n/*\n *  Deinitialization\n */\n\nvoid SysExit(void)\n{\n#if defined __MACOSX__\n\textern void DarwinSysExit(void);\n\tDarwinSysExit();\n#endif\n}\n\n\n/*\n *  Manage open file handles\n */\n\nstatic void sys_add_mac_file_handle(mac_file_handle *fh)\n{\n\topen_mac_file_handle *p = new open_mac_file_handle;\n\tp->fh = fh;\n\tp->next = open_mac_file_handles;\n\topen_mac_file_handles = p;\n}\n\nstatic void sys_remove_mac_file_handle(mac_file_handle *fh)\n{\n\topen_mac_file_handle *p = open_mac_file_handles;\n\topen_mac_file_handle *q = NULL;\n\n\twhile (p) {\n\t\tif (p->fh == fh) {\n\t\t\tif (q)\n\t\t\t\tq->next = p->next;\n\t\t\telse\n\t\t\t\topen_mac_file_handles = p->next;\n\t\t\tdelete p;\n\t\t\tbreak;\n\t\t}\n\t\tq = p;\n\t\tp = p->next;\n\t}\n}\n\n\n/*\n *  Account for media that has just arrived\n */\n\nvoid SysMediaArrived(const char *path, int type)\n{\n\t// Replace the \"cdrom\" entry (we are polling, it's unique)\n\tif (type == MEDIA_CD && !PrefsFindBool(\"nocdrom\"))\n\t\tPrefsReplaceString(\"cdrom\", path);\n\n\t// Wait for media to be available for reading\n\tif (open_mac_file_handles) {\n\t\tconst int MAX_WAIT = 5;\n\t\tfor (int i = 0; i < MAX_WAIT; i++) {\n\t\t\tif (access(path, R_OK) == 0)\n\t\t\t\tbreak;\n\t\t\tswitch (errno) {\n\t\t\tcase ENOENT: // Unlikely\n\t\t\tcase EACCES: // MacOS X is mounting the media\n\t\t\t\tsleep(1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprintf(\"WARNING: Cannot access %s (%s)\\n\", path, strerror(errno));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor (open_mac_file_handle *p = open_mac_file_handles; p != NULL; p = p->next) {\n\t\tmac_file_handle * const fh = p->fh;\n\n\t\t// Re-open CD-ROM device\n\t\tif (fh->is_cdrom && type == MEDIA_CD) {\n\t\t\tcdrom_close(fh);\n\t\t\tif (cdrom_open(fh, path)) {\n\t\t\t\tfh->is_media_present = true;\n\t\t\t\tMountVolume(fh);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/*\n *  Account for media that has just been removed\n */\n\nvoid SysMediaRemoved(const char *path, int type)\n{\n\tif ((type & MEDIA_REMOVABLE) != MEDIA_CD)\n\t\treturn;\n\n\tfor (open_mac_file_handle *p = open_mac_file_handles; p != NULL; p = p->next) {\n\t\tmac_file_handle * const fh = p->fh;\n\n\t\t// Mark media as not available\n\t\tif (!fh->is_cdrom || !fh->is_media_present)\n\t\t\tcontinue;\n\t\tif (fh->name && strcmp(fh->name, path) == 0) {\n\t\t\tfh->is_media_present = false;\n\t\t\tbreak;\n\t\t}\n#if defined __MACOSX__\n\t\tif (fh->ioctl_name && strcmp(fh->ioctl_name, path) == 0) {\n\t\t\tfh->is_media_present = false;\n\t\t\tbreak;\n\t\t}\n#endif\n\t}\n}\n\n\n/*\n *  Mount first floppy disk\n */\n\nvoid SysMountFirstFloppy(void)\n{\n\tif (first_floppy)\n\t\tMountVolume(first_floppy);\n}\n\n\n/*\n *  This gets called when no \"floppy\" prefs items are found\n *  It scans for available floppy drives and adds appropriate prefs items\n */\n\nvoid SysAddFloppyPrefs(void)\n{\n#if defined(__linux__)\n\tDIR *fd_dir = opendir(\"/dev/floppy\");\n\tif (fd_dir) {\n\t\tstruct dirent *floppy_dev;\n\t\twhile ((floppy_dev = readdir(fd_dir)) != NULL) {\n\t\t\tif (strstr(floppy_dev->d_name, \"u1440\") != NULL) {\n\t\t\t\tchar fd_dev[20];\n\t\t\t\tsprintf(fd_dev, \"/dev/floppy/%s\", floppy_dev->d_name);\n\t\t\t\tPrefsAddString(\"floppy\", fd_dev);\n\t\t\t}\n\t\t}\n\t\tclosedir(fd_dir);\n\t} else {\n\t\tPrefsAddString(\"floppy\", \"/dev/fd0\");\n\t\tPrefsAddString(\"floppy\", \"/dev/fd1\");\n\t}\n#elif defined(__NetBSD__)\n\tPrefsAddString(\"floppy\", \"/dev/fd0a\");\n\tPrefsAddString(\"floppy\", \"/dev/fd1a\");\n#elif defined(__APPLE__) && defined(__MACH__)\n  #if defined(AQUA) || defined(HAVE_FRAMEWORK_COREFOUNDATION)\n\textern\tvoid DarwinAddFloppyPrefs(void);\n\n\tDarwinAddFloppyPrefs();\n  #else\n\t// Until I can convince the other guys that my Darwin code is useful,\n\t// we just add something safe (a non-existant device):\n\tPrefsAddString(\"floppy\", \"/dev/null\");\n  #endif\n#else\n\tPrefsAddString(\"floppy\", \"/dev/fd0\");\n\tPrefsAddString(\"floppy\", \"/dev/fd1\");\n#endif\n}\n\n\n/*\n *  This gets called when no \"disk\" prefs items are found\n *  It scans for available HFS volumes and adds appropriate prefs items\n *\tOn OS X, we could do the same, but on an OS X machine I think it is\n *\tvery unlikely that any mounted volumes would contain a system which\n *\tis old enough to boot a 68k Mac, so we just do nothing here for now.\n */\n\nvoid SysAddDiskPrefs(void)\n{\n#ifdef __linux__\n\tFILE *f = fopen(\"/etc/fstab\", \"r\");\n\tif (f) {\n\t\tchar line[256];\n\t\twhile(fgets(line, 255, f)) {\n\t\t\t// Read line\n\t\t\tint len = strlen(line);\n\t\t\tif (len == 0 || line[0] == '#')\n\t\t\t\tcontinue;\n\t\t\tline[len-1] = 0;\n\n\t\t\t// Parse line\n\t\t\tchar *dev = NULL, *mnt_point = NULL, *fstype = NULL;\n\t\t\tif (sscanf(line, \"%as %as %as\", &dev, &mnt_point, &fstype) == 3) {\n\t\t\t\tif (strcmp(fstype, \"hfs\") == 0)\n\t\t\t\t\tPrefsAddString(\"disk\", dev);\n\t\t\t}\n\t\t\tfree(dev); free(mnt_point); free(fstype);\n\t\t}\n\t\tfclose(f);\n\t}\n#endif\n}\n\n\n/*\n *  This gets called when no \"cdrom\" prefs items are found\n *  It scans for available CD-ROM drives and adds appropriate prefs items\n */\n\nvoid SysAddCDROMPrefs(void)\n{\n\t// Don't scan for drives if nocdrom option given\n\tif (PrefsFindBool(\"nocdrom\"))\n\t\treturn;\n\n#if defined(__linux__)\n\tif (access(\"/dev/.devfsd\", F_OK) < 0)\n\t\tPrefsAddString(\"cdrom\", \"/dev/cdrom\");\n\telse {\n\t\tDIR *cd_dir = opendir(\"/dev/cdroms\");\n\t\tif (cd_dir) {\n\t\t\tstruct dirent *cdrom_dev;\n\t\t\twhile ((cdrom_dev = readdir(cd_dir)) != NULL) {\n\t\t\t\tif (strcmp(cdrom_dev->d_name, \".\") != 0 && strcmp(cdrom_dev->d_name, \"..\") != 0) {\n\t\t\t\t\tchar cd_dev[20];\n\t\t\t\t\tsprintf(cd_dev, \"/dev/cdroms/%s\", cdrom_dev->d_name);\n\t\t\t\t\tPrefsAddString(\"cdrom\", cd_dev);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(cd_dir);\n\t\t}\n\t}\n#elif defined __MACOSX__\n\t// There is no predefined path for CD-ROMs on MacOS X. Rather, we\n\t// define a single fake CD-ROM entry for the emulated MacOS.\n\t// XXX this means we handle only CD-ROM drive at a time, wherever\n\t// the disk is, the latest one is used.\n\tPrefsAddString(\"cdrom\", \"/dev/poll/cdrom\");\n#elif defined(__FreeBSD__) || defined(__NetBSD__)\n\tPrefsAddString(\"cdrom\", \"/dev/cd0c\");\n#endif\n}\n\n\n/*\n *  Add default serial prefs (must be added, even if no ports present)\n */\n\nvoid SysAddSerialPrefs(void)\n{\n#if defined(__linux__)\n\tif (access(\"/dev/.devfsd\", F_OK) < 0) {\n\t\tPrefsAddString(\"seriala\", \"/dev/ttyS0\");\n\t\tPrefsAddString(\"serialb\", \"/dev/ttyS1\");\n\t} else {\n\t\tPrefsAddString(\"seriala\", \"/dev/tts/0\");\n\t\tPrefsAddString(\"serialb\", \"/dev/tts/1\");\n\t}\n#elif defined(__FreeBSD__)\n\tPrefsAddString(\"seriala\", \"/dev/cuaa0\");\n\tPrefsAddString(\"serialb\", \"/dev/cuaa1\");\n#elif defined(__NetBSD__)\n\tPrefsAddString(\"seriala\", \"/dev/tty00\");\n\tPrefsAddString(\"serialb\", \"/dev/tty01\");\n#elif defined(__APPLE__) && defined(__MACH__)\n  #if defined(AQUA) || defined(HAVE_FRAMEWORK_COREFOUNDATION)\n\textern\tvoid DarwinAddSerialPrefs(void);\n\n\tDarwinAddSerialPrefs();\n  #else\n\t// Until I can convince the other guys that my Darwin code is useful,\n\t// we just add something safe (non-existant devices):\n\tPrefsAddString(\"seriala\", \"/dev/null\");\n\tPrefsAddString(\"serialb\", \"/dev/null\");\n  #endif\n#endif\n}\n\n\n/*\n *  Open CD-ROM device and initialize internal data\n */\n\nstatic bool cdrom_open_1(mac_file_handle *fh)\n{\n#if defined __MACOSX__\n\t// In OS X, the device name is OK for sending ioctls to,\n\t// but not for reading raw CDROM data from.\n\t// (it seems to have extra data padded in)\n\t//\n\t// So, we keep the already opened file handle,\n\t// and open a slightly different file for CDROM data \n\t//\n\tfh->ioctl_fd = fh->fd;\n\tfh->ioctl_name = fh->name;\n\tfh->fd = -1;\n\tfh->name = (char *)malloc(strlen(fh->ioctl_name) + 3);\n\tif (fh->name) {\n\t\tstrcpy(fh->name, fh->ioctl_name);\n\t\tstrcat(fh->name, \"s1\");\n\t\tfh->fd = open(fh->name, O_RDONLY, O_NONBLOCK);\n\t}\n\tif (fh->ioctl_fd < 0)\n\t\treturn false;\n#endif\n\treturn true;\n}\n\nbool cdrom_open(mac_file_handle *fh, const char *path)\n{\n\tif (path)\n\t\tfh->name = strdup(path);\n\tfh->fd = open(fh->name, O_RDONLY, O_NONBLOCK);\n\tfh->start_byte = 0;\n\tif (!cdrom_open_1(fh))\n\t\treturn false;\n\treturn fh->fd >= 0;\n}\n\n\n/*\n *  Close a CD-ROM device\n */\n\nvoid cdrom_close(mac_file_handle *fh)\n{\n\n\tif (fh->fd >= 0) {\n\t\tclose(fh->fd);\n\t\tfh->fd = -1;\n\t}\n\tif (fh->name) {\n\t\tfree(fh->name);\n\t\tfh->name = NULL;\n\t}\n#if defined __MACOSX__\n\tif (fh->ioctl_fd >= 0) {\n\t\tclose(fh->ioctl_fd);\n\t\tfh->ioctl_fd = -1;\n\t}\n\tif (fh->ioctl_name) {\n\t\tfree(fh->ioctl_name);\n\t\tfh->ioctl_name = NULL;\n\t}\n#endif\n}\n\n\n/*\n *  Check if device is a mounted HFS volume, get mount name\n */\n\nstatic bool is_drive_mounted(const char *dev_name, char *mount_name)\n{\n#ifdef __linux__\n\tFILE *f = fopen(\"/proc/mounts\", \"r\");\n\tif (f) {\n\t\tchar line[256];\n\t\twhile(fgets(line, 255, f)) {\n\t\t\t// Read line\n\t\t\tint len = strlen(line);\n\t\t\tif (len == 0)\n\t\t\t\tcontinue;\n\t\t\tline[len-1] = 0;\n\n\t\t\t// Parse line\n\t\t\tif (strncmp(line, dev_name, strlen(dev_name)) == 0) {\n\t\t\t\tmount_name[0] = 0;\n\t\t\t\tchar *dummy;\n\t\t\t\tsscanf(line, \"%as %s\", &dummy, mount_name);\n\t\t\t\tfree(dummy);\n\t\t\t\tfclose(f);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tfclose(f);\n\t}\n#endif\n\treturn false;\n}\n\n\n/*\n *  Open file/device, create new file handle (returns NULL on error)\n */\n \nstatic mac_file_handle *open_filehandle(const char *name)\n{\n\t\tmac_file_handle *fh = new mac_file_handle;\n\t\tmemset(fh, 0, sizeof(mac_file_handle));\n\t\tfh->name = strdup(name);\n\t\tfh->fd = -1;\n\t\tfh->generic_disk = NULL;\n#if defined __MACOSX__\n\t\tfh->ioctl_fd = -1;\n\t\tfh->ioctl_name = NULL;\n#endif\n\t\treturn fh;\n}\n\nvoid *Sys_open(const char *name, bool read_only)\n{\n\tbool is_file = strncmp(name, \"/dev/\", 5) != 0;\n#if defined(__FreeBSD__)\n\t                // SCSI                             IDE\n\tbool is_cdrom = strncmp(name, \"/dev/cd\", 7) == 0 || strncmp(name, \"/dev/acd\", 8) == 0;\n#else\n\tbool is_cdrom = strncmp(name, \"/dev/cd\", 7) == 0;\n#endif\n\tbool is_floppy = strncmp(name, \"/dev/fd\", 7) == 0;\n\n\tbool is_polled_media = strncmp(name, \"/dev/poll/\", 10) == 0;\n\tif (is_floppy) // Floppy open fails if there's no disk inserted\n\t\tis_polled_media = true;\n\n#if defined __MACOSX__\n\t// There is no set filename in /dev which is the cdrom,\n\t// so we have to see if it is any of the devices that we found earlier\n\t{\n\t\tint index = 0;\n\t\tconst char *str;\n\t\twhile ((str = PrefsFindString(\"cdrom\", index++)) != NULL) {\n\t\t\tif (is_polled_media || strcmp(str, name) == 0) {\n\t\t\t\tis_cdrom = true;\n\t\t\t\tread_only = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tD(bug(\"Sys_open(%s, %s)\\n\", name, read_only ? \"read-only\" : \"read/write\"));\n\n\t// Check if write access is allowed, set read-only flag if not\n\tif (!read_only && access(name, W_OK))\n\t\tread_only = true;\n\n\t// Print warning message and eventually unmount drive when this is an HFS volume mounted under Linux (double mounting will corrupt the volume)\n\tchar mount_name[256];\n\tif (!is_file && !read_only && is_drive_mounted(name, mount_name)) {\n\t\tchar str[512];\n\t\tsprintf(str, GetString(STR_VOLUME_IS_MOUNTED_WARN), mount_name);\n\t\tWarningAlert(str);\n\t\tsprintf(str, \"umount %s\", mount_name);\n\t\tif (system(str)) {\n\t\t\tsprintf(str, GetString(STR_CANNOT_UNMOUNT_WARN), mount_name, strerror(errno));\n\t\t\tWarningAlert(str);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t// Open file/device\n\n#if defined(BINCUE)\n\tvoid *binfd = open_bincue(name);\n\tif (binfd) {\n\t\tmac_file_handle *fh = open_filehandle(name);\n\t\tD(bug(\"opening %s as bincue\\n\", name));\n\t\tfh->bincue_fd = binfd;\n\t\tfh->is_bincue = true;\n\t\tfh->read_only = true;\n\t\tfh->is_media_present = true;\n\t\tsys_add_mac_file_handle(fh);\n\t\treturn fh;\n\t}\n#endif\n\n\n\tfor (int i = 0; disk_factories[i]; ++i) {\n\t\tdisk_factory *f = disk_factories[i];\n\t\tdisk_generic *generic;\n\t\tdisk_generic::status st = f(name, read_only, &generic);\n\t\tif (st == disk_generic::DISK_INVALID)\n\t\t\treturn NULL;\n\t\tif (st == disk_generic::DISK_VALID) {\n\t\t\tmac_file_handle *fh = open_filehandle(name);\n\t\t\tfh->generic_disk = generic;\n\t\t\tfh->file_size = generic->size();\n\t\t\tfh->read_only = generic->is_read_only();\n\t\t\tfh->is_media_present = true;\n\t\t\tsys_add_mac_file_handle(fh);\n\t\t\treturn fh;\n\t\t}\n\t}\n\n\tint open_flags = (read_only ? O_RDONLY : O_RDWR);\n#if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__MACOSX__)\n\topen_flags |= (is_cdrom ? O_NONBLOCK : 0);\n#endif\n#if defined(__MACOSX__)\n\topen_flags |= (is_file ? O_EXLOCK | O_NONBLOCK : 0);\n#endif\n\tint fd = open(name, open_flags);\n#if defined(__MACOSX__)\n\tif (fd < 0 && (open_flags & O_EXLOCK)) {\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t// File system does not support locking. Try again without.\n\t\t\topen_flags &= ~O_EXLOCK;\n\t\t\tfd = open(name, open_flags);\n\t\t} else if (errno == EAGAIN) {\n\t\t\t// File is likely already locked by another process.\n\t\t\tprintf(\"WARNING: Cannot open %s (%s)\\n\", name, strerror(errno));\n\t\t\treturn NULL;\n\t\t}\n\t}\n#endif\n\tif (fd < 0 && !read_only) {\n\t\t// Read-write failed, try read-only\n\t\tread_only = true;\n\t\tfd = open(name, O_RDONLY);\n\t}\n\tif (fd >= 0 || is_polled_media) {\n\t\tmac_file_handle *fh = open_filehandle(name);\n\t\tfh->fd = fd;\n\t\tfh->is_file = is_file;\n\t\tfh->read_only = read_only;\n\t\tfh->is_floppy = is_floppy;\n\t\tfh->is_cdrom = is_cdrom;\n\t\tif (fh->is_file) {\n\t\t\tfh->is_media_present = true;\n\t\t\t// Detect disk image file layout\n\t\t\tloff_t size = 0;\n\t\t\tsize = lseek(fd, 0, SEEK_END);\n\t\t\tuint8 data[256];\n\t\t\tlseek(fd, 0, SEEK_SET);\n\t\t\tread(fd, data, 256);\n\t\t\tFileDiskLayout(size, data, fh->start_byte, fh->file_size);\n\t\t} else {\n\t\t\tstruct stat st;\n\t\t\tif (fstat(fd, &st) == 0) {\n\t\t\t\tfh->is_media_present = true;\n\t\t\t\tif (S_ISBLK(st.st_mode)) {\n\t\t\t\t\tfh->is_cdrom = is_cdrom;\n#if defined(__linux__)\n\t\t\t\t\tfh->is_floppy = (MAJOR(st.st_rdev) == FLOPPY_MAJOR);\n#ifdef CDROM_GET_CAPABILITY\n\t\t\t\t\tif (is_cdrom) {\n\t\t\t\t\t\tfh->cdrom_cap = ioctl(fh->fd, CDROM_GET_CAPABILITY);\n\t\t\t\t\t\tif (fh->cdrom_cap < 0)\n\t\t\t\t\t\t\tfh->cdrom_cap = 0;\n\t\t\t\t\t}\n#endif\n#elif defined(__FreeBSD__)\n\t\t\t\t\tfh->is_floppy = ((st.st_rdev >> 16) == 2);\n#ifdef CDIOCCAPABILITY\n\t\t\t\t\tif (is_cdrom) {\n\t\t\t\t\t\tif (ioctl(fh->fd, CDIOCCAPABILITY, &fh->cdrom_cap) < 0)\n\t\t\t\t\t\t\tmemset(&fh->cdrom_cap, 0, sizeof(fh->cdrom_cap));\n\t\t\t\t\t}\n#endif\n#elif defined(__NetBSD__)\n\t\t\t\t\tfh->is_floppy = ((st.st_rdev >> 16) == 2);\n#endif\n\t\t\t\t}\n#if defined __MACOSX__\n\t\t\t\tif (is_cdrom) {\n\t\t\t\t\tfh->is_cdrom = true;\n\t\t\t\t\tfh->is_floppy = false;\n\t\t\t\t\tif (cdrom_open_1(fh))\n\t\t\t\t\t\tfh->is_media_present = true;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t\tif (fh->is_floppy && first_floppy == NULL)\n\t\t\tfirst_floppy = fh;\n\t\tsys_add_mac_file_handle(fh);\n\t\treturn fh;\n\t} else {\n\t\tprintf(\"WARNING: Cannot open %s (%s)\\n\", name, strerror(errno));\n\t\treturn NULL;\n\t}\n}\n\n\n/*\n *  Close file/device, delete file handle\n */\n\nvoid Sys_close(void *arg)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn;\n\n\tsys_remove_mac_file_handle(fh);\n\n#if defined(BINCUE)\n\tif (fh->is_bincue)\n\t\tclose_bincue(fh->bincue_fd);\n#endif\n\tif (fh->generic_disk)\n\t\tdelete fh->generic_disk;\n\n\tif (fh->is_cdrom)\n\t\tcdrom_close(fh);\n\tif (fh->fd >= 0)\n\t\tclose(fh->fd);\n\tif (fh->name)\n\t\tfree(fh->name);\n\tdelete fh;\n}\n\n\n/*\n *  Read \"length\" bytes from file/device, starting at \"offset\", to \"buffer\",\n *  returns number of bytes read (or 0)\n */\n\nsize_t Sys_read(void *arg, void *buffer, loff_t offset, size_t length)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn 0;\n\n#if defined(BINCUE)\n\tif (fh->is_bincue)\n\t\treturn read_bincue(fh->bincue_fd, buffer, offset, length);\n#endif\n\n\tif (fh->generic_disk)\n\t\treturn fh->generic_disk->read(buffer, offset, length);\n\t\n\t// Seek to position\n\tif (lseek(fh->fd, offset + fh->start_byte, SEEK_SET) < 0)\n\t\treturn 0;\n\n\t// Read data\n\treturn read(fh->fd, buffer, length);\n}\n\n\n/*\n *  Write \"length\" bytes from \"buffer\" to file/device, starting at \"offset\",\n *  returns number of bytes written (or 0)\n */\n\nsize_t Sys_write(void *arg, void *buffer, loff_t offset, size_t length)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn 0;\n\n\tif (fh->generic_disk)\n\t\treturn fh->generic_disk->write(buffer, offset, length);\n\n\t// Seek to position\n\tif (lseek(fh->fd, offset + fh->start_byte, SEEK_SET) < 0)\n\t\treturn 0;\n\n\t// Write data\n\treturn write(fh->fd, buffer, length);\n}\n\n\n/*\n *  Return size of file/device (minus header)\n */\n\nloff_t SysGetFileSize(void *arg)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn true;\n\n#if defined(BINCUE)\n\tif (fh->is_bincue)\n\t\treturn size_bincue(fh->bincue_fd);\n#endif \n\n\tif (fh->generic_disk)\n\t\treturn fh->file_size;\n\n\tif (fh->is_file)\n\t\treturn fh->file_size;\n\telse {\n#if defined(__linux__)\n\t\tlong blocks;\n\t\tif (ioctl(fh->fd, BLKGETSIZE, &blocks) < 0)\n\t\t\treturn 0;\n\t\tD(bug(\" BLKGETSIZE returns %d blocks\\n\", blocks));\n\t\treturn (loff_t)blocks * 512;\n#elif defined __MACOSX__\n\t\tuint32 block_size;\n\t\tif (ioctl(fh->ioctl_fd, DKIOCGETBLOCKSIZE, &block_size) < 0)\n\t\t\treturn 0;\n\t\tD(bug(\" DKIOCGETBLOCKSIZE returns %lu bytes\\n\", (unsigned long)block_size));\n\t\tuint64 block_count;\n\t\tif (ioctl(fh->ioctl_fd, DKIOCGETBLOCKCOUNT, &block_count) < 0)\n\t\t\treturn 0;\n\t\tD(bug(\" DKIOCGETBLOCKCOUNT returns %llu blocks\\n\", (unsigned long long)block_count));\n\t\treturn block_count * block_size;\n#else\n\t\treturn lseek(fh->fd, 0, SEEK_END) - fh->start_byte;\n#endif\n\t}\n}\n\n\n/*\n *  Eject volume (if applicable)\n */\n\nvoid SysEject(void *arg)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn;\n\n#if defined(__linux__)\n\tif (fh->is_floppy) {\n\t\tif (fh->fd >= 0) {\n\t\t\tfsync(fh->fd);\n\t\t\tioctl(fh->fd, FDFLUSH);\n\t\t\tioctl(fh->fd, FDEJECT);\n\t\t\tclose(fh->fd);\t// Close and reopen so the driver will see the media change\n\t\t}\n\t\tfh->fd = open(fh->name, fh->read_only ? O_RDONLY : O_RDWR);\n\t} else if (fh->is_cdrom) {\n\t\tioctl(fh->fd, CDROMEJECT);\n\t\tclose(fh->fd);\t// Close and reopen so the driver will see the media change\n\t\tfh->fd = open(fh->name, O_RDONLY | O_NONBLOCK);\n\t}\n#elif defined(__FreeBSD__) || defined(__NetBSD__)\n\tif (fh->is_floppy) {\n\t\tfsync(fh->fd);\n\t} else if (fh->is_cdrom) {\n\t\tioctl(fh->fd, CDIOCEJECT);\n\t\tclose(fh->fd);\t// Close and reopen so the driver will see the media change\n\t\tfh->fd = open(fh->name, O_RDONLY | O_NONBLOCK);\n\t}\n#elif defined(__APPLE__) && defined(__MACH__)\n\tif (fh->is_cdrom && fh->is_media_present) {\n\t\tclose(fh->fd);\n\t\tfh->fd = -1;\n\t\tif (ioctl(fh->ioctl_fd, DKIOCEJECT) < 0) {\n\t\t\tD(bug(\" DKIOCEJECT failed on file %s: %s\\n\",\n\t\t\t\t   fh->ioctl_name, strerror(errno)));\n\n\t\t\t// If we are running MacOS X, the device may be in busy\n\t\t\t// state because the Finder has mounted the disk\n\t\t\tclose(fh->ioctl_fd);\n\t\t\tfh->ioctl_fd = -1;\n\n\t\t\t// Try to use \"diskutil eject\" but it can take up to 5\n\t\t\t// seconds to complete\n\t\t\tstatic const char eject_cmd[] = \"/usr/sbin/diskutil eject %s 2>&1 >/dev/null\";\n\t\t\tchar *cmd = (char *)alloca(strlen(eject_cmd) + strlen(fh->ioctl_name) + 1);\n\t\t\tsprintf(cmd, eject_cmd, fh->ioctl_name);\n\t\t\tsystem(cmd);\n\t\t}\n\t\tfh->is_media_present = false;\n\t}\n#endif\n}\n\n\n/*\n *  Format volume (if applicable)\n */\n\nbool SysFormat(void *arg)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn false;\n\n\t//!!\n\treturn true;\n}\n\n\n/*\n *  Check if file/device is read-only (this includes the read-only flag on Sys_open())\n */\n\nbool SysIsReadOnly(void *arg)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn true;\n\n#if defined(__linux__)\n\tif (fh->is_floppy) {\n\t\tif (fh->fd >= 0) {\n\t\t\tstruct floppy_drive_struct stat;\n\t\t\tioctl(fh->fd, FDGETDRVSTAT, &stat);\n\t\t\treturn !(stat.flags & FD_DISK_WRITABLE);\n\t\t} else\n\t\t\treturn true;\n\t} else\n#endif\n\t\treturn fh->read_only;\n}\n\n\n/*\n *  Check if the given file handle refers to a fixed or a removable disk\n */\n\nbool SysIsFixedDisk(void *arg)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn true;\n\n\tif (fh->generic_disk)\n\t\treturn true;\n\n\tif (fh->is_file)\n\t\treturn true;\n\telse if (fh->is_floppy || fh->is_cdrom)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\n\n/*\n *  Check if a disk is inserted in the drive (always true for files)\n */\n\nbool SysIsDiskInserted(void *arg)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn false;\n\n\tif (fh->generic_disk)\n\t\treturn true;\n\t\n\tif (fh->is_file) {\n\t\treturn true;\n\n#if defined(__linux__)\n\t} else if (fh->is_floppy) {\n\t\tchar block[512];\n\t\tlseek(fh->fd, 0, SEEK_SET);\n\t\tssize_t actual = read(fh->fd, block, 512);\n\t\tif (actual < 0) {\n\t\t\tclose(fh->fd);\t// Close and reopen so the driver will see the media change\n\t\t\tfh->fd = open(fh->name, fh->read_only ? O_RDONLY : O_RDWR);\n\t\t\tactual = read(fh->fd, block, 512);\n\t\t}\n\t\treturn actual == 512;\n\t} else if (fh->is_cdrom) {\n#ifdef CDROM_MEDIA_CHANGED\n\t\tif (fh->cdrom_cap & CDC_MEDIA_CHANGED) {\n\t\t\t// If we don't do this, all attempts to read from a disc fail\n\t\t\t// once the tray has been opened (altough the TOC reads fine).\n\t\t\t// Can somebody explain this to me?\n\t\t\tif (ioctl(fh->fd, CDROM_MEDIA_CHANGED) == 1) {\n\t\t\t\tclose(fh->fd);\n\t\t\t\tfh->fd = open(fh->name, O_RDONLY | O_NONBLOCK);\n\t\t\t}\n\t\t}\n#endif\n#ifdef CDROM_DRIVE_STATUS\n\t\tif (fh->cdrom_cap & CDC_DRIVE_STATUS) {\n\t\t\treturn ioctl(fh->fd, CDROM_DRIVE_STATUS, CDSL_CURRENT) == CDS_DISC_OK;\n\t\t}\n#endif\n\t\tcdrom_tochdr header;\n\t\treturn ioctl(fh->fd, CDROMREADTOCHDR, &header) == 0;\n#elif defined(__FreeBSD__) || defined(__NetBSD__)\n\t} else if (fh->is_floppy) {\n\t\treturn false;\t//!!\n\t} else if (fh->is_cdrom) {\n\t\tstruct ioc_toc_header header;\n\t\treturn ioctl(fh->fd, CDIOREADTOCHEADER, &header) == 0;\n#elif defined __MACOSX__\n\t} else if (fh->is_cdrom || fh->is_floppy) {\n\t\treturn fh->is_media_present;\n#endif\n\n\t} else\n\t\treturn true;\n}\n\n\n/*\n *  Prevent medium removal (if applicable)\n */\n\nvoid SysPreventRemoval(void *arg)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn;\n\n#if defined(__linux__) && defined(CDROM_LOCKDOOR)\n\tif (fh->is_cdrom)\n\t\tioctl(fh->fd, CDROM_LOCKDOOR, 1);\t\n#endif\n}\n\n\n/*\n *  Allow medium removal (if applicable)\n */\n\nvoid SysAllowRemoval(void *arg)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn;\n\n#if defined(__linux__) && defined(CDROM_LOCKDOOR)\n\tif (fh->is_cdrom)\n\t\tioctl(fh->fd, CDROM_LOCKDOOR, 0);\t\n#endif\n}\n\n\n/*\n *  Read CD-ROM TOC (binary MSF format, 804 bytes max.)\n */\n\nbool SysCDReadTOC(void *arg, uint8 *toc)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn false;\n\n#if defined(BINCUE)\n\tif (fh->is_bincue)\n\t\treturn readtoc_bincue(fh->bincue_fd, toc);\n#endif\n\n\tif (fh->is_cdrom) {\n\n#if defined(__linux__)\n\t\tuint8 *p = toc + 2;\n\n\t\t// Header\n\t\tcdrom_tochdr header;\n\t\tif (ioctl(fh->fd, CDROMREADTOCHDR, &header) < 0)\n\t\t\treturn false;\n\t\t*p++ = header.cdth_trk0;\n\t\t*p++ = header.cdth_trk1;\n\n\t\t// Tracks\n\t\tcdrom_tocentry entry;\n\t\tfor (int i=header.cdth_trk0; i<=header.cdth_trk1; i++) {\n\t\t\tentry.cdte_track = i;\n\t\t\tentry.cdte_format = CDROM_MSF;\n\t\t\tif (ioctl(fh->fd, CDROMREADTOCENTRY, &entry) < 0)\n\t\t\t\treturn false;\n\t\t\t*p++ = 0;\n\t\t\t*p++ = (entry.cdte_adr << 4) | entry.cdte_ctrl;\n\t\t\t*p++ = entry.cdte_track;\n\t\t\t*p++ = 0;\n\t\t\t*p++ = 0;\n\t\t\t*p++ = entry.cdte_addr.msf.minute;\n\t\t\t*p++ = entry.cdte_addr.msf.second;\n\t\t\t*p++ = entry.cdte_addr.msf.frame;\n\t\t}\n\n\t\t// Leadout track\n\t\tentry.cdte_track = CDROM_LEADOUT;\n\t\tentry.cdte_format = CDROM_MSF;\n\t\tif (ioctl(fh->fd, CDROMREADTOCENTRY, &entry) < 0)\n\t\t\treturn false;\n\t\t*p++ = 0;\n\t\t*p++ = (entry.cdte_adr << 4) | entry.cdte_ctrl;\n\t\t*p++ = entry.cdte_track;\n\t\t*p++ = 0;\n\t\t*p++ = 0;\n\t\t*p++ = entry.cdte_addr.msf.minute;\n\t\t*p++ = entry.cdte_addr.msf.second;\n\t\t*p++ = entry.cdte_addr.msf.frame;\n\n\t\t// TOC size\n\t\tint toc_size = p - toc;\n\t\t*toc++ = toc_size >> 8;\n\t\t*toc++ = toc_size & 0xff;\n\t\treturn true;\n#elif defined __MACOSX__ && defined MAC_OS_X_VERSION_10_2\n\t\tif (fh->is_media_present) {\n\t\t\textern bool DarwinCDReadTOC(char *name, uint8 *toc);\n\t\t\treturn DarwinCDReadTOC(fh->name, toc);\n\t\t}\n\t\treturn false;\n#elif defined(__FreeBSD__)\n\t\tuint8 *p = toc + 2;\n\n\t\t// Header\n\t\tstruct ioc_toc_header header;\n\t\tif (ioctl(fh->fd, CDIOREADTOCHEADER, &header) < 0)\n\t\t\treturn false;\n\t\t*p++ = header.starting_track;\n\t\t*p++ = header.ending_track;\n\n\t\t// Tracks\n\t\tstruct ioc_read_toc_single_entry entry;\n\t\tfor (int i=header.starting_track; i<=header.ending_track; i++) {\n\t\t\tentry.track = i;\n\t\t\tentry.address_format = CD_MSF_FORMAT;\n\t\t\tif (ioctl(fh->fd, CDIOREADTOCENTRY, &entry) < 0)\n\t\t\t\treturn false;\n\t\t\t*p++ = 0;\n\t\t\t*p++ = (entry.entry.addr_type << 4) | entry.entry.control;\n\t\t\t*p++ = entry.entry.track;\n\t\t\t*p++ = 0;\n\t\t\t*p++ = 0;\n\t\t\t*p++ = entry.entry.addr.msf.minute;\n\t\t\t*p++ = entry.entry.addr.msf.second;\n\t\t\t*p++ = entry.entry.addr.msf.frame;\n\t\t}\n\n\t\t// Leadout track\n\t\tentry.track = CD_TRACK_INFO;\n\t\tentry.address_format = CD_MSF_FORMAT;\n\t\tif (ioctl(fh->fd, CDIOREADTOCENTRY, &entry) < 0)\n\t\t\treturn false;\n\t\t*p++ = 0;\n\t\t*p++ = (entry.entry.addr_type << 4) | entry.entry.control;\n\t\t*p++ = entry.entry.track;\n\t\t*p++ = 0;\n\t\t*p++ = 0;\n\t\t*p++ = entry.entry.addr.msf.minute;\n\t\t*p++ = entry.entry.addr.msf.second;\n\t\t*p++ = entry.entry.addr.msf.frame;\n\n\t\t// TOC size\n\t\tint toc_size = p - toc;\n\t\t*toc++ = toc_size >> 8;\n\t\t*toc++ = toc_size & 0xff;\n\t\treturn true;\n#elif defined(__NetBSD__)\n\t\tuint8 *p = toc + 2;\n\n\t\t// Header\n\t\tstruct ioc_toc_header header;\n\t\tif (ioctl(fh->fd, CDIOREADTOCHEADER, &header) < 0)\n\t\t\treturn false;\n\t\t*p++ = header.starting_track;\n\t\t*p++ = header.ending_track;\n\n\t\t// Tracks (this is nice... :-)\n\t\tstruct ioc_read_toc_entry entries;\n\t\tentries.address_format = CD_MSF_FORMAT;\n\t\tentries.starting_track = 1;\n\t\tentries.data_len = 800;\n\t\tentries.data = (cd_toc_entry *)p;\n\t\tif (ioctl(fh->fd, CDIOREADTOCENTRIES, &entries) < 0)\n\t\t\treturn false;\n\n\t\t// TOC size\n\t\tint toc_size = p - toc;\n\t\t*toc++ = toc_size >> 8;\n\t\t*toc++ = toc_size & 0xff;\n\t\treturn true;\n#else\n\t\treturn false;\n#endif\n\t} else\n\t\treturn false;\n}\n\n\n/*\n *  Read CD-ROM position data (Sub-Q Channel, 16 bytes, see SCSI standard)\n */\n\nbool SysCDGetPosition(void *arg, uint8 *pos)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn false;\n\n#if defined(BINCUE)\n\tif (fh->is_bincue)\n\t\treturn GetPosition_bincue(fh->bincue_fd, pos);\n#endif\n\n\tif (fh->is_cdrom) {\n#if defined(__linux__)\n\t\tcdrom_subchnl chan;\n\t\tchan.cdsc_format = CDROM_MSF;\n\t\tif (ioctl(fh->fd, CDROMSUBCHNL, &chan) < 0)\n\t\t\treturn false;\n\t\t*pos++ = 0;\n\t\t*pos++ = chan.cdsc_audiostatus;\n\t\t*pos++ = 0;\n\t\t*pos++ = 12;\t// Sub-Q data length\n\t\t*pos++ = 0;\n\t\t*pos++ = (chan.cdsc_adr << 4) | chan.cdsc_ctrl;\n\t\t*pos++ = chan.cdsc_trk;\n\t\t*pos++ = chan.cdsc_ind;\n\t\t*pos++ = 0;\n\t\t*pos++ = chan.cdsc_absaddr.msf.minute;\n\t\t*pos++ = chan.cdsc_absaddr.msf.second;\n\t\t*pos++ = chan.cdsc_absaddr.msf.frame;\n\t\t*pos++ = 0;\n\t\t*pos++ = chan.cdsc_reladdr.msf.minute;\n\t\t*pos++ = chan.cdsc_reladdr.msf.second;\n\t\t*pos++ = chan.cdsc_reladdr.msf.frame;\n\t\treturn true;\n#elif defined(__FreeBSD__) || defined(__NetBSD__)\n\t\tstruct ioc_read_subchannel chan;\n\t\tchan.data_format = CD_MSF_FORMAT;\n\t\tchan.address_format = CD_MSF_FORMAT;\n\t\tchan.track = CD_CURRENT_POSITION;\n\t\tif (ioctl(fh->fd, CDIOCREADSUBCHANNEL, &chan) < 0)\n\t\t\treturn false;\n\t\t*pos++ = 0;\n\t\t*pos++ = chan.data->header.audio_status;\n\t\t*pos++ = 0;\n\t\t*pos++ = 12;\t// Sub-Q data length\n\t\t*pos++ = 0;\n\t\t*pos++ = (chan.data->what.position.addr_type << 4) | chan.data->what.position.control;\n\t\t*pos++ = chan.data->what.position.track_number;\n\t\t*pos++ = chan.data->what.position.index_number;\n\t\t*pos++ = 0;\n\t\t*pos++ = chan.data->what.position.absaddr.msf.minute;\n\t\t*pos++ = chan.data->what.position.absaddr.msf.second;\n\t\t*pos++ = chan.data->what.position.absaddr.msf.frame;\n\t\t*pos++ = 0;\n\t\t*pos++ = chan.data->what.position.reladdr.msf.minute;\n\t\t*pos++ = chan.data->what.position.reladdr.msf.second;\n\t\t*pos++ = chan.data->what.position.reladdr.msf.frame;\n\t\treturn true;\n#else\n\t\treturn false;\n#endif\n\t} else\n\t\treturn false;\n}\n\n\n/*\n *  Play CD audio\n */\n\nbool SysCDPlay(void *arg, uint8 start_m, uint8 start_s, uint8 start_f, uint8 end_m, uint8 end_s, uint8 end_f)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn false;\n\n#if defined(BINCUE)\n\tif (fh->is_bincue)\n\t\treturn CDPlay_bincue(fh->bincue_fd, start_m, start_s, start_f, end_m, end_s, end_f);\n#endif\n\n\tif (fh->is_cdrom) {\n#if defined(__linux__)\n\t\tcdrom_msf play;\n\t\tplay.cdmsf_min0 = start_m;\n\t\tplay.cdmsf_sec0 = start_s;\n\t\tplay.cdmsf_frame0 = start_f;\n\t\tplay.cdmsf_min1 = end_m;\n\t\tplay.cdmsf_sec1 = end_s;\n\t\tplay.cdmsf_frame1 = end_f;\n\t\treturn ioctl(fh->fd, CDROMPLAYMSF, &play) == 0;\n#elif defined(__FreeBSD__) || defined(__NetBSD__)\n\t\tstruct ioc_play_msf play;\n\t\tplay.start_m = start_m;\n\t\tplay.start_s = start_s;\n\t\tplay.start_f = start_f;\n\t\tplay.end_m = end_m;\n\t\tplay.end_s = end_s;\n\t\tplay.end_f = end_f;\n\t\treturn ioctl(fh->fd, CDIOCPLAYMSF, &play) == 0;\n#else\n\t\treturn false;\n#endif\n\t} else\n\t\treturn false;\n}\n\n\n/*\n *  Pause CD audio\n */\n\nbool SysCDPause(void *arg)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn false;\n\n#if defined(BINCUE)\n\tif (fh->is_bincue)\n\t\treturn CDPause_bincue(fh->bincue_fd);\n#endif\n\n\tif (fh->is_cdrom) {\n#if defined(__linux__)\n\t\treturn ioctl(fh->fd, CDROMPAUSE) == 0;\n#elif defined(__FreeBSD__) || defined(__NetBSD__)\n\t\treturn ioctl(fh->fd, CDIOCPAUSE) == 0;\n#else\n\t\treturn false;\n#endif\n\t} else\n\t\treturn false;\n}\n\n\n/*\n *  Resume paused CD audio\n */\n\nbool SysCDResume(void *arg)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn false;\n\n#if defined(BINCUE)\n\tif (fh->is_bincue)\n\t\treturn CDResume_bincue(fh->bincue_fd);\n#endif\n\n\n\tif (fh->is_cdrom) {\n#if defined(__linux__)\n\t\treturn ioctl(fh->fd, CDROMRESUME) == 0;\n#elif defined(__FreeBSD__) || defined(__NetBSD__)\n\t\treturn ioctl(fh->fd, CDIOCRESUME) == 0;\n#else\n\t\treturn false;\n#endif\n\t} else\n\t\treturn false;\n}\n\n\n/*\n *  Stop CD audio\n */\n\nbool SysCDStop(void *arg, uint8 lead_out_m, uint8 lead_out_s, uint8 lead_out_f)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn false;\n\n#if defined(BINCUE)\n\tif (fh->is_bincue)\n\t\treturn CDStop_bincue(fh->bincue_fd);\n#endif\n\n\n\tif (fh->is_cdrom) {\n#if defined(__linux__)\n\t\treturn ioctl(fh->fd, CDROMSTOP) == 0;\n#elif defined(__FreeBSD__) || defined(__NetBSD__)\n\t\treturn ioctl(fh->fd, CDIOCSTOP) == 0;\n#else\n\t\treturn false;\n#endif\n\t} else\n\t\treturn false;\n}\n\n\n/*\n *  Perform CD audio fast-forward/fast-reverse operation starting from specified address\n */\n\nbool SysCDScan(void *arg, uint8 start_m, uint8 start_s, uint8 start_f, bool reverse)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn false;\n\n\t// Not supported under Linux\n\treturn false;\n}\n\n\n/*\n *  Set CD audio volume (0..255 each channel)\n */\n\nvoid SysCDSetVolume(void *arg, uint8 left, uint8 right)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn;\n\n\tif (fh->is_cdrom) {\n#if defined(__linux__)\n\t\tcdrom_volctrl vol;\n\t\tvol.channel0 = vol.channel2 = left;\n\t\tvol.channel1 = vol.channel3 = right;\n\t\tioctl(fh->fd, CDROMVOLCTRL, &vol);\n#elif defined(__FreeBSD__) || defined(__NetBSD__)\n\t\tstruct ioc_vol vol;\n\t\tvol.vol[0] = vol.vol[2] = left;\n\t\tvol.vol[1] = vol.vol[3] = right;\n\t\tioctl(fh->fd, CDIOCSETVOL, &vol);\n#endif\n\t}\n}\n\n\n/*\n *  Get CD audio volume (0..255 each channel)\n */\n\nvoid SysCDGetVolume(void *arg, uint8 &left, uint8 &right)\n{\n\tmac_file_handle *fh = (mac_file_handle *)arg;\n\tif (!fh)\n\t\treturn;\n\n\tleft = right = 0;\n\tif (fh->is_cdrom) {\n#if defined(__linux__)\n\t\tcdrom_volctrl vol;\n\t\tioctl(fh->fd, CDROMVOLREAD, &vol);\n\t\tleft = vol.channel0;\n\t\tright = vol.channel1;\n#elif defined(__FreeBSD__) || defined(__NetBSD__)\n\t\tstruct ioc_vol vol;\n\t\tioctl(fh->fd, CDIOCGETVOL, &vol);\n\t\tleft = vol.vol[0];\n\t\tright = vol.vol[1];\n#endif\n\t}\n}\n","/*\n *  rom_patches.cpp - ROM patches\n *\n *  Basilisk II (C) Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include <string.h>\n\n#include \"sysdeps.h\"\n#include \"cpu_emulation.h\"\n#include \"main.h\"\n#include \"emul_op.h\"\n#include \"macos_util.h\"\n#include \"slot_rom.h\"\n#include \"sony.h\"\n#include \"disk.h\"\n#include \"cdrom.h\"\n#include \"video.h\"\n#include \"extfs.h\"\n#include \"prefs.h\"\n#include \"rom_patches.h\"\n#include \"memory.h\"\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n// Global variables\nuint32 UniversalInfo;\t\t// ROM offset of UniversalInfo\nuint32 PutScrapPatch = 0;\t// Mac address of PutScrap() patch\nuint32 GetScrapPatch = 0;\t// Mac address of GetScrap() patch\nuint32 ROMBreakpoint = 0;\t// ROM offset of breakpoint (0 = disabled, 0x2310 = CritError)\nbool PrintROMInfo = false;\t// Flag: print ROM information in PatchROM()\nbool PatchHWBases = true;\t// Flag: patch hardware base addresses\n\nstatic uint32 sony_offset;\t\t// ROM offset of .Sony driver\nstatic uint32 serd_offset;\t\t// ROM offset of SERD resource (serial drivers)\nstatic uint32 microseconds_offset;\t// ROM offset of Microseconds() replacement routine\nstatic uint32 debugutil_offset;\t\t// ROM offset of DebugUtil() replacement routine\n\n// Prototypes\nuint16 ROMVersion;\n\n/*\n *  Macros used to extract one of the 16-bit words from a 32-bit word value\n */\n\n#define HiWord(X) (((X) >> 16) & 0xffff)\n#define LoWord(X) ((X) & 0xffff)\n\n\n/*\n *  Search ROM for byte string, return ROM offset (or 0)\n */\n\nstatic uint32 find_rom_data(uint32 start, uint32 end, const uint8 *data, uint32 data_len)\n{\n\tuint32 ofs = start;\n\twhile (ofs < end) {\n\t\tif (!memcmp((void *)(ROMBaseHost + ofs), data, data_len))\n\t\t\treturn ofs;\n\t\tofs++;\n\t}\n\treturn 0;\n}\n\n\n/*\n *  Search ROM resource by type/ID, return ROM offset of resource data\n */\n\nstatic uint32 rsrc_ptr = 0;\n\nstatic uint32 find_rom_resource(uint32 s_type, int16 s_id, bool cont = false)\n{\n\tuint32 lp = ROMBaseMac + ReadMacInt32(ROMBaseMac + 0x1a);\n\tuint32 x = ReadMacInt32(lp);\n\n\tif (!cont)\n\t\trsrc_ptr = x;\n\telse\n\t\trsrc_ptr = ReadMacInt32(ROMBaseMac + rsrc_ptr + 8);\n\n\tfor (;;) {\n\t\tlp = ROMBaseMac + rsrc_ptr;\n\t\tuint32 data = ReadMacInt32(lp + 12);\n\t\tuint32 type = ReadMacInt32(lp + 16);\n\t\tint16 id = ReadMacInt16(lp + 20);\n\n\t\tif (type == s_type && id == s_id)\n\t\t\treturn data;\n\n\t\trsrc_ptr = ReadMacInt32(lp + 8);\n\t\tif (!rsrc_ptr)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\n\n/*\n *  Search offset of A-Trap routine in ROM\n */\n\nstatic uint32 find_rom_trap(uint16 trap)\n{\n\tuint8 *bp = (uint8 *)(ROMBaseHost + ReadMacInt32(ROMBaseMac + 0x22));\n\tuint16 rom_trap = 0xa800;\n\tuint32 ofs = 0;\n\nagain:\n\tfor (int i=0; i<0x400; i++) {\n\t\tbool unimplemented = false;\n\t\tuint8 b = *bp++;\n\t\tif (b == 0x80)\t\t\t// Unimplemented trap\n\t\t\tunimplemented = true;\n\t\telse if (b == 0xff) {\t// Absolute address\n\t\t\tofs = (bp[0] << 24) | (bp[1] << 16) | (bp[2] << 8) | bp[3];\n\t\t\tbp += 4;\n\t\t} else if (b & 0x80) {\t// 1 byte offset\n\t\t\tint16 add = (b & 0x7f) << 1;\n\t\t\tif (!add)\n\t\t\t\treturn 0;\n\t\t\tofs += add;\n\t\t} else {\t\t\t\t// 2 byte offset\n\t\t\tint16 add = ((b << 8) | *bp++) << 1;\n\t\t\tif (!add)\n\t\t\t\treturn 0;\n\t\t\tofs += add;\n\t\t}\n\t\tif (rom_trap == trap)\n\t\t\treturn unimplemented ? 0 : ofs;\n\t\trom_trap++;\n\t}\n\trom_trap = 0xa000;\n\tgoto again;\n}\n\n\n/*\n *  Print ROM information to stream,\n */\n\nstatic void list_rom_resources(void)\n{\n\tprintf(\"ROM Resources:\\n\");\n\tprintf(\"Offset\\t Type\\tID\\tSize\\tName\\n\");\n\tprintf(\"------------------------------------------------\\n\");\n\n\tuint32 lp = ROMBaseMac + ReadMacInt32(ROMBaseMac + 0x1a);\n\tuint32 rsrc_ptr = ReadMacInt32(lp);\n\n\tfor (;;) {\n\t\tlp = ROMBaseMac + rsrc_ptr;\n\t\tuint32 data = ReadMacInt32(lp + 12);\n\n\t\tchar name[32];\n\t\tint name_len = ReadMacInt8(lp + 23), i;\n\t\tfor (i=0; i<name_len; i++)\n\t\t\tname[i] = ReadMacInt8(lp + 24 + i);\n\t\tname[i] = 0;\n\n\t\tprintf(\"%08x %c%c%c%c\\t%d\\t%d\\t%s\\n\", data, ReadMacInt8(lp + 16), ReadMacInt8(lp + 17), ReadMacInt8(lp + 18), ReadMacInt8(lp + 19), ReadMacInt16(lp + 20), ReadMacInt32(ROMBaseMac + data - 8), name);\n\n\t\trsrc_ptr = ReadMacInt32(lp + 8);\n\t\tif (!rsrc_ptr)\n\t\t\tbreak;\n\t}\n\tprintf(\"\\n\");\n}\n\n// Mapping of Model IDs to Model names\nstruct mac_desc {\n\tconst char *name;\n\tint32 id;\n};\n\nstatic mac_desc MacDesc[] = {\n\t{\"Classic\"\t\t\t\t, 1},\n\t{\"Mac XL\"\t\t\t\t, 2},\n\t{\"Mac 512KE\"\t\t\t, 3},\n\t{\"Mac Plus\"\t\t\t\t, 4},\n\t{\"Mac SE\"\t\t\t\t, 5},\n\t{\"Mac II\"\t\t\t\t, 6},\n\t{\"Mac IIx\"\t\t\t\t, 7},\n\t{\"Mac IIcx\"\t\t\t\t, 8},\n\t{\"Mac SE/030\"\t\t\t, 9},\n\t{\"Mac Portable\"\t\t\t, 10},\n\t{\"Mac IIci\"\t\t\t\t, 11},\n\t{\"Mac IIfx\"\t\t\t\t, 13},\n\t{\"Mac Classic\"\t\t\t, 17},\n\t{\"Mac IIsi\"\t\t\t\t, 18},\n\t{\"Mac LC\"\t\t\t\t, 19},\n\t{\"Quadra 900\"\t\t\t, 20},\n\t{\"PowerBook 170\"\t\t, 21},\n\t{\"Quadra 700\"\t\t\t, 22},\n\t{\"Classic II\"\t\t\t, 23},\n\t{\"PowerBook 100\"\t\t, 24},\n\t{\"PowerBook 140\"\t\t, 25},\n\t{\"Quadra 950\"\t\t\t, 26},\n\t{\"Mac LCIII/Performa 450\", 27},\n\t{\"PowerBook Duo 210\"\t, 29},\n\t{\"Centris 650\"\t\t\t, 30},\n\t{\"PowerBook Duo 230\"\t, 32},\n\t{\"PowerBook 180\"\t\t, 33},\n\t{\"PowerBook 160\"\t\t, 34},\n\t{\"Quadra 800\"\t\t\t, 35},\n\t{\"Quadra 650\"\t\t\t, 36},\n\t{\"Mac LCII\"\t\t\t\t, 37},\n\t{\"PowerBook Duo 250\"\t, 38},\n\t{\"Mac IIvi\"\t\t\t\t, 44},\n\t{\"Mac IIvm/Performa 600\", 45},\n\t{\"Mac IIvx\"\t\t\t\t, 48},\n\t{\"Color Classic/Performa 250\", 49},\n\t{\"PowerBook 165c\"\t\t, 50},\n\t{\"Centris 610\"\t\t\t, 52},\n\t{\"Quadra 610\"\t\t\t, 53},\n\t{\"PowerBook 145\"\t\t, 54},\n\t{\"Mac LC520\"\t\t\t, 56},\n\t{\"Quadra/Centris 660AV\"\t, 60},\n\t{\"Performa 46x\"\t\t\t, 62},\n\t{\"PowerBook 180c\"\t\t, 71},\n\t{\"PowerBook 520/520c/540/540c\", 72},\n\t{\"PowerBook Duo 270c\"\t, 77},\n\t{\"Quadra 840AV\"\t\t\t, 78},\n\t{\"Performa 550\"\t\t\t, 80},\n\t{\"PowerBook 165\"\t\t, 84},\n\t{\"PowerBook 190\"\t\t, 85},\n\t{\"Mac TV\"\t\t\t\t, 88},\n\t{\"Mac LC475/Performa 47x\", 89},\n\t{\"Mac LC575\"\t\t\t, 92},\n\t{\"Quadra 605\"\t\t\t, 94},\n\t{\"Quadra 630\"\t\t\t, 98},\n\t{\"Mac LC580\"\t\t\t, 99},\n\t{\"PowerBook Duo 280\"\t, 102},\n\t{\"PowerBook Duo 280c\"\t, 103},\n\t{\"PowerBook 150\"\t\t, 115},\n\t{\"unknown\", -1}\n};\n\nstatic void print_universal_info(uint32 info)\n{\n\tuint8 id = ReadMacInt8(info + 18);\n\tuint16 hwcfg = ReadMacInt16(info + 16);\n\tuint16 rom85 = ReadMacInt16(info + 20);\n\n\t// Find model name\n\tconst char *name = \"unknown\";\n\tfor (int i=0; MacDesc[i].id >= 0; i++)\n\t\tif (MacDesc[i].id == id + 6) {\n\t\t\tname = MacDesc[i].name;\n\t\t\tbreak;\n\t\t}\n\n\tprintf(\"%08x %02x\\t%04x\\t%04x\\t%s\\n\", info - ROMBaseMac, id, hwcfg, rom85, name);\n}\n\nstatic void list_universal_infos(void)\n{\n\tuint32 ofs = 0x3000;\n\tfor (int i=0; i<0x2000; i+=2, ofs+=2)\n\t\tif (ReadMacInt32(ROMBaseMac + ofs) == 0xdc000505) {\n\t\t\tofs -= 16;\n\t\t\tuint32 q;\n\t\t\tfor (q=ofs; q > 0 && ReadMacInt32(ROMBaseMac + q) != ofs - q; q-=4) ;\n\t\t\tif (q > 0) {\n\t\t\t\tprintf(\"Universal Table at %08x:\\n\", q);\n\t\t\t\tprintf(\"Offset\\t ID\\tHWCfg\\tROM85\\tModel\\n\");\n\t\t\t\tprintf(\"------------------------------------------------\\n\");\n\t\t\t\twhile ((ofs = ReadMacInt32(ROMBaseMac + q))) {\n\t\t\t\t\tprint_universal_info(ROMBaseMac + ofs + q);\n\t\t\t\t\tq += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tprintf(\"\\n\");\n}\n\nstatic void print_rom_info(void)\n{\n\tprintf(\"\\nROM Info:\\n\");\n\tprintf(\"Checksum    : %08x\\n\", ReadMacInt32(ROMBaseMac));\n\tprintf(\"Version     : %04x\\n\", ROMVersion);\n\tprintf(\"Sub Version : %04x\\n\", ReadMacInt16(ROMBaseMac + 18));\n\tprintf(\"Resource Map: %08x\\n\", ReadMacInt32(ROMBaseMac + 26));\n\tprintf(\"Trap Tables : %08x\\n\\n\", ReadMacInt32(ROMBaseMac + 34));\n\tif (ROMVersion == ROM_VERSION_32) {\n\t\tlist_rom_resources();\n\t\tlist_universal_infos();\n\t}\n}\n\n\n/*\n *  Driver stubs\n */\n\nstatic const uint8 sony_driver[] = {\t// Replacement for .Sony driver\n\t// Driver header\n\tSonyDriverFlags >> 8, SonyDriverFlags & 0xff, 0, 0, 0, 0, 0, 0,\n\t0x00, 0x18,\t\t\t\t\t\t\t// Open() offset\n\t0x00, 0x1c,\t\t\t\t\t\t\t// Prime() offset\n\t0x00, 0x20,\t\t\t\t\t\t\t// Control() offset\n\t0x00, 0x2c,\t\t\t\t\t\t\t// Status() offset\n\t0x00, 0x52,\t\t\t\t\t\t\t// Close() offset\n\t0x05, 0x2e, 0x53, 0x6f, 0x6e, 0x79,\t// \".Sony\"\n\n\t// Open()\n\tM68K_EMUL_OP_SONY_OPEN >> 8, M68K_EMUL_OP_SONY_OPEN & 0xff,\n\t0x4e, 0x75,\t\t\t\t\t\t\t//  rts\n\n\t// Prime()\n\tM68K_EMUL_OP_SONY_PRIME >> 8, M68K_EMUL_OP_SONY_PRIME & 0xff,\n\t0x60, 0x0e,\t\t\t\t\t\t\t//  bra\t\tIOReturn\n\n\t// Control()\n\tM68K_EMUL_OP_SONY_CONTROL >> 8, M68K_EMUL_OP_SONY_CONTROL & 0xff,\n\t0x0c, 0x68, 0x00, 0x01, 0x00, 0x1a,\t//  cmp.w\t#1,$1a(a0)\n\t0x66, 0x04,\t\t\t\t\t\t\t//  bne\t\tIOReturn\n\t0x4e, 0x75,\t\t\t\t\t\t\t//  rts\n\n\t// Status()\n\tM68K_EMUL_OP_SONY_STATUS >> 8, M68K_EMUL_OP_SONY_STATUS & 0xff,\n\n\t// IOReturn\n\t0x32, 0x28, 0x00, 0x06,\t\t\t\t//  move.w\t6(a0),d1\n\t0x08, 0x01, 0x00, 0x09,\t\t\t\t//  btst\t\t#9,d1\n\t0x67, 0x0c,\t\t\t\t\t\t\t//  beq\t\t1\n\t0x4a, 0x40,\t\t\t\t\t\t\t//  tst.w\td0\n\t0x6f, 0x02,\t\t\t\t\t\t\t//  ble\t\t2\n\t0x42, 0x40,\t\t\t\t\t\t\t//  clr.w\td0\n\t0x31, 0x40, 0x00, 0x10,\t\t\t\t//2 move.w\td0,$10(a0)\n\t0x4e, 0x75,\t\t\t\t\t\t\t//  rts\n\t0x4a, 0x40,\t\t\t\t\t\t\t//1 tst.w\td0\n\t0x6f, 0x04,\t\t\t\t\t\t\t//  ble\t\t3\n\t0x42, 0x40,\t\t\t\t\t\t\t//  clr.w\td0\n\t0x4e, 0x75,\t\t\t\t\t\t\t//  rts\n\t0x2f, 0x38, 0x08, 0xfc,\t\t\t\t//3 move.l\t$8fc,-(sp)\n\t0x4e, 0x75,\t\t\t\t\t\t\t//  rts\n\n\t// Close()\n\t0x70, 0xe8,\t\t\t\t\t\t\t//  moveq\t#-24,d0\n\t0x4e, 0x75\t\t\t\t\t\t\t//  rts\n};\n\nstatic const uint8 disk_driver[] = {\t// Generic disk driver\n\t// Driver header\n\tDiskDriverFlags >> 8, DiskDriverFlags & 0xff, 0, 0, 0, 0, 0, 0,\n\t0x00, 0x18,\t\t\t\t\t\t\t// Open() offset\n\t0x00, 0x1c,\t\t\t\t\t\t\t// Prime() offset\n\t0x00, 0x20,\t\t\t\t\t\t\t// Control() offset\n\t0x00, 0x2c,\t\t\t\t\t\t\t// Status() offset\n\t0x00, 0x52,\t\t\t\t\t\t\t// Close() offset\n\t0x05, 0x2e, 0x44, 0x69, 0x73, 0x6b,\t// \".Disk\"\n\n\t// Open()\n\tM68K_EMUL_OP_DISK_OPEN >> 8, M68K_EMUL_OP_DISK_OPEN & 0xff,\n\t0x4e, 0x75,\t\t\t\t\t\t\t//  rts\n\n\t// Prime()\n\tM68K_EMUL_OP_DISK_PRIME >> 8, M68K_EMUL_OP_DISK_PRIME & 0xff,\n\t0x60, 0x0e,\t\t\t\t\t\t\t//  bra\t\tIOReturn\n\n\t// Control()\n\tM68K_EMUL_OP_DISK_CONTROL >> 8, M68K_EMUL_OP_DISK_CONTROL & 0xff,\n\t0x0c, 0x68, 0x00, 0x01, 0x00, 0x1a,\t//  cmp.w\t#1,$1a(a0)\n\t0x66, 0x04,\t\t\t\t\t\t\t//  bne\t\tIOReturn\n\t0x4e, 0x75,\t\t\t\t\t\t\t//  rts\n\n\t// Status()\n\tM68K_EMUL_OP_DISK_STATUS >> 8, M68K_EMUL_OP_DISK_STATUS & 0xff,\n\n\t// IOReturn\n\t0x32, 0x28, 0x00, 0x06,\t\t\t\t//  move.w\t6(a0),d1\n\t0x08, 0x01, 0x00, 0x09,\t\t\t\t//  btst\t\t#9,d1\n\t0x67, 0x0c,\t\t\t\t\t\t\t//  beq\t\t1\n\t0x4a, 0x40,\t\t\t\t\t\t\t//  tst.w\td0\n\t0x6f, 0x02,\t\t\t\t\t\t\t//  ble\t\t2\n\t0x42, 0x40,\t\t\t\t\t\t\t//  clr.w\td0\n\t0x31, 0x40, 0x00, 0x10,\t\t\t\t//2 move.w\td0,$10(a0)\n\t0x4e, 0x75,\t\t\t\t\t\t\t//  rts\n\t0x4a, 0x40,\t\t\t\t\t\t\t//1 tst.w\td0\n\t0x6f, 0x04,\t\t\t\t\t\t\t//  ble\t\t3\n\t0x42, 0x40,\t\t\t\t\t\t\t//  clr.w\td0\n\t0x4e, 0x75,\t\t\t\t\t\t\t//  rts\n\t0x2f, 0x38, 0x08, 0xfc,\t\t\t\t//3 move.l\t$8fc,-(sp)\n\t0x4e, 0x75,\t\t\t\t\t\t\t//  rts\n\n\t// Close()\n\t0x70, 0xe8,\t\t\t\t\t\t\t//  moveq\t#-24,d0\n\t0x4e, 0x75\t\t\t\t\t\t\t//  rts\n};\n\nstatic const uint8 cdrom_driver[] = {\t// CD-ROM driver\n\t// Driver header\n\tCDROMDriverFlags >> 8, CDROMDriverFlags & 0xff, 0, 0, 0, 0, 0, 0,\n\t0x00, 0x1c,\t\t\t\t\t\t\t// Open() offset\n\t0x00, 0x20,\t\t\t\t\t\t\t// Prime() offset\n\t0x00, 0x24,\t\t\t\t\t\t\t// Control() offset\n\t0x00, 0x30,\t\t\t\t\t\t\t// Status() offset\n\t0x00, 0x56,\t\t\t\t\t\t\t// Close() offset\n\t0x08, 0x2e, 0x41, 0x70, 0x70, 0x6c, 0x65, 0x43, 0x44, 0x00,\t// \".AppleCD\"\n\n\t// Open()\n\tM68K_EMUL_OP_CDROM_OPEN >> 8, M68K_EMUL_OP_CDROM_OPEN & 0xff,\n\t0x4e, 0x75,\t\t\t\t\t\t\t//  rts\n\n\t// Prime()\n\tM68K_EMUL_OP_CDROM_PRIME >> 8, M68K_EMUL_OP_CDROM_PRIME & 0xff,\n\t0x60, 0x0e,\t\t\t\t\t\t\t//  bra\t\tIOReturn\n\n\t// Control()\n\tM68K_EMUL_OP_CDROM_CONTROL >> 8, M68K_EMUL_OP_CDROM_CONTROL & 0xff,\n\t0x0c, 0x68, 0x00, 0x01, 0x00, 0x1a,\t//  cmp.w\t#1,$1a(a0)\n\t0x66, 0x04,\t\t\t\t\t\t\t//  bne\t\tIOReturn\n\t0x4e, 0x75,\t\t\t\t\t\t\t//  rts\n\n\t// Status()\n\tM68K_EMUL_OP_CDROM_STATUS >> 8, M68K_EMUL_OP_CDROM_STATUS & 0xff,\n\n\t// IOReturn\n\t0x32, 0x28, 0x00, 0x06,\t\t\t\t//  move.w\t6(a0),d1\n\t0x08, 0x01, 0x00, 0x09,\t\t\t\t//  btst\t\t#9,d1\n\t0x67, 0x0c,\t\t\t\t\t\t\t//  beq\t\t1\n\t0x4a, 0x40,\t\t\t\t\t\t\t//  tst.w\td0\n\t0x6f, 0x02,\t\t\t\t\t\t\t//  ble\t\t2\n\t0x42, 0x40,\t\t\t\t\t\t\t//  clr.w\td0\n\t0x31, 0x40, 0x00, 0x10,\t\t\t\t//2 move.w\td0,$10(a0)\n\t0x4e, 0x75,\t\t\t\t\t\t\t//  rts\n\t0x4a, 0x40,\t\t\t\t\t\t\t//1 tst.w\td0\n\t0x6f, 0x04,\t\t\t\t\t\t\t//  ble\t\t3\n\t0x42, 0x40,\t\t\t\t\t\t\t//  clr.w\td0\n\t0x4e, 0x75,\t\t\t\t\t\t\t//  rts\n\t0x2f, 0x38, 0x08, 0xfc,\t\t\t\t//3 move.l\t$8fc,-(sp)\n\t0x4e, 0x75,\t\t\t\t\t\t\t//  rts\n\n\t// Close()\n\t0x70, 0xe8,\t\t\t\t\t\t\t//  moveq\t#-24,d0\n\t0x4e, 0x75\t\t\t\t\t\t\t//  rts\n};\n\nstatic const uint8 ain_driver[] = {\t// .AIn driver header\n\t// Driver header\n\t0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x18,\t\t\t\t\t\t\t// Open() offset\n\t0x00, 0x1e,\t\t\t\t\t\t\t// Prime() offset\n\t0x00, 0x24,\t\t\t\t\t\t\t// Control() offset\n\t0x00, 0x32,\t\t\t\t\t\t\t// Status() offset\n\t0x00, 0x38,\t\t\t\t\t\t\t// Close() offset\n\t0x04, 0x2e, 0x41, 0x49, 0x6e, 0x09,\t// \".AIn\",9\n\n\t// Open()\n\t0x70, 0x00,\t\t\t\t\t\t\t//  moveq\t#0,d0\n\tM68K_EMUL_OP_SERIAL_OPEN >> 8, M68K_EMUL_OP_SERIAL_OPEN & 0xff,\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\n\t// Prime()\n\t0x70, 0x00,\t\t\t\t\t\t\t//  moveq\t#0,d0\n\tM68K_EMUL_OP_SERIAL_PRIME >> 8, M68K_EMUL_OP_SERIAL_PRIME & 0xff,\n\t0x60, 0x1a,\t\t\t\t\t\t\t//\tbra\t\tIOReturn\n\n\t// Control()\n\t0x70, 0x00,\t\t\t\t\t\t\t//  moveq\t#0,d0\n\tM68K_EMUL_OP_SERIAL_CONTROL >> 8, M68K_EMUL_OP_SERIAL_CONTROL & 0xff,\n\t0x0c, 0x68, 0x00, 0x01, 0x00, 0x1a,\t//\tcmp.w\t#1,$1a(a0)\n\t0x66, 0x0e,\t\t\t\t\t\t\t//\tbne\t\tIOReturn\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\n\t// Status()\n\t0x70, 0x00,\t\t\t\t\t\t\t//  moveq\t#0,d0\n\tM68K_EMUL_OP_SERIAL_STATUS >> 8, M68K_EMUL_OP_SERIAL_STATUS & 0xff,\n\t0x60, 0x06,\t\t\t\t\t\t\t//  bra IOReturn\n\n\t// Close()\n\t0x70, 0x00,\t\t\t\t\t\t\t//  moveq\t#0,d0\n\tM68K_EMUL_OP_SERIAL_CLOSE >> 8, M68K_EMUL_OP_SERIAL_CLOSE & 0xff,\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\n\t// IOReturn\n\t0x32, 0x28, 0x00, 0x06,\t\t\t\t//\tmove.w\t6(a0),d1\n\t0x08, 0x01, 0x00, 0x09,\t\t\t\t//\tbtst\t#9,d1\n\t0x67, 0x0c,\t\t\t\t\t\t\t//\tbeq\t\t1\n\t0x4a, 0x40,\t\t\t\t\t\t\t//\ttst.w\td0\n\t0x6f, 0x02,\t\t\t\t\t\t\t//\tble\t\t2\n\t0x42, 0x40,\t\t\t\t\t\t\t//\tclr.w\td0\n\t0x31, 0x40, 0x00, 0x10,\t\t\t\t//2\tmove.w\td0,$10(a0)\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\t0x4a, 0x40,\t\t\t\t\t\t\t//1\ttst.w\td0\n\t0x6f, 0x04,\t\t\t\t\t\t\t//\tble\t\t3\n\t0x42, 0x40,\t\t\t\t\t\t\t//\tclr.w\td0\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\t0x2f, 0x38, 0x08, 0xfc,\t\t\t\t//3\tmove.l\t$8fc,-(a7)\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n};\n\nstatic const uint8 aout_driver[] = {\t// .AOut driver header\n\t// Driver header\n\t0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x1a,\t\t\t\t\t\t\t// Open() offset\n\t0x00, 0x20,\t\t\t\t\t\t\t// Prime() offset\n\t0x00, 0x26,\t\t\t\t\t\t\t// Control() offset\n\t0x00, 0x34,\t\t\t\t\t\t\t// Status() offset\n\t0x00, 0x3a,\t\t\t\t\t\t\t// Close() offset\n\t0x05, 0x2e, 0x41, 0x4f, 0x75, 0x74, 0x09, 0x00,\t\t// \".AOut\",9\n\n\t// Open()\n\t0x70, 0x01,\t\t\t\t\t\t\t//  moveq\t#1,d0\n\tM68K_EMUL_OP_SERIAL_OPEN >> 8, M68K_EMUL_OP_SERIAL_OPEN & 0xff,\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\n\t// Prime()\n\t0x70, 0x01,\t\t\t\t\t\t\t//  moveq\t#1,d0\n\tM68K_EMUL_OP_SERIAL_PRIME >> 8, M68K_EMUL_OP_SERIAL_PRIME & 0xff,\n\t0x60, 0x1a,\t\t\t\t\t\t\t//\tbra\t\tIOReturn\n\n\t// Control()\n\t0x70, 0x01,\t\t\t\t\t\t\t//  moveq\t#1,d0\n\tM68K_EMUL_OP_SERIAL_CONTROL >> 8, M68K_EMUL_OP_SERIAL_CONTROL & 0xff,\n\t0x0c, 0x68, 0x00, 0x01, 0x00, 0x1a,\t//\tcmp.w\t#1,$1a(a0)\n\t0x66, 0x0e,\t\t\t\t\t\t\t//\tbne\t\tIOReturn\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\n\t// Status()\n\t0x70, 0x01,\t\t\t\t\t\t\t//  moveq\t#1,d0\n\tM68K_EMUL_OP_SERIAL_STATUS >> 8, M68K_EMUL_OP_SERIAL_STATUS & 0xff,\n\t0x60, 0x06,\t\t\t\t\t\t\t//  bra IOReturn\n\n\t// Close()\n\t0x70, 0x01,\t\t\t\t\t\t\t//  moveq\t#1,d0\n\tM68K_EMUL_OP_SERIAL_CLOSE >> 8, M68K_EMUL_OP_SERIAL_CLOSE & 0xff,\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\n\t// IOReturn\n\t0x32, 0x28, 0x00, 0x06,\t\t\t\t//\tmove.w\t6(a0),d1\n\t0x08, 0x01, 0x00, 0x09,\t\t\t\t//\tbtst\t#9,d1\n\t0x67, 0x0c,\t\t\t\t\t\t\t//\tbeq\t\t1\n\t0x4a, 0x40,\t\t\t\t\t\t\t//\ttst.w\td0\n\t0x6f, 0x02,\t\t\t\t\t\t\t//\tble\t\t2\n\t0x42, 0x40,\t\t\t\t\t\t\t//\tclr.w\td0\n\t0x31, 0x40, 0x00, 0x10,\t\t\t\t//2\tmove.w\td0,$10(a0)\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\t0x4a, 0x40,\t\t\t\t\t\t\t//1\ttst.w\td0\n\t0x6f, 0x04,\t\t\t\t\t\t\t//\tble\t\t3\n\t0x42, 0x40,\t\t\t\t\t\t\t//\tclr.w\td0\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\t0x2f, 0x38, 0x08, 0xfc,\t\t\t\t//3\tmove.l\t$8fc,-(a7)\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n};\n\nstatic const uint8 bin_driver[] = {\t// .BIn driver header\n\t// Driver header\n\t0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x18,\t\t\t\t\t\t\t// Open() offset\n\t0x00, 0x1e,\t\t\t\t\t\t\t// Prime() offset\n\t0x00, 0x24,\t\t\t\t\t\t\t// Control() offset\n\t0x00, 0x32,\t\t\t\t\t\t\t// Status() offset\n\t0x00, 0x38,\t\t\t\t\t\t\t// Close() offset\n\t0x04, 0x2e, 0x42, 0x49, 0x6e, 0x09,\t// \".BIn\",9\n\n\t// Open()\n\t0x70, 0x02,\t\t\t\t\t\t\t//  moveq\t#2,d0\n\tM68K_EMUL_OP_SERIAL_OPEN >> 8, M68K_EMUL_OP_SERIAL_OPEN & 0xff,\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\n\t// Prime()\n\t0x70, 0x02,\t\t\t\t\t\t\t//  moveq\t#2,d0\n\tM68K_EMUL_OP_SERIAL_PRIME >> 8, M68K_EMUL_OP_SERIAL_PRIME & 0xff,\n\t0x60, 0x1a,\t\t\t\t\t\t\t//\tbra\t\tIOReturn\n\n\t// Control()\n\t0x70, 0x02,\t\t\t\t\t\t\t//  moveq\t#2,d0\n\tM68K_EMUL_OP_SERIAL_CONTROL >> 8, M68K_EMUL_OP_SERIAL_CONTROL & 0xff,\n\t0x0c, 0x68, 0x00, 0x01, 0x00, 0x1a,\t//\tcmp.w\t#1,$1a(a0)\n\t0x66, 0x0e,\t\t\t\t\t\t\t//\tbne\t\tIOReturn\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\n\t// Status()\n\t0x70, 0x02,\t\t\t\t\t\t\t//  moveq\t#2,d0\n\tM68K_EMUL_OP_SERIAL_STATUS >> 8, M68K_EMUL_OP_SERIAL_STATUS & 0xff,\n\t0x60, 0x06,\t\t\t\t\t\t\t//  bra IOReturn\n\n\t// Close()\n\t0x70, 0x02,\t\t\t\t\t\t\t//  moveq\t#2,d0\n\tM68K_EMUL_OP_SERIAL_CLOSE >> 8, M68K_EMUL_OP_SERIAL_CLOSE & 0xff,\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\n\t// IOReturn\n\t0x32, 0x28, 0x00, 0x06,\t\t\t\t//\tmove.w\t6(a0),d1\n\t0x08, 0x01, 0x00, 0x09,\t\t\t\t//\tbtst\t#9,d1\n\t0x67, 0x0c,\t\t\t\t\t\t\t//\tbeq\t\t1\n\t0x4a, 0x40,\t\t\t\t\t\t\t//\ttst.w\td0\n\t0x6f, 0x02,\t\t\t\t\t\t\t//\tble\t\t2\n\t0x42, 0x40,\t\t\t\t\t\t\t//\tclr.w\td0\n\t0x31, 0x40, 0x00, 0x10,\t\t\t\t//2\tmove.w\td0,$10(a0)\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\t0x4a, 0x40,\t\t\t\t\t\t\t//1\ttst.w\td0\n\t0x6f, 0x04,\t\t\t\t\t\t\t//\tble\t\t3\n\t0x42, 0x40,\t\t\t\t\t\t\t//\tclr.w\td0\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\t0x2f, 0x38, 0x08, 0xfc,\t\t\t\t//3\tmove.l\t$8fc,-(a7)\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n};\n\nstatic const uint8 bout_driver[] = {\t// .BOut driver header\n\t// Driver header\n\t0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x1a,\t\t\t\t\t\t\t// Open() offset\n\t0x00, 0x20,\t\t\t\t\t\t\t// Prime() offset\n\t0x00, 0x26,\t\t\t\t\t\t\t// Control() offset\n\t0x00, 0x34,\t\t\t\t\t\t\t// Status() offset\n\t0x00, 0x3a,\t\t\t\t\t\t\t// Close() offset\n\t0x05, 0x2e, 0x42, 0x4f, 0x75, 0x74, 0x09, 0x00,\t\t// \".BOut\",9\n\n\t// Open()\n\t0x70, 0x03,\t\t\t\t\t\t\t//  moveq\t#3,d0\n\tM68K_EMUL_OP_SERIAL_OPEN >> 8, M68K_EMUL_OP_SERIAL_OPEN & 0xff,\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\n\t// Prime()\n\t0x70, 0x03,\t\t\t\t\t\t\t//  moveq\t#3,d0\n\tM68K_EMUL_OP_SERIAL_PRIME >> 8, M68K_EMUL_OP_SERIAL_PRIME & 0xff,\n\t0x60, 0x1a,\t\t\t\t\t\t\t//\tbra\t\tIOReturn\n\n\t// Control()\n\t0x70, 0x03,\t\t\t\t\t\t\t//  moveq\t#3,d0\n\tM68K_EMUL_OP_SERIAL_CONTROL >> 8, M68K_EMUL_OP_SERIAL_CONTROL & 0xff,\n\t0x0c, 0x68, 0x00, 0x01, 0x00, 0x1a,\t//\tcmp.w\t#1,$1a(a0)\n\t0x66, 0x0e,\t\t\t\t\t\t\t//\tbne\t\tIOReturn\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\n\t// Status()\n\t0x70, 0x03,\t\t\t\t\t\t\t//  moveq\t#3,d0\n\tM68K_EMUL_OP_SERIAL_STATUS >> 8, M68K_EMUL_OP_SERIAL_STATUS & 0xff,\n\t0x60, 0x06,\t\t\t\t\t\t\t//  bra IOReturn\n\n\t// Close()\n\t0x70, 0x03,\t\t\t\t\t\t\t//  moveq\t#3,d0\n\tM68K_EMUL_OP_SERIAL_CLOSE >> 8, M68K_EMUL_OP_SERIAL_CLOSE & 0xff,\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\n\t// IOReturn\n\t0x32, 0x28, 0x00, 0x06,\t\t\t\t//\tmove.w\t6(a0),d1\n\t0x08, 0x01, 0x00, 0x09,\t\t\t\t//\tbtst\t#9,d1\n\t0x67, 0x0c,\t\t\t\t\t\t\t//\tbeq\t\t1\n\t0x4a, 0x40,\t\t\t\t\t\t\t//\ttst.w\td0\n\t0x6f, 0x02,\t\t\t\t\t\t\t//\tble\t\t2\n\t0x42, 0x40,\t\t\t\t\t\t\t//\tclr.w\td0\n\t0x31, 0x40, 0x00, 0x10,\t\t\t\t//2\tmove.w\td0,$10(a0)\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\t0x4a, 0x40,\t\t\t\t\t\t\t//1\ttst.w\td0\n\t0x6f, 0x04,\t\t\t\t\t\t\t//\tble\t\t3\n\t0x42, 0x40,\t\t\t\t\t\t\t//\tclr.w\td0\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n\t0x2f, 0x38, 0x08, 0xfc,\t\t\t\t//3\tmove.l\t$8fc,-(a7)\n\t0x4e, 0x75,\t\t\t\t\t\t\t//\trts\n};\n\n\n/*\n *  ADBOp() patch\n */\n\nstatic const uint8 adbop_patch[] = {\t// Call ADBOp() completion procedure\n\t\t\t\t\t\t\t\t\t\t// The completion procedure may call ADBOp() again!\n\t0x40, 0xe7,\t\t\t\t//\tmove\tsr,-(sp)\n\t0x00, 0x7c, 0x07, 0x00,\t//\tori\t\t#$0700,sr\n\tM68K_EMUL_OP_ADBOP >> 8, M68K_EMUL_OP_ADBOP & 0xff,\n\t0x48, 0xe7, 0x70, 0xf0,\t//\tmovem.l\td1-d3/a0-a3,-(sp)\n\t0x26, 0x48,\t\t\t\t//\tmove.l\ta0,a3\n\t0x4a, 0xab, 0x00, 0x04,\t//\ttst.l\t4(a3)\n\t0x67, 0x00, 0x00, 0x18,\t//\tbeq\t\t1\n\t0x20, 0x53,\t\t\t\t//\tmove.l\t(a3),a0\n\t0x22, 0x6b, 0x00, 0x04,\t//\tmove.l\t4(a3),a1\n\t0x24, 0x6b, 0x00, 0x08,\t//\tmove.l\t8(a3),a2\n\t0x26, 0x78, 0x0c, 0xf8,\t//\tmove.l\t$cf8,a3\n\t0x4e, 0x91,\t\t\t\t//\tjsr\t\t(a1)\n\t0x70, 0x00,\t\t\t\t//\tmoveq\t#0,d0\n\t0x60, 0x00, 0x00, 0x04,\t//\tbra\t\t2\n\t0x70, 0xff,\t\t\t\t//1\tmoveq\t#-1,d0\n\t0x4c, 0xdf, 0x0f, 0x0e,\t//2\tmovem.l\t(sp)+,d1-d3/a0-a3\n\t0x46, 0xdf,\t\t\t\t//\tmove\t(sp)+,sr\n\t0x4e, 0x75\t\t\t\t//\trts\n};\n\n\n/*\n *  Install .Sony, disk and CD-ROM drivers\n */\n\nvoid InstallDrivers(uint32 pb)\n{\n\tD(bug(\"InstallDrivers, pb %08x\\n\", pb));\n\tM68kRegisters r;\n\n\t// Install Microseconds() replacement routine\n\tr.a[0] = ROMBaseMac + microseconds_offset;\n\tr.d[0] = 0xa093;\n\tExecute68kTrap(0xa247, &r);\t\t// SetOSTrapAddress()\n\n\t// Install DebugUtil() replacement routine\n\tr.a[0] = ROMBaseMac + debugutil_offset;\n\tr.d[0] = 0xa08d;\n\tExecute68kTrap(0xa247, &r);\t\t// SetOSTrapAddress()\n\n\t// Install disk driver\n\tr.a[0] = ROMBaseMac + sony_offset + 0x100;\n\tr.d[0] = (uint32)DiskRefNum;\n\tExecute68kTrap(0xa43d, &r);\t\t// DrvrInstallRsrvMem()\n\tr.a[0] = ReadMacInt32(ReadMacInt32(0x11c) + ~DiskRefNum * 4);\t// Get driver handle from Unit Table\n\tExecute68kTrap(0xa029, &r);\t\t// HLock()\n\tuint32 dce = ReadMacInt32(r.a[0]);\n\tWriteMacInt32(dce + dCtlDriver, ROMBaseMac + sony_offset + 0x100);\n\tWriteMacInt16(dce + dCtlFlags, DiskDriverFlags);\n\n\t// Open disk driver\n\tWriteMacInt32(pb + ioNamePtr, ROMBaseMac + sony_offset + 0x112);\n\tr.a[0] = pb;\n\tExecute68kTrap(0xa000, &r);\t\t// Open()\n\n\t// Install CD-ROM driver unless nocdrom option given\n\tif (!PrefsFindBool(\"nocdrom\")) {\n\n\t\t// Install CD-ROM driver\n\t\tr.a[0] = ROMBaseMac + sony_offset + 0x200;\n\t\tr.d[0] = (uint32)CDROMRefNum;\n\t\tExecute68kTrap(0xa43d, &r);\t\t// DrvrInstallRsrvMem()\n\t\tr.a[0] = ReadMacInt32(ReadMacInt32(0x11c) + ~CDROMRefNum * 4);\t// Get driver handle from Unit Table\n\t\tExecute68kTrap(0xa029, &r);\t\t// HLock()\n\t\tdce = ReadMacInt32(r.a[0]);\n\t\tWriteMacInt32(dce + dCtlDriver, ROMBaseMac + sony_offset + 0x200);\n\t\tWriteMacInt16(dce + dCtlFlags, CDROMDriverFlags);\n\n\t\t// Open CD-ROM driver\n\t\tWriteMacInt32(pb + ioNamePtr, ROMBaseMac + sony_offset + 0x212);\n\t\tr.a[0] = pb;\n\t\tExecute68kTrap(0xa000, &r);\t\t// Open()\n\t}\n}\n\n\n/*\n *  Install serial drivers\n */\n\nvoid InstallSERD(void)\n{\n\tD(bug(\"InstallSERD\\n\"));\n\n\t// All drivers are inside the SERD resource\n\tM68kRegisters r;\n\n\t// Install .AIn driver\n\tr.d[0] = (uint32)-6;\n\tr.a[0] = ROMBaseMac + serd_offset + 0x100;\n\tExecute68kTrap(0xa53d, &r);\t// DrvrInstallRsrvMem()\n\tExecute68kTrap(0xa029, &r);\t// HLock()\n\tuint32 drvr_ptr = ReadMacInt32(r.a[0]);\n\tWriteMacInt32(drvr_ptr + dCtlDriver, ROMBaseMac + serd_offset + 0x100);\t\t\t// Pointer to driver header\n\tWriteMacInt16(drvr_ptr + dCtlFlags, (ain_driver[0] << 8) + ain_driver[1]);\t\t// Driver flags\n\tWriteMacInt16(drvr_ptr + dCtlQHdr + qFlags, 9);\t\t\t\t\t\t\t\t\t// Version number\n\n\t// Install .AOut driver\n\tr.d[0] = (uint32)-7;\n\tr.a[0] = ROMBaseMac + serd_offset + 0x200;\n\tExecute68kTrap(0xa53d, &r);\t// DrvrInstallRsrvMem()\n\tExecute68kTrap(0xa029, &r);\t// HLock()\n\tdrvr_ptr = ReadMacInt32(r.a[0]);\n\tWriteMacInt32(drvr_ptr + dCtlDriver, ROMBaseMac + serd_offset + 0x200);\t\t\t// Pointer to driver header\n\tWriteMacInt16(drvr_ptr + dCtlFlags, (aout_driver[0] << 8) + aout_driver[1]);\t// Driver flags\n\tWriteMacInt16(drvr_ptr + dCtlQHdr + qFlags, 9);\t\t\t\t\t\t\t\t\t// Version number\n\n\t// Install .BIn driver\n\tr.d[0] = (uint32)-8;\n\tr.a[0] = ROMBaseMac + serd_offset + 0x300;\n\tExecute68kTrap(0xa53d, &r);\t// DrvrInstallRsrvMem()\n\tExecute68kTrap(0xa029, &r);\t// HLock()\n\tdrvr_ptr = ReadMacInt32(r.a[0]);\n\tWriteMacInt32(drvr_ptr + dCtlDriver, ROMBaseMac + serd_offset + 0x300);\t\t\t// Pointer to driver header\n\tWriteMacInt16(drvr_ptr + dCtlFlags, (bin_driver[0] << 8) + bin_driver[1]);\t\t// Driver flags\n\tWriteMacInt16(drvr_ptr + dCtlQHdr + qFlags, 9);\t\t\t\t\t\t\t\t\t// Version number\n\n\t// Install .BOut driver\n\tr.d[0] = (uint32)-9;\n\tr.a[0] = ROMBaseMac + serd_offset + 0x400;\n\tExecute68kTrap(0xa53d, &r);\t// DrvrInstallRsrvMem()\n\tExecute68kTrap(0xa029, &r);\t// HLock()\n\tdrvr_ptr = ReadMacInt32(r.a[0]);\n\tWriteMacInt32(drvr_ptr + dCtlDriver, ROMBaseMac + serd_offset + 0x400);\t\t\t// Pointer to driver header\n\tWriteMacInt16(drvr_ptr + dCtlFlags, (bout_driver[0] << 8) + bout_driver[1]);\t// Driver flags\n\tWriteMacInt16(drvr_ptr + dCtlQHdr + qFlags, 9);\t\t\t\t\t\t\t\t\t// Version number\n}\n\n\n/*\n *  Install patches after MacOS startup\n */\n\nvoid PatchAfterStartup(void)\n{\n#if SUPPORTS_EXTFS\n\t// Install external file system\n\tInstallExtFS();\n#endif\n}\n\n\n/*\n *  Check ROM version, returns false if ROM version is not supported\n */\n\nbool CheckROM(void)\n{\n\t// Read version\n\tROMVersion = ntohs(*(uint16 *)(ROMBaseHost + 8));\n\n#if REAL_ADDRESSING || DIRECT_ADDRESSING\n\t// Real and direct addressing modes require a 32-bit clean ROM\n\treturn ROMVersion == ROM_VERSION_32;\n#else\n\t// Virtual addressing mode works with 32-bit clean Mac II ROMs and Classic ROMs\n\treturn (ROMVersion == ROM_VERSION_CLASSIC) || (ROMVersion == ROM_VERSION_32);\n#endif\n}\n\n\n/*\n *  Install ROM patches, returns false if ROM version is not supported\n */\n\n// ROM patches for Mac Classic/SE ROMs (version $0276)\nstatic bool patch_rom_classic(void)\n{\n\tuint16 *wp;\n\tuint32 base;\n\n\t// Don't jump into debugger (VIA line)\n\twp = (uint16 *)(ROMBaseHost + 0x1c40);\n\t*wp = htons(0x601e);\n\n\t// Don't complain about incorrect ROM checksum\n\twp = (uint16 *)(ROMBaseHost + 0x1c6c);\n\t*wp = htons(0x7c00);\n\n\t// Don't initialize IWM\n\twp = (uint16 *)(ROMBaseHost + 0x50);\n\t*wp++ = htons(M68K_NOP);\n\t*wp = htons(M68K_NOP);\n\n\t// Skip startup sound\n\twp = (uint16 *)(ROMBaseHost + 0x6a);\n\t*wp++ = htons(M68K_NOP);\n\t*wp = htons(M68K_NOP);\n\n\t// Don't loop in ADB init\n\twp = (uint16 *)(ROMBaseHost + 0x3364);\n\t*wp = htons(M68K_NOP);\n\n\t// Patch ClkNoMem\n\twp = (uint16 *)(ROMBaseHost + 0xa2c0);\n\t*wp++ = htons(M68K_EMUL_OP_CLKNOMEM);\n\t*wp = htons(0x4ed5);\t\t\t// jmp\t(a5)\n\n\t// Skip main memory test (not that it wouldn't pass, but it's faster that way)\n\twp = (uint16 *)(ROMBaseHost + 0x11e);\n\t*wp++ = htons(M68K_NOP);\n\t*wp = htons(M68K_NOP);\n\n\t// Install our own drivers\n\twp = (uint16 *)(ROMBaseHost + 0x3f82a);\n\t*wp++ = htons(M68K_EMUL_OP_INSTALL_DRIVERS);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp = htons(M68K_NOP);\n\n#if 1\n\t// Don't look for SCSI devices\n\twp = (uint16 *)(ROMBaseHost + 0xd5a);\n\t*wp = htons(0x601e);\n#endif\n\n\t// Replace .Sony driver\n\tsony_offset = 0x34680;\n\tD(bug(\"sony %08lx\\n\", sony_offset));\n\tmemcpy(ROMBaseHost + sony_offset, sony_driver, sizeof(sony_driver));\n\n\t// Install .Disk and .AppleCD drivers\n\tmemcpy(ROMBaseHost + sony_offset + 0x100, disk_driver, sizeof(disk_driver));\n\tmemcpy(ROMBaseHost + sony_offset + 0x200, cdrom_driver, sizeof(cdrom_driver));\n\n\t// Copy icons to ROM\n\tSonyDiskIconAddr = ROMBaseMac + sony_offset + 0x400;\n\tmemcpy(ROMBaseHost + sony_offset + 0x400, SonyDiskIcon, sizeof(SonyDiskIcon));\n\tSonyDriveIconAddr = ROMBaseMac + sony_offset + 0x600;\n\tmemcpy(ROMBaseHost + sony_offset + 0x600, SonyDriveIcon, sizeof(SonyDriveIcon));\n\tDiskIconAddr = ROMBaseMac + sony_offset + 0x800;\n\tmemcpy(ROMBaseHost + sony_offset + 0x800, DiskIcon, sizeof(DiskIcon));\n\tCDROMIconAddr = ROMBaseMac + sony_offset + 0xa00;\n\tmemcpy(ROMBaseHost + sony_offset + 0xa00, CDROMIcon, sizeof(CDROMIcon));\n\n\t// Install SERD patch and serial drivers\n\tserd_offset = 0x31bae;\n\tD(bug(\"serd %08lx\\n\", serd_offset));\n\twp = (uint16 *)(ROMBaseHost + serd_offset + 12);\n\t*wp++ = htons(M68K_EMUL_OP_SERD);\n\t*wp = htons(M68K_RTS);\n\tmemcpy(ROMBaseHost + serd_offset + 0x100, ain_driver, sizeof(ain_driver));\n\tmemcpy(ROMBaseHost + serd_offset + 0x200, aout_driver, sizeof(aout_driver));\n\tmemcpy(ROMBaseHost + serd_offset + 0x300, bin_driver, sizeof(bin_driver));\n\tmemcpy(ROMBaseHost + serd_offset + 0x400, bout_driver, sizeof(bout_driver));\n\n\t// Replace ADBOp()\n\tmemcpy(ROMBaseHost + 0x3880, adbop_patch, sizeof(adbop_patch));\n\n\t// Replace Time Manager\n\twp = (uint16 *)(ROMBaseHost + 0x1a95c);\n\t*wp++ = htons(M68K_EMUL_OP_INSTIME);\n\t*wp = htons(M68K_RTS);\n\twp = (uint16 *)(ROMBaseHost + 0x1a96a);\n\t*wp++ = htons(0x40e7);\t\t// move\tsr,-(sp)\n\t*wp++ = htons(0x007c);\t\t// ori\t#$0700,sr\n\t*wp++ = htons(0x0700);\n\t*wp++ = htons(M68K_EMUL_OP_RMVTIME);\n\t*wp++ = htons(0x46df);\t\t// move\t(sp)+,sr\n\t*wp = htons(M68K_RTS);\n\twp = (uint16 *)(ROMBaseHost + 0x1a984);\n\t*wp++ = htons(0x40e7);\t\t// move\tsr,-(sp)\n\t*wp++ = htons(0x007c);\t\t// ori\t#$0700,sr\n\t*wp++ = htons(0x0700);\n\t*wp++ = htons(M68K_EMUL_OP_PRIMETIME);\n\t*wp++ = htons(0x46df);\t\t// move\t(sp)+,sr\n\t*wp++ = htons(M68K_RTS);\n\tmicroseconds_offset = (uint8 *)wp - ROMBaseHost;\n\t*wp++ = htons(M68K_EMUL_OP_MICROSECONDS);\n\t*wp++ = htons(M68K_RTS);\n\n\t// Replace DebugUtil\n\tdebugutil_offset = (uint8 *)wp - ROMBaseHost;\n\t*wp++ = htons(M68K_EMUL_OP_DEBUGUTIL);\n\t*wp = htons(M68K_RTS);\n\n\t// Replace SCSIDispatch()\n\twp = (uint16 *)(ROMBaseHost + 0x1a206);\n\t*wp++ = htons(M68K_EMUL_OP_SCSI_DISPATCH);\n\t*wp++ = htons(0x2e49);\t\t// move.l\ta1,a7\n\t*wp = htons(M68K_JMP_A0);\n\n\t// Modify vCheckLoad() so we can patch resources\n\twp = (uint16 *)(ROMBaseHost + 0xe740);\n\t*wp++ = htons(M68K_JMP);\n\t*wp++ = htons((ROMBaseMac + sony_offset + 0x300) >> 16);\n\t*wp = htons((ROMBaseMac + sony_offset + 0x300) & 0xffff);\n\twp = (uint16 *)(ROMBaseHost + sony_offset + 0x300);\n\t*wp++ = htons(0x2f03);\t\t// move.l\td3,-(sp) (save type)\n\t*wp++ = htons(0x2078);\t\t// move.l\t$07f0,a0\n\t*wp++ = htons(0x07f0);\n\t*wp++ = htons(M68K_JSR_A0);\n\t*wp++ = htons(0x221f);\t\t// move.l\t(sp)+,d1 (restore type)\n\t*wp++ = htons(M68K_EMUL_OP_CHECKLOAD);\n\t*wp = htons(M68K_RTS);\n\n\t// Install PutScrap() patch for clipboard data exchange (the patch is activated by EMUL_OP_INSTALL_DRIVERS)\n\tPutScrapPatch = ROMBaseMac + sony_offset + 0xc00;\n\tbase = ROMBaseMac + 0x12794;\n\twp = (uint16 *)(ROMBaseHost + sony_offset + 0xc00);\n\t*wp++ = htons(M68K_EMUL_OP_PUT_SCRAP);\n\t*wp++ = htons(M68K_JMP);\n\t*wp++ = htons(base >> 16);\n\t*wp = htons(base & 0xffff);\n\n#if 0\n\t// Boot from internal EDisk\n\twp = (uint16 *)(ROMBaseHost + 0x3f83c);\n\t*wp = htons(M68K_NOP);\n#endif\n\n\t// Patch VIA interrupt handler\n\twp = (uint16 *)(ROMBaseHost + 0x2b3a);\t// Level 1 handler\n\t*wp++ = htons(0x5888);\t\t// addq.l\t#4,a0\n\t*wp++ = htons(0x5888);\t\t// addq.l\t#4,a0\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp = htons(M68K_NOP);\n\n\twp = (uint16 *)(ROMBaseHost + 0x2be4);\t// 60Hz handler (handles everything)\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_EMUL_OP_IRQ);\n\t*wp++ = htons(0x4a80);\t\t// tst.l\td0\n\t*wp = htons(0x67f4);\t\t// beq\t\t0x402be2\n\treturn true;\n}\n\n// ROM patches for 32-bit clean Mac-II ROMs (version $067c)\nstatic bool patch_rom_32(void)\n{\n\tuint16 *wp;\n\tuint8 *bp;\n\tuint32 base;\n\n\t// Find UniversalInfo\n\tstatic const uint8 universal_dat[] = {0xdc, 0x00, 0x05, 0x05, 0x3f, 0xff, 0x01, 0x00};\n\tif ((base = find_rom_data(0x3400, 0x3c00, universal_dat, sizeof(universal_dat))) == 0) return false;\n\tUniversalInfo = base - 0x10;\n\tD(bug(\"universal %08lx\\n\", UniversalInfo));\n\n\t// Patch UniversalInfo (disable NuBus slots)\n\tbp = ROMBaseHost + UniversalInfo + ReadMacInt32(ROMBaseMac + UniversalInfo + 12);\t// nuBusInfoPtr\n\tbp[0] = 0x03;\n\tfor (int i=1; i<16; i++)\n\t\tbp[i] = 0x08;\n\n\t// Set model ID from preferences\n\tbp = ROMBaseHost + UniversalInfo + 18;\t\t// productKind\n\t*bp = PrefsFindInt32(\"modelid\");\n\n#if !ROM_IS_WRITE_PROTECTED\n#if defined(USE_SCRATCHMEM_SUBTERFUGE)\n\t// Set hardware base addresses to scratch memory area\n\tif (PatchHWBases) {\n\t\textern uint8 *ScratchMem;\n\t\tconst uint32 ScratchMemBase = Host2MacAddr(ScratchMem);\n\t\t\n\t\tD(bug(\"LMGlob\\tOfs/4\\tBase\\n\"));\n\t\tbase = ROMBaseMac + UniversalInfo + ReadMacInt32(ROMBaseMac + UniversalInfo); // decoderInfoPtr\n\t\twp = (uint16 *)(ROMBaseHost + 0x94a);\n\t\twhile (*wp != 0xffff) {\n\t\t\tint16 ofs = ntohs(*wp++);\t\t\t// offset in decoderInfo (/4)\n\t\t\tint16 lmg = ntohs(*wp++);\t\t\t// address of LowMem global\n\t\t\tD(bug(\"0x%04x\\t%d\\t0x%08x\\n\", lmg, ofs, ReadMacInt32(base + ofs*4)));\n\t\t\t\n\t\t\t// Fake address only if this is not the ASC base\n\t\t\tif (lmg != 0xcc0)\n\t\t\t\tWriteMacInt32(base + ofs*4, ScratchMemBase);\n\t\t}\n\t}\n#else\n#error System specific handling for writable ROM is required here\n#endif\n#endif\n\n\t// Make FPU optional\n\tif (FPUType == 0) {\n\t\tbp = ROMBaseHost + UniversalInfo + 22;\t// defaultRSRCs\n\t\t*bp = 4;\t// FPU optional\n\t}\n\n\t// Install special reset opcode and jump (skip hardware detection and tests)\n\twp = (uint16 *)(ROMBaseHost + 0x8c);\n\t*wp++ = htons(M68K_EMUL_OP_RESET);\n\t*wp++ = htons(M68K_JMP);\n\t*wp++ = htons((ROMBaseMac + 0xba) >> 16);\n\t*wp = htons((ROMBaseMac + 0xba) & 0xffff);\n\n\t// Don't GetHardwareInfo\n\twp = (uint16 *)(ROMBaseHost + 0xc2);\n\t*wp++ = htons(M68K_NOP);\n\t*wp = htons(M68K_NOP);\n\n\t// Don't init VIAs\n\twp = (uint16 *)(ROMBaseHost + 0xc6);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp = htons(M68K_NOP);\n\n\t// Fake CPU type test\n\twp = (uint16 *)(ROMBaseHost + 0x7c0);\n\t*wp++ = htons(0x7e00 + CPUType);\n\t*wp = htons(M68K_RTS);\n\n\t// Don't clear end of BootGlobs upto end of RAM (address xxxx0000)\n\tstatic const uint8 clear_globs_dat[] = {0x42, 0x9a, 0x36, 0x0a, 0x66, 0xfa};\n\tbase = find_rom_data(0xa00, 0xb00, clear_globs_dat, sizeof(clear_globs_dat));\n\tD(bug(\"clear_globs %08lx\\n\", base));\n\tif (base) {\t\t// ROM15/20/22/23/26/27/32\n\t\twp = (uint16 *)(ROMBaseHost + base + 2);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp = htons(M68K_NOP);\n\t}\n\n\t// Patch InitMMU (no MMU present, don't choke on unknown CPU types)\n\tif (ROMSize <= 0x80000) {\n\t\tstatic const uint8 init_mmu_dat[] = {0x0c, 0x47, 0x00, 0x03, 0x62, 0x00, 0xfe};\n\t\tif ((base = find_rom_data(0x4000, 0x50000, init_mmu_dat, sizeof(init_mmu_dat))) == 0) return false;\n\t} else {\n\t\tstatic const uint8 init_mmu_dat[] = {0x0c, 0x47, 0x00, 0x04, 0x62, 0x00, 0xfd};\n\t\tif ((base = find_rom_data(0x80000, 0x90000, init_mmu_dat, sizeof(init_mmu_dat))) == 0) return false;\n\t}\n\tD(bug(\"init_mmu %08lx\\n\", base));\n\twp = (uint16 *)(ROMBaseHost + base);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\twp++;\n\t*wp++ = htons(0x7000);\t\t\t// moveq #0,d0\n\t*wp = htons(M68K_NOP);\n\n\t// Patch InitMMU (no RBV present)\n\tstatic const uint8 init_mmu2_dat[] = {0x08, 0x06, 0x00, 0x0d, 0x67};\n\tif (ROMSize <= 0x80000) {\n\t\tbase = find_rom_data(0x4000, 0x50000, init_mmu2_dat, sizeof(init_mmu2_dat));\n\t} else {\n\t\tbase = find_rom_data(0x80000, 0x90000, init_mmu2_dat, sizeof(init_mmu2_dat));\n\t}\n\tD(bug(\"init_mmu2 %08lx\\n\", base));\n\tif (base) {\t\t// ROM11/10/13/26\n\t\tbp = (uint8 *)(ROMBaseHost + base + 4);\n\t\t*bp = 0x60;\t\t\t\t\t\t// bra\n\t}\n\n\t// Patch InitMMU (don't init MMU)\n\tstatic const uint8 init_mmu3_dat[] = {0x0c, 0x2e, 0x00, 0x01, 0xff, 0xe6, 0x66, 0x0c, 0x4c, 0xed, 0x03, 0x87, 0xff, 0xe8};\n\tif (ROMSize <= 0x80000) {\n\t\tif ((base = find_rom_data(0x4000, 0x50000, init_mmu3_dat, sizeof(init_mmu3_dat))) == 0) return false;\n\t} else {\n\t\tif ((base = find_rom_data(0x80000, 0x90000, init_mmu3_dat, sizeof(init_mmu3_dat))) == 0) return false;\n\t}\n\tD(bug(\"init_mmu3 %08lx\\n\", base));\n\twp = (uint16 *)(ROMBaseHost + base + 6);\n\t*wp = htons(M68K_NOP);\n\n\t// Replace XPRAM routines\n\tstatic const uint8 read_xpram_dat[] = {0x26, 0x4e, 0x41, 0xf9, 0x50, 0xf0, 0x00, 0x00, 0x08, 0x90, 0x00, 0x02};\n\tbase = find_rom_data(0x40000, 0x50000, read_xpram_dat, sizeof(read_xpram_dat));\n\tD(bug(\"read_xpram %08lx\\n\", base));\n\tif (base) {\t\t\t// ROM10\n\t\twp = (uint16 *)(ROMBaseHost + base);\n\t\t*wp++ = htons(M68K_EMUL_OP_READ_XPRAM);\n\t\t*wp = htons(0x4ed6);\t\t// jmp\t(a6)\n\t}\n\tstatic const uint8 read_xpram2_dat[] = {0x26, 0x4e, 0x08, 0x92, 0x00, 0x02, 0xea, 0x59, 0x02, 0x01, 0x00, 0x07, 0x00, 0x01, 0x00, 0xb8};\n\tbase = find_rom_data(0x40000, 0x50000, read_xpram2_dat, sizeof(read_xpram2_dat));\n\tD(bug(\"read_xpram2 %08lx\\n\", base));\n\tif (base) {\t\t\t// ROM11\n\t\twp = (uint16 *)(ROMBaseHost + base);\n\t\t*wp++ = htons(M68K_EMUL_OP_READ_XPRAM);\n\t\t*wp = htons(0x4ed6);\t\t// jmp\t(a6)\n\t}\n\tif (ROMSize > 0x80000) {\n\t\tstatic const uint8 read_xpram3_dat[] = {0x48, 0xe7, 0xe0, 0x60, 0x02, 0x01, 0x00, 0x70, 0x0c, 0x01, 0x00, 0x20};\n\t\tbase = find_rom_data(0x80000, 0x90000, read_xpram3_dat, sizeof(read_xpram3_dat));\n\t\tD(bug(\"read_xpram3 %08lx\\n\", base));\n\t\tif (base) {\t\t// ROM15\n\t\t\twp = (uint16 *)(ROMBaseHost + base);\n\t\t\t*wp++ = htons(M68K_EMUL_OP_READ_XPRAM2);\n\t\t\t*wp = htons(M68K_RTS);\n\t\t}\n\t}\n\n\t// Patch ClkNoMem\n\tbase = find_rom_trap(0xa053);\n\twp = (uint16 *)(ROMBaseHost + base);\n\tif (ntohs(*wp) == 0x4ed5) {\t// ROM23/26/27/32\n\t\tstatic const uint8 clk_no_mem_dat[] = {0x40, 0xc2, 0x00, 0x7c, 0x07, 0x00, 0x48, 0x42};\n\t\tif ((base = find_rom_data(0xb0000, 0xb8000, clk_no_mem_dat, sizeof(clk_no_mem_dat))) == 0) return false;\n\t}\n\tD(bug(\"clk_no_mem %08lx\\n\", base));\n\twp = (uint16 *)(ROMBaseHost + base);\n\t*wp++ = htons(M68K_EMUL_OP_CLKNOMEM);\n\t*wp = htons(0x4ed5);\t\t\t// jmp\t(a5)\n\n\t// Patch BootGlobs\n\twp = (uint16 *)(ROMBaseHost + 0x10e);\n\t*wp++ = htons(M68K_EMUL_OP_PATCH_BOOT_GLOBS);\n\t*wp = htons(M68K_NOP);\n\n\t// Don't init SCC\n\tstatic const uint8 init_scc_dat[] = {0x08, 0x38, 0x00, 0x01, 0x0d, 0xd1, 0x67, 0x04};\n\tif ((base = find_rom_data(0xa00, 0xa80, init_scc_dat, sizeof(init_scc_dat))) == 0) return false;\n\tD(bug(\"init_scc %08lx\\n\", base));\n\twp = (uint16 *)(ROMBaseHost + base);\n\t*wp = htons(M68K_RTS);\n\n\t// Don't access 0x50f1a101\n\twp = (uint16 *)(ROMBaseHost + 0x4232);\n\tif (ntohs(wp[1]) == 0x50f1 && ntohs(wp[2]) == 0xa101) {\t// ROM32\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp = htons(M68K_NOP);\n\t}\n\n\t// Don't init IWM\n\twp = (uint16 *)(ROMBaseHost + 0x9c0);\n\t*wp = htons(M68K_RTS);\n\n\t// Don't init SCSI\n\twp = (uint16 *)(ROMBaseHost + 0x9a0);\n\t*wp = htons(M68K_RTS);\n\n\t// Don't init ASC\n\tstatic const uint8 init_asc_dat[] = {0x26, 0x68, 0x00, 0x30, 0x12, 0x00, 0xeb, 0x01};\n\tbase = find_rom_data(0x4000, 0x5000, init_asc_dat, sizeof(init_asc_dat));\n\tD(bug(\"init_asc %08lx\\n\", base));\n\tif (base) {\t\t// ROM15/22/23/26/27/32\n\t\twp = (uint16 *)(ROMBaseHost + base);\n\t\t*wp = htons(0x4ed6);\t\t// jmp\t(a6)\n\t}\n\n\t// Don't EnableExtCache\n\twp = (uint16 *)(ROMBaseHost + 0x190);\n\t*wp++ = htons(M68K_NOP);\n\t*wp = htons(M68K_NOP);\n\n\t// Don't DisableIntSources\n\twp = (uint16 *)(ROMBaseHost + 0x9f4c);\n\t*wp = htons(M68K_RTS);\n\n\t// Fake CPU speed test (SetupTimeK)\n\t// *** increased jl : MacsBug uses TimeDBRA for kbd repeat timing\n\twp = (uint16 *)(ROMBaseHost + 0x800);\n\t*wp++ = htons(0x31fc);\t\t\t// move.w\t#xxx,TimeDBRA\n\t*wp++ = htons(10000);\n\t*wp++ = htons(0x0d00);\n\t*wp++ = htons(0x31fc);\t\t\t// move.w\t#xxx,TimeSCCDBRA\n\t*wp++ = htons(10000);\n\t*wp++ = htons(0x0d02);\n\t*wp++ = htons(0x31fc);\t\t\t// move.w\t#xxx,TimeSCSIDBRA\n\t*wp++ = htons(10000);\n\t*wp++ = htons(0x0b24);\n\t*wp++ = htons(0x31fc);\t\t\t// move.w\t#xxx,TimeRAMDBRA\n\t*wp++ = htons(10000);\n\t*wp++ = htons(0x0cea);\n\t*wp = htons(M68K_RTS);\n\n#if REAL_ADDRESSING\n\t// Move system zone to start of Mac RAM\n\twp = (uint16 *)(ROMBaseHost + 0x50a);\n\t*wp++ = htons(HiWord(RAMBaseMac + 0x2000));\n\t*wp++ = htons(LoWord(RAMBaseMac + 0x2000));\n\t*wp++ = htons(HiWord(RAMBaseMac + 0x3800));\n\t*wp = htons(LoWord(RAMBaseMac + 0x3800));\n#endif\n\n#if !ROM_IS_WRITE_PROTECTED\n#if defined(USE_SCRATCHMEM_SUBTERFUGE)\n\t// Set fake handle at 0x0000 to scratch memory area (so broken Mac programs won't write into Mac ROM)\n\textern uint8 *ScratchMem;\n\tconst uint32 ScratchMemBase = Host2MacAddr(ScratchMem);\n\twp = (uint16 *)(ROMBaseHost + 0xccaa);\n\t*wp++ = htons(0x203c);\t\t\t// move.l\t#ScratchMem,d0\n\t*wp++ = htons(ScratchMemBase >> 16);\n\t*wp = htons(ScratchMemBase);\n#else\n#error System specific handling for writable ROM is required here\n#endif\n#endif\n\n#if REAL_ADDRESSING && defined(AMIGA)\n\t// Don't overwrite SysBase under AmigaOS\n\twp = (uint16 *)(ROMBaseHost + 0xccb4);\n\t*wp++ = htons(M68K_NOP);\n\t*wp = htons(M68K_NOP);\n#endif\n\t\n#if REAL_ADDRESSING && !defined(AMIGA)\n\t// gb-- Temporary hack to get rid of crashes in Speedometer\n\twp = (uint16 *)(ROMBaseHost + 0xdba2);\n\tif (ntohs(*wp) == 0x662c)\t\t// bne.b\t#$2c\n\t\t*wp = htons(0x602c);\t\t// bra.b\t#$2c\n#endif\n\t\n\t// Don't write to VIA in InitTimeMgr\n\twp = (uint16 *)(ROMBaseHost + 0xb0e2);\n\t*wp++ = htons(0x4cdf);\t\t\t// movem.l\t(sp)+,d0-d5/a0-a4\n\t*wp++ = htons(0x1f3f);\n\t*wp = htons(M68K_RTS);\n\n\t// Don't read ModelID from 0x5ffffffc\n\tstatic const uint8 model_id_dat[] = {0x20, 0x7c, 0x5f, 0xff, 0xff, 0xfc, 0x72, 0x07, 0xc2, 0x90};\n\tbase = find_rom_data(0x40000, 0x50000, model_id_dat, sizeof(model_id_dat));\n\tD(bug(\"model_id %08lx\\n\", base));\n\tif (base) {\t\t// ROM20\n\t\twp = (uint16 *)(ROMBaseHost + base + 8);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp = htons(M68K_NOP);\n\t}\n\n\t// Don't read ModelID from 0x5ffffffc\n\tstatic const uint8 model_id2_dat[] = {0x45, 0xf9, 0x5f, 0xff, 0xff, 0xfc, 0x20, 0x12};\n\tbase = find_rom_data(0x4000, 0x5000, model_id2_dat, sizeof(model_id2_dat));\n\tD(bug(\"model_id2 %08lx\\n\", base));\n\tif (base) {\t\t// ROM27/32\n\t\twp = (uint16 *)(ROMBaseHost + base + 6);\n\t\t*wp++ = htons(0x7000);\t// moveq\t#0,d0\n\t\t*wp++ = htons(0xb040);\t// cmp.w\td0,d0\n\t\t*wp = htons(0x4ed6);\t// jmp\t\t(a6)\n\t}\n\n\t// Install slot ROM\n\tif (!InstallSlotROM())\n\t\treturn false;\n\n\t// Don't probe NuBus slots\n\tstatic const uint8 nubus_dat[] = {0x45, 0xfa, 0x00, 0x0a, 0x42, 0xa7, 0x10, 0x11};\n\tbase = find_rom_data(0x5000, 0x6000, nubus_dat, sizeof(nubus_dat));\n\tD(bug(\"nubus %08lx\\n\", base));\n\tif (base) {\t\t// ROM10/11\n\t\twp = (uint16 *)(ROMBaseHost + base + 6);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp = htons(M68K_NOP);\n\t}\n\n\t// Don't EnableOneSecInts\n\tstatic const uint8 lea_dat[] = {0x41, 0xf9};\n\tif ((base = find_rom_data(0x226, 0x22a, lea_dat, sizeof(lea_dat))) == 0) return false;\n\tD(bug(\"enable_one_sec_ints %08lx\\n\", base));\n\twp = (uint16 *)(ROMBaseHost + base);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp = htons(M68K_NOP);\n\n\t// Don't EnableParityPatch/Enable60HzInts\n\tif ((base = find_rom_data(0x230, 0x234, lea_dat, sizeof(lea_dat))) == 0) {\n\t\twp = (uint16 *)(ROMBaseHost + 0x230);\n\t\tif (ntohs(*wp) == 0x6100)\t// ROM11\n\t\t\tbase = 0x230;\n\t\telse\n\t\t\treturn false;\n\t}\n\tD(bug(\"enable_60hz_ints %08lx\\n\", base));\n\twp = (uint16 *)(ROMBaseHost + base);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp = htons(M68K_NOP);\n\n\t// Compute boot stack pointer and fix logical/physical RAM size (CompBootStack) (must be done after InitMemMgr!)\n\twp = (uint16 *)(ROMBaseHost + 0x490);\n\t*wp++ = htons(0x2038);\t// move.l\t$10c,d0\n\t*wp++ = htons(0x010c);\n\t*wp++ = htons(0xd0b8);\t// add.l\t$2a6,d0\n\t*wp++ = htons(0x02a6);\n\t*wp++ = htons(0xe288);\t// lsr.l\t#1,d0\n\t*wp++ = htons(0x0880);\t// bclr\t\t#0,d0\n\t*wp++ = htons(0x0000);\n\t*wp++ = htons(0x0440);\t// subi.w\t#$400,d0\n\t*wp++ = htons(0x0400);\n\t*wp++ = htons(0x2040);\t// move.l\td0,a0\n\t*wp++ = htons(M68K_EMUL_OP_FIX_MEMSIZE);\n\t*wp++ = htons(M68K_RTS);\n\n\tstatic const uint8 fix_memsize2_dat[] = {0x22, 0x30, 0x81, 0xe2, 0x0d, 0xdc, 0xff, 0xba, 0xd2, 0xb0, 0x81, 0xe2, 0x0d, 0xdc, 0xff, 0xec, 0x21, 0xc1, 0x1e, 0xf8};\n\tbase = find_rom_data(0x4c000, 0x4c080, fix_memsize2_dat, sizeof(fix_memsize2_dat));\n\tD(bug(\"fix_memsize2 %08lx\\n\", base));\n\tif (base) {\t\t// ROM15/22/23/26/27/32\n\t\twp = (uint16 *)(ROMBaseHost + base + 16);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp = htons(M68K_NOP);\n\t}\n\n\t// Don't open .Sound driver but install our own drivers\n\twp = (uint16 *)(ROMBaseHost + 0x1142);\n\t*wp = htons(M68K_EMUL_OP_INSTALL_DRIVERS);\n\n\t// Don't access SonyVars\n\twp = (uint16 *)(ROMBaseHost + 0x1144);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\twp += 2;\n\t*wp = htons(M68K_NOP);\n\n\t// Don't write to VIA in InitADB\n\twp = (uint16 *)(ROMBaseHost + 0xa8a8);\n\tif (*wp == 0) {\t\t// ROM22/23/26/27/32\n\t\twp = (uint16 *)(ROMBaseHost + 0xb2c6a);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp = htons(M68K_NOP);\n\t\twp = (uint16 *)(ROMBaseHost + 0xb2d2e);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\twp += 2;\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp = htons(M68K_NOP);\n\t} else {\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp = htons(M68K_NOP);\n\t\twp = (uint16 *)(ROMBaseHost + 0xa662);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp++ = htons(M68K_NOP);\n\t\twp += 2;\n\t\t*wp++ = htons(M68K_NOP);\n\t\t*wp = htons(M68K_NOP);\n\t}\n\n\t// Don't EnableSlotInts\n\tif ((base = find_rom_data(0x2ee, 0x2f2, lea_dat, sizeof(lea_dat))) == 0) return false;\n\tD(bug(\"enable_slot_ints %08lx\\n\", base));\n\twp = (uint16 *)(ROMBaseHost + base);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp = htons(M68K_NOP);\n\n\t// Don't mangle frame buffer base (GetDevBase)\n\twp = (uint16 *)(ROMBaseHost + 0x5b78);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(0x2401);\t\t// move.l\td1,d2\n\t*wp = htons(0x605e);\t\t// bra\t\t0x40805bde\n\n\t// Really don't mangle frame buffer base\n\tif (ROMSize > 0x80000) {\n\t\tstatic const uint8 frame_base_dat[] = {0x22, 0x78, 0x0d, 0xd8, 0xd3, 0xe9, 0x00, 0x08};\n\t\tbase = find_rom_data(0x8c000, 0x8d000, frame_base_dat, sizeof(frame_base_dat));\n\t\tD(bug(\"frame_base %08lx\\n\", base));\n\t\tif (base) {\t\t// ROM22/23/26/27/32\n\t\t\twp = (uint16 *)(ROMBaseHost + base);\n\t\t\t*wp++ = htons(0x2401);\t// move.l\td1,d2\n\t\t\t*wp = htons(M68K_RTS);\n\t\t}\n\t}\n\n\t// Don't write to VIA2\n\tstatic const uint8 via2_dat[] = {0x20, 0x78, 0x0c, 0xec, 0x11, 0x7c, 0x00, 0x90};\n\tif ((base = find_rom_data(0xa000, 0xa400, via2_dat, sizeof(via2_dat))) == 0) return false;\n\tD(bug(\"via2 %08lx\\n\", base));\n\twp = (uint16 *)(ROMBaseHost + base + 4);\n\t*wp = htons(M68K_RTS);\n\n\t// Don't write to VIA2, even on ROM20\n\tstatic const uint8 via2b_dat[] = {0x20, 0x78, 0x0c, 0xec, 0x11, 0x7c, 0x00, 0x90, 0x00, 0x13, 0x4e, 0x75};\n\tbase = find_rom_data(0x40000, 0x44000, via2b_dat, sizeof(via2b_dat));\n\tD(bug(\"via2b %08lx\\n\", base));\n\tif (base) {\t\t// ROM19/20\n\t\twp = (uint16 *)(ROMBaseHost + base + 4);\n\t\t*wp = htons(M68K_RTS);\n\t}\n\n\t// Don't use PTEST instruction on 68040/060\n\tif (ROMSize > 0x80000) {\n\n\t\t// BlockMove()\n\t\tstatic const uint8 bmove_dat[] = {0x20, 0x5f, 0x22, 0x5f, 0x0c, 0x38, 0x00, 0x04, 0x01, 0x2f};\n\t\tbase = find_rom_data(0x87000, 0x87800, bmove_dat, sizeof(bmove_dat));\n\t\tD(bug(\"block_move %08lx\\n\", base));\n\t\tif (base) {\t\t// ROM15/22/23/26/27/32\n\t\t\twp = (uint16 *)(ROMBaseHost + base + 4);\n\t\t\t*wp++ = htons(M68K_EMUL_OP_BLOCK_MOVE);\n\t\t\t*wp++ = htons(0x7000);\n\t\t\t*wp = htons(M68K_RTS);\n\t\t}\n\n\t\t// SANE\n\t\tstatic const uint8 ptest2_dat[] = {0x0c, 0x38, 0x00, 0x04, 0x01, 0x2f, 0x6d, 0x54, 0x48, 0xe7, 0xf8, 0x60};\n\t\tbase = find_rom_data(0, ROMSize, ptest2_dat, sizeof(ptest2_dat));\n\t\tD(bug(\"ptest2 %08lx\\n\", base));\n\t\tif (base) {\t\t// ROM15/20/22/23/26/27/32\n\t\t\twp = (uint16 *)(ROMBaseHost + base + 8);\n\t\t\t*wp++ = htons(M68K_NOP);\n\t\t\t*wp++ = htons(0xf4f8);\t\t// cpusha\tdc/ic\n\t\t\t*wp++ = htons(M68K_NOP);\n\t\t\t*wp++ = htons(0x7000);\t\t// moveq\t#0,d0\n\t\t\t*wp = htons(M68K_RTS);\n\t\t}\n\t}\n\n\t// Don't set MemoryDispatch() to unimplemented trap\n\tstatic const uint8 memdisp_dat[] = {0x30, 0x3c, 0xa8, 0x9f, 0xa7, 0x46, 0x30, 0x3c, 0xa0, 0x5c, 0xa2, 0x47};\n\tbase = find_rom_data(0x4f100, 0x4f180, memdisp_dat, sizeof(memdisp_dat));\n\tD(bug(\"memdisp %08lx\\n\", base));\n\tif (base) {\t// ROM15/22/23/26/27/32\n\t\twp = (uint16 *)(ROMBaseHost + base + 10);\n\t\t*wp = htons(M68K_NOP);\n\t}\n\n\t// Patch .EDisk driver (don't scan for EDisks in the area ROMBase..0xe00000)\n\tuint32 edisk_offset = find_rom_resource(FOURCC('D','R','V','R'), 51);\n\tif (edisk_offset) {\n\t\tstatic const uint8 edisk_dat[] = {0xd5, 0xfc, 0x00, 0x01, 0x00, 0x00, 0xb5, 0xfc, 0x00, 0xe0, 0x00, 0x00};\n\t\tbase = find_rom_data(edisk_offset, edisk_offset + 0x10000, edisk_dat, sizeof(edisk_dat));\n\t\tD(bug(\"edisk %08lx\\n\", base));\n\t\tif (base) {\n\t\t\twp = (uint16 *)(ROMBaseHost + base + 8);\n\t\t\t*wp++ = 0;\n\t\t\t*wp = 0;\n\t\t}\n\t}\n\n\t// Replace .Sony driver\n\tsony_offset = find_rom_resource(FOURCC('D','R','V','R'), 4);\n\tD(bug(\"sony %08lx\\n\", sony_offset));\n\tmemcpy(ROMBaseHost + sony_offset, sony_driver, sizeof(sony_driver));\n\n\t// Install .Disk and .AppleCD drivers\n\tmemcpy(ROMBaseHost + sony_offset + 0x100, disk_driver, sizeof(disk_driver));\n\tmemcpy(ROMBaseHost + sony_offset + 0x200, cdrom_driver, sizeof(cdrom_driver));\n\n\t// Copy icons to ROM\n\tSonyDiskIconAddr = ROMBaseMac + sony_offset + 0x400;\n\tmemcpy(ROMBaseHost + sony_offset + 0x400, SonyDiskIcon, sizeof(SonyDiskIcon));\n\tSonyDriveIconAddr = ROMBaseMac + sony_offset + 0x600;\n\tmemcpy(ROMBaseHost + sony_offset + 0x600, SonyDriveIcon, sizeof(SonyDriveIcon));\n\tDiskIconAddr = ROMBaseMac + sony_offset + 0x800;\n\tmemcpy(ROMBaseHost + sony_offset + 0x800, DiskIcon, sizeof(DiskIcon));\n\tCDROMIconAddr = ROMBaseMac + sony_offset + 0xa00;\n\tmemcpy(ROMBaseHost + sony_offset + 0xa00, CDROMIcon, sizeof(CDROMIcon));\n\n\t// Install SERD patch and serial drivers\n\tserd_offset = find_rom_resource(FOURCC('S','E','R','D'), 0);\n\tD(bug(\"serd %08lx\\n\", serd_offset));\n\twp = (uint16 *)(ROMBaseHost + serd_offset + 12);\n\t*wp++ = htons(M68K_EMUL_OP_SERD);\n\t*wp = htons(M68K_RTS);\n\tmemcpy(ROMBaseHost + serd_offset + 0x100, ain_driver, sizeof(ain_driver));\n\tmemcpy(ROMBaseHost + serd_offset + 0x200, aout_driver, sizeof(aout_driver));\n\tmemcpy(ROMBaseHost + serd_offset + 0x300, bin_driver, sizeof(bin_driver));\n\tmemcpy(ROMBaseHost + serd_offset + 0x400, bout_driver, sizeof(bout_driver));\n\n\t// Replace ADBOp()\n\tmemcpy(ROMBaseHost + find_rom_trap(0xa07c), adbop_patch, sizeof(adbop_patch));\n\n\t// Replace Time Manager (the Microseconds patch is activated in InstallDrivers())\n\twp = (uint16 *)(ROMBaseHost + find_rom_trap(0xa058));\n\t*wp++ = htons(M68K_EMUL_OP_INSTIME);\n\t*wp = htons(M68K_RTS);\n\twp = (uint16 *)(ROMBaseHost + find_rom_trap(0xa059));\n\t*wp++ = htons(0x40e7);\t\t// move\tsr,-(sp)\n\t*wp++ = htons(0x007c);\t\t// ori\t#$0700,sr\n\t*wp++ = htons(0x0700);\n\t*wp++ = htons(M68K_EMUL_OP_RMVTIME);\n\t*wp++ = htons(0x46df);\t\t// move\t(sp)+,sr\n\t*wp = htons(M68K_RTS);\n\twp = (uint16 *)(ROMBaseHost + find_rom_trap(0xa05a));\n\t*wp++ = htons(0x40e7);\t\t// move\tsr,-(sp)\n\t*wp++ = htons(0x007c);\t\t// ori\t#$0700,sr\n\t*wp++ = htons(0x0700);\n\t*wp++ = htons(M68K_EMUL_OP_PRIMETIME);\n\t*wp++ = htons(0x46df);\t\t// move\t(sp)+,sr\n\t*wp++ = htons(M68K_RTS);\n\tmicroseconds_offset = (uint8 *)wp - ROMBaseHost;\n\t*wp++ = htons(M68K_EMUL_OP_MICROSECONDS);\n\t*wp++ = htons(M68K_RTS);\n\n\t// Replace DebugUtil\n\tdebugutil_offset = (uint8 *)wp - ROMBaseHost;\n\t*wp++ = htons(M68K_EMUL_OP_DEBUGUTIL);\n\t*wp = htons(M68K_RTS);\n\n\t// Replace SCSIDispatch()\n\twp = (uint16 *)(ROMBaseHost + find_rom_trap(0xa815));\n\t*wp++ = htons(M68K_EMUL_OP_SCSI_DISPATCH);\n\t*wp++ = htons(0x2e49);\t\t// move.l\ta1,a7\n\t*wp = htons(M68K_JMP_A0);\n\n\t// Modify vCheckLoad() so we can patch resources\n\twp = (uint16 *)(ROMBaseHost + 0x1b8f4);\n\t*wp++ = htons(M68K_JMP);\n\t*wp++ = htons((ROMBaseMac + sony_offset + 0x300) >> 16);\n\t*wp = htons((ROMBaseMac + sony_offset + 0x300) & 0xffff);\n\twp = (uint16 *)(ROMBaseHost + sony_offset + 0x300);\n\t*wp++ = htons(0x2f03);\t\t// move.l\td3,-(sp) (save type)\n\t*wp++ = htons(0x2078);\t\t// move.l\t$07f0,a0\n\t*wp++ = htons(0x07f0);\n\t*wp++ = htons(M68K_JSR_A0);\n\t*wp++ = htons(0x221f);\t\t// move.l\t(sp)+,d1 (restore type)\n\t*wp++ = htons(M68K_EMUL_OP_CHECKLOAD);\n\t*wp = htons(M68K_RTS);\n\n\t// Patch PowerOff()\n\twp = (uint16 *)(ROMBaseHost + find_rom_trap(0xa05b));\t// PowerOff()\n\t*wp = htons(M68K_EMUL_OP_SHUTDOWN);\n\n\t// Install PutScrap() patch for clipboard data exchange (the patch is activated by EMUL_OP_INSTALL_DRIVERS)\n\tPutScrapPatch = ROMBaseMac + sony_offset + 0xc00;\n\tbase = ROMBaseMac + find_rom_trap(0xa9fe);\n\twp = (uint16 *)(ROMBaseHost + sony_offset + 0xc00);\n\t*wp++ = htons(M68K_EMUL_OP_PUT_SCRAP);\n\t*wp++ = htons(M68K_JMP);\n\t*wp++ = htons(base >> 16);\n\t*wp = htons(base & 0xffff);\n\n\t// Install GetScrap() patch for clipboard data exchange (the patch is activated by EMUL_OP_INSTALL_DRIVERS)\n\tGetScrapPatch = ROMBaseMac + sony_offset + 0xd00;\n\tbase = ROMBaseMac + find_rom_trap(0xa9fd);\n\twp = (uint16 *)(ROMBaseHost + sony_offset + 0xd00);\n\t*wp++ = htons(M68K_EMUL_OP_GET_SCRAP);\n\t*wp++ = htons(M68K_JMP);\n\t*wp++ = htons(base >> 16);\n\t*wp = htons(base & 0xffff);\n\n\t// Look for double PACK 4 resources\n\tif ((base = find_rom_resource(FOURCC('P','A','C','K'), 4)) == 0) return false;\n\tif ((base = find_rom_resource(FOURCC('P','A','C','K'), 4, true)) == 0 && FPUType == 0)\n\t\tprintf(\"WARNING: This ROM seems to require an FPU\\n\");\n\n\t// Patch VIA interrupt handler\n\twp = (uint16 *)(ROMBaseHost + 0x9bc4);\t// Level 1 handler\n\t*wp++ = htons(0x7002);\t\t// moveq\t#2,d0 (always 60Hz interrupt)\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp = htons(M68K_NOP);\n\n\twp = (uint16 *)(ROMBaseHost + 0xa296);\t// 60Hz handler (handles everything)\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_NOP);\n\t*wp++ = htons(M68K_EMUL_OP_IRQ);\n\t*wp++ = htons(0x4a80);\t\t// tst.l\td0\n\t*wp = htons(0x67f4);\t\t// beq\t\t0x4080a294\n\treturn true;\n}\n\nbool PatchROM(void)\n{\n\t// Print some information about the ROM\n\tif (PrintROMInfo)\n\t\tprint_rom_info();\n\n\t// Patch ROM depending on version\n\tswitch (ROMVersion) {\n\t\tcase ROM_VERSION_CLASSIC:\n\t\t\tif (!patch_rom_classic())\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase ROM_VERSION_32:\n\t\t\tif (!patch_rom_32())\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n\n\t// Install breakpoint\n\tif (ROMBreakpoint) {\n\t\tuint16 *wp = (uint16 *)(ROMBaseHost + ROMBreakpoint);\n\t\t*wp = htons(M68K_EMUL_BREAK);\n\t}\n\n\t// Clear caches as we loaded and patched code\n\tFlushCodeCache(ROMBaseHost, ROMSize);\n\treturn true;\n}\n","/*\n * UAE - The Un*x Amiga Emulator\n *\n * Read 68000 CPU specs from file \"table68k\"\n *\n * Copyright 1995,1996 Bernd Schmidt\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"sysdeps.h\"\n#include \"readcpu.h\"\n\nint nr_cpuop_funcs;\n\nstruct mnemolookup lookuptab[] = {\n    { i_ILLG, \"ILLEGAL\" },\n    { i_OR, \"OR\" },\n    { i_CHK, \"CHK\" },\n    { i_CHK2, \"CHK2\" },\n    { i_AND, \"AND\" },\n    { i_EOR, \"EOR\" },\n    { i_ORSR, \"ORSR\" },\n    { i_ANDSR, \"ANDSR\" },\n    { i_EORSR, \"EORSR\" },\n    { i_SUB, \"SUB\" },\n    { i_SUBA, \"SUBA\" },\n    { i_SUBX, \"SUBX\" },\n    { i_SBCD, \"SBCD\" },\n    { i_ADD, \"ADD\" },\n    { i_ADDA, \"ADDA\" },\n    { i_ADDX, \"ADDX\" },\n    { i_ABCD, \"ABCD\" },\n    { i_NEG, \"NEG\" },\n    { i_NEGX, \"NEGX\" },\n    { i_NBCD, \"NBCD\" },\n    { i_CLR, \"CLR\" },\n    { i_NOT, \"NOT\" },\n    { i_TST, \"TST\" },\n    { i_BTST, \"BTST\" },\n    { i_BCHG, \"BCHG\" },\n    { i_BCLR, \"BCLR\" },\n    { i_BSET, \"BSET\" },\n    { i_CMP, \"CMP\" },\n    { i_CMPM, \"CMPM\" },\n    { i_CMPA, \"CMPA\" },\n    { i_MVPRM, \"MVPRM\" },\n    { i_MVPMR, \"MVPMR\" },\n    { i_MOVE, \"MOVE\" },\n    { i_MOVEA, \"MOVEA\" },\n    { i_MVSR2, \"MVSR2\" },\n    { i_MV2SR, \"MV2SR\" },\n    { i_SWAP, \"SWAP\" },\n    { i_EXG, \"EXG\" },\n    { i_EXT, \"EXT\" },\n    { i_MVMEL, \"MVMEL\" },\n    { i_MVMLE, \"MVMLE\" },\n    { i_TRAP, \"TRAP\" },\n    { i_MVR2USP, \"MVR2USP\" },\n    { i_MVUSP2R, \"MVUSP2R\" },\n    { i_NOP, \"NOP\" },\n    { i_RESET, \"RESET\" },\n    { i_RTE, \"RTE\" },\n    { i_RTD, \"RTD\" },\n    { i_LINK, \"LINK\" },\n    { i_UNLK, \"UNLK\" },\n    { i_RTS, \"RTS\" },\n    { i_STOP, \"STOP\" },\n    { i_TRAPV, \"TRAPV\" },\n    { i_RTR, \"RTR\" },\n    { i_JSR, \"JSR\" },\n    { i_JMP, \"JMP\" },\n    { i_BSR, \"BSR\" },\n    { i_Bcc, \"Bcc\" },\n    { i_LEA, \"LEA\" },\n    { i_PEA, \"PEA\" },\n    { i_DBcc, \"DBcc\" },\n    { i_Scc, \"Scc\" },\n    { i_DIVU, \"DIVU\" },\n    { i_DIVS, \"DIVS\" },\n    { i_MULU, \"MULU\" },\n    { i_MULS, \"MULS\" },\n    { i_ASR, \"ASR\" },\n    { i_ASL, \"ASL\" },\n    { i_LSR, \"LSR\" },\n    { i_LSL, \"LSL\" },\n    { i_ROL, \"ROL\" },\n    { i_ROR, \"ROR\" },\n    { i_ROXL, \"ROXL\" },\n    { i_ROXR, \"ROXR\" },\n    { i_ASRW, \"ASRW\" },\n    { i_ASLW, \"ASLW\" },\n    { i_LSRW, \"LSRW\" },\n    { i_LSLW, \"LSLW\" },\n    { i_ROLW, \"ROLW\" },\n    { i_RORW, \"RORW\" },\n    { i_ROXLW, \"ROXLW\" },\n    { i_ROXRW, \"ROXRW\" },\n\n    { i_MOVE2C, \"MOVE2C\" },\n    { i_MOVEC2, \"MOVEC2\" },\n    { i_CAS, \"CAS\" },\n    { i_CAS2, \"CAS2\" },\n    { i_MULL, \"MULL\" },\n    { i_DIVL, \"DIVL\" },\n    { i_BFTST, \"BFTST\" },\n    { i_BFEXTU, \"BFEXTU\" },\n    { i_BFCHG, \"BFCHG\" },\n    { i_BFEXTS, \"BFEXTS\" },\n    { i_BFCLR, \"BFCLR\" },\n    { i_BFFFO, \"BFFFO\" },\n    { i_BFSET, \"BFSET\" },\n    { i_BFINS, \"BFINS\" },\n    { i_PACK, \"PACK\" },\n    { i_UNPK, \"UNPK\" },\n    { i_TAS, \"TAS\" },\n    { i_BKPT, \"BKPT\" },\n    { i_CALLM, \"CALLM\" },\n    { i_RTM, \"RTM\" },\n    { i_TRAPcc, \"TRAPcc\" },\n    { i_MOVES, \"MOVES\" },\n    { i_FPP, \"FPP\" },\n    { i_FDBcc, \"FDBcc\" },\n    { i_FScc, \"FScc\" },\n    { i_FTRAPcc, \"FTRAPcc\" },\n    { i_FBcc, \"FBcc\" },\n    { i_FBcc, \"FBcc\" },\n    { i_FSAVE, \"FSAVE\" },\n    { i_FRESTORE, \"FRESTORE\" },\n\n    { i_CINVL, \"CINVL\" },\n    { i_CINVP, \"CINVP\" },\n    { i_CINVA, \"CINVA\" },\n    { i_CPUSHL, \"CPUSHL\" },\n    { i_CPUSHP, \"CPUSHP\" },\n    { i_CPUSHA, \"CPUSHA\" },\n    { i_MOVE16, \"MOVE16\" },\n\n\t{ i_EMULOP_RETURN, \"EMULOP_RETURN\" },\n\t{ i_EMULOP, \"EMULOP\" },\n\t\n    { i_MMUOP, \"MMUOP\" },\n    { i_ILLG, \"\" },\n};\n\nstruct instr *table68k;\n\nstatic __inline__ amodes mode_from_str (const char *str)\n{\n    if (strncmp (str, \"Dreg\", 4) == 0) return Dreg;\n    if (strncmp (str, \"Areg\", 4) == 0) return Areg;\n    if (strncmp (str, \"Aind\", 4) == 0) return Aind;\n    if (strncmp (str, \"Apdi\", 4) == 0) return Apdi;\n    if (strncmp (str, \"Aipi\", 4) == 0) return Aipi;\n    if (strncmp (str, \"Ad16\", 4) == 0) return Ad16;\n    if (strncmp (str, \"Ad8r\", 4) == 0) return Ad8r;\n    if (strncmp (str, \"absw\", 4) == 0) return absw;\n    if (strncmp (str, \"absl\", 4) == 0) return absl;\n    if (strncmp (str, \"PC16\", 4) == 0) return PC16;\n    if (strncmp (str, \"PC8r\", 4) == 0) return PC8r;\n    if (strncmp (str, \"Immd\", 4) == 0) return imm;\n    abort ();\n    return (amodes)0;\n}\n\nstatic __inline__ amodes mode_from_mr (int mode, int reg)\n{\n    switch (mode) {\n     case 0: return Dreg;\n     case 1: return Areg;\n     case 2: return Aind;\n     case 3: return Aipi;\n     case 4: return Apdi;\n     case 5: return Ad16;\n     case 6: return Ad8r;\n     case 7:\n\tswitch (reg) {\n\t case 0: return absw;\n\t case 1: return absl;\n\t case 2: return PC16;\n\t case 3: return PC8r;\n\t case 4: return imm;\n\t case 5:\n\t case 6:\n\t case 7: return am_illg;\n\t}\n    }\n    abort ();\n    return (amodes)0;\n}\n\nstatic void build_insn (int insn)\n{\n    int find = -1;\n    int variants;\n    struct instr_def id;\n    const char *opcstr;\n    int i, n;\n\n    int flaglive = 0, flagdead = 0;\n\tint cflow = 0;\n\n    id = defs68k[insn];\n\n\t// Control flow information\n\tcflow = id.cflow;\n\t\n\t// Mask of flags set/used\n\tunsigned char flags_set(0), flags_used(0);\n\t\n\tfor (i = 0, n = 4; i < 5; i++, n--) {\n\t\tswitch (id.flaginfo[i].flagset) {\n\t\t\tcase fa_unset: case fa_isjmp: break;\n\t\t\tdefault: flags_set |= (1 << n);\n\t\t}\n\t\t\n\t\tswitch (id.flaginfo[i].flaguse) {\n\t\t\tcase fu_unused: case fu_isjmp: break;\n\t\t\tdefault: flags_used |= (1 << n);\n\t\t}\n\t}\n\t\n    for (i = 0; i < 5; i++) {\n\tswitch (id.flaginfo[i].flagset){\n\t case fa_unset: break;\n\t case fa_zero: flagdead |= 1 << i; break;\n\t case fa_one: flagdead |= 1 << i; break;\n\t case fa_dontcare: flagdead |= 1 << i; break;\n\t case fa_unknown: flagdead = -1; goto out1;\n\t case fa_set: flagdead |= 1 << i; break;\n\t}\n    }\n\n    out1:\n    for (i = 0; i < 5; i++) {\n\tswitch (id.flaginfo[i].flaguse) {\n\t case fu_unused: break;\n\t case fu_unknown: flaglive = -1; goto out2;\n\t case fu_used: flaglive |= 1 << i; break;\n\t}\n    }\n    out2:\n\n    opcstr = id.opcstr;\n    for (variants = 0; variants < (1 << id.n_variable); variants++) {\n\tint bitcnt[lastbit];\n\tint bitval[lastbit];\n\tint bitpos[lastbit];\n\tint i;\n\tuae_u16 opc = id.bits;\n\tuae_u16 msk, vmsk;\n\tint pos = 0;\n\tint mnp = 0;\n\tint bitno = 0;\n\tchar mnemonic[64];\n\n\twordsizes sz = sz_long;\n\tint srcgather = 0, dstgather = 0;\n\tint usesrc = 0, usedst = 0;\n\tint srctype = 0;\n\tint srcpos = -1, dstpos = -1;\n\n\tamodes srcmode = am_unknown, destmode = am_unknown;\n\tint srcreg = -1, destreg = -1;\n\n\tfor (i = 0; i < lastbit; i++)\n\t    bitcnt[i] = bitval[i] = 0;\n\n\tvmsk = 1 << id.n_variable;\n\n\tfor (i = 0, msk = 0x8000; i < 16; i++, msk >>= 1) {\n\t    if (!(msk & id.mask)) {\n\t\tint currbit = id.bitpos[bitno++];\n\t\tint bit_set;\n\t\tvmsk >>= 1;\n\t\tbit_set = variants & vmsk ? 1 : 0;\n\t\tif (bit_set)\n\t\t    opc |= msk;\n\t\tbitpos[currbit] = 15 - i;\n\t\tbitcnt[currbit]++;\n\t\tbitval[currbit] <<= 1;\n\t\tbitval[currbit] |= bit_set;\n\t    }\n\t}\n\n\tif (bitval[bitj] == 0) bitval[bitj] = 8;\n\t/* first check whether this one does not match after all */\n\tif (bitval[bitz] == 3 || bitval[bitC] == 1)\n\t    continue;\n\tif (bitcnt[bitI] && (bitval[bitI] == 0x00 || bitval[bitI] == 0xff))\n\t    continue;\n\tif (bitcnt[bitE] && (bitval[bitE] == 0x00))\n\t\tcontinue;\n\n\t/* bitI and bitC get copied to biti and bitc */\n\tif (bitcnt[bitI]) {\n\t    bitval[biti] = bitval[bitI]; bitpos[biti] = bitpos[bitI];\n\t}\n\tif (bitcnt[bitC])\n\t    bitval[bitc] = bitval[bitC];\n\n\tpos = 0;\n\twhile (opcstr[pos] && !isspace(opcstr[pos])) {\n\t    if (opcstr[pos] == '.') {\n\t\tpos++;\n\t\tswitch (opcstr[pos]) {\n\n\t\t case 'B': sz = sz_byte; break;\n\t\t case 'W': sz = sz_word; break;\n\t\t case 'L': sz = sz_long; break;\n\t\t case 'z':\n\t\t    switch (bitval[bitz]) {\n\t\t     case 0: sz = sz_byte; break;\n\t\t     case 1: sz = sz_word; break;\n\t\t     case 2: sz = sz_long; break;\n\t\t     default: abort();\n\t\t    }\n\t\t    break;\n\t\t default: abort();\n\t\t}\n\t    } else {\n\t\tmnemonic[mnp] = opcstr[pos];\n\t\tif (mnemonic[mnp] == 'f') {\n\t\t    find = -1;\n\t\t    switch (bitval[bitf]) {\n\t\t     case 0: mnemonic[mnp] = 'R'; break;\n\t\t     case 1: mnemonic[mnp] = 'L'; break;\n\t\t     default: abort();\n\t\t    }\n\t\t}\n\t\tmnp++;\n\t\tif ((unsigned)mnp >= sizeof(mnemonic) - 1) {\n\t\t\tmnemonic[sizeof(mnemonic) - 1] = 0;\n\t\t\tfprintf(stderr, \"Instruction %s overflow\\n\", mnemonic);\n\t\t\tabort();\n\t\t}\n\t    }\n\t    pos++;\n\t}\n\tmnemonic[mnp] = 0;\n\n\t/* now, we have read the mnemonic and the size */\n\twhile (opcstr[pos] && isspace(opcstr[pos]))\n\t    pos++;\n\n\t/* A goto a day keeps the D******a away. */\n\tif (opcstr[pos] == 0)\n\t    goto endofline;\n\n\t/* parse the source address */\n\tusesrc = 1;\n\tswitch (opcstr[pos++]) {\n\t case 'D':\n\t    srcmode = Dreg;\n\t    switch (opcstr[pos++]) {\n\t     case 'r': srcreg = bitval[bitr]; srcgather = 1; srcpos = bitpos[bitr]; break;\n\t     case 'R': srcreg = bitval[bitR]; srcgather = 1; srcpos = bitpos[bitR]; break;\n\t     default: abort();\n\t    }\n\n\t    break;\n\t case 'A':\n\t    srcmode = Areg;\n\t    switch (opcstr[pos++]) {\n\t     case 'r': srcreg = bitval[bitr]; srcgather = 1; srcpos = bitpos[bitr]; break;\n\t     case 'R': srcreg = bitval[bitR]; srcgather = 1; srcpos = bitpos[bitR]; break;\n\t     default: abort();\n\t    }\n\t    switch (opcstr[pos]) {\n\t     case 'p': srcmode = Apdi; pos++; break;\n\t     case 'P': srcmode = Aipi; pos++; break;\n\t    }\n\t    break;\n\tcase 'L':\n\t\tsrcmode = absl;\n\t\tbreak;\n\t case '#':\n\t    switch (opcstr[pos++]) {\n\t     case 'z': srcmode = imm; break;\n\t     case '0': srcmode = imm0; break;\n\t     case '1': srcmode = imm1; break;\n\t     case '2': srcmode = imm2; break;\n\t     case 'i': srcmode = immi; srcreg = (uae_s32)(uae_s8)bitval[biti];\n\t\tif (CPU_EMU_SIZE < 4) {\n\t\t    /* Used for branch instructions */\n\t\t    srctype = 1;\n\t\t    srcgather = 1;\n\t\t    srcpos = bitpos[biti];\n\t\t}\n\t\tbreak;\n\t     case 'j': srcmode = immi; srcreg = bitval[bitj];\n\t\tif (CPU_EMU_SIZE < 3) {\n\t\t    /* 1..8 for ADDQ/SUBQ and rotshi insns */\n\t\t    srcgather = 1;\n\t\t    srctype = 3;\n\t\t    srcpos = bitpos[bitj];\n\t\t}\n\t\tbreak;\n\t     case 'J': srcmode = immi; srcreg = bitval[bitJ];\n\t\tif (CPU_EMU_SIZE < 5) {\n\t\t    /* 0..15 */\n\t\t    srcgather = 1;\n\t\t    srctype = 2;\n\t\t    srcpos = bitpos[bitJ];\n\t\t}\n\t\tbreak;\n\t     case 'k': srcmode = immi; srcreg = bitval[bitk];\n\t\tif (CPU_EMU_SIZE < 3) {\n\t\t    srcgather = 1;\n\t\t    srctype = 4;\n\t\t    srcpos = bitpos[bitk];\n\t\t}\n\t\tbreak;\n\t     case 'K': srcmode = immi; srcreg = bitval[bitK];\n\t\tif (CPU_EMU_SIZE < 5) {\n\t\t    /* 0..15 */\n\t\t    srcgather = 1;\n\t\t    srctype = 5;\n\t\t    srcpos = bitpos[bitK];\n\t\t}\n\t\tbreak;\n\t\t case 'E': srcmode = immi; srcreg = bitval[bitE];\n\t\tif (CPU_EMU_SIZE < 5) { // gb-- what is CPU_EMU_SIZE used for ??\n\t\t\t/* 1..255 */\n\t\t\tsrcgather = 1;\n\t\t\tsrctype = 6;\n\t\t\tsrcpos = bitpos[bitE];\n\t\t}\n\t\tbreak;\n\t\t case 'p': srcmode = immi; srcreg = bitval[bitp];\n\t\tif (CPU_EMU_SIZE < 5) {\n\t\t\t/* 0..3 */\n\t\t\tsrcgather = 1;\n\t\t\tsrctype = 7;\n\t\t\tsrcpos = bitpos[bitp];\n\t\t}\n\t\tbreak;\n\t     default: abort();\n\t    }\n\t    break;\n\t case 'd':\n\t    srcreg = bitval[bitD];\n\t    srcmode = mode_from_mr(bitval[bitd],bitval[bitD]);\n\t    if (srcmode == am_illg)\n\t\tcontinue;\n\t    if (CPU_EMU_SIZE < 2 &&\n\t\t(srcmode == Areg || srcmode == Dreg || srcmode == Aind\n\t\t || srcmode == Ad16 || srcmode == Ad8r || srcmode == Aipi\n\t\t || srcmode == Apdi))\n\t    {\n\t\tsrcgather = 1; srcpos = bitpos[bitD];\n\t    }\n\t    if (opcstr[pos] == '[') {\n\t\tpos++;\n\t\tif (opcstr[pos] == '!') {\n\t\t    /* exclusion */\n\t\t    do {\n\t\t\tpos++;\n\t\t\tif (mode_from_str(opcstr+pos) == srcmode)\n\t\t\t    goto nomatch;\n\t\t\tpos += 4;\n\t\t    } while (opcstr[pos] == ',');\n\t\t    pos++;\n\t\t} else {\n\t\t    if (opcstr[pos+4] == '-') {\n\t\t\t/* replacement */\n\t\t\tif (mode_from_str(opcstr+pos) == srcmode)\n\t\t\t    srcmode = mode_from_str(opcstr+pos+5);\n\t\t\telse\n\t\t\t    goto nomatch;\n\t\t\tpos += 10;\n\t\t    } else {\n\t\t\t/* normal */\n\t\t\twhile(mode_from_str(opcstr+pos) != srcmode) {\n\t\t\t    pos += 4;\n\t\t\t    if (opcstr[pos] == ']')\n\t\t\t\tgoto nomatch;\n\t\t\t    pos++;\n\t\t\t}\n\t\t\twhile(opcstr[pos] != ']') pos++;\n\t\t\tpos++;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    /* Some addressing modes are invalid as destination */\n\t    if (srcmode == imm || srcmode == PC16 || srcmode == PC8r)\n\t\tgoto nomatch;\n\t    break;\n\t case 's':\n\t    srcreg = bitval[bitS];\n\t    srcmode = mode_from_mr(bitval[bits],bitval[bitS]);\n\n\t    if (srcmode == am_illg)\n\t\tcontinue;\n\t    if (CPU_EMU_SIZE < 2 &&\n\t\t(srcmode == Areg || srcmode == Dreg || srcmode == Aind\n\t\t || srcmode == Ad16 || srcmode == Ad8r || srcmode == Aipi\n\t\t || srcmode == Apdi))\n\t    {\n\t\tsrcgather = 1; srcpos = bitpos[bitS];\n\t    }\n\t    if (opcstr[pos] == '[') {\n\t\tpos++;\n\t\tif (opcstr[pos] == '!') {\n\t\t    /* exclusion */\n\t\t    do {\n\t\t\tpos++;\n\t\t\tif (mode_from_str(opcstr+pos) == srcmode)\n\t\t\t    goto nomatch;\n\t\t\tpos += 4;\n\t\t    } while (opcstr[pos] == ',');\n\t\t    pos++;\n\t\t} else {\n\t\t    if (opcstr[pos+4] == '-') {\n\t\t\t/* replacement */\n\t\t\tif (mode_from_str(opcstr+pos) == srcmode)\n\t\t\t    srcmode = mode_from_str(opcstr+pos+5);\n\t\t\telse\n\t\t\t    goto nomatch;\n\t\t\tpos += 10;\n\t\t    } else {\n\t\t\t/* normal */\n\t\t\twhile(mode_from_str(opcstr+pos) != srcmode) {\n\t\t\t    pos += 4;\n\t\t\t    if (opcstr[pos] == ']')\n\t\t\t\tgoto nomatch;\n\t\t\t    pos++;\n\t\t\t}\n\t\t\twhile(opcstr[pos] != ']') pos++;\n\t\t\tpos++;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\t default: abort();\n\t}\n\t/* safety check - might have changed */\n\tif (srcmode != Areg && srcmode != Dreg && srcmode != Aind\n\t    && srcmode != Ad16 && srcmode != Ad8r && srcmode != Aipi\n\t    && srcmode != Apdi && srcmode != immi)\n\t{\n\t    srcgather = 0;\n\t}\n\tif (srcmode == Areg && sz == sz_byte)\n\t    goto nomatch;\n\n\tif (opcstr[pos] != ',')\n\t    goto endofline;\n\tpos++;\n\n\t/* parse the destination address */\n\tusedst = 1;\n\tswitch (opcstr[pos++]) {\n\t case 'D':\n\t    destmode = Dreg;\n\t    switch (opcstr[pos++]) {\n\t     case 'r': destreg = bitval[bitr]; dstgather = 1; dstpos = bitpos[bitr]; break;\n\t     case 'R': destreg = bitval[bitR]; dstgather = 1; dstpos = bitpos[bitR]; break;\n\t     default: abort();\n\t    }\n\t\tif (dstpos < 0 || dstpos >= 32)\n\t\t\tabort();\n\t    break;\n\t case 'A':\n\t    destmode = Areg;\n\t    switch (opcstr[pos++]) {\n\t     case 'r': destreg = bitval[bitr]; dstgather = 1; dstpos = bitpos[bitr]; break;\n\t     case 'R': destreg = bitval[bitR]; dstgather = 1; dstpos = bitpos[bitR]; break;\n\t\tcase 'x': destreg = 0; dstgather = 0; dstpos = 0; break;\n\t     default: abort();\n\t    }\n\t\tif (dstpos < 0 || dstpos >= 32)\n\t\t\tabort();\n\t    switch (opcstr[pos]) {\n\t     case 'p': destmode = Apdi; pos++; break;\n\t     case 'P': destmode = Aipi; pos++; break;\n\t    }\n\t    break;\n\tcase 'L':\n\t\tdestmode = absl;\n\t\tbreak;\n\t case '#':\n\t    switch (opcstr[pos++]) {\n\t     case 'z': destmode = imm; break;\n\t     case '0': destmode = imm0; break;\n\t     case '1': destmode = imm1; break;\n\t     case '2': destmode = imm2; break;\n\t     case 'i': destmode = immi; destreg = (uae_s32)(uae_s8)bitval[biti]; break;\n\t     case 'j': destmode = immi; destreg = bitval[bitj]; break;\n\t     case 'J': destmode = immi; destreg = bitval[bitJ]; break;\n\t     case 'k': destmode = immi; destreg = bitval[bitk]; break;\n\t     case 'K': destmode = immi; destreg = bitval[bitK]; break;\n\t     default: abort();\n\t    }\n\t    break;\n\t case 'd':\n\t    destreg = bitval[bitD];\n\t    destmode = mode_from_mr(bitval[bitd],bitval[bitD]);\n\t    if (destmode == am_illg)\n\t\tcontinue;\n\t    if (CPU_EMU_SIZE < 1 &&\n\t\t(destmode == Areg || destmode == Dreg || destmode == Aind\n\t\t || destmode == Ad16 || destmode == Ad8r || destmode == Aipi\n\t\t || destmode == Apdi))\n\t    {\n\t\tdstgather = 1; dstpos = bitpos[bitD];\n\t    }\n\n\t    if (opcstr[pos] == '[') {\n\t\tpos++;\n\t\tif (opcstr[pos] == '!') {\n\t\t    /* exclusion */\n\t\t    do {\n\t\t\tpos++;\n\t\t\tif (mode_from_str(opcstr+pos) == destmode)\n\t\t\t    goto nomatch;\n\t\t\tpos += 4;\n\t\t    } while (opcstr[pos] == ',');\n\t\t    pos++;\n\t\t} else {\n\t\t    if (opcstr[pos+4] == '-') {\n\t\t\t/* replacement */\n\t\t\tif (mode_from_str(opcstr+pos) == destmode)\n\t\t\t    destmode = mode_from_str(opcstr+pos+5);\n\t\t\telse\n\t\t\t    goto nomatch;\n\t\t\tpos += 10;\n\t\t    } else {\n\t\t\t/* normal */\n\t\t\twhile(mode_from_str(opcstr+pos) != destmode) {\n\t\t\t    pos += 4;\n\t\t\t    if (opcstr[pos] == ']')\n\t\t\t\tgoto nomatch;\n\t\t\t    pos++;\n\t\t\t}\n\t\t\twhile(opcstr[pos] != ']') pos++;\n\t\t\tpos++;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    /* Some addressing modes are invalid as destination */\n\t    if (destmode == imm || destmode == PC16 || destmode == PC8r)\n\t\tgoto nomatch;\n\t    break;\n\t case 's':\n\t    destreg = bitval[bitS];\n\t    destmode = mode_from_mr(bitval[bits],bitval[bitS]);\n\n\t    if (destmode == am_illg)\n\t\tcontinue;\n\t    if (CPU_EMU_SIZE < 1 &&\n\t\t(destmode == Areg || destmode == Dreg || destmode == Aind\n\t\t || destmode == Ad16 || destmode == Ad8r || destmode == Aipi\n\t\t || destmode == Apdi))\n\t    {\n\t\tdstgather = 1; dstpos = bitpos[bitS];\n\t    }\n\n\t    if (opcstr[pos] == '[') {\n\t\tpos++;\n\t\tif (opcstr[pos] == '!') {\n\t\t    /* exclusion */\n\t\t    do {\n\t\t\tpos++;\n\t\t\tif (mode_from_str(opcstr+pos) == destmode)\n\t\t\t    goto nomatch;\n\t\t\tpos += 4;\n\t\t    } while (opcstr[pos] == ',');\n\t\t    pos++;\n\t\t} else {\n\t\t    if (opcstr[pos+4] == '-') {\n\t\t\t/* replacement */\n\t\t\tif (mode_from_str(opcstr+pos) == destmode)\n\t\t\t    destmode = mode_from_str(opcstr+pos+5);\n\t\t\telse\n\t\t\t    goto nomatch;\n\t\t\tpos += 10;\n\t\t    } else {\n\t\t\t/* normal */\n\t\t\twhile(mode_from_str(opcstr+pos) != destmode) {\n\t\t\t    pos += 4;\n\t\t\t    if (opcstr[pos] == ']')\n\t\t\t\tgoto nomatch;\n\t\t\t    pos++;\n\t\t\t}\n\t\t\twhile(opcstr[pos] != ']') pos++;\n\t\t\tpos++;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\t default: abort();\n\t}\n\t/* safety check - might have changed */\n\tif (destmode != Areg && destmode != Dreg && destmode != Aind\n\t    && destmode != Ad16 && destmode != Ad8r && destmode != Aipi\n\t    && destmode != Apdi)\n\t{\n\t    dstgather = 0;\n\t}\n\n\tif (destmode == Areg && sz == sz_byte)\n\t    goto nomatch;\n#if 0\n\tif (sz == sz_byte && (destmode == Aipi || destmode == Apdi)) {\n\t    dstgather = 0;\n\t}\n#endif\n\tendofline:\n\t/* now, we have a match */\n\tif (table68k[opc].mnemo != i_ILLG)\n\t    fprintf(stderr, \"Double match: %x: %s\\n\", opc, opcstr);\n\tif (find == -1) {\n\t    for (find = 0;; find++) {\n\t\tif (strcmp(mnemonic, lookuptab[find].name) == 0) {\n\t\t    table68k[opc].mnemo = lookuptab[find].mnemo;\n\t\t    break;\n\t\t}\n\t\tif (strlen(lookuptab[find].name) == 0) abort();\n\t    }\n\t}\n\telse {\n\t    table68k[opc].mnemo = lookuptab[find].mnemo;\n\t}\n\ttable68k[opc].cc = bitval[bitc];\n\tif (table68k[opc].mnemo == i_BTST\n\t    || table68k[opc].mnemo == i_BSET\n\t    || table68k[opc].mnemo == i_BCLR\n\t    || table68k[opc].mnemo == i_BCHG)\n\t{\n\t    sz = destmode == Dreg ? sz_long : sz_byte;\n\t}\n\ttable68k[opc].size = sz;\n\ttable68k[opc].sreg = srcreg;\n\ttable68k[opc].dreg = destreg;\n\ttable68k[opc].smode = srcmode;\n\ttable68k[opc].dmode = destmode;\n\ttable68k[opc].spos = srcgather ? srcpos : -1;\n\ttable68k[opc].dpos = dstgather ? dstpos : -1;\n\ttable68k[opc].suse = usesrc;\n\ttable68k[opc].duse = usedst;\n\ttable68k[opc].stype = srctype;\n\ttable68k[opc].plev = id.plevel;\n\ttable68k[opc].clev = id.cpulevel;\n#if 0\n\tfor (i = 0; i < 5; i++) {\n\t    table68k[opc].flaginfo[i].flagset = id.flaginfo[i].flagset;\n\t    table68k[opc].flaginfo[i].flaguse = id.flaginfo[i].flaguse;\n\t}\n#endif\n\t\n\t// Fix flags used information for Scc, Bcc, TRAPcc, DBcc instructions\n\tif\t(\ttable68k[opc].mnemo == i_Scc\n\t\t||\ttable68k[opc].mnemo == i_Bcc\n\t\t||\ttable68k[opc].mnemo == i_DBcc\n\t\t||\ttable68k[opc].mnemo == i_TRAPcc\n\t\t)\t{\n\t\tswitch (table68k[opc].cc) {\n\t\t// CC mask:\tXNZVC\n\t\t// \t\t\t 8421\n\t\tcase 0: flags_used = 0x00; break;\t/*  T */\n\t\tcase 1: flags_used = 0x00; break;\t/*  F */\n\t\tcase 2: flags_used = 0x05; break;\t/* HI */\n\t\tcase 3: flags_used = 0x05; break;\t/* LS */\n\t\tcase 4: flags_used = 0x01; break;\t/* CC */\n\t\tcase 5: flags_used = 0x01; break;\t/* CS */\n\t\tcase 6: flags_used = 0x04; break;\t/* NE */\n\t\tcase 7: flags_used = 0x04; break;\t/* EQ */\n\t\tcase 8: flags_used = 0x02; break;\t/* VC */\n\t\tcase 9: flags_used = 0x02; break;\t/* VS */\n\t\tcase 10:flags_used = 0x08; break;\t/* PL */\n\t\tcase 11:flags_used = 0x08; break;\t/* MI */\n\t\tcase 12:flags_used = 0x0A; break;\t/* GE */\n\t\tcase 13:flags_used = 0x0A; break;\t/* LT */\n\t\tcase 14:flags_used = 0x0E; break;\t/* GT */\n\t\tcase 15:flags_used = 0x0E; break;\t/* LE */\n\t\t}\n\t}\n\t\t\n#if 1\n\t/* gb-- flagdead and flaglive would not have correct information */\n\ttable68k[opc].flagdead = flags_set;\n\ttable68k[opc].flaglive = flags_used;\n#else\n\ttable68k[opc].flagdead = flagdead;\n\ttable68k[opc].flaglive = flaglive;\n#endif\n\ttable68k[opc].cflow = cflow;\n\tnomatch:\n\t/* FOO! */;\n    }\n}\n\n\nvoid read_table68k (void)\n{\n    int i;\n\n    table68k = (struct instr *)malloc (65536 * sizeof (struct instr));\n    for (i = 0; i < 65536; i++) {\n\ttable68k[i].mnemo = i_ILLG;\n\ttable68k[i].handler = -1;\n    }\n    for (i = 0; i < n_defs68k; i++) {\n\tbuild_insn (i);\n    }\n}\n\nstatic int mismatch;\n\nstatic void handle_merges (long int opcode)\n{\n    uae_u16 smsk;\n    uae_u16 dmsk;\n    int sbitdst, dstend;\n    int srcreg, dstreg;\n\n    if (table68k[opcode].spos == -1) {\n\tsbitdst = 1; smsk = 0;\n    } else {\n\tswitch (table68k[opcode].stype) {\n\t case 0:\n\t    smsk = 7; sbitdst = 8; break;\n\t case 1:\n\t    smsk = 255; sbitdst = 256; break;\n\t case 2:\n\t    smsk = 15; sbitdst = 16; break;\n\t case 3:\n\t    smsk = 7; sbitdst = 8; break;\n\t case 4:\n\t    smsk = 7; sbitdst = 8; break;\n\t case 5:\n\t    smsk = 63; sbitdst = 64; break;\n\t case 6:\n\t \tsmsk = 255; sbitdst = 256; break;\n\t case 7:\n\t \tsmsk = 3; sbitdst = 4; break;\n\t default:\n\t    smsk = 0; sbitdst = 0;\n\t    abort();\n\t    break;\n\t}\n\tsmsk <<= table68k[opcode].spos;\n    }\n    if (table68k[opcode].dpos == -1) {\n\tdstend = 1; dmsk = 0;\n    } else {\n\tdmsk = 7 << table68k[opcode].dpos;\n\tdstend = 8;\n    }\n    for (srcreg=0; srcreg < sbitdst; srcreg++) {\n\tfor (dstreg=0; dstreg < dstend; dstreg++) {\n\t    uae_u16 code = opcode;\n\n\t    code = (code & ~smsk) | (srcreg << table68k[opcode].spos);\n\t    code = (code & ~dmsk) | (dstreg << table68k[opcode].dpos);\n\n\t    /* Check whether this is in fact the same instruction.\n\t     * The instructions should never differ, except for the\n\t     * Bcc.(BW) case. */\n\t    if (table68k[code].mnemo != table68k[opcode].mnemo\n\t\t|| table68k[code].size != table68k[opcode].size\n\t\t|| table68k[code].suse != table68k[opcode].suse\n\t\t|| table68k[code].duse != table68k[opcode].duse)\n\t    {\n\t\tmismatch++; continue;\n\t    }\n\t    if (table68k[opcode].suse\n\t\t&& (table68k[opcode].spos != table68k[code].spos\n\t\t    || table68k[opcode].smode != table68k[code].smode\n\t\t    || table68k[opcode].stype != table68k[code].stype))\n\t    {\n\t\tmismatch++; continue;\n\t    }\n\t    if (table68k[opcode].duse\n\t\t&& (table68k[opcode].dpos != table68k[code].dpos\n\t\t    || table68k[opcode].dmode != table68k[code].dmode))\n\t    {\n\t\tmismatch++; continue;\n\t    }\n\n\t    if (code != opcode)\n\t\ttable68k[code].handler = opcode;\n\t}\n    }\n}\n\nvoid do_merges (void)\n{\n    long int opcode;\n    int nr = 0;\n    mismatch = 0;\n    for (opcode = 0; opcode < 65536; opcode++) {\n\tif (table68k[opcode].handler != -1 || table68k[opcode].mnemo == i_ILLG)\n\t    continue;\n\tnr++;\n\thandle_merges (opcode);\n    }\n    nr_cpuop_funcs = nr;\n}\n\nint get_no_mismatches (void)\n{\n    return mismatch;\n}\n\nconst char *get_instruction_name (unsigned int opcode)\n{\n    struct instr *ins = &table68k[opcode];\n    for (int i = 0; lookuptab[i].name[0]; i++) {\n\tif (ins->mnemo == lookuptab[i].mnemo)\n\t    return lookuptab[i].name;\n    }\n    abort();\n    return NULL;\n}\n\nstatic char *get_ea_string (amodes mode, wordsizes size)\n{\n    static char buffer[80];\n\n    buffer[0] = 0;\n    switch (mode){\n     case Dreg:\n\tstrcpy (buffer,\"Dn\");\n\tbreak;\n     case Areg:\n\tstrcpy (buffer,\"An\");\n\tbreak;\n     case Aind:\n\tstrcpy (buffer,\"(An)\");\n\tbreak;\n     case Aipi:\n\tstrcpy (buffer,\"(An)+\");\n\tbreak;\n     case Apdi:\n\tstrcpy (buffer,\"-(An)\");\n\tbreak;\n     case Ad16:\n\tstrcpy (buffer,\"(d16,An)\");\n\tbreak;\n     case Ad8r:\n\tstrcpy (buffer,\"(d8,An,Xn)\");\n\tbreak;\n     case PC16:\n\tstrcpy (buffer,\"(d16,PC)\");\n\tbreak;\n     case PC8r:\n\t strcpy (buffer,\"(d8,PC,Xn)\");\n\tbreak;\n     case absw:\n\tstrcpy (buffer,\"(xxx).W\");\n\tbreak;\n     case absl:\n\tstrcpy (buffer,\"(xxx).L\");\n\tbreak;\n     case imm:\n\tswitch (size){\n\t case sz_byte:\n\t    strcpy (buffer,\"#<data>.B\");\n\t    break;\n\t case sz_word:\n\t    strcpy (buffer,\"#<data>.W\");\n\t    break;\n\t case sz_long:\n\t    strcpy (buffer,\"#<data>.L\");\n\t    break;\n\t default:\n\t    break;\n\t}\n\tbreak;\n     case imm0:\n\tstrcpy (buffer,\"#<data>.B\");\n\tbreak;\n     case imm1:\n\tstrcpy (buffer,\"#<data>.W\");\n\tbreak;\n     case imm2:\n\tstrcpy (buffer,\"#<data>.L\");\n\tbreak;\n     case immi:\n\tstrcpy (buffer,\"#<data>\");\n\tbreak;\n\n     default:\n\tbreak;\n    }\n    return buffer;\n}\n\nconst char *get_instruction_string (unsigned int opcode)\n{\n    static char out[100];\n    struct instr *ins;\n\n    strcpy (out, get_instruction_name (opcode));\n\n    ins = &table68k[opcode];\n    if (ins->size == sz_byte)\n\tstrcat (out,\".B\");\n    if (ins->size == sz_word)\n\tstrcat (out,\".W\");\n    if (ins->size == sz_long)\n\tstrcat (out,\".L\");\n    strcat (out,\" \");\n    if (ins->suse)\n\tstrcat (out, get_ea_string (ins->smode, ins->size));\n    if (ins->duse) {\n\tif (ins->suse)\n\t    strcat (out,\",\");\n\tstrcat (out, get_ea_string (ins->dmode, ins->size));\n    }\n    return out;\n}\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n    typedef Alloc::is_always_equal\n          | is_empty                     is_always_equal;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\ntemplate <class T> T* addressof(const T&& r) noexcept = delete;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class T>\nvoid destroy_at(T* location);\n\ntemplate <class ForwardIterator>\n void destroy(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator destroy_n(ForwardIterator first, Size n);\n\ntemplate <class InputIterator, class ForwardIterator>\n ForwardIterator uninitialized_move(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\n pair<InputIterator,ForwardIterator> uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator>\n void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);\n\ntemplate <class ForwardIterator>\n void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Size>\n ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n    typedef weak_ptr<T> weak_type; // C++17\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <stdexcept>\n#include <cstring>\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_relaxed_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_RELAXED) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_RELAXED);\n#else\n    return *__value;\n#endif\n}\n\ntemplate <class _ValueType>\ninline _LIBCPP_ALWAYS_INLINE\n_ValueType __libcpp_acquire_load(_ValueType const* __value) {\n#if !defined(_LIBCPP_HAS_NO_THREADS) && \\\n    defined(__ATOMIC_ACQUIRE) &&        \\\n    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)\n    return __atomic_load_n(__value, __ATOMIC_ACQUIRE);\n#else\n    return *__value;\n#endif\n}\n\n// addressof moved to <type_traits>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_CXX03_LANG\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\ntemplate <class _From, class _To>\nstruct __rebind_pointer {\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_From>::template rebind<_To>        type;\n#else\n    typedef typename pointer_traits<_From>::template rebind<_To>::other type;\n#endif\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp>\nstruct __has_is_always_equal\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_always_equal* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>\nstruct __is_always_equal\n{\n    typedef typename _VSTD::is_empty<_Alloc>::type type;\n};\n\ntemplate <class _Alloc>\nstruct __is_always_equal<_Alloc, true>\n{\n    typedef typename _Alloc::is_always_equal type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_CXX03_LANG\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TEMPLATE_VIS allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n    typedef typename __is_always_equal<allocator_type>::type\n                     is_always_equal;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_CXX03_LANG\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Iter, class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, (void) ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), *__begin1);\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_range_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            typedef typename remove_const<_Tp>::type _Vp;\n            ptrdiff_t _Np = __end1 - __begin1;\n            if (_Np > 0)\n            {\n                _VSTD::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));\n                __begin2 += _Np;\n            }\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            if (_Np > 0)\n                _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max() / sizeof(value_type);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\ntemplate <class _Traits, class _Tp>\nstruct __rebind_alloc_helper\n{\n#ifndef _LIBCPP_CXX03_LANG\n    typedef typename _Traits::template rebind_alloc<_Tp>        type;\n#else\n    typedef typename _Traits::template rebind_alloc<_Tp>::other type;\n#endif\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n        }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n    typedef true_type is_always_equal;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n    {\n        if (__n > max_size())\n            __throw_length_error(\"allocator<const T>::allocate(size_t n)\"\n                                 \" 'n' exceeds maximum supported size\");\n        return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));\n    }\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__libcpp_deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TEMPLATE_VIS raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(_Tp&& __element)\n        {::new(&*__x_) _Tp(_VSTD::move(__element)); return *this;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n#if _LIBCPP_STD_VER >= 14\n    _LIBCPP_INLINE_VISIBILITY _OutputIterator base() const { return __x_; } \n#endif\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n                                       && !__libcpp_is_final<_T1>::value,\n                                bool = is_empty<_T2>::value\n                                       && !__libcpp_is_final<_T2>::value\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_(), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __first_(), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() : __first_() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_() {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||\n                                           is_same<_Ptr1, _Ptr2>::value ||\n                                           __has_element_type<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete\n{\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete void type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TEMPLATE_VIS unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        !is_array<_Up>::value &&\n        is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n        is_assignable<deleter_type&, _Ep&>::value,\n        unique_ptr&\n    >::type\n    operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TEMPLATE_VIS unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p,\n            typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat()) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d,\n                                       typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p,\n                                         typename remove_reference<deleter_type>::type&& __d,\n                                         typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, void>::type\n    reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t = nullptr) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Dp>::value,\n    void\n>::type\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len) _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK \n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            } __s;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\nstruct _PairT {\n  size_t first;\n  size_t second;\n};\n\n_LIBCPP_INLINE_VISIBILITY\ninline size_t __hash_combine(size_t __lhs, size_t __rhs) _NOEXCEPT {\n    typedef __scalar_hash<_PairT> _HashT;\n    const _PairT __p = {__lhs, __rhs};\n    return _HashT()(__p);\n}\n\ntemplate<class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, (void) ++__r)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) ++__r, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, (void) --__n)\n            ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy_at(_Tp* __loc) {\n    _LIBCPP_ASSERT(__loc, \"null pointer given to destroy_at\");\n    __loc->~_Tp();\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid destroy(_ForwardIterator __first, _ForwardIterator __last) {\n    for (; __first != __last; ++__first)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {\n    for (; __n > 0; (void)++__first, --__n)\n        _VSTD::destroy_at(_VSTD::addressof(*__first));\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt;\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __idx != __last; ++__idx)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {\n    using _Vt = typename iterator_traits<_ForwardIterator>::value_type;\n    auto __idx = __first;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; (void)++__idx, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt();\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first, __idx);\n        throw;\n    }\n#endif\n}\n\n\ntemplate <class _InputIt, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIt uninitialized_move(_InputIt __first, _InputIt __last, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __first != __last; (void)++__idx, ++__first)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return __idx;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\ntemplate <class _InputIt, class _Size, class _ForwardIt>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIt, _ForwardIt>\nuninitialized_move_n(_InputIt __first, _Size __n, _ForwardIt __first_res) {\n    using _Vt = typename iterator_traits<_ForwardIt>::value_type;\n    auto __idx = __first_res;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try {\n#endif\n    for (; __n > 0; ++__idx, (void)++__first, --__n)\n        ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));\n    return {__first, __idx};\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    } catch (...) {\n        _VSTD::destroy(__first_res, __idx);\n        throw;\n    }\n#endif\n}\n\n\n#endif // _LIBCPP_STD_VER > 14\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_weak_ptr()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_weak_ptr();\n#else\n    _VSTD::abort();\n#endif\n}\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {\n        return __libcpp_relaxed_load(&__shared_owners_) + 1;\n    }\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? _VSTD::addressof(__data_.first().second()) : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n\n    _Al __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type _Al;\n    typedef allocator_traits<_Al> _ATraits;\n    typedef pointer_traits<typename _ATraits::pointer> _PTraits;\n    _Al __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(_PTraits::pointer_to(*this), 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TEMPLATE_VIS enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS shared_ptr\n{\npublic:\n    typedef _Tp element_type;\n\n#if _LIBCPP_STD_VER > 14\n    typedef weak_ptr<_Tp> weak_type;\n#endif\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp>\n        explicit shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp>\n        shared_ptr(_Yp* __p, _Dp __d,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp, class _Alloc>\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY  shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#else\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp> __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp, class _OrigPtr>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e,\n                           _OrigPtr* __ptr) _NOEXCEPT\n        {\n            typedef typename remove_cv<_Yp>::type _RawYp;\n            if (__e && __e->__weak_this_.expired())\n            {\n                __e->__weak_this_ = shared_ptr<_RawYp>(*this,\n                    const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));\n            }\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const volatile void*, const volatile void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p, __p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n        __enable_weak_this(__p, __p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n            _CntrlBlk(__p, __d, __a);\n        __cntrl_ = _VSTD::addressof(*__hold2.release());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,\n#endif\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get(), __r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                !is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n#if _LIBCPP_STD_VER > 11\n    if (__ptr_ == nullptr)\n        __cntrl_ = nullptr;\n    else\n#endif\n    {\n        typedef __shared_ptr_pointer<_Yp*,\n                                     reference_wrapper<typename remove_reference<_Dp>::type>,\n                                     allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n        __enable_weak_this(__r.get(), __r.get());\n    }\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))\n        _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = _VSTD::addressof(*__hold2.release());\n    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, \n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, \n                   typename shared_ptr<_Tp>::element_type*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _Vp;\n    return less<_Vp>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> _LIBCPP_INLINE_VISIBILITY weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        _LIBCPP_INLINE_VISIBILITY\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;\n    template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;\n};\n\ntemplate<class _Tp>\ninline\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n        __throw_bad_weak_ptr();\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp = void> struct owner_less;\n#else\ntemplate <class _Tp> struct owner_less;\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS owner_less<void>\n{\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()( shared_ptr<_Tp> const& __x,  weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    template <class _Tp, class _Up>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(   weak_ptr<_Tp> const& __x,   weak_ptr<_Up> const& __y) const\n        {return __x.owner_before(__y);}\n    typedef void is_transparent;\n};\n#endif\n\ntemplate<class _Tp>\nclass _LIBCPP_TEMPLATE_VIS enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<_Tp> weak_from_this() _NOEXCEPT\n       { return __weak_this_; }\n\n    _LIBCPP_INLINE_VISIBILITY\n    weak_ptr<const _Tp> weak_from_this() const _NOEXCEPT\n        { return __weak_this_; }\n#endif // _LIBCPP_STD_VER > 14\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n\n#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    shared_ptr<_Tp> __temp;\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        _VSTD::swap(__temp, *__p);\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    _VSTD::swap(__temp, *__v);\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)\n\n//enum class\n#if defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE)\n# ifndef _LIBCPP_CXX03_LANG\nenum class pointer_safety : unsigned char {\n  relaxed,\n  preferred,\n  strict\n};\n# endif\n#else\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety() : __v_() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n#endif\n\n#if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) && \\\n    defined(_LIBCPP_BUILDING_MEMORY)\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n#else\n// This function is only offered in C++03 under ABI v1.\n# if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) || !defined(_LIBCPP_CXX03_LANG)\ninline _LIBCPP_INLINE_VISIBILITY\npointer_safety get_pointer_safety() _NOEXCEPT {\n  return pointer_safety::relaxed;\n}\n# endif\n#endif\n\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n// --- Helper for container swap --\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    __swap_allocator(__a1, __a2, \n      integral_constant<bool, _VSTD::allocator_traits<_Alloc>::propagate_on_container_swap::value>());\n}\n\ntemplate <typename _Alloc>\n_LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)\n#if _LIBCPP_STD_VER >= 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)\n#endif\n{\n    using _VSTD::swap;\n    swap(__a1, __a2);\n}\n\ntemplate <typename _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __swap_allocator(_Alloc &, _Alloc &, false_type) _NOEXCEPT {}\n\ntemplate <typename _Alloc, typename _Traits=allocator_traits<_Alloc> >\nstruct __noexcept_move_assign_container : public integral_constant<bool, \n    _Traits::propagate_on_container_move_assignment::value\n#if _LIBCPP_STD_VER > 14\n        || _Traits::is_always_equal::value\n#else\n        && is_nothrow_move_assignable<_Alloc>::value\n#endif\n    > {};\n\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class _Tp, class _Alloc>\nstruct __temp_value {\n    typedef allocator_traits<_Alloc> _Traits;\n    \n    typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;\n    _Alloc &__a;\n\n    _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }\n    _Tp &   get() { return *__addr(); }\n        \n    template<class... _Args>\n    __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc)\n    { _Traits::construct(__a, __addr(), _VSTD::forward<_Args>(__args)...); }\n    \n    ~__temp_value() { _Traits::destroy(__a, __addr()); }\n    };\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","/*\n *  slot_rom.cpp - Slot declaration ROM\n *\n *  Basilisk II (C) Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/*\n *  SEE ALSO\n *    Inside Macintosh: Devices, chapter 2 \"Slot Manager\"\n *    Designing Cards and Drivers for the Macintosh Family, Second Edition\n */\n\n#include <stdio.h>\n#include <string.h>\n\n#include \"sysdeps.h\"\n#include \"cpu_emulation.h\"\n#include \"main.h\"\n#include \"video.h\"\n#include \"emul_op.h\"\n#include \"version.h\"\n#include \"slot_rom.h\"\n\n\n// Temporary buffer for slot ROM\nstatic uint8 srom[4096];\n\n// Index in srom\nstatic uint32 p;\n\n// Length of slot ROM\nstatic int slot_rom_size = 0;\n\n\n/*\n *  Construct slot declaration ROM and copy it into the Mac ROM (must be called after VideoInit())\n */\n\nstatic void Offs(uint8 type, uint32 ptr)\n{\n\tuint32 offs = ptr - p;\n\tsrom[p++] = type;\n\tsrom[p++] = offs >> 16;\n\tsrom[p++] = offs >> 8;\n\tsrom[p++] = offs;\n}\n\nstatic void Rsrc(uint8 type, uint32 data)\n{\n\tsrom[p++] = type;\n\tsrom[p++] = data >> 16;\n\tsrom[p++] = data >> 8;\n\tsrom[p++] = data;\n}\n\nstatic void EndOfList(void)\n{\n\tsrom[p++] = 0xff;\n\tsrom[p++] = 0;\n\tsrom[p++] = 0;\n\tsrom[p++] = 0;\n}\n\nstatic void Long(uint32 data)\n{\n\tsrom[p++] = data >> 24;\n\tsrom[p++] = data >> 16;\n\tsrom[p++] = data >> 8;\n\tsrom[p++] = data;\n}\n\nstatic void Word(uint16 data)\n{\n\tsrom[p++] = data >> 8;\n\tsrom[p++] = data;\n}\n\nstatic void String(const char *str)\n{\n\twhile ((srom[p++] = *str++) != 0) ;\n\tif (p & 1)\n\t\tsrom[p++] = 0;\n}\n\nstatic void PString(const char *str)\n{\n\tsrom[p++] = strlen(str);\n\twhile ((srom[p++] = *str++) != 0) ;\n\tp--;\n\tif (p & 1)\n\t\tsrom[p++] = 0;\n}\n\nstatic uint32 VModeParms(const monitor_desc &m, video_depth depth)\n{\n\tconst video_mode &mode = m.get_current_mode();\n\n\tuint32 ret = p;\n\tLong(50);\t\t\t\t\t// Length\n\tLong(0);\t\t\t\t\t// Base offset\n\tWord(m.get_bytes_per_row(depth, mode.resolution_id));\n\tWord(0);\t\t\t\t\t// Bounds\n\tWord(0);\n\tWord(mode.y);\n\tWord(mode.x);\n\tWord(0);\t\t\t\t\t// Version\n\tWord(0);\t\t\t\t\t// Pack type\n\tLong(0);\t\t\t\t\t// Pack size\n\tLong(0x00480000);\t\t\t// HRes\n\tLong(0x00480000);\t\t\t// VRes\n\tswitch (depth) {\n\t\tcase VDEPTH_1BIT:\n\t\t\tWord(0);\t\t\t// Pixel type (indirect)\n\t\t\tWord(1);\t\t\t// Pixel size\n\t\t\tWord(1);\t\t\t// CmpCount\n\t\t\tWord(1);\t\t\t// CmpSize\n\t\t\tbreak;\n\t\tcase VDEPTH_2BIT:\n\t\t\tWord(0);\t\t\t// Pixel type (indirect)\n\t\t\tWord(2);\t\t\t// Pixel size\n\t\t\tWord(1);\t\t\t// CmpCount\n\t\t\tWord(2);\t\t\t// CmpSize\n\t\t\tbreak;\n\t\tcase VDEPTH_4BIT:\n\t\t\tWord(0);\t\t\t// Pixel type (indirect)\n\t\t\tWord(4);\t\t\t// Pixel size\n\t\t\tWord(1);\t\t\t// CmpCount\n\t\t\tWord(4);\t\t\t// CmpSize\n\t\t\tbreak;\n\t\tcase VDEPTH_8BIT:\n\t\t\tWord(0);\t\t\t// Pixel type (indirect)\n\t\t\tWord(8);\t\t\t// Pixel size\n\t\t\tWord(1);\t\t\t// CmpCount\n\t\t\tWord(8);\t\t\t// CmpSize\n\t\t\tbreak;\n\t\tcase VDEPTH_16BIT:\n\t\t\tWord(16);\t\t\t// Pixel type (direct)\n\t\t\tWord(16);\t\t\t// Pixel size\n\t\t\tWord(3);\t\t\t// CmpCount\n\t\t\tWord(5);\t\t\t// CmpSize\n\t\t\tbreak;\n\t\tcase VDEPTH_32BIT:\n\t\t\tWord(16);\t\t\t// Pixel type (direct)\n\t\t\tWord(32);\t\t\t// Pixel size\n\t\t\tWord(3);\t\t\t// CmpCount\n\t\t\tWord(8);\t\t\t// CmpSize\n\t\t\tbreak;\n\t}\n\tLong(0);\t\t\t\t\t// Plane size\n\tLong(0);\t\t\t\t\t// Reserved\n\treturn ret;\n}\n\nstatic uint32 VModeDesc(uint32 params, bool direct)\n{\n\tuint32 ret = p;\n\tOffs(0x01, params);\t\t\t// Video parameters\n\tRsrc(0x03, 1);\t\t\t\t// Page count\n\tRsrc(0x04, direct ? 2 : 0);\t// Device type\n\tEndOfList();\n\treturn ret;\n}\n\nstatic uint32 VMonitor(const monitor_desc &m, uint32 videoType, uint32 videoName, uint32 vidDrvrDir, uint32 gammaDir)\n{\n\tuint32 minorBase, minorLength;\n\tuint32 vidModeParms1, vidModeParms2, vidModeParms4, vidModeParms8, vidModeParms16, vidModeParms32;\n\tuint32 vidMode1, vidMode2, vidMode4, vidMode8, vidMode16, vidMode32;\n\tuint32 ret;\n\n\tminorBase = p;\n\tLong(m.get_mac_frame_base());\t// Frame buffer base\n\tminorLength = p;\n\tLong(0);\t\t\t\t\t// Frame buffer size (unspecified)\n\n\tvidModeParms1 = VModeParms(m, VDEPTH_1BIT);\n\tvidModeParms2 = VModeParms(m, VDEPTH_2BIT);\n\tvidModeParms4 = VModeParms(m, VDEPTH_4BIT);\n\tvidModeParms8 = VModeParms(m, VDEPTH_8BIT);\n\tvidModeParms16 = VModeParms(m, VDEPTH_16BIT);\n\tvidModeParms32 = VModeParms(m, VDEPTH_32BIT);\n\n\tvidMode1 = VModeDesc(vidModeParms1, false);\n\tvidMode2 = VModeDesc(vidModeParms2, false);\n\tvidMode4 = VModeDesc(vidModeParms4, false);\n\tvidMode8 = VModeDesc(vidModeParms8, false);\n\tvidMode16 = VModeDesc(vidModeParms16, true);\n\tvidMode32 = VModeDesc(vidModeParms32, true);\n\n\tret = p;\n\tOffs(0x01, videoType);\t\t\t\t// Video type descriptor\n\tOffs(0x02, videoName);\t\t\t\t// Driver name\n\tOffs(0x04, vidDrvrDir);\t\t\t\t// Driver directory\n\tRsrc(0x08, 0x4232);\t\t\t\t\t// Hardware device ID ('B2')\n\tOffs(0x0a, minorBase);\t\t\t\t// Frame buffer base\n\tOffs(0x0b, minorLength);\t\t\t// Frame buffer length\n\tOffs(0x40, gammaDir);\t\t\t\t// Gamma directory\n\tRsrc(0x7d, 6);\t\t\t\t\t\t// Video attributes: Default to color, built-in\n\tif (m.has_depth(VDEPTH_1BIT))\n\t\tOffs(m.depth_to_apple_mode(VDEPTH_1BIT), vidMode1);\t// Video mode parameters for 1 bit\n\tif (m.has_depth(VDEPTH_2BIT))\n\t\tOffs(m.depth_to_apple_mode(VDEPTH_2BIT), vidMode2);\t// Video mode parameters for 2 bit\n\tif (m.has_depth(VDEPTH_4BIT))\n\t\tOffs(m.depth_to_apple_mode(VDEPTH_4BIT), vidMode4);\t// Video mode parameters for 4 bit\n\tif (m.has_depth(VDEPTH_8BIT))\n\t\tOffs(m.depth_to_apple_mode(VDEPTH_8BIT), vidMode8);\t// Video mode parameters for 8 bit\n\tif (m.has_depth(VDEPTH_16BIT))\n\t\tOffs(m.depth_to_apple_mode(VDEPTH_16BIT), vidMode16);\t// Video mode parameters for 16 bit\n\tif (m.has_depth(VDEPTH_32BIT))\n\t\tOffs(m.depth_to_apple_mode(VDEPTH_32BIT), vidMode32);\t// Video mode parameters for 32 bit\n\tEndOfList();\n\treturn ret;\n}\n\nbool InstallSlotROM(void)\n{\n\tuint32 boardType, boardName, vendorID, revLevel, partNum, date;\n\tuint32 vendorInfo, sRsrcBoard;\n\n\tuint32 videoType, videoName, videoDrvr, vidDrvrDir;\n\tuint32 defaultGamma, gammaDir;\n\n\tuint32 cpuType, cpuName, cpuMajor, cpuMinor, sRsrcCPU;\n\n\tuint32 etherType, etherName, etherDrvr, etherDrvrDir, sRsrcEther;\n\n\tuint32 sRsrcDir;\n\n\tvector<monitor_desc *>::const_iterator m, mend = VideoMonitors.end();\n\tvector<uint32> sRsrcVideo;\n\n\tchar str[256];\n\tint i;\n\tp = 0;\n\n\t// Board sResource\n\tboardType = p;\t\t\t\t\t\t// Literals\n\tWord(1); Word(0); Word(0); Word(0);\t// Board sResource\n\tboardName = p;\n\tString(\"Basilisk II Slot ROM\");\n\tvendorID = p;\n\tString(\"Christian Bauer\");\n\trevLevel = p;\n\tsprintf(str, \"V%d.%d\", VERSION_MAJOR, VERSION_MINOR);\n\tString(str);\n\tpartNum = p;\n\tString(\"BasiliskII\");\n\tdate = p;\n\tString(__DATE__);\n\n\tvendorInfo = p;\t\t\t\t\t\t// Vendor Info\n\tOffs(0x01, vendorID);\t\t\t\t// Vendor ID\n\tOffs(0x03, revLevel);\t\t\t\t// Revision level\n\tOffs(0x04, partNum);\t\t\t\t// Part number\n\tOffs(0x05, date);\t\t\t\t\t// ROM build date\n\tEndOfList();\n\n\tsRsrcBoard = p;\n\tOffs(0x01, boardType);\t\t\t\t// Board descriptor\n\tOffs(0x02, boardName);\t\t\t\t// Board name\n\tRsrc(0x20, 0x4232);\t\t\t\t\t// Board ID ('B2')\n\tOffs(0x24, vendorInfo);\t\t\t\t// Vendor Info\n\tEndOfList();\n\n\tvideoType = p;\n\tWord(3); Word(1); Word(1); Word(0x4232);\t// Display Video Apple 'B2'\n\tvideoName = p;\n\tString(\"Display_Video_Apple_Basilisk\");\n\n\tvideoDrvr = p;\t\t\t\t\t\t// Video driver\n\tLong(0x72);\t\t\t\t\t\t\t// Length\n\tWord(0x4c00); Word(0); Word(0); Word(0);\n\tWord(0x32);\t\t\t\t\t\t\t// Open offset\n\tWord(0x36);\t\t\t\t\t\t\t// Prime offset\n\tWord(0x3a);\t\t\t\t\t\t\t// Control offset\n\tWord(0x46);\t\t\t\t\t\t\t// Status offset\n\tWord(0x6c);\t\t\t\t\t\t\t// Close offset\n\tPString(\".Display_Video_Apple_Basilisk\");\n\tWord(1);\t\t\t\t\t\t\t// Driver version\n\tWord(M68K_EMUL_OP_VIDEO_OPEN);\t\t// Open()\n\tWord(0x4e75);\n\tWord(0x70ff);\t\t\t\t\t\t// Prime()\n\tWord(0x600e);\n\tWord(M68K_EMUL_OP_VIDEO_CONTROL);\t// Control()\n\tWord(0x0c68); Word(0x0001); Word(0x001a);\n\tWord(0x6604);\n\tWord(0x4e75);\n\tWord(M68K_EMUL_OP_VIDEO_STATUS);\t// Status()\n\tWord(0x3228); Word(0x0006);\t\t\t// IOReturn\n\tWord(0x0801); Word(0x0009);\n\tWord(0x670c);\n\tWord(0x4a40);\n\tWord(0x6f02);\n\tWord(0x4240);\n\tWord(0x3140); Word(0x0010);\n\tWord(0x4e75);\n\tWord(0x4a40);\n\tWord(0x6f04);\n\tWord(0x4240);\n\tWord(0x4e75);\n\tWord(0x2f38); Word(0x08fc);\n\tWord(0x4e75);\n\tWord(0x70e8);\t\t\t\t\t\t// Close()\n\tWord(0x4e75);\n\n\tvidDrvrDir = p;\t\t\t\t\t\t// Driver directory\n\tOffs(0x02, videoDrvr);\t\t\t\t// sMacOS68020\n\tEndOfList();\n\n\tdefaultGamma = p;\t\t\t\t\t// Gamma table\n\tLong(38 + 0x100);\t\t\t\t\t// Length\n\tWord(0x2000);\t\t\t\t\t\t// Resource ID\n\tString(\"Mac HiRes Std Gamma\");\n\tWord(0);\t\t\t\t\t\t\t// Version\n\tWord(0);\t\t\t\t\t\t\t// Type\n\tWord(0);\t\t\t\t\t\t\t// FormulaSize\n\tWord(1);\t\t\t\t\t\t\t// ChanCnt\n\tWord(0x0100);\t\t\t\t\t\t// DataCnt\n\tWord(8);\t\t\t\t\t\t\t// ChanWidth\n\tLong(0x0005090B); Long(0x0E101315); Long(0x17191B1D); Long(0x1E202224);\n\tLong(0x2527282A); Long(0x2C2D2F30); Long(0x31333436); Long(0x37383A3B);\n\tLong(0x3C3E3F40); Long(0x42434445); Long(0x4748494A); Long(0x4B4D4E4F);\n\tLong(0x50515254); Long(0x55565758); Long(0x595A5B5C); Long(0x5E5F6061);\n\tLong(0x62636465); Long(0x66676869); Long(0x6A6B6C6D); Long(0x6E6F7071);\n\tLong(0x72737475); Long(0x76777879); Long(0x7A7B7C7D); Long(0x7E7F8081);\n\tLong(0x81828384); Long(0x85868788); Long(0x898A8B8C); Long(0x8C8D8E8F);\n\tLong(0x90919293); Long(0x94959596); Long(0x9798999A); Long(0x9B9B9C9D);\n\tLong(0x9E9FA0A1); Long(0xA1A2A3A4); Long(0xA5A6A6A7); Long(0xA8A9AAAB);\n\tLong(0xABACADAE); Long(0xAFB0B0B1); Long(0xB2B3B4B4); Long(0xB5B6B7B8);\n\tLong(0xB8B9BABB); Long(0xBCBCBDBE); Long(0xBFC0C0C1); Long(0xC2C3C3C4);\n\tLong(0xC5C6C7C7); Long(0xC8C9CACA); Long(0xCBCCCDCD); Long(0xCECFD0D0);\n\tLong(0xD1D2D3D3); Long(0xD4D5D6D6); Long(0xD7D8D9D9); Long(0xDADBDCDC);\n\tLong(0xDDDEDFDF); Long(0xE0E1E1E2); Long(0xE3E4E4E5); Long(0xE6E7E7E8);\n\tLong(0xE9E9EAEB); Long(0xECECEDEE); Long(0xEEEFF0F1); Long(0xF1F2F3F3);\n\tLong(0xF4F5F5F6); Long(0xF7F8F8F9); Long(0xFAFAFBFC); Long(0xFCFDFEFF);\n\n\tgammaDir = p;\t\t\t\t\t\t// Gamma directory\n\tOffs(0x80, defaultGamma);\n\tEndOfList();\n\n\tfor (m = VideoMonitors.begin(); m != mend; ++m)\n\t\tsRsrcVideo.push_back(VMonitor(**m, videoType, videoName, vidDrvrDir, gammaDir));\n\n\t// CPU sResource\n\tcpuType = p;\t\t\t\t\t\t// Literals\n\tWord(10); Word(3); Word(0); Word(24);\t// CPU 68020\n\tcpuName = p;\n\tString(\"CPU_68020\");\n\tcpuMajor = p;\n\tLong(0); Long(0x7fffffff);\n\tcpuMinor = p;\n\tLong(0xf0800000); Long(0xf0ffffff);\n\n\tsRsrcCPU = p;\n\tOffs(0x01, cpuType);\t\t\t\t// Type descriptor\n\tOffs(0x02, cpuName);\t\t\t\t// CPU name\n\tOffs(0x81, cpuMajor);\t\t\t\t// Major RAM space\n\tOffs(0x82, cpuMinor);\t\t\t\t// Minor RAM space\n\tEndOfList();\n\n\t// Ethernet sResource\n\tetherType = p;\t\t\t\t\t\t// Literals\n\tWord(4); Word(1); Word(1); Word(0x4232);\t// Network Ethernet Apple 'B2'\n\tetherName = p;\n\tString(\"Network_Ethernet_Apple_BasiliskII\");\n\n\tetherDrvr = p;\t\t\t\t\t\t// Video driver\n\tLong(0x88);\t\t\t\t\t\t\t// Length\n\tWord(0x4400); Word(0); Word(0); Word(0);\n\tWord(0x4a);\t\t\t\t\t\t\t// Open offset\n\tWord(0x4e);\t\t\t\t\t\t\t// Prime offset\n\tWord(0x52);\t\t\t\t\t\t\t// Control offset\n\tWord(0x4e);\t\t\t\t\t\t\t// Status offset\n\tWord(0x82);\t\t\t\t\t\t\t// Close offset\n\tPString(\".ENET\");\n\tWord(0x0111); Word(0x8000);\t\t\t// Driver version\n\tWord(0);\n\tPString(\"1.1.1  \");\n\tPString(\"Basilisk II Ethernet Network Driver\");\n\tWord(M68K_EMUL_OP_ETHER_OPEN);\t\t// Open()\n\tWord(0x4e75);\n\tWord(0x70ef);\t\t\t\t\t\t// Prime()/Status()\n\tWord(0x600c);\n\tWord(M68K_EMUL_OP_ETHER_CONTROL);\t// Control()\n\tWord(0x0c68); Word(0x0001); Word(0x001a);\n\tWord(0x6602);\n\tWord(0x4e75);\n\tWord(0x3228); Word(0x0006);\t\t\t// IOReturn\n\tWord(0x0801); Word(0x0009);\n\tWord(0x670c);\n\tWord(0x4a40);\n\tWord(0x6f02);\n\tWord(0x4240);\n\tWord(0x3140); Word(0x0010);\n\tWord(0x4e75);\n\tWord(0x4a40);\n\tWord(0x6f04);\n\tWord(0x4240);\n\tWord(0x4e75);\n\tWord(0x2f38); Word(0x08fc);\n\tWord(0x4e75);\n\tWord(0x70e8);\t\t\t\t\t\t// Close()\n\tWord(0x4e75);\n\n\tetherDrvrDir = p;\t\t\t\t\t// Driver directory\n\tOffs(0x02, etherDrvr);\t\t\t\t// sMacOS68020\n\tEndOfList();\n\n\tsRsrcEther = p;\n\tOffs(0x01, etherType);\t\t\t\t// Type descriptor\n\tOffs(0x02, etherName);\t\t\t\t// Driver name\n\tOffs(0x04, etherDrvrDir);\t\t\t// Driver directory\n\tRsrc(0x07, 2);\t\t\t\t\t\t// Flags: OpenAtStart\n\tRsrc(0x08, 0x4232);\t\t\t\t\t// Hardware device ID ('B2')\n\tEndOfList();\n\n\t// sResource directory\n\tsRsrcDir = p;\n\tOffs(0x01, sRsrcBoard);\n\tfor (m = VideoMonitors.begin(), i = 0; m != mend; ++m, ++i)\n\t\tOffs((*m)->get_slot_id(), sRsrcVideo[i]);\n\tOffs(0xf0, sRsrcCPU);\n\tOffs(0xf1, sRsrcEther);\n\tEndOfList();\n\n\t// Format/header block\n\tOffs(0, sRsrcDir);\t\t\t\t\t// sResource directory\n\tLong(p + 16);\t\t\t\t\t\t// Length of declaration data\n\tLong(0);\t\t\t\t\t\t\t// CRC (calculated later)\n\tWord(0x0101);\t\t\t\t\t\t// Rev. level, format\n\tLong(0x5a932bc7);\t\t\t\t\t// Test pattern\n\tWord(0x000f);\t\t\t\t\t\t// Byte lanes\n\n\t// Copy slot ROM to Mac ROM\n\tslot_rom_size = p;\n\tmemcpy(ROMBaseHost + ROMSize - slot_rom_size, srom, slot_rom_size);\n\n\t// Calculate checksum\n\tChecksumSlotROM();\n\treturn true;\n}\n\n/*\n *  Calculate slot ROM checksum (in-place)\n */\n\nvoid ChecksumSlotROM(void)\n{\n\t// Calculate CRC\n\tuint8 *p = ROMBaseHost + ROMSize - slot_rom_size;\n\tp[slot_rom_size - 12] = 0;\n\tp[slot_rom_size - 11] = 0;\n\tp[slot_rom_size - 10] = 0;\n\tp[slot_rom_size - 9] = 0;\n\tuint32 crc = 0;\n\tfor (int i=0; i<slot_rom_size; i++) {\n\t\tcrc = (crc << 1) | (crc >> 31);\n\t\tcrc += p[i];\n\t}\n\tp[slot_rom_size - 12] = crc >> 24;\n\tp[slot_rom_size - 11] = crc >> 16;\n\tp[slot_rom_size - 10] = crc >> 8;\n\tp[slot_rom_size - 9] = crc;\n}\n","// -*- C++ -*-\n//===-------------------------- iterator ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ITERATOR\n#define _LIBCPP_ITERATOR\n\n/*\n    iterator synopsis\n\nnamespace std\n{\n\ntemplate<class Iterator>\nstruct iterator_traits\n{\n    typedef typename Iterator::difference_type difference_type;\n    typedef typename Iterator::value_type value_type;\n    typedef typename Iterator::pointer pointer;\n    typedef typename Iterator::reference reference;\n    typedef typename Iterator::iterator_category iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<const T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class Category, class T, class Distance = ptrdiff_t,\n         class Pointer = T*, class Reference = T&>\nstruct iterator\n{\n    typedef T         value_type;\n    typedef Distance  difference_type;\n    typedef Pointer   pointer;\n    typedef Reference reference;\n    typedef Category  iterator_category;\n};\n\nstruct input_iterator_tag  {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag       : public input_iterator_tag         {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag       {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};\n\n// extension: second argument not conforming to C++03\ntemplate <class InputIterator>\nvoid advance(InputIterator& i,\n             typename iterator_traits<InputIterator>::difference_type n);\n\ntemplate <class InputIterator>\ntypename iterator_traits<InputIterator>::difference_type\ndistance(InputIterator first, InputIterator last);\n\ntemplate <class Iterator>\nclass reverse_iterator\n    : public iterator<typename iterator_traits<Iterator>::iterator_category,\n                      typename iterator_traits<Iterator>::value_type,\n                      typename iterator_traits<Iterator>::difference_type,\n                      typename iterator_traits<Iterator>::pointer,\n                      typename iterator_traits<Iterator>::reference>\n{\nprotected:\n    Iterator current;\npublic:\n    typedef Iterator                                            iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type difference_type;\n    typedef typename iterator_traits<Iterator>::reference       reference;\n    typedef typename iterator_traits<Iterator>::pointer         pointer;\n\n    constexpr reverse_iterator();\n    constexpr explicit reverse_iterator(Iterator x);\n    template <class U> constexpr reverse_iterator(const reverse_iterator<U>& u);\n    template <class U> constexpr reverse_iterator& operator=(const reverse_iterator<U>& u);\n    constexpr Iterator base() const;\n    constexpr reference operator*() const;\n    constexpr pointer   operator->() const;\n    constexpr reverse_iterator& operator++();\n    constexpr reverse_iterator  operator++(int);\n    constexpr reverse_iterator& operator--();\n    constexpr reverse_iterator  operator--(int);\n    constexpr reverse_iterator  operator+ (difference_type n) const;\n    constexpr reverse_iterator& operator+=(difference_type n);\n    constexpr reverse_iterator  operator- (difference_type n) const;\n    constexpr reverse_iterator& operator-=(difference_type n);\n    constexpr reference         operator[](difference_type n) const;\n};\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool                          // constexpr in C++17\noperator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr auto\noperator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y)\n-> decltype(__y.base() - __x.base());   // constexpr in C++17\n\ntemplate <class Iterator>\nconstexpr reverse_iterator<Iterator>\noperator+(typename reverse_iterator<Iterator>::difference_type n, \n          const reverse_iterator<Iterator>& x);   // constexpr in C++17\n\ntemplate <class Iterator>\nconstexpr reverse_iterator<Iterator> make_reverse_iterator(Iterator i); // C++14, constexpr in C++17\n\ntemplate <class Container>\nclass back_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                   container_type;\n    typedef void                        value_type;\n    typedef void                        difference_type;\n    typedef void                        reference;\n    typedef void                        pointer;\n\n    explicit back_insert_iterator(Container& x);\n    back_insert_iterator& operator=(const typename Container::value_type& value);\n    back_insert_iterator& operator*();\n    back_insert_iterator& operator++();\n    back_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> back_insert_iterator<Container> back_inserter(Container& x);\n\ntemplate <class Container>\nclass front_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                    container_type;\n    typedef void                         value_type;\n    typedef void                         difference_type;\n    typedef void                         reference;\n    typedef void                         pointer;\n\n    explicit front_insert_iterator(Container& x);\n    front_insert_iterator& operator=(const typename Container::value_type& value);\n    front_insert_iterator& operator*();\n    front_insert_iterator& operator++();\n    front_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> front_insert_iterator<Container> front_inserter(Container& x);\n\ntemplate <class Container>\nclass insert_iterator\n{\nprotected:\n    Container* container;\n    typename Container::iterator iter;\npublic:\n    typedef Container              container_type;\n    typedef void                   value_type;\n    typedef void                   difference_type;\n    typedef void                   reference;\n    typedef void                   pointer;\n\n    insert_iterator(Container& x, typename Container::iterator i);\n    insert_iterator& operator=(const typename Container::value_type& value);\n    insert_iterator& operator*();\n    insert_iterator& operator++();\n    insert_iterator& operator++(int);\n};\n\ntemplate <class Container, class Iterator>\ninsert_iterator<Container> inserter(Container& x, Iterator i);\n\ntemplate <class Iterator>\nclass move_iterator {\npublic:\n    typedef Iterator                                              iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type   difference_type;\n    typedef Iterator                                              pointer;\n    typedef typename iterator_traits<Iterator>::value_type        value_type;\n    typedef typename iterator_traits<Iterator>::iterator_category iterator_category;\n    typedef value_type&&                                          reference;\n \n    constexpr move_iterator();  // all the constexprs are in C++17\n    constexpr explicit move_iterator(Iterator i);\n    template <class U>\n      constexpr move_iterator(const move_iterator<U>& u);\n    template <class U>\n      constexpr move_iterator& operator=(const move_iterator<U>& u);\n    constexpr iterator_type base() const;\n    constexpr reference operator*() const;\n    constexpr pointer operator->() const;\n    constexpr move_iterator& operator++();\n    constexpr move_iterator operator++(int);\n    constexpr move_iterator& operator--();\n    constexpr move_iterator operator--(int);\n    constexpr move_iterator operator+(difference_type n) const; \n    constexpr move_iterator& operator+=(difference_type n); \n    constexpr move_iterator operator-(difference_type n) const; \n    constexpr move_iterator& operator-=(difference_type n); \n    constexpr unspecified operator[](difference_type n) const;\nprivate:\n    Iterator current; // exposition only\n};\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator==(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator!=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator<(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator<=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator>(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr bool   // constexpr in C++17\noperator>=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nconstexpr auto   // constexpr in C++17\noperator-(const move_iterator<Iterator1>& x,\n          const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());\n\ntemplate <class Iterator>\nconstexpr move_iterator<Iterator> operator+(   // constexpr in C++17\n            typename move_iterator<Iterator>::difference_type n, \n            const move_iterator<Iterator>& x);\n\ntemplate <class Iterator>   // constexpr in C++17\nconstexpr  move_iterator<Iterator> make_move_iterator(const Iterator& i);\n\n\ntemplate <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>\nclass istream_iterator\n    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_istream<charT,traits> istream_type;\n\n    constexpr istream_iterator();\n    istream_iterator(istream_type& s);\n    istream_iterator(const istream_iterator& x);\n    ~istream_iterator();\n\n    const T& operator*() const;\n    const T* operator->() const;\n    istream_iterator& operator++();\n    istream_iterator  operator++(int);\n};\n\ntemplate <class T, class charT, class traits, class Distance>\nbool operator==(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\ntemplate <class T, class charT, class traits, class Distance>\nbool operator!=(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT> >\nclass ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void ,void>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_ostream<charT,traits> ostream_type;\n\n    ostream_iterator(ostream_type& s);\n    ostream_iterator(ostream_type& s, const charT* delimiter);\n    ostream_iterator(const ostream_iterator& x);\n    ~ostream_iterator();\n    ostream_iterator& operator=(const T& value);\n\n    ostream_iterator& operator*();\n    ostream_iterator& operator++();\n    ostream_iterator& operator++(int);\n};\n\ntemplate<class charT, class traits = char_traits<charT> >\nclass istreambuf_iterator\n    : public iterator<input_iterator_tag, charT,\n                      typename traits::off_type, unspecified,\n                      charT>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef typename traits::int_type     int_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_istream<charT,traits>   istream_type;\n\n    istreambuf_iterator() noexcept;\n    istreambuf_iterator(istream_type& s) noexcept;\n    istreambuf_iterator(streambuf_type* s) noexcept;\n    istreambuf_iterator(a-private-type) noexcept;\n\n    charT                operator*() const;\n    pointer operator->() const;\n    istreambuf_iterator& operator++();\n    a-private-type       operator++(int);\n\n    bool equal(const istreambuf_iterator& b) const;\n};\n\ntemplate <class charT, class traits>\nbool operator==(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\ntemplate <class charT, class traits>\nbool operator!=(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_ostream<charT,traits>   ostream_type;\n\n    ostreambuf_iterator(ostream_type& s) noexcept;\n    ostreambuf_iterator(streambuf_type* s) noexcept;\n    ostreambuf_iterator& operator=(charT c);\n    ostreambuf_iterator& operator*();\n    ostreambuf_iterator& operator++();\n    ostreambuf_iterator& operator++(int);\n    bool failed() const noexcept;\n};\n\ntemplate <class C> constexpr auto begin(C& c) -> decltype(c.begin());\ntemplate <class C> constexpr auto begin(const C& c) -> decltype(c.begin());\ntemplate <class C> constexpr auto end(C& c) -> decltype(c.end());\ntemplate <class C> constexpr auto end(const C& c) -> decltype(c.end());\ntemplate <class T, size_t N> constexpr T* begin(T (&array)[N]);\ntemplate <class T, size_t N> constexpr T* end(T (&array)[N]);\n\ntemplate <class C> auto constexpr cbegin(const C& c) -> decltype(std::begin(c));        // C++14\ntemplate <class C> auto constexpr cend(const C& c) -> decltype(std::end(c));            // C++14\ntemplate <class C> auto constexpr rbegin(C& c) -> decltype(c.rbegin());                 // C++14\ntemplate <class C> auto constexpr rbegin(const C& c) -> decltype(c.rbegin());           // C++14\ntemplate <class C> auto constexpr rend(C& c) -> decltype(c.rend());                     // C++14\ntemplate <class C> constexpr auto rend(const C& c) -> decltype(c.rend());               // C++14\ntemplate <class E> reverse_iterator<const E*> constexpr rbegin(initializer_list<E> il); // C++14\ntemplate <class E> reverse_iterator<const E*> constexpr rend(initializer_list<E> il);   // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> constexpr rbegin(T (&array)[N]);      // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> constexpr rend(T (&array)[N]);        // C++14\ntemplate <class C> constexpr auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14\ntemplate <class C> constexpr auto crend(const C& c) -> decltype(std::rend(c));          // C++14\n\n// 24.8, container access:\ntemplate <class C> constexpr auto size(const C& c) -> decltype(c.size());         // C++17\ntemplate <class T, size_t N> constexpr size_t size(const T (&array)[N]) noexcept; // C++17\ntemplate <class C> constexpr auto empty(const C& c) -> decltype(c.empty());       // C++17\ntemplate <class T, size_t N> constexpr bool empty(const T (&array)[N]) noexcept;  // C++17\ntemplate <class E> constexpr bool empty(initializer_list<E> il) noexcept;         // C++17\ntemplate <class C> constexpr auto data(C& c) -> decltype(c.data());               // C++17\ntemplate <class C> constexpr auto data(const C& c) -> decltype(c.data());         // C++17\ntemplate <class T, size_t N> constexpr T* data(T (&array)[N]) noexcept;           // C++17\ntemplate <class E> constexpr const E* data(initializer_list<E> il) noexcept;      // C++17\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd> // for forward declarations of vector and string.\n#include <__functional_base>\n#include <type_traits>\n#include <cstddef>\n#include <initializer_list>\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nstruct _LIBCPP_TEMPLATE_VIS input_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS output_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS forward_iterator_tag       : public input_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct _LIBCPP_TEMPLATE_VIS random_access_iterator_tag : public bidirectional_iterator_tag {};\n\ntemplate <class _Tp>\nstruct __has_iterator_category\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::iterator_category* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits_impl {};\n\ntemplate <class _Iter>\nstruct __iterator_traits_impl<_Iter, true>\n{\n    typedef typename _Iter::difference_type   difference_type;\n    typedef typename _Iter::value_type        value_type;\n    typedef typename _Iter::pointer           pointer;\n    typedef typename _Iter::reference         reference;\n    typedef typename _Iter::iterator_category iterator_category;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits {};\n\ntemplate <class _Iter>\nstruct __iterator_traits<_Iter, true>\n    :  __iterator_traits_impl\n      <\n        _Iter,\n        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||\n        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value\n      >\n{};\n\n// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category\n//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a\n//    conforming extension which allows some programs to compile and behave as\n//    the client expects instead of failing at compile time.\n\ntemplate <class _Iter>\nstruct _LIBCPP_TEMPLATE_VIS iterator_traits\n    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS iterator_traits<_Tp*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef typename remove_const<_Tp>::type value_type;\n    typedef _Tp* pointer;\n    typedef _Tp& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>\nstruct __has_iterator_category_convertible_to\n    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>\n{};\n\ntemplate <class _Tp, class _Up>\nstruct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};\n\ntemplate <class _Tp>\nstruct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_exactly_input_iterator\n    : public integral_constant<bool, \n         __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value && \n        !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {};\n\ntemplate<class _Category, class _Tp, class _Distance = ptrdiff_t,\n         class _Pointer = _Tp*, class _Reference = _Tp&>\nstruct _LIBCPP_TEMPLATE_VIS iterator\n{\n    typedef _Tp        value_type;\n    typedef _Distance  difference_type;\n    typedef _Pointer   pointer;\n    typedef _Reference reference;\n    typedef _Category  iterator_category;\n};\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)\n{\n    for (; __n > 0; --__n)\n        ++__i;\n}\n\ntemplate <class _BiDirIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_BiDirIter& __i,\n             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)\n{\n    if (__n >= 0)\n        for (; __n > 0; --__n)\n            ++__i;\n    else\n        for (; __n < 0; ++__n)\n            --__i;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_RandIter& __i,\n             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)\n{\n   __i += __n;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n)\n{\n    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\n__distance(_InputIter __first, _InputIter __last, input_iterator_tag)\n{\n    typename iterator_traits<_InputIter>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        ++__r;\n    return __r;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_RandIter>::difference_type\n__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)\n{\n    return __last - __first;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\ndistance(_InputIter __first, _InputIter __last)\n{\n    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIter\nnext(_InputIter __x,\n     typename iterator_traits<_InputIter>::difference_type __n = 1,\n     typename enable_if<__is_input_iterator<_InputIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, __n);\n    return __x;\n}\n\ntemplate <class _BidiretionalIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidiretionalIter\nprev(_BidiretionalIter __x,\n     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,\n     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, -__n);\n    return __x;\n}\n\ntemplate <class _Iter>\nclass _LIBCPP_TEMPLATE_VIS reverse_iterator\n    : public iterator<typename iterator_traits<_Iter>::iterator_category,\n                      typename iterator_traits<_Iter>::value_type,\n                      typename iterator_traits<_Iter>::difference_type,\n                      typename iterator_traits<_Iter>::pointer,\n                      typename iterator_traits<_Iter>::reference>\n{\nprivate:\n    /*mutable*/ _Iter __t;  // no longer used as of LWG #2360, not removed due to ABI break\nprotected:\n    _Iter current;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<_Iter>::difference_type difference_type;\n    typedef typename iterator_traits<_Iter>::reference       reference;\n    typedef typename iterator_traits<_Iter>::pointer         pointer;\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator() : __t(), current() {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n        reverse_iterator(const reverse_iterator<_Up>& __u) : __t(__u.base()), current(__u.base()) {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n        reverse_iterator& operator=(const reverse_iterator<_Up>& __u)\n            { __t = current = __u.base(); return *this; }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    _Iter base() const {return current;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference operator*() const {_Iter __tmp = current; return *--__tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    pointer  operator->() const {return _VSTD::addressof(operator*());}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator++() {--current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator++(int) {reverse_iterator __tmp(*this); --current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator--() {++current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator--(int) {reverse_iterator __tmp(*this); ++current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator+ (difference_type __n) const {return reverse_iterator(current - __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator+=(difference_type __n) {current -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator  operator- (difference_type __n) const {return reverse_iterator(current + __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reverse_iterator& operator-=(difference_type __n) {current += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference         operator[](difference_type __n) const {return *(*this + __n);}\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n-> decltype(__y.base() - __x.base())\n{\n    return __y.base() - __x.base();\n}\n#else\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename reverse_iterator<_Iter1>::difference_type\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __y.base() - __x.base();\n}\n#endif\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Iter>\noperator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)\n{\n    return reverse_iterator<_Iter>(__x.base() - __n);\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Iter> make_reverse_iterator(_Iter __i)\n{\n    return reverse_iterator<_Iter>(__i);\n}\n#endif\n\ntemplate <class _Container>\nclass _LIBCPP_TEMPLATE_VIS back_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      void>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_back(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_back(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nback_insert_iterator<_Container>\nback_inserter(_Container& __x)\n{\n    return back_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TEMPLATE_VIS front_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      void>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_front(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_front(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nfront_insert_iterator<_Container>\nfront_inserter(_Container& __x)\n{\n    return front_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TEMPLATE_VIS insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      void>\n{\nprotected:\n    _Container* container;\n    typename _Container::iterator iter;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, typename _Container::iterator __i)\n        : container(_VSTD::addressof(__x)), iter(__i) {}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {iter = container->insert(iter, __value_); ++iter; return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {iter = container->insert(iter, _VSTD::move(__value_)); ++iter; return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\ninsert_iterator<_Container>\ninserter(_Container& __x, typename _Container::iterator __i)\n{\n    return insert_iterator<_Container>(__x, __i);\n}\n\ntemplate <class _Tp, class _CharT = char,\n          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>\nclass _LIBCPP_TEMPLATE_VIS istream_iterator\n    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_istream<_CharT,_Traits> istream_type;\nprivate:\n    istream_type* __in_stream_;\n    _Tp __value_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istream_iterator() : __in_stream_(0), __value_() {}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(_VSTD::addressof(__s))\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const {return __value_;}\n    _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const {return _VSTD::addressof((operator*()));}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)\n        {istream_iterator __t(*this); ++(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const istream_iterator& __x, const istream_iterator& __y)\n        {return __x.__in_stream_ == __y.__in_stream_;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >\nclass _LIBCPP_TEMPLATE_VIS ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_ostream<_CharT,_Traits> ostream_type;\nprivate:\n    ostream_type* __out_stream_;\n    const char_type* __delim_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s) _NOEXCEPT\n        : __out_stream_(_VSTD::addressof(__s)), __delim_(0) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter) _NOEXCEPT\n        : __out_stream_(_VSTD::addressof(__s)), __delim_(__delimiter) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)\n        {\n            *__out_stream_ << __value_;\n            if (__delim_)\n                *__out_stream_ << __delim_;\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) {return *this;}\n};\n\ntemplate<class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS istreambuf_iterator\n    : public iterator<input_iterator_tag, _CharT,\n                      typename _Traits::off_type, _CharT*,\n                      _CharT>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef typename _Traits::int_type      int_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_istream<_CharT,_Traits>   istream_type;\nprivate:\n    mutable streambuf_type* __sbuf_;\n\n    class __proxy\n    {\n        char_type __keep_;\n        streambuf_type* __sbuf_;\n        _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)\n            : __keep_(__c), __sbuf_(__s) {}\n        friend class istreambuf_iterator;\n    public:\n        _LIBCPP_INLINE_VISIBILITY char_type operator*() const {return __keep_;}\n    };\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __test_for_eof() const\n    {\n        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))\n            __sbuf_ = 0;\n        return __sbuf_ == 0;\n    }\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT\n        : __sbuf_(__p.__sbuf_) {}\n\n    _LIBCPP_INLINE_VISIBILITY char_type  operator*() const\n        {return static_cast<char_type>(__sbuf_->sgetc());}\n    _LIBCPP_INLINE_VISIBILITY char_type* operator->() const {return nullptr;}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()\n        {\n            __sbuf_->sbumpc();\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)\n        {\n            return __proxy(__sbuf_->sbumpc(), __sbuf_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const\n        {return __test_for_eof() == __b.__test_for_eof();}\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return __a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return !__a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TEMPLATE_VIS ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_ostream<_CharT,_Traits>   ostream_type;\nprivate:\n    streambuf_type* __sbuf_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(ostream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator=(_CharT __c)\n        {\n            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))\n                __sbuf_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++(int) {return *this;}\n    _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\n    template <class _Ch, class _Tr>\n    friend\n    _LIBCPP_HIDDEN\n    ostreambuf_iterator<_Ch, _Tr>\n    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,\n                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,\n                     ios_base& __iob, _Ch __fl);\n#endif\n};\n\ntemplate <class _Iter>\nclass _LIBCPP_TEMPLATE_VIS move_iterator\n{\nprivate:\n    _Iter __i;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type difference_type;\n    typedef iterator_type pointer;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    typedef typename iterator_traits<iterator_type>::reference __reference;\n    typedef typename conditional<\n            is_reference<__reference>::value,\n            typename remove_reference<__reference>::type&&,\n            __reference\n        >::type reference;\n#else\n    typedef typename iterator_traits<iterator_type>::reference reference;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator() : __i() {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    explicit move_iterator(_Iter __x) : __i(__x) {}\n    template <class _Up>\n      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n      move_iterator(const move_iterator<_Up>& __u) : __i(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 _Iter base() const {return __i;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 \n    reference operator*() const { return static_cast<reference>(*__i); }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    pointer  operator->() const { return __i;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator++() {++__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator++(int) {move_iterator __tmp(*this); ++__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator--() {--__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator--(int) {move_iterator __tmp(*this); --__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator+ (difference_type __n) const {return move_iterator(__i + __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator+=(difference_type __n) {__i += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator  operator- (difference_type __n) const {return move_iterator(__i - __n);}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    move_iterator& operator-=(difference_type __n) {__i -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\n    reference operator[](difference_type __n) const { return static_cast<reference>(__i[__n]); }\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nbool\noperator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n-> decltype(__x.base() - __y.base())\n{\n    return __x.base() - __y.base();\n}\n#else\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename move_iterator<_Iter1>::difference_type\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() - __y.base();\n}\n#endif\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nmove_iterator<_Iter>\noperator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)\n{\n    return move_iterator<_Iter>(__x.base() + __n);\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nmove_iterator<_Iter>\nmake_move_iterator(_Iter __i)\n{\n    return move_iterator<_Iter>(__i);\n}\n\n// __wrap_iter\n\ntemplate <class _Iter> class __wrap_iter;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nauto\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n-> decltype(__x.base() - __y.base());\n#else\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n#endif\n\ntemplate <class _Iter>\n_LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT_DEBUG;\n\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*>);\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    __wrap_iter<_Tp*>\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i);\n\n#endif\n\ntemplate <class _Iter>\nclass __wrap_iter\n{\npublic:\n    typedef _Iter                                                      iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type        value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer           pointer;\n    typedef typename iterator_traits<iterator_type>::reference         reference;\nprivate:\n    iterator_type __i;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter() _NOEXCEPT_DEBUG\n#if _LIBCPP_STD_VER > 11\n                : __i{}\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY __wrap_iter(const __wrap_iter<_Up>& __u,\n        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT_DEBUG\n        : __i(__u.base())\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__u);\n#endif\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter(const __wrap_iter& __x)\n        : __i(__x.base())\n    {\n        __get_db()->__iterator_copy(this, &__x);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter& operator=(const __wrap_iter& __x)\n    {\n        if (this != &__x)\n        {\n            __get_db()->__iterator_copy(this, &__x);\n            __i = __x.__i;\n        }\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    ~__wrap_iter()\n    {\n        __get_db()->__erase_i(this);\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return *__i;\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return (pointer)_VSTD::addressof(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator++() _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable iterator\");\n#endif\n        ++__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator++(int) _NOEXCEPT_DEBUG\n        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator--() _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable iterator\");\n#endif\n        --__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator--(int) _NOEXCEPT_DEBUG\n        {__wrap_iter __tmp(*this); --(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT_DEBUG\n        {__wrap_iter __w(*this); __w += __n; return __w;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator+=(difference_type __n) _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),\n                   \"Attempted to add/subtract iterator outside of valid range\");\n#endif\n        __i += __n;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator- (difference_type __n) const _NOEXCEPT_DEBUG\n        {return *this + (-__n);}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator-=(difference_type __n) _NOEXCEPT_DEBUG\n        {*this += -__n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference        operator[](difference_type __n) const _NOEXCEPT_DEBUG\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),\n                   \"Attempted to subscript iterator outside of valid range\");\n#endif\n        return __i[__n];\n    }\n\n    _LIBCPP_INLINE_VISIBILITY iterator_type base() const _NOEXCEPT_DEBUG {return __i;}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(const void* __p, iterator_type __x) : __i(__x)\n    {\n        __get_db()->__insert_ic(this, __p);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(iterator_type __x) _NOEXCEPT_DEBUG : __i(__x) {}\n#endif\n\n    template <class _Up> friend class __wrap_iter;\n    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;\n    template <class _Tp, class _Alloc> friend class _LIBCPP_TEMPLATE_VIS vector;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Iter1, class _Iter2>\n    friend\n    auto\n    operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n    -> decltype(__x.base() - __y.base());\n#else\n    template <class _Iter1, class _Iter2>\n    friend\n    typename __wrap_iter<_Iter1>::difference_type\n    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;\n#endif\n\n    template <class _Iter1>\n    friend\n    __wrap_iter<_Iter1>\n    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT_DEBUG;\n\n    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);\n    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n    template <class _Tp>\n    friend\n    typename enable_if\n    <\n        is_trivially_copy_assignable<_Tp>::value,\n        _Tp*\n    >::type\n    __unwrap_iter(__wrap_iter<_Tp*>);\n#else\n  template <class _Tp>\n  inline _LIBCPP_INLINE_VISIBILITY\n  typename enable_if\n  <\n      is_trivially_copy_assignable<_Tp>::value,\n      __wrap_iter<_Tp*>\n  >::type\n  __unwrap_iter(__wrap_iter<_Tp*> __i);\n#endif\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to compare incomparable iterators\");\n#endif\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG\n{\n    return !(__y < __x);\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n-> decltype(__x.base() - __y.base())\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n#else\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n#endif\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type __n,\n          __wrap_iter<_Iter> __x) _NOEXCEPT_DEBUG\n{\n    __x += __n;\n    return __x;\n}\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator\n    : public _LIBCPP_BOOL_CONSTANT(is_pointer<_Iter>::value) {};\n    \ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<move_iterator<_Iter> >\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<reverse_iterator<_Iter> >\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) {};\n\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nbegin(_Tp (&__array)[_Np])\n{\n    return __array;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nend(_Tp (&__array)[_Np])\n{\n    return __array + _Np;\n}\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nbegin(_Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nbegin(const _Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nend(_Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto\nend(const _Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array + _Np);\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array);\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.end());\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nreverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.begin());\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cbegin(const _Cp& __c) -> decltype(_VSTD::begin(__c))\n{\n    return _VSTD::begin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cend(const _Cp& __c) -> decltype(_VSTD::end(__c))\n{\n    return _VSTD::end(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rbegin(_Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rbegin(const _Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rend(_Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto rend(const _Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto crbegin(const _Cp& __c) -> decltype(_VSTD::rbegin(__c))\n{\n    return _VSTD::rbegin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14\nauto crend(const _Cp& __c) -> decltype(_VSTD::rend(__c))\n{\n    return _VSTD::rend(__c);\n}\n\n#endif\n\n\n#else  // defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nbegin(_Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nbegin(const _Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nend(_Cp& __c)\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nend(const _Cp& __c)\n{\n    return __c.end();\n}\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Cont>\nconstexpr auto size(const _Cont& __c) -> decltype(__c.size()) { return __c.size(); }\n\ntemplate <class _Tp, size_t _Sz>\nconstexpr size_t size(const _Tp (&)[_Sz]) noexcept { return _Sz; }\n\ntemplate <class _Cont>\nconstexpr auto empty(const _Cont& __c) -> decltype(__c.empty()) { return __c.empty(); }\n\ntemplate <class _Tp, size_t _Sz>\nconstexpr bool empty(const _Tp (&)[_Sz]) noexcept { return false; }\n\ntemplate <class _Ep>\nconstexpr bool empty(initializer_list<_Ep> __il) noexcept { return __il.size() == 0; }\n\ntemplate <class _Cont> constexpr\nauto data(_Cont& __c) -> decltype(__c.data()) { return __c.data(); }\n\ntemplate <class _Cont> constexpr\nauto data(const _Cont& __c) -> decltype(__c.data()) { return __c.data(); }\n\ntemplate <class _Tp, size_t _Sz>\nconstexpr _Tp* data(_Tp (&__array)[_Sz]) noexcept { return __array; }\n\ntemplate <class _Ep>\nconstexpr const _Ep* data(initializer_list<_Ep> __il) noexcept { return __il.begin(); }\n#endif\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ITERATOR\n","// -*- C++ -*-\n//===----------------------------- new ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_NEW\n#define _LIBCPP_NEW\n\n/*\n    new synopsis\n\nnamespace std\n{\n\nclass bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() noexcept;\n    bad_alloc(const bad_alloc&) noexcept;\n    bad_alloc& operator=(const bad_alloc&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_array_length : public bad_alloc // FIXME: Not part of C++\n{\npublic:\n    bad_array_length() noexcept;\n};\n\nclass bad_array_new_length : public bad_alloc // C++14\n{\npublic:\n    bad_array_new_length() noexcept;\n};\n\nenum class align_val_t : size_t {}; // C++17\nstruct nothrow_t {};\nextern const nothrow_t nothrow;\ntypedef void (*new_handler)();\nnew_handler set_new_handler(new_handler new_p) noexcept;\nnew_handler get_new_handler() noexcept;\n\n}  // std\n\nvoid* operator new(std::size_t size);                                   // replaceable\nvoid* operator new(std::size_t size, std::align_val_t alignment);       // replaceable, C++17\nvoid* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable\nvoid* operator new(std::size_t size, std::align_val_t alignment,\n                   const std::nothrow_t&) noexcept;                     // replaceable, C++17\nvoid  operator delete(void* ptr) noexcept;                              // replaceable\nvoid  operator delete(void* ptr, std::size_t size) noexcept;            // replaceable, C++14\nvoid  operator delete(void* ptr, std::align_val_t alignment) noexcept;  // replaceable, C++17\nvoid  operator delete(void* ptr, std::size_t size,\n                      std::align_val_t alignment) noexcept;             // replaceable, C++17\nvoid  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable\nvoid  operator delete(void* ptr, std:align_val_t alignment,\n                      const std::nothrow_t&) noexcept;                  // replaceable, C++17\n\nvoid* operator new[](std::size_t size);                                 // replaceable\nvoid* operator new[](std::size_t size,\n                     std::align_val_t alignment) noexcept;              // replaceable, C++17\nvoid* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable\nvoid* operator new[](std::size_t size, std::align_val_t alignment,\n                     const std::nothrow_t&) noexcept;                   // replaceable, C++17\nvoid  operator delete[](void* ptr) noexcept;                            // replaceable\nvoid  operator delete[](void* ptr, std::size_t size) noexcept;          // replaceable, C++14\nvoid  operator delete[](void* ptr,\n                        std::align_val_t alignment) noexcept;           // replaceable, C++17\nvoid  operator delete[](void* ptr, std::size_t size,\n                        std::align_val_t alignment) noexcept;           // replaceable, C++17\nvoid  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable\nvoid  operator delete[](void* ptr, std::align_val_t alignment,\n                        const std::nothrow_t&) noexcept;                // replaceable, C++17\n\nvoid* operator new  (std::size_t size, void* ptr) noexcept;\nvoid* operator new[](std::size_t size, void* ptr) noexcept;\nvoid  operator delete  (void* ptr, void*) noexcept;\nvoid  operator delete[](void* ptr, void*) noexcept;\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#if !(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER >= 14 || \\\n    (defined(__cpp_sized_deallocation) && __cpp_sized_deallocation >= 201309))\n# define _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) && \\\n    (!(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER > 14 || \\\n    (defined(__cpp_aligned_new) && __cpp_aligned_new >= 201606)))\n# define _LIBCPP_HAS_NO_ALIGNED_ALLOCATION\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() _NOEXCEPT;\n    virtual ~bad_alloc() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_new_length\n    : public bad_alloc\n{\npublic:\n    bad_array_new_length() _NOEXCEPT;\n    virtual ~bad_array_new_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec\n\n#if defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_length\n    : public bad_alloc\n{\npublic:\n    bad_array_length() _NOEXCEPT;\n    virtual ~bad_array_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#define _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n\n#endif  // defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\n#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) || _LIBCPP_STD_VER > 14\n#ifndef _LIBCPP_CXX03_LANG\nenum class _LIBCPP_ENUM_VIS align_val_t : size_t { };\n#else\nenum align_val_t { __zero = 0, __max = (size_t)-1 };\n#endif\n#endif\n\nstruct _LIBCPP_TYPE_VIS nothrow_t {};\nextern _LIBCPP_FUNC_VIS const nothrow_t nothrow;\ntypedef void (*new_handler)();\n_LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;\n\n}  // std\n\n#if defined(_LIBCPP_CXX03_LANG)\n#define _THROW_BAD_ALLOC throw(std::bad_alloc)\n#else\n#define _THROW_BAD_ALLOC\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::size_t __sz) _NOEXCEPT;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_ALIGNED_ALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;\n#endif\n\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t) _THROW_BAD_ALLOC;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t) _NOEXCEPT;\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION\n_LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete[](void* __p, std::size_t __sz, std::align_val_t) _NOEXCEPT;\n#endif\n#endif\n\ninline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {}\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ninline _LIBCPP_INLINE_VISIBILITY void *__allocate(size_t __size) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  return ::operator new(__size);\n#else\n  return __builtin_operator_new(__size);\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void __libcpp_deallocate(void *__ptr) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  ::operator delete(__ptr);\n#else\n  __builtin_operator_delete(__ptr);\n#endif\n}\n\n#ifdef _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_bad_array_length()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw bad_array_length();\n#else\n\t_VSTD::abort();\n#endif\n}\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_NEW\n","/*\n * UAE - The Un*x Amiga Emulator\n *\n * Memory management\n *\n * (c) 1995 Bernd Schmidt\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"sysdeps.h\"\n\n#include \"cpu_emulation.h\"\n#include \"main.h\"\n#include \"video.h\"\n\n#include \"m68k.h\"\n#include \"memory.h\"\n#include \"readcpu.h\"\n#include \"newcpu.h\"\n\n#if !REAL_ADDRESSING && !DIRECT_ADDRESSING\n\nstatic bool illegal_mem = false;\n\n#ifdef SAVE_MEMORY_BANKS\naddrbank *mem_banks[65536];\n#else\naddrbank mem_banks[65536];\n#endif\n\n#ifdef WORDS_BIGENDIAN\n# define swap_words(X) (X)\n#else\n# define swap_words(X) (((X) >> 16) | ((X) << 16))\n#endif\n\n#ifdef NO_INLINE_MEMORY_ACCESS\nuae_u32 longget (uaecptr addr)\n{\n    return call_mem_get_func (get_mem_bank (addr).lget, addr);\n}\nuae_u32 wordget (uaecptr addr)\n{\n    return call_mem_get_func (get_mem_bank (addr).wget, addr);\n}\nuae_u32 byteget (uaecptr addr)\n{\n    return call_mem_get_func (get_mem_bank (addr).bget, addr);\n}\nvoid longput (uaecptr addr, uae_u32 l)\n{\n    call_mem_put_func (get_mem_bank (addr).lput, addr, l);\n}\nvoid wordput (uaecptr addr, uae_u32 w)\n{\n    call_mem_put_func (get_mem_bank (addr).wput, addr, w);\n}\nvoid byteput (uaecptr addr, uae_u32 b)\n{\n    call_mem_put_func (get_mem_bank (addr).bput, addr, b);\n}\n#endif\n\n/* A dummy bank that only contains zeros */\n\nstatic uae_u32 REGPARAM2 dummy_lget (uaecptr) REGPARAM;\nstatic uae_u32 REGPARAM2 dummy_wget (uaecptr) REGPARAM;\nstatic uae_u32 REGPARAM2 dummy_bget (uaecptr) REGPARAM;\nstatic void REGPARAM2 dummy_lput (uaecptr, uae_u32) REGPARAM;\nstatic void REGPARAM2 dummy_wput (uaecptr, uae_u32) REGPARAM;\nstatic void REGPARAM2 dummy_bput (uaecptr, uae_u32) REGPARAM;\n\nuae_u32 REGPARAM2 dummy_lget (uaecptr addr)\n{\n    if (illegal_mem)\n\twrite_log (\"Illegal lget at %08lx\\n\", addr);\n\n    return 0;\n}\n\nuae_u32 REGPARAM2 dummy_wget (uaecptr addr)\n{\n    if (illegal_mem)\n\twrite_log (\"Illegal wget at %08lx\\n\", addr);\n\n    return 0;\n}\n\nuae_u32 REGPARAM2 dummy_bget (uaecptr addr)\n{\n    if (illegal_mem)\n\twrite_log (\"Illegal bget at %08lx\\n\", addr);\n\n    return 0;\n}\n\nvoid REGPARAM2 dummy_lput (uaecptr addr, uae_u32 l)\n{\n    if (illegal_mem)\n\twrite_log (\"Illegal lput at %08lx\\n\", addr);\n}\nvoid REGPARAM2 dummy_wput (uaecptr addr, uae_u32 w)\n{\n    if (illegal_mem)\n\twrite_log (\"Illegal wput at %08lx\\n\", addr);\n}\nvoid REGPARAM2 dummy_bput (uaecptr addr, uae_u32 b)\n{\n    if (illegal_mem)\n\twrite_log (\"Illegal bput at %08lx\\n\", addr);\n}\n\n/* Mac RAM (32 bit addressing) */\n\nstatic uae_u32 REGPARAM2 ram_lget(uaecptr) REGPARAM;\nstatic uae_u32 REGPARAM2 ram_wget(uaecptr) REGPARAM;\nstatic uae_u32 REGPARAM2 ram_bget(uaecptr) REGPARAM;\nstatic void REGPARAM2 ram_lput(uaecptr, uae_u32) REGPARAM;\nstatic void REGPARAM2 ram_wput(uaecptr, uae_u32) REGPARAM;\nstatic void REGPARAM2 ram_bput(uaecptr, uae_u32) REGPARAM;\nstatic uae_u8 *REGPARAM2 ram_xlate(uaecptr addr) REGPARAM;\n\nstatic uintptr RAMBaseDiff;\t// RAMBaseHost - RAMBaseMac\n\nuae_u32 REGPARAM2 ram_lget(uaecptr addr)\n{\n    uae_u32 *m;\n    m = (uae_u32 *)(RAMBaseDiff + addr);\n    return do_get_mem_long(m);\n}\n\nuae_u32 REGPARAM2 ram_wget(uaecptr addr)\n{\n    uae_u16 *m;\n    m = (uae_u16 *)(RAMBaseDiff + addr);\n    return do_get_mem_word(m);\n}\n\nuae_u32 REGPARAM2 ram_bget(uaecptr addr)\n{\n    return (uae_u32)*(uae_u8 *)(RAMBaseDiff + addr);\n}\n\nvoid REGPARAM2 ram_lput(uaecptr addr, uae_u32 l)\n{\n    uae_u32 *m;\n    m = (uae_u32 *)(RAMBaseDiff + addr);\n    do_put_mem_long(m, l);\n}\n\nvoid REGPARAM2 ram_wput(uaecptr addr, uae_u32 w)\n{\n    uae_u16 *m;\n    m = (uae_u16 *)(RAMBaseDiff + addr);\n    do_put_mem_word(m, w);\n}\n\nvoid REGPARAM2 ram_bput(uaecptr addr, uae_u32 b)\n{\n\t*(uae_u8 *)(RAMBaseDiff + addr) = b;\n}\n\nuae_u8 *REGPARAM2 ram_xlate(uaecptr addr)\n{\n    return (uae_u8 *)(RAMBaseDiff + addr);\n}\n\n/* Mac RAM (24 bit addressing) */\n\nstatic uae_u32 REGPARAM2 ram24_lget(uaecptr) REGPARAM;\nstatic uae_u32 REGPARAM2 ram24_wget(uaecptr) REGPARAM;\nstatic uae_u32 REGPARAM2 ram24_bget(uaecptr) REGPARAM;\nstatic void REGPARAM2 ram24_lput(uaecptr, uae_u32) REGPARAM;\nstatic void REGPARAM2 ram24_wput(uaecptr, uae_u32) REGPARAM;\nstatic void REGPARAM2 ram24_bput(uaecptr, uae_u32) REGPARAM;\nstatic uae_u8 *REGPARAM2 ram24_xlate(uaecptr addr) REGPARAM;\n\nuae_u32 REGPARAM2 ram24_lget(uaecptr addr)\n{\n    uae_u32 *m;\n    m = (uae_u32 *)(RAMBaseDiff + (addr & 0xffffff));\n    return do_get_mem_long(m);\n}\n\nuae_u32 REGPARAM2 ram24_wget(uaecptr addr)\n{\n    uae_u16 *m;\n    m = (uae_u16 *)(RAMBaseDiff + (addr & 0xffffff));\n    return do_get_mem_word(m);\n}\n\nuae_u32 REGPARAM2 ram24_bget(uaecptr addr)\n{\n    return (uae_u32)*(uae_u8 *)(RAMBaseDiff + (addr & 0xffffff));\n}\n\nvoid REGPARAM2 ram24_lput(uaecptr addr, uae_u32 l)\n{\n    uae_u32 *m;\n    m = (uae_u32 *)(RAMBaseDiff + (addr & 0xffffff));\n    do_put_mem_long(m, l);\n}\n\nvoid REGPARAM2 ram24_wput(uaecptr addr, uae_u32 w)\n{\n    uae_u16 *m;\n    m = (uae_u16 *)(RAMBaseDiff + (addr & 0xffffff));\n    do_put_mem_word(m, w);\n}\n\nvoid REGPARAM2 ram24_bput(uaecptr addr, uae_u32 b)\n{\n\t*(uae_u8 *)(RAMBaseDiff + (addr & 0xffffff)) = b;\n}\n\nuae_u8 *REGPARAM2 ram24_xlate(uaecptr addr)\n{\n    return (uae_u8 *)(RAMBaseDiff + (addr & 0xffffff));\n}\n\n/* Mac ROM (32 bit addressing) */\n\nstatic uae_u32 REGPARAM2 rom_lget(uaecptr) REGPARAM;\nstatic uae_u32 REGPARAM2 rom_wget(uaecptr) REGPARAM;\nstatic uae_u32 REGPARAM2 rom_bget(uaecptr) REGPARAM;\nstatic void REGPARAM2 rom_lput(uaecptr, uae_u32) REGPARAM;\nstatic void REGPARAM2 rom_wput(uaecptr, uae_u32) REGPARAM;\nstatic void REGPARAM2 rom_bput(uaecptr, uae_u32) REGPARAM;\nstatic uae_u8 *REGPARAM2 rom_xlate(uaecptr addr) REGPARAM;\n\nstatic uintptr ROMBaseDiff;\t// ROMBaseHost - ROMBaseMac\n\nuae_u32 REGPARAM2 rom_lget(uaecptr addr)\n{\n    uae_u32 *m;\n    m = (uae_u32 *)(ROMBaseDiff + addr);\n    return do_get_mem_long(m);\n}\n\nuae_u32 REGPARAM2 rom_wget(uaecptr addr)\n{\n    uae_u16 *m;\n    m = (uae_u16 *)(ROMBaseDiff + addr);\n    return do_get_mem_word(m);\n}\n\nuae_u32 REGPARAM2 rom_bget(uaecptr addr)\n{\n    return (uae_u32)*(uae_u8 *)(ROMBaseDiff + addr);\n}\n\nvoid REGPARAM2 rom_lput(uaecptr addr, uae_u32 b)\n{\n    if (illegal_mem)\n\twrite_log (\"Illegal ROM lput at %08lx\\n\", addr);\n}\n\nvoid REGPARAM2 rom_wput(uaecptr addr, uae_u32 b)\n{\n    if (illegal_mem)\n\twrite_log (\"Illegal ROM wput at %08lx\\n\", addr);\n}\n\nvoid REGPARAM2 rom_bput(uaecptr addr, uae_u32 b)\n{\n    if (illegal_mem)\n\twrite_log (\"Illegal ROM bput at %08lx\\n\", addr);\n}\n\nuae_u8 *REGPARAM2 rom_xlate(uaecptr addr)\n{\n    return (uae_u8 *)(ROMBaseDiff + addr);\n}\n\n/* Mac ROM (24 bit addressing) */\n\nstatic uae_u32 REGPARAM2 rom24_lget(uaecptr) REGPARAM;\nstatic uae_u32 REGPARAM2 rom24_wget(uaecptr) REGPARAM;\nstatic uae_u32 REGPARAM2 rom24_bget(uaecptr) REGPARAM;\nstatic uae_u8 *REGPARAM2 rom24_xlate(uaecptr addr) REGPARAM;\n\nuae_u32 REGPARAM2 rom24_lget(uaecptr addr)\n{\n    uae_u32 *m;\n    m = (uae_u32 *)(ROMBaseDiff + (addr & 0xffffff));\n    return do_get_mem_long(m);\n}\n\nuae_u32 REGPARAM2 rom24_wget(uaecptr addr)\n{\n    uae_u16 *m;\n    m = (uae_u16 *)(ROMBaseDiff + (addr & 0xffffff));\n    return do_get_mem_word(m);\n}\n\nuae_u32 REGPARAM2 rom24_bget(uaecptr addr)\n{\n    return (uae_u32)*(uae_u8 *)(ROMBaseDiff + (addr & 0xffffff));\n}\n\nuae_u8 *REGPARAM2 rom24_xlate(uaecptr addr)\n{\n    return (uae_u8 *)(ROMBaseDiff + (addr & 0xffffff));\n}\n\n/* Frame buffer */\n\nstatic uae_u32 REGPARAM2 frame_direct_lget(uaecptr) REGPARAM;\nstatic uae_u32 REGPARAM2 frame_direct_wget(uaecptr) REGPARAM;\nstatic uae_u32 REGPARAM2 frame_direct_bget(uaecptr) REGPARAM;\nstatic void REGPARAM2 frame_direct_lput(uaecptr, uae_u32) REGPARAM;\nstatic void REGPARAM2 frame_direct_wput(uaecptr, uae_u32) REGPARAM;\nstatic void REGPARAM2 frame_direct_bput(uaecptr, uae_u32) REGPARAM;\n\nstatic uae_u32 REGPARAM2 frame_host_555_lget(uaecptr) REGPARAM;\nstatic uae_u32 REGPARAM2 frame_host_555_wget(uaecptr) REGPARAM;\nstatic void REGPARAM2 frame_host_555_lput(uaecptr, uae_u32) REGPARAM;\nstatic void REGPARAM2 frame_host_555_wput(uaecptr, uae_u32) REGPARAM;\n\nstatic uae_u32 REGPARAM2 frame_host_565_lget(uaecptr) REGPARAM;\nstatic uae_u32 REGPARAM2 frame_host_565_wget(uaecptr) REGPARAM;\nstatic void REGPARAM2 frame_host_565_lput(uaecptr, uae_u32) REGPARAM;\nstatic void REGPARAM2 frame_host_565_wput(uaecptr, uae_u32) REGPARAM;\n\nstatic uae_u32 REGPARAM2 frame_host_888_lget(uaecptr) REGPARAM;\nstatic void REGPARAM2 frame_host_888_lput(uaecptr, uae_u32) REGPARAM;\n\nstatic uae_u8 *REGPARAM2 frame_xlate(uaecptr addr) REGPARAM;\n\nstatic uintptr FrameBaseDiff;\t// MacFrameBaseHost - MacFrameBaseMac\n\nuae_u32 REGPARAM2 frame_direct_lget(uaecptr addr)\n{\n    uae_u32 *m;\n    m = (uae_u32 *)(FrameBaseDiff + addr);\n    return do_get_mem_long(m);\n}\n\nuae_u32 REGPARAM2 frame_direct_wget(uaecptr addr)\n{\n    uae_u16 *m;\n    m = (uae_u16 *)(FrameBaseDiff + addr);\n    return do_get_mem_word(m);\n}\n\nuae_u32 REGPARAM2 frame_direct_bget(uaecptr addr)\n{\n    return (uae_u32)*(uae_u8 *)(FrameBaseDiff + addr);\n}\n\nvoid REGPARAM2 frame_direct_lput(uaecptr addr, uae_u32 l)\n{\n    uae_u32 *m;\n    m = (uae_u32 *)(FrameBaseDiff + addr);\n    do_put_mem_long(m, l);\n}\n\nvoid REGPARAM2 frame_direct_wput(uaecptr addr, uae_u32 w)\n{\n    uae_u16 *m;\n    m = (uae_u16 *)(FrameBaseDiff + addr);\n    do_put_mem_word(m, w);\n}\n\nvoid REGPARAM2 frame_direct_bput(uaecptr addr, uae_u32 b)\n{\n    *(uae_u8 *)(FrameBaseDiff + addr) = b;\n}\n\nuae_u32 REGPARAM2 frame_host_555_lget(uaecptr addr)\n{\n    uae_u32 *m, l;\n    m = (uae_u32 *)(FrameBaseDiff + addr);\n    l = *m;\n\treturn swap_words(l);\n}\n\nuae_u32 REGPARAM2 frame_host_555_wget(uaecptr addr)\n{\n    uae_u16 *m;\n    m = (uae_u16 *)(FrameBaseDiff + addr);\n    return *m;\n}\n\nvoid REGPARAM2 frame_host_555_lput(uaecptr addr, uae_u32 l)\n{\n    uae_u32 *m;\n    m = (uae_u32 *)(FrameBaseDiff + addr);\n    *m = swap_words(l);\n}\n\nvoid REGPARAM2 frame_host_555_wput(uaecptr addr, uae_u32 w)\n{\n    uae_u16 *m;\n    m = (uae_u16 *)(FrameBaseDiff + addr);\n    *m = w;\n}\n\nuae_u32 REGPARAM2 frame_host_565_lget(uaecptr addr)\n{\n    uae_u32 *m, l;\n    m = (uae_u32 *)(FrameBaseDiff + addr);\n    l = *m;\n    l = (l & 0x001f001f) | ((l >> 1) & 0x7fe07fe0);\n    return swap_words(l);\n}\n\nuae_u32 REGPARAM2 frame_host_565_wget(uaecptr addr)\n{\n    uae_u16 *m, w;\n    m = (uae_u16 *)(FrameBaseDiff + addr);\n    w = *m;\n    return (w & 0x1f) | ((w >> 1) & 0x7fe0);\n}\n\nvoid REGPARAM2 frame_host_565_lput(uaecptr addr, uae_u32 l)\n{\n    uae_u32 *m;\n    m = (uae_u32 *)(FrameBaseDiff + addr);\n    l = (l & 0x001f001f) | ((l << 1) & 0xffc0ffc0);\n    *m = swap_words(l);\n}\n\nvoid REGPARAM2 frame_host_565_wput(uaecptr addr, uae_u32 w)\n{\n    uae_u16 *m;\n    m = (uae_u16 *)(FrameBaseDiff + addr);\n    *m = (w & 0x1f) | ((w << 1) & 0xffc0);\n}\n\nuae_u32 REGPARAM2 frame_host_888_lget(uaecptr addr)\n{\n    uae_u32 *m, l;\n    m = (uae_u32 *)(FrameBaseDiff + addr);\n    return *m;\n}\n\nvoid REGPARAM2 frame_host_888_lput(uaecptr addr, uae_u32 l)\n{\n    uae_u32 *m;\n    m = (uae_u32 *)(MacFrameBaseHost + addr - MacFrameBaseMac);\n    *m = l;\n}\n\nuae_u8 *REGPARAM2 frame_xlate(uaecptr addr)\n{\n    return (uae_u8 *)(FrameBaseDiff + addr);\n}\n\n/* Default memory access functions */\n\nuae_u8 *REGPARAM2 default_xlate (uaecptr a)\n{\n    write_log(\"Your Mac program just did something terribly stupid\\n\");\n    return NULL;\n}\n\n/* Address banks */\n\naddrbank dummy_bank = {\n    dummy_lget, dummy_wget, dummy_bget,\n    dummy_lput, dummy_wput, dummy_bput,\n    default_xlate\n};\n\naddrbank ram_bank = {\n    ram_lget, ram_wget, ram_bget,\n    ram_lput, ram_wput, ram_bput,\n    ram_xlate\n};\n\naddrbank ram24_bank = {\n    ram24_lget, ram24_wget, ram24_bget,\n    ram24_lput, ram24_wput, ram24_bput,\n    ram24_xlate\n};\n\naddrbank rom_bank = {\n    rom_lget, rom_wget, rom_bget,\n    rom_lput, rom_wput, rom_bput,\n    rom_xlate\n};\n\naddrbank rom24_bank = {\n    rom24_lget, rom24_wget, rom24_bget,\n    rom_lput, rom_wput, rom_bput,\n    rom24_xlate\n};\n\naddrbank frame_direct_bank = {\n    frame_direct_lget, frame_direct_wget, frame_direct_bget,\n    frame_direct_lput, frame_direct_wput, frame_direct_bput,\n    frame_xlate\n};\n\naddrbank frame_host_555_bank = {\n    frame_host_555_lget, frame_host_555_wget, frame_direct_bget,\n    frame_host_555_lput, frame_host_555_wput, frame_direct_bput,\n    frame_xlate\n};\n\naddrbank frame_host_565_bank = {\n    frame_host_565_lget, frame_host_565_wget, frame_direct_bget,\n    frame_host_565_lput, frame_host_565_wput, frame_direct_bput,\n    frame_xlate\n};\n\naddrbank frame_host_888_bank = {\n    frame_host_888_lget, frame_direct_wget, frame_direct_bget,\n    frame_host_888_lput, frame_direct_wput, frame_direct_bput,\n    frame_xlate\n};\n\nvoid memory_init(void)\n{\n\tfor(long i=0; i<65536; i++)\n\t\tput_mem_bank(i<<16, &dummy_bank);\n\n\t// Limit RAM size to not overlap ROM\n\tuint32 ram_size = RAMSize > ROMBaseMac ? ROMBaseMac : RAMSize;\n\n\tRAMBaseDiff = (uintptr_t)RAMBaseHost - (uintptr_t)RAMBaseMac;\n\tROMBaseDiff = (uintptr_t)ROMBaseHost - (uintptr_t)ROMBaseMac;\n\tFrameBaseDiff = (uintptr_t)MacFrameBaseHost - (uintptr_t)MacFrameBaseMac;\n\n\t// Map RAM and ROM\n\tif (TwentyFourBitAddressing) {\n\t\tmap_banks(&ram24_bank, RAMBaseMac >> 16, ram_size >> 16);\n\t\tmap_banks(&rom24_bank, ROMBaseMac >> 16, ROMSize >> 16);\n\t} else {\n\t\tmap_banks(&ram_bank, RAMBaseMac >> 16, ram_size >> 16);\n\t\tmap_banks(&rom_bank, ROMBaseMac >> 16, ROMSize >> 16);\n\t}\n\n\t// Map frame buffer\n\tswitch (MacFrameLayout) {\n\t\tcase FLAYOUT_DIRECT:\n\t\t\tmap_banks(&frame_direct_bank, MacFrameBaseMac >> 16, (MacFrameSize >> 16) + 1);\n\t\t\tbreak;\n\t\tcase FLAYOUT_HOST_555:\n\t\t\tmap_banks(&frame_host_555_bank, MacFrameBaseMac >> 16, (MacFrameSize >> 16) + 1);\n\t\t\tbreak;\n\t\tcase FLAYOUT_HOST_565:\n\t\t\tmap_banks(&frame_host_565_bank, MacFrameBaseMac >> 16, (MacFrameSize >> 16) + 1);\n\t\t\tbreak;\n\t\tcase FLAYOUT_HOST_888:\n\t\t\tmap_banks(&frame_host_888_bank, MacFrameBaseMac >> 16, (MacFrameSize >> 16) + 1);\n\t\t\tbreak;\n\t}\n}\n\nvoid map_banks(addrbank *bank, int start, int size)\n{\n    int bnr;\n    unsigned long int hioffs = 0, endhioffs = 0x100;\n\n    if (start >= 0x100) {\n\tfor (bnr = start; bnr < start + size; bnr++)\n\t    put_mem_bank (bnr << 16, bank);\n\treturn;\n    }\n    if (TwentyFourBitAddressing) endhioffs = 0x10000;\n    for (hioffs = 0; hioffs < endhioffs; hioffs += 0x100)\n\tfor (bnr = start; bnr < start+size; bnr++)\n\t    put_mem_bank((bnr + hioffs) << 16, bank);\n}\n\n#endif /* !REAL_ADDRESSING && !DIRECT_ADDRESSING */\n\n","/*\n * UAE - The Un*x Amiga Emulator\n *\n * MC68000 emulation\n *\n * (c) 1995 Bernd Schmidt\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"sysdeps.h\"\n\n#include \"cpu_emulation.h\"\n#include \"main.h\"\n#include \"emul_op.h\"\n\nextern int intlev(void);\t// From baisilisk_glue.cpp\n\n#include \"m68k.h\"\n#include \"memory.h\"\n#include \"readcpu.h\"\n#include \"newcpu.h\"\n#include \"compiler/compemu.h\"\n#include \"fpu/fpu.h\"\n\n#if defined(ENABLE_EXCLUSIVE_SPCFLAGS) && !defined(HAVE_HARDWARE_LOCKS)\nB2_mutex *spcflags_lock = NULL;\n#endif\n\n#if ENABLE_MON\n#include \"mon.h\"\n#include \"mon_disass.h\"\n#endif\n\nbool quit_program = false;\nstruct flag_struct regflags;\n\n/* Opcode of faulting instruction */\nuae_u16 last_op_for_exception_3;\n/* PC at fault time */\nuaecptr last_addr_for_exception_3;\n/* Address that generated the exception */\nuaecptr last_fault_for_exception_3;\n\nint areg_byteinc[] = { 1,1,1,1,1,1,1,2 };\nint imm8_table[] = { 8,1,2,3,4,5,6,7 };\n\nint movem_index1[256];\nint movem_index2[256];\nint movem_next[256];\n\ncpuop_func *cpufunctbl[65536];\n\n#if FLIGHT_RECORDER\nstruct rec_step {\n\tuae_u32 pc;\n#if FLIGHT_RECORDER >= 2\n\tuae_u32 d[8];\n\tuae_u32 a[8];\n#endif\n};\n\nconst int LOG_SIZE = 32768;\nstatic rec_step log[LOG_SIZE];\nstatic int log_ptr = -1; // First time initialization\n\nstatic const char *log_filename(void)\n{\n\tconst char *name = getenv(\"M68K_LOG_FILE\");\n\treturn name ? name : \"log.68k\";\n}\n\nvoid m68k_record_step(uaecptr pc)\n{\n#if FLIGHT_RECORDER >= 2\n\t/* XXX: if LSB is set, we are recording from generated code and we\n\t   don't support registers recording yet.  */\n\tif ((pc & 1) == 0) {\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tlog[log_ptr].d[i] = m68k_dreg(regs, i);\n\t\t\tlog[log_ptr].a[i] = m68k_areg(regs, i);\n\t\t}\n\t}\n#endif\n\tlog[log_ptr].pc = pc;\n\tlog_ptr = (log_ptr + 1) % LOG_SIZE;\n}\n\nstatic void dump_log(void)\n{\n\tFILE *f = fopen(log_filename(), \"w\");\n\tif (f == NULL)\n\t\treturn;\n\tfor (int i = 0; i < LOG_SIZE; i++) {\n\t\tint j = (i + log_ptr) % LOG_SIZE;\n\t\tuae_u32 pc = log[j].pc & ~1;\n\t\tfprintf(f, \"pc %08x\", pc);\n#if FLIGHT_RECORDER >= 2\n\t\tfprintf(f, \"\\n\");\n\t\tif ((log[j].pc & 1) == 0) {\n\t\t\tfprintf(f, \"d0 %08x d1 %08x d2 %08x d3 %08x\\n\", log[j].d[0], log[j].d[1], log[j].d[2], log[j].d[3]);\n\t\t\tfprintf(f, \"d4 %08x d5 %08x d6 %08x d7 %08x\\n\", log[j].d[4], log[j].d[5], log[j].d[6], log[j].d[7]);\n\t\t\tfprintf(f, \"a0 %08x a1 %08x a2 %08x a3 %08x\\n\", log[j].a[0], log[j].a[1], log[j].a[2], log[j].a[3]);\n\t\t\tfprintf(f, \"a4 %08x a5 %08x a6 %08x a7 %08x\\n\", log[j].a[4], log[j].a[5], log[j].a[6], log[j].a[7]);\n\t\t}\n#else\n\t\tfprintf(f, \" | \");\n#endif\n#if ENABLE_MON\n\t\tdisass_68k(f, pc);\n#endif\n\t}\n\tfclose(f);\n}\n#endif\n\n#if ENABLE_MON\nstatic void dump_regs(void)\n{\n\tm68k_dumpstate(NULL);\n}\n#endif\n\n#define COUNT_INSTRS 0\n\n#if COUNT_INSTRS\nstatic unsigned long int instrcount[65536];\nstatic uae_u16 opcodenums[65536];\n\nstatic int compfn (const void *el1, const void *el2)\n{\n    return instrcount[*(const uae_u16 *)el1] < instrcount[*(const uae_u16 *)el2];\n}\n\nstatic char *icountfilename (void)\n{\n    char *name = getenv (\"INSNCOUNT\");\n    if (name)\n\treturn name;\n    return COUNT_INSTRS == 2 ? \"frequent.68k\" : \"insncount\";\n}\n\nvoid dump_counts (void)\n{\n    FILE *f = fopen (icountfilename (), \"w\");\n    unsigned long int total;\n    int i;\n\n    write_log (\"Writing instruction count file...\\n\");\n    for (i = 0; i < 65536; i++) {\n\topcodenums[i] = i;\n\ttotal += instrcount[i];\n    }\n    qsort (opcodenums, 65536, sizeof(uae_u16), compfn);\n\n    fprintf (f, \"Total: %lu\\n\", total);\n    for (i=0; i < 65536; i++) {\n\tunsigned long int cnt = instrcount[opcodenums[i]];\n\tstruct instr *dp;\n\tstruct mnemolookup *lookup;\n\tif (!cnt)\n\t    break;\n\tdp = table68k + opcodenums[i];\n\tfor (lookup = lookuptab;lookup->mnemo != dp->mnemo; lookup++)\n\t    ;\n\tfprintf (f, \"%04x: %lu %s\\n\", opcodenums[i], cnt, lookup->name);\n    }\n    fclose (f);\n}\n#else\nvoid dump_counts (void)\n{\n}\n#endif\n\nint broken_in;\n\nstatic __inline__ unsigned int cft_map (unsigned int f)\n{\n#ifndef HAVE_GET_WORD_UNSWAPPED\n    return f;\n#else\n    return ((f >> 8) & 255) | ((f & 255) << 8);\n#endif\n}\n\nvoid REGPARAM2 op_illg_1 (uae_u32 opcode) REGPARAM;\n\nvoid REGPARAM2 op_illg_1 (uae_u32 opcode)\n{\n    op_illg (cft_map (opcode));\n}\n\nstatic void build_cpufunctbl (void)\n{\n    int i;\n    unsigned long opcode;\n\tint cpu_level = 0;\t\t// 68000 (default)\n\tif (CPUType == 4)\n\t\tcpu_level = 4;\t\t// 68040 with FPU\n\telse {\n\t\tif (FPUType)\n\t\t\tcpu_level = 3;\t// 68020 with FPU\n\t\telse if (CPUType >= 2)\n\t\t\tcpu_level = 2;\t// 68020\n\t\telse if (CPUType == 1)\n\t\t\tcpu_level = 1;\n\t}\n    struct cputbl *tbl = (\n\t\t  cpu_level == 4 ? op_smalltbl_0_ff\n\t\t: cpu_level == 3 ? op_smalltbl_1_ff\n\t\t: cpu_level == 2 ? op_smalltbl_2_ff\n\t\t: cpu_level == 1 ? op_smalltbl_3_ff\n\t\t: op_smalltbl_4_ff);\n\n    for (opcode = 0; opcode < 65536; opcode++)\n\tcpufunctbl[cft_map (opcode)] = op_illg_1;\n    for (i = 0; tbl[i].handler != NULL; i++) {\n\tif (! tbl[i].specific)\n\t    cpufunctbl[cft_map (tbl[i].opcode)] = tbl[i].handler;\n    }\n    for (opcode = 0; opcode < 65536; opcode++) {\n\tcpuop_func *f;\n\n\tif (table68k[opcode].mnemo == i_ILLG || table68k[opcode].clev > cpu_level)\n\t    continue;\n\n\tif (table68k[opcode].handler != -1) {\n\t    f = cpufunctbl[cft_map (table68k[opcode].handler)];\n\t    if (f == op_illg_1)\n\t\tabort();\n\t    cpufunctbl[cft_map (opcode)] = f;\n\t}\n    }\n    for (i = 0; tbl[i].handler != NULL; i++) {\n\tif (tbl[i].specific)\n\t    cpufunctbl[cft_map (tbl[i].opcode)] = tbl[i].handler;\n    }\n}\n\nvoid init_m68k (void)\n{\n    int i;\n\n    for (i = 0 ; i < 256 ; i++) {\n\tint j;\n\tfor (j = 0 ; j < 8 ; j++) {\n\t\tif (i & (1 << j)) break;\n\t}\n\tmovem_index1[i] = j;\n\tmovem_index2[i] = 7-j;\n\tmovem_next[i] = i & (~(1 << j));\n    }\n#if COUNT_INSTRS\n    {\n\tFILE *f = fopen (icountfilename (), \"r\");\n\tmemset (instrcount, 0, sizeof instrcount);\n\tif (f) {\n\t    uae_u32 opcode, count, total;\n\t    char name[20];\n\t    write_log (\"Reading instruction count file...\\n\");\n\t    fscanf (f, \"Total: %lu\\n\", &total);\n\t    while (fscanf (f, \"%lx: %lu %s\\n\", &opcode, &count, name) == 3) {\n\t\tinstrcount[opcode] = count;\n\t    }\n\t    fclose(f);\n\t}\n    }\n#endif\n    read_table68k ();\n    do_merges ();\n\n    build_cpufunctbl ();\n\t\n#if defined(ENABLE_EXCLUSIVE_SPCFLAGS) && !defined(HAVE_HARDWARE_LOCKS)\n\tspcflags_lock = B2_create_mutex();\n#endif\n    fpu_init(CPUType == 4);\n}\n\nvoid exit_m68k (void)\n{\n\tfpu_exit ();\n#if defined(ENABLE_EXCLUSIVE_SPCFLAGS) && !defined(HAVE_HARDWARE_LOCKS)\n\tB2_delete_mutex(spcflags_lock);\n#endif\n}\n\nstruct regstruct regs, lastint_regs;\nstatic struct regstruct regs_backup[16];\nstatic int backup_pointer = 0;\nstatic long int m68kpc_offset;\nint lastint_no;\n\n#if REAL_ADDRESSING || DIRECT_ADDRESSING\n#define get_ibyte_1(o) get_byte(get_virtual_address(regs.pc_p) + (o) + 1)\n#define get_iword_1(o) get_word(get_virtual_address(regs.pc_p) + (o))\n#define get_ilong_1(o) get_long(get_virtual_address(regs.pc_p) + (o))\n#else\n#define get_ibyte_1(o) get_byte(regs.pc + (regs.pc_p - regs.pc_oldp) + (o) + 1)\n#define get_iword_1(o) get_word(regs.pc + (regs.pc_p - regs.pc_oldp) + (o))\n#define get_ilong_1(o) get_long(regs.pc + (regs.pc_p - regs.pc_oldp) + (o))\n#endif\n\nuae_s32 ShowEA (int reg, amodes mode, wordsizes size, char *buf)\n{\n    uae_u16 dp;\n    uae_s8 disp8;\n    uae_s16 disp16;\n    int r;\n    uae_u32 dispreg;\n    uaecptr addr;\n    uae_s32 offset = 0;\n    char buffer[80];\n\n    switch (mode){\n     case Dreg:\n\tsprintf (buffer,\"D%d\", reg);\n\tbreak;\n     case Areg:\n\tsprintf (buffer,\"A%d\", reg);\n\tbreak;\n     case Aind:\n\tsprintf (buffer,\"(A%d)\", reg);\n\tbreak;\n     case Aipi:\n\tsprintf (buffer,\"(A%d)+\", reg);\n\tbreak;\n     case Apdi:\n\tsprintf (buffer,\"-(A%d)\", reg);\n\tbreak;\n     case Ad16:\n\tdisp16 = get_iword_1 (m68kpc_offset); m68kpc_offset += 2;\n\taddr = m68k_areg(regs,reg) + (uae_s16)disp16;\n\tsprintf (buffer,\"(A%d,$%04x) == $%08lx\", reg, disp16 & 0xffff,\n\t\t\t\t\t(unsigned long)addr);\n\tbreak;\n     case Ad8r:\n\tdp = get_iword_1 (m68kpc_offset); m68kpc_offset += 2;\n\tdisp8 = dp & 0xFF;\n\tr = (dp & 0x7000) >> 12;\n\tdispreg = dp & 0x8000 ? m68k_areg(regs,r) : m68k_dreg(regs,r);\n\tif (!(dp & 0x800)) dispreg = (uae_s32)(uae_s16)(dispreg);\n\tdispreg <<= (dp >> 9) & 3;\n\n\tif (dp & 0x100) {\n\t    uae_s32 outer = 0, disp = 0;\n\t    uae_s32 base = m68k_areg(regs,reg);\n\t    char name[10];\n\t    sprintf (name,\"A%d, \",reg);\n\t    if (dp & 0x80) { base = 0; name[0] = 0; }\n\t    if (dp & 0x40) dispreg = 0;\n\t    if ((dp & 0x30) == 0x20) { disp = (uae_s32)(uae_s16)get_iword_1 (m68kpc_offset); m68kpc_offset += 2; }\n\t    if ((dp & 0x30) == 0x30) { disp = get_ilong_1 (m68kpc_offset); m68kpc_offset += 4; }\n\t    base += disp;\n\n\t    if ((dp & 0x3) == 0x2) { outer = (uae_s32)(uae_s16)get_iword_1 (m68kpc_offset); m68kpc_offset += 2; }\n\t    if ((dp & 0x3) == 0x3) { outer = get_ilong_1 (m68kpc_offset); m68kpc_offset += 4; }\n\n\t    if (!(dp & 4)) base += dispreg;\n\t    if (dp & 3) base = get_long (base);\n\t    if (dp & 4) base += dispreg;\n\n\t    addr = base + outer;\n\t    sprintf (buffer,\"(%s%c%d.%c*%d+%ld)+%ld == $%08lx\", name,\n\t\t    dp & 0x8000 ? 'A' : 'D', (int)r, dp & 0x800 ? 'L' : 'W',\n\t\t    1 << ((dp >> 9) & 3),\n\t\t    disp,outer,\n\t\t    (unsigned long)addr);\n\t} else {\n\t  addr = m68k_areg(regs,reg) + (uae_s32)((uae_s8)disp8) + dispreg;\n\t  sprintf (buffer,\"(A%d, %c%d.%c*%d, $%02x) == $%08lx\", reg,\n\t       dp & 0x8000 ? 'A' : 'D', (int)r, dp & 0x800 ? 'L' : 'W',\n\t       1 << ((dp >> 9) & 3), disp8,\n\t       (unsigned long)addr);\n\t}\n\tbreak;\n     case PC16:\n\taddr = m68k_getpc () + m68kpc_offset;\n\tdisp16 = get_iword_1 (m68kpc_offset); m68kpc_offset += 2;\n\taddr += (uae_s16)disp16;\n\tsprintf (buffer,\"(PC,$%04x) == $%08lx\", disp16 & 0xffff,(unsigned long)addr);\n\tbreak;\n     case PC8r:\n\taddr = m68k_getpc () + m68kpc_offset;\n\tdp = get_iword_1 (m68kpc_offset); m68kpc_offset += 2;\n\tdisp8 = dp & 0xFF;\n\tr = (dp & 0x7000) >> 12;\n\tdispreg = dp & 0x8000 ? m68k_areg(regs,r) : m68k_dreg(regs,r);\n\tif (!(dp & 0x800)) dispreg = (uae_s32)(uae_s16)(dispreg);\n\tdispreg <<= (dp >> 9) & 3;\n\n\tif (dp & 0x100) {\n\t    uae_s32 outer = 0,disp = 0;\n\t    uae_s32 base = addr;\n\t    char name[10];\n\t    sprintf (name,\"PC, \");\n\t    if (dp & 0x80) { base = 0; name[0] = 0; }\n\t    if (dp & 0x40) dispreg = 0;\n\t    if ((dp & 0x30) == 0x20) { disp = (uae_s32)(uae_s16)get_iword_1 (m68kpc_offset); m68kpc_offset += 2; }\n\t    if ((dp & 0x30) == 0x30) { disp = get_ilong_1 (m68kpc_offset); m68kpc_offset += 4; }\n\t    base += disp;\n\n\t    if ((dp & 0x3) == 0x2) { outer = (uae_s32)(uae_s16)get_iword_1 (m68kpc_offset); m68kpc_offset += 2; }\n\t    if ((dp & 0x3) == 0x3) { outer = get_ilong_1 (m68kpc_offset); m68kpc_offset += 4; }\n\n\t    if (!(dp & 4)) base += dispreg;\n\t    if (dp & 3) base = get_long (base);\n\t    if (dp & 4) base += dispreg;\n\n\t    addr = base + outer;\n\t    sprintf (buffer,\"(%s%c%d.%c*%d+%ld)+%ld == $%08lx\", name,\n\t\t    dp & 0x8000 ? 'A' : 'D', (int)r, dp & 0x800 ? 'L' : 'W',\n\t\t    1 << ((dp >> 9) & 3),\n\t\t    disp,outer,\n\t\t    (unsigned long)addr);\n\t} else {\n\t  addr += (uae_s32)((uae_s8)disp8) + dispreg;\n\t  sprintf (buffer,\"(PC, %c%d.%c*%d, $%02x) == $%08lx\", dp & 0x8000 ? 'A' : 'D',\n\t\t(int)r, dp & 0x800 ? 'L' : 'W',  1 << ((dp >> 9) & 3),\n\t\tdisp8, (unsigned long)addr);\n\t}\n\tbreak;\n     case absw:\n\tsprintf (buffer,\"$%08lx\", (unsigned long)(uae_s32)(uae_s16)get_iword_1 (m68kpc_offset));\n\tm68kpc_offset += 2;\n\tbreak;\n     case absl:\n\tsprintf (buffer,\"$%08lx\", (unsigned long)get_ilong_1 (m68kpc_offset));\n\tm68kpc_offset += 4;\n\tbreak;\n     case imm:\n\tswitch (size){\n\t case sz_byte:\n\t    sprintf (buffer,\"#$%02x\", (unsigned int)(get_iword_1 (m68kpc_offset) & 0xff));\n\t    m68kpc_offset += 2;\n\t    break;\n\t case sz_word:\n\t    sprintf (buffer,\"#$%04x\", (unsigned int)(get_iword_1 (m68kpc_offset) & 0xffff));\n\t    m68kpc_offset += 2;\n\t    break;\n\t case sz_long:\n\t    sprintf (buffer,\"#$%08lx\", (unsigned long)(get_ilong_1 (m68kpc_offset)));\n\t    m68kpc_offset += 4;\n\t    break;\n\t default:\n\t    break;\n\t}\n\tbreak;\n     case imm0:\n\toffset = (uae_s32)(uae_s8)get_iword_1 (m68kpc_offset);\n\tm68kpc_offset += 2;\n\tsprintf (buffer,\"#$%02x\", (unsigned int)(offset & 0xff));\n\tbreak;\n     case imm1:\n\toffset = (uae_s32)(uae_s16)get_iword_1 (m68kpc_offset);\n\tm68kpc_offset += 2;\n\tsprintf (buffer,\"#$%04x\", (unsigned int)(offset & 0xffff));\n\tbreak;\n     case imm2:\n\toffset = (uae_s32)get_ilong_1 (m68kpc_offset);\n\tm68kpc_offset += 4;\n\tsprintf (buffer,\"#$%08lx\", (unsigned long)offset);\n\tbreak;\n     case immi:\n\toffset = (uae_s32)(uae_s8)(reg & 0xff);\n\tsprintf (buffer,\"#$%08lx\", (unsigned long)offset);\n\tbreak;\n     default:\n\tbreak;\n    }\n    if (buf == 0)\n\tprintf (\"%s\", buffer);\n    else\n\tstrcat (buf, buffer);\n    return offset;\n}\n\n/* The plan is that this will take over the job of exception 3 handling -\n * the CPU emulation functions will just do a longjmp to m68k_go whenever\n * they hit an odd address. */\nstatic int verify_ea (int reg, amodes mode, wordsizes size, uae_u32 *val)\n{\n    uae_u16 dp;\n    uae_s8 disp8;\n    uae_s16 disp16;\n    int r;\n    uae_u32 dispreg;\n    uaecptr addr;\n    uae_s32 offset = 0;\n\n    switch (mode){\n     case Dreg:\n\t*val = m68k_dreg (regs, reg);\n\treturn 1;\n     case Areg:\n\t*val = m68k_areg (regs, reg);\n\treturn 1;\n\n     case Aind:\n     case Aipi:\n\taddr = m68k_areg (regs, reg);\n\tbreak;\n     case Apdi:\n\taddr = m68k_areg (regs, reg);\n\tbreak;\n     case Ad16:\n\tdisp16 = get_iword_1 (m68kpc_offset); m68kpc_offset += 2;\n\taddr = m68k_areg(regs,reg) + (uae_s16)disp16;\n\tbreak;\n     case Ad8r:\n\taddr = m68k_areg (regs, reg);\n     d8r_common:\n\tdp = get_iword_1 (m68kpc_offset); m68kpc_offset += 2;\n\tdisp8 = dp & 0xFF;\n\tr = (dp & 0x7000) >> 12;\n\tdispreg = dp & 0x8000 ? m68k_areg(regs,r) : m68k_dreg(regs,r);\n\tif (!(dp & 0x800)) dispreg = (uae_s32)(uae_s16)(dispreg);\n\tdispreg <<= (dp >> 9) & 3;\n\n\tif (dp & 0x100) {\n\t    uae_s32 outer = 0, disp = 0;\n\t    uae_s32 base = addr;\n\t    if (dp & 0x80) base = 0;\n\t    if (dp & 0x40) dispreg = 0;\n\t    if ((dp & 0x30) == 0x20) { disp = (uae_s32)(uae_s16)get_iword_1 (m68kpc_offset); m68kpc_offset += 2; }\n\t    if ((dp & 0x30) == 0x30) { disp = get_ilong_1 (m68kpc_offset); m68kpc_offset += 4; }\n\t    base += disp;\n\n\t    if ((dp & 0x3) == 0x2) { outer = (uae_s32)(uae_s16)get_iword_1 (m68kpc_offset); m68kpc_offset += 2; }\n\t    if ((dp & 0x3) == 0x3) { outer = get_ilong_1 (m68kpc_offset); m68kpc_offset += 4; }\n\n\t    if (!(dp & 4)) base += dispreg;\n\t    if (dp & 3) base = get_long (base);\n\t    if (dp & 4) base += dispreg;\n\n\t    addr = base + outer;\n\t} else {\n\t  addr += (uae_s32)((uae_s8)disp8) + dispreg;\n\t}\n\tbreak;\n     case PC16:\n\taddr = m68k_getpc () + m68kpc_offset;\n\tdisp16 = get_iword_1 (m68kpc_offset); m68kpc_offset += 2;\n\taddr += (uae_s16)disp16;\n\tbreak;\n     case PC8r:\n\taddr = m68k_getpc () + m68kpc_offset;\n\tgoto d8r_common;\n     case absw:\n\taddr = (uae_s32)(uae_s16)get_iword_1 (m68kpc_offset);\n\tm68kpc_offset += 2;\n\tbreak;\n     case absl:\n\taddr = get_ilong_1 (m68kpc_offset);\n\tm68kpc_offset += 4;\n\tbreak;\n     case imm:\n\tswitch (size){\n\t case sz_byte:\n\t    *val = get_iword_1 (m68kpc_offset) & 0xff;\n\t    m68kpc_offset += 2;\n\t    break;\n\t case sz_word:\n\t    *val = get_iword_1 (m68kpc_offset) & 0xffff;\n\t    m68kpc_offset += 2;\n\t    break;\n\t case sz_long:\n\t    *val = get_ilong_1 (m68kpc_offset);\n\t    m68kpc_offset += 4;\n\t    break;\n\t default:\n\t    break;\n\t}\n\treturn 1;\n     case imm0:\n\t*val = (uae_s32)(uae_s8)get_iword_1 (m68kpc_offset);\n\tm68kpc_offset += 2;\n\treturn 1;\n     case imm1:\n\t*val = (uae_s32)(uae_s16)get_iword_1 (m68kpc_offset);\n\tm68kpc_offset += 2;\n\treturn 1;\n     case imm2:\n\t*val = get_ilong_1 (m68kpc_offset);\n\tm68kpc_offset += 4;\n\treturn 1;\n     case immi:\n\t*val = (uae_s32)(uae_s8)(reg & 0xff);\n\treturn 1;\n     default:\n\taddr = 0;\n\tbreak;\n    }\n    if ((addr & 1) == 0)\n\treturn 1;\n\n    last_addr_for_exception_3 = m68k_getpc () + m68kpc_offset;\n    last_fault_for_exception_3 = addr;\n    return 0;\n}\n\nuae_u32 get_disp_ea_020 (uae_u32 base, uae_u32 dp)\n{\n    int reg = (dp >> 12) & 15;\n    uae_s32 regd = regs.regs[reg];\n    if ((dp & 0x800) == 0)\n\tregd = (uae_s32)(uae_s16)regd;\n    regd <<= (dp >> 9) & 3;\n    if (dp & 0x100) {\n\tuae_s32 outer = 0;\n\tif (dp & 0x80) base = 0;\n\tif (dp & 0x40) regd = 0;\n\n\tif ((dp & 0x30) == 0x20) base += (uae_s32)(uae_s16)next_iword();\n\tif ((dp & 0x30) == 0x30) base += next_ilong();\n\n\tif ((dp & 0x3) == 0x2) outer = (uae_s32)(uae_s16)next_iword();\n\tif ((dp & 0x3) == 0x3) outer = next_ilong();\n\n\tif ((dp & 0x4) == 0) base += regd;\n\tif (dp & 0x3) base = get_long (base);\n\tif (dp & 0x4) base += regd;\n\n\treturn base + outer;\n    } else {\n\treturn base + (uae_s32)((uae_s8)dp) + regd;\n    }\n}\n\nuae_u32 get_disp_ea_000 (uae_u32 base, uae_u32 dp)\n{\n    int reg = (dp >> 12) & 15;\n    uae_s32 regd = regs.regs[reg];\n#if 1\n    if ((dp & 0x800) == 0)\n\tregd = (uae_s32)(uae_s16)regd;\n    return base + (uae_s8)dp + regd;\n#else\n    /* Branch-free code... benchmark this again now that\n     * things are no longer inline.  */\n    uae_s32 regd16;\n    uae_u32 mask;\n    mask = ((dp & 0x800) >> 11) - 1;\n    regd16 = (uae_s32)(uae_s16)regd;\n    regd16 &= mask;\n    mask = ~mask;\n    base += (uae_s8)dp;\n    regd &= mask;\n    regd |= regd16;\n    return base + regd;\n#endif\n}\n\nvoid MakeSR (void)\n{\n#if 0\n    assert((regs.t1 & 1) == regs.t1);\n    assert((regs.t0 & 1) == regs.t0);\n    assert((regs.s & 1) == regs.s);\n    assert((regs.m & 1) == regs.m);\n    assert((XFLG & 1) == XFLG);\n    assert((NFLG & 1) == NFLG);\n    assert((ZFLG & 1) == ZFLG);\n    assert((VFLG & 1) == VFLG);\n    assert((CFLG & 1) == CFLG);\n#endif\n    regs.sr = ((regs.t1 << 15) | (regs.t0 << 14)\n\t       | (regs.s << 13) | (regs.m << 12) | (regs.intmask << 8)\n\t       | (GET_XFLG << 4) | (GET_NFLG << 3) | (GET_ZFLG << 2) | (GET_VFLG << 1)\n\t       | GET_CFLG);\n}\n\nvoid MakeFromSR (void)\n{\n    int oldm = regs.m;\n    int olds = regs.s;\n\n    regs.t1 = (regs.sr >> 15) & 1;\n    regs.t0 = (regs.sr >> 14) & 1;\n    regs.s = (regs.sr >> 13) & 1;\n    regs.m = (regs.sr >> 12) & 1;\n    regs.intmask = (regs.sr >> 8) & 7;\n    SET_XFLG ((regs.sr >> 4) & 1);\n    SET_NFLG ((regs.sr >> 3) & 1);\n    SET_ZFLG ((regs.sr >> 2) & 1);\n    SET_VFLG ((regs.sr >> 1) & 1);\n    SET_CFLG (regs.sr & 1);\n    if (CPUType >= 2) {\n\tif (olds != regs.s) {\n\t    if (olds) {\n\t\tif (oldm)\n\t\t    regs.msp = m68k_areg(regs, 7);\n\t\telse\n\t\t    regs.isp = m68k_areg(regs, 7);\n\t\tm68k_areg(regs, 7) = regs.usp;\n\t    } else {\n\t\tregs.usp = m68k_areg(regs, 7);\n\t\tm68k_areg(regs, 7) = regs.m ? regs.msp : regs.isp;\n\t    }\n\t} else if (olds && oldm != regs.m) {\n\t    if (oldm) {\n\t\tregs.msp = m68k_areg(regs, 7);\n\t\tm68k_areg(regs, 7) = regs.isp;\n\t    } else {\n\t\tregs.isp = m68k_areg(regs, 7);\n\t\tm68k_areg(regs, 7) = regs.msp;\n\t    }\n\t}\n    } else {\n\tif (olds != regs.s) {\n\t    if (olds) {\n\t\tregs.isp = m68k_areg(regs, 7);\n\t\tm68k_areg(regs, 7) = regs.usp;\n\t    } else {\n\t\tregs.usp = m68k_areg(regs, 7);\n\t\tm68k_areg(regs, 7) = regs.isp;\n\t    }\n\t}\n    }\n\n    SPCFLAGS_SET( SPCFLAG_INT );\n    if (regs.t1 || regs.t0)\n\t\tSPCFLAGS_SET( SPCFLAG_TRACE );\n    else\n   \t/* Keep SPCFLAG_DOTRACE, we still want a trace exception for\n\t   SR-modifying instructions (including STOP).  */\n\t\tSPCFLAGS_CLEAR( SPCFLAG_TRACE );\n}\n\nvoid Exception(int nr, uaecptr oldpc)\n{\n    uae_u32 currpc = m68k_getpc ();\n    MakeSR();\n    if (!regs.s) {\n\tregs.usp = m68k_areg(regs, 7);\n\tif (CPUType >= 2)\n\t    m68k_areg(regs, 7) = regs.m ? regs.msp : regs.isp;\n\telse\n\t    m68k_areg(regs, 7) = regs.isp;\n\tregs.s = 1;\n    }\n    if (CPUType > 0) {\n\tif (nr == 2 || nr == 3) {\n\t    int i;\n\t    /* @@@ this is probably wrong (?) */\n\t    for (i = 0 ; i < 12 ; i++) {\n\t\tm68k_areg(regs, 7) -= 2;\n\t\tput_word (m68k_areg(regs, 7), 0);\n\t    }\n\t    m68k_areg(regs, 7) -= 2;\n\t    put_word (m68k_areg(regs, 7), 0xa000 + nr * 4);\n\t} else if (nr ==5 || nr == 6 || nr == 7 || nr == 9) {\n\t    m68k_areg(regs, 7) -= 4;\n\t    put_long (m68k_areg(regs, 7), oldpc);\n\t    m68k_areg(regs, 7) -= 2;\n\t    put_word (m68k_areg(regs, 7), 0x2000 + nr * 4);\n\t} else if (regs.m && nr >= 24 && nr < 32) {\n\t    m68k_areg(regs, 7) -= 2;\n\t    put_word (m68k_areg(regs, 7), nr * 4);\n\t    m68k_areg(regs, 7) -= 4;\n\t    put_long (m68k_areg(regs, 7), currpc);\n\t    m68k_areg(regs, 7) -= 2;\n\t    put_word (m68k_areg(regs, 7), regs.sr);\n\t    regs.sr |= (1 << 13);\n\t    regs.msp = m68k_areg(regs, 7);\n\t    m68k_areg(regs, 7) = regs.isp;\n\t    m68k_areg(regs, 7) -= 2;\n\t    put_word (m68k_areg(regs, 7), 0x1000 + nr * 4);\n\t} else {\n\t    m68k_areg(regs, 7) -= 2;\n\t    put_word (m68k_areg(regs, 7), nr * 4);\n\t}\n    } else {\n\tif (nr == 2 || nr == 3) {\n\t    m68k_areg(regs, 7) -= 12;\n\t    /* ??????? */\n\t    if (nr == 3) {\n\t\tput_long (m68k_areg(regs, 7), last_fault_for_exception_3);\n\t\tput_word (m68k_areg(regs, 7)+4, last_op_for_exception_3);\n\t\tput_long (m68k_areg(regs, 7)+8, last_addr_for_exception_3);\n\t    }\n\t    write_log (\"Exception!\\n\");\n\t    goto kludge_me_do;\n\t}\n    }\n    m68k_areg(regs, 7) -= 4;\n    put_long (m68k_areg(regs, 7), currpc);\nkludge_me_do:\n    m68k_areg(regs, 7) -= 2;\n    put_word (m68k_areg(regs, 7), regs.sr);\n    m68k_setpc (get_long (regs.vbr + 4*nr));\n\tSPCFLAGS_SET( SPCFLAG_JIT_END_COMPILE );\n    fill_prefetch_0 ();\n    regs.t1 = regs.t0 = regs.m = 0;\n\tSPCFLAGS_CLEAR( SPCFLAG_TRACE | SPCFLAG_DOTRACE );\n}\n\nstatic void Interrupt(int nr)\n{\n    assert(nr < 8 && nr >= 0);\n    lastint_regs = regs;\n    lastint_no = nr;\n    Exception(nr+24, 0);\n\n    regs.intmask = nr;\n\tSPCFLAGS_SET( SPCFLAG_INT );\n}\n\nstatic int caar, cacr, tc, itt0, itt1, dtt0, dtt1, mmusr, urp, srp;\n\nstatic int movec_illg (int regno)\n{\n\tswitch (CPUType) {\n\tcase 1:\n\t\tif ((regno & 0x7ff) <= 1)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tif ((regno & 0x7ff) <= 2)\n\t\t\treturn 0;\n\t\tif (regno == 3 || regno == 4)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase 4:\n\t\tif ((regno & 0x7ff) <= 7) {\n\t\t\tif (regno != 0x802)\n\t\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 1;\n}\n\nint m68k_move2c (int regno, uae_u32 *regp)\n{\n  if (movec_illg (regno)) {\n\top_illg (0x4E7B);\n\treturn 0;\n  } else {\n\tswitch (regno) {\n\t case 0: regs.sfc = *regp & 7; break;\n\t case 1: regs.dfc = *regp & 7; break;\n\t case 2:\n\t\tcacr = *regp & (CPUType < 4 ? 0x3 : 0x80008000);\n#if USE_JIT\n\t\tif (CPUType < 4) {\n\t\t\tset_cache_state(cacr&1);\n\t\t\tif (*regp & 0x08)\n\t\t\t\tflush_icache(1);\n\t\t}\n\t\telse {\n\t\t\tset_cache_state(cacr&0x8000);\n\t\t}\n#endif\n\t break;\n\t case 3: tc = *regp & 0xc000; break;\n\t case 4: itt0 = *regp & 0xffffe364; break;\n\t case 5: itt1 = *regp & 0xffffe364; break;\n\t case 6: dtt0 = *regp & 0xffffe364; break;\n\t case 7: dtt1 = *regp & 0xffffe364; break;\n\t case 0x800: regs.usp = *regp; break;\n\t case 0x801: regs.vbr = *regp; break;\n\t case 0x802: caar = *regp &0xfc; break;\n\t case 0x803: regs.msp = *regp; if (regs.m == 1) m68k_areg(regs, 7) = regs.msp; break;\n\t case 0x804: regs.isp = *regp; if (regs.m == 0) m68k_areg(regs, 7) = regs.isp; break;\n\tcase 0x805: mmusr = *regp; break;\n\tcase 0x806: urp = *regp; break;\n\tcase 0x807: srp = *regp; break;\n\t default:\n\t    op_illg (0x4E7B);\n\t    return 0;\n\t}\n  }\n  return 1;\n}\n\nint m68k_movec2 (int regno, uae_u32 *regp)\n{\n    if (movec_illg (regno))\n    {\n\top_illg (0x4E7A);\n\treturn 0;\n    } else {\n\tswitch (regno) {\n\t case 0: *regp = regs.sfc; break;\n\t case 1: *regp = regs.dfc; break;\n\t case 2: *regp = cacr; break;\n\t case 3: *regp = tc; break;\n\t case 4: *regp = itt0; break;\n\t case 5: *regp = itt1; break;\n\t case 6: *regp = dtt0; break;\n\t case 7: *regp = dtt1; break;\n\t case 0x800: *regp = regs.usp; break;\n\t case 0x801: *regp = regs.vbr; break;\n\t case 0x802: *regp = caar; break;\n\t case 0x803: *regp = regs.m == 1 ? m68k_areg(regs, 7) : regs.msp; break;\n\t case 0x804: *regp = regs.m == 0 ? m68k_areg(regs, 7) : regs.isp; break;\n\tcase 0x805: *regp = mmusr; break;\n\tcase 0x806: *regp = urp; break;\n\tcase 0x807: *regp = srp; break;\n\t default:\n\t    op_illg (0x4E7A);\n\t    return 0;\n\t}\n\t}\n\treturn 1;\n}\n\nstatic __inline__ int\ndiv_unsigned(uae_u32 src_hi, uae_u32 src_lo, uae_u32 div, uae_u32 *quot, uae_u32 *rem)\n{\n\tuae_u32 q = 0, cbit = 0;\n\tint i;\n\n\tif (div <= src_hi) {\n\t    return 1;\n\t}\n\tfor (i = 0 ; i < 32 ; i++) {\n\t\tcbit = src_hi & 0x80000000ul;\n\t\tsrc_hi <<= 1;\n\t\tif (src_lo & 0x80000000ul) src_hi++;\n\t\tsrc_lo <<= 1;\n\t\tq = q << 1;\n\t\tif (cbit || div <= src_hi) {\n\t\t\tq |= 1;\n\t\t\tsrc_hi -= div;\n\t\t}\n\t}\n\t*quot = q;\n\t*rem = src_hi;\n\treturn 0;\n}\n\nvoid m68k_divl (uae_u32 opcode, uae_u32 src, uae_u16 extra, uaecptr oldpc)\n{\n#if defined(uae_s64)\n    if (src == 0) {\n\tException (5, oldpc);\n\treturn;\n    }\n    if (extra & 0x800) {\n\t/* signed variant */\n\tuae_s64 a = (uae_s64)(uae_s32)m68k_dreg(regs, (extra >> 12) & 7);\n\tuae_s64 quot, rem;\n\n\tif (extra & 0x400) {\n\t    a &= 0xffffffffu;\n\t    a |= (uae_s64)m68k_dreg(regs, extra & 7) << 32;\n\t}\n\trem = a % (uae_s64)(uae_s32)src;\n\tquot = a / (uae_s64)(uae_s32)src;\n\tif ((quot & UVAL64(0xffffffff80000000)) != 0\n\t    && (quot & UVAL64(0xffffffff80000000)) != UVAL64(0xffffffff80000000))\n\t{\n\t    SET_VFLG (1);\n\t    SET_NFLG (1);\n\t    SET_CFLG (0);\n\t} else {\n\t    if (((uae_s32)rem < 0) != ((uae_s64)a < 0)) rem = -rem;\n\t    SET_VFLG (0);\n\t    SET_CFLG (0);\n\t    SET_ZFLG (((uae_s32)quot) == 0);\n\t    SET_NFLG (((uae_s32)quot) < 0);\n\t    m68k_dreg(regs, extra & 7) = rem;\n\t    m68k_dreg(regs, (extra >> 12) & 7) = quot;\n\t}\n    } else {\n\t/* unsigned */\n\tuae_u64 a = (uae_u64)(uae_u32)m68k_dreg(regs, (extra >> 12) & 7);\n\tuae_u64 quot, rem;\n\n\tif (extra & 0x400) {\n\t    a &= 0xffffffffu;\n\t    a |= (uae_u64)m68k_dreg(regs, extra & 7) << 32;\n\t}\n\trem = a % (uae_u64)src;\n\tquot = a / (uae_u64)src;\n\tif (quot > 0xffffffffu) {\n\t    SET_VFLG (1);\n\t    SET_NFLG (1);\n\t    SET_CFLG (0);\n\t} else {\n\t    SET_VFLG (0);\n\t    SET_CFLG (0);\n\t    SET_ZFLG (((uae_s32)quot) == 0);\n\t    SET_NFLG (((uae_s32)quot) < 0);\n\t    m68k_dreg(regs, extra & 7) = rem;\n\t    m68k_dreg(regs, (extra >> 12) & 7) = quot;\n\t}\n    }\n#else\n    if (src == 0) {\n\tException (5, oldpc);\n\treturn;\n    }\n    if (extra & 0x800) {\n\t/* signed variant */\n\tuae_s32 lo = (uae_s32)m68k_dreg(regs, (extra >> 12) & 7);\n\tuae_s32 hi = lo < 0 ? -1 : 0;\n\tuae_s32 save_high;\n\tuae_u32 quot, rem;\n\tuae_u32 sign;\n\n\tif (extra & 0x400) {\n\t    hi = (uae_s32)m68k_dreg(regs, extra & 7);\n\t}\n\tsave_high = hi;\n\tsign = (hi ^ src);\n\tif (hi < 0) {\n\t    hi = ~hi;\n\t    lo = -lo;\n\t    if (lo == 0) hi++;\n\t}\n\tif ((uae_s32)src < 0) src = -src;\n\tif (div_unsigned(hi, lo, src, &quot, &rem) ||\n\t    (sign & 0x80000000) ? quot > 0x80000000 : quot > 0x7fffffff) {\n\t    SET_VFLG (1);\n\t    SET_NFLG (1);\n\t    SET_CFLG (0);\n\t} else {\n\t    if (sign & 0x80000000) quot = -quot;\n\t    if (((uae_s32)rem < 0) != (save_high < 0)) rem = -rem;\n\t    SET_VFLG (0);\n\t    SET_CFLG (0);\n\t    SET_ZFLG (((uae_s32)quot) == 0);\n\t    SET_NFLG (((uae_s32)quot) < 0);\n\t    m68k_dreg(regs, extra & 7) = rem;\n\t    m68k_dreg(regs, (extra >> 12) & 7) = quot;\n\t}\n    } else {\n\t/* unsigned */\n\tuae_u32 lo = (uae_u32)m68k_dreg(regs, (extra >> 12) & 7);\n\tuae_u32 hi = 0;\n\tuae_u32 quot, rem;\n\n\tif (extra & 0x400) {\n\t    hi = (uae_u32)m68k_dreg(regs, extra & 7);\n\t}\n\tif (div_unsigned(hi, lo, src, &quot, &rem)) {\n\t    SET_VFLG (1);\n\t    SET_NFLG (1);\n\t    SET_CFLG (0);\n\t} else {\n\t    SET_VFLG (0);\n\t    SET_CFLG (0);\n\t    SET_ZFLG (((uae_s32)quot) == 0);\n\t    SET_NFLG (((uae_s32)quot) < 0);\n\t    m68k_dreg(regs, extra & 7) = rem;\n\t    m68k_dreg(regs, (extra >> 12) & 7) = quot;\n\t}\n    }\n#endif\n}\n\nstatic __inline__ void\nmul_unsigned(uae_u32 src1, uae_u32 src2, uae_u32 *dst_hi, uae_u32 *dst_lo)\n{\n\tuae_u32 r0 = (src1 & 0xffff) * (src2 & 0xffff);\n\tuae_u32 r1 = ((src1 >> 16) & 0xffff) * (src2 & 0xffff);\n\tuae_u32 r2 = (src1 & 0xffff) * ((src2 >> 16) & 0xffff);\n\tuae_u32 r3 = ((src1 >> 16) & 0xffff) * ((src2 >> 16) & 0xffff);\n\tuae_u32 lo;\n\n\tlo = r0 + ((r1 << 16) & 0xffff0000ul);\n\tif (lo < r0) r3++;\n\tr0 = lo;\n\tlo = r0 + ((r2 << 16) & 0xffff0000ul);\n\tif (lo < r0) r3++;\n\tr3 += ((r1 >> 16) & 0xffff) + ((r2 >> 16) & 0xffff);\n\t*dst_lo = lo;\n\t*dst_hi = r3;\n}\n\nvoid m68k_mull (uae_u32 opcode, uae_u32 src, uae_u16 extra)\n{\n#if defined(uae_s64)\n    if (extra & 0x800) {\n\t/* signed variant */\n\tuae_s64 a = (uae_s64)(uae_s32)m68k_dreg(regs, (extra >> 12) & 7);\n\n\ta *= (uae_s64)(uae_s32)src;\n\tSET_VFLG (0);\n\tSET_CFLG (0);\n\tSET_ZFLG (a == 0);\n\tSET_NFLG (a < 0);\n\tif (extra & 0x400)\n\t    m68k_dreg(regs, extra & 7) = a >> 32;\n\telse if ((a & UVAL64(0xffffffff80000000)) != 0\n\t\t && (a & UVAL64(0xffffffff80000000)) != UVAL64(0xffffffff80000000))\n\t{\n\t    SET_VFLG (1);\n\t}\n\tm68k_dreg(regs, (extra >> 12) & 7) = (uae_u32)a;\n    } else {\n\t/* unsigned */\n\tuae_u64 a = (uae_u64)(uae_u32)m68k_dreg(regs, (extra >> 12) & 7);\n\n\ta *= (uae_u64)src;\n\tSET_VFLG (0);\n\tSET_CFLG (0);\n\tSET_ZFLG (a == 0);\n\tSET_NFLG (((uae_s64)a) < 0);\n\tif (extra & 0x400)\n\t    m68k_dreg(regs, extra & 7) = a >> 32;\n\telse if ((a & UVAL64(0xffffffff00000000)) != 0) {\n\t    SET_VFLG (1);\n\t}\n\tm68k_dreg(regs, (extra >> 12) & 7) = (uae_u32)a;\n    }\n#else\n    if (extra & 0x800) {\n\t/* signed variant */\n\tuae_s32 src1,src2;\n\tuae_u32 dst_lo,dst_hi;\n\tuae_u32 sign;\n\n\tsrc1 = (uae_s32)src;\n\tsrc2 = (uae_s32)m68k_dreg(regs, (extra >> 12) & 7);\n\tsign = (src1 ^ src2);\n\tif (src1 < 0) src1 = -src1;\n\tif (src2 < 0) src2 = -src2;\n\tmul_unsigned((uae_u32)src1,(uae_u32)src2,&dst_hi,&dst_lo);\n\tif (sign & 0x80000000) {\n\t\tdst_hi = ~dst_hi;\n\t\tdst_lo = -dst_lo;\n\t\tif (dst_lo == 0) dst_hi++;\n\t}\n\tSET_VFLG (0);\n\tSET_CFLG (0);\n\tSET_ZFLG (dst_hi == 0 && dst_lo == 0);\n\tSET_NFLG (((uae_s32)dst_hi) < 0);\n\tif (extra & 0x400)\n\t    m68k_dreg(regs, extra & 7) = dst_hi;\n\telse if ((dst_hi != 0 || (dst_lo & 0x80000000) != 0)\n\t\t && ((dst_hi & 0xffffffff) != 0xffffffff\n\t\t     || (dst_lo & 0x80000000) != 0x80000000))\n\t{\n\t    SET_VFLG (1);\n\t}\n\tm68k_dreg(regs, (extra >> 12) & 7) = dst_lo;\n    } else {\n\t/* unsigned */\n\tuae_u32 dst_lo,dst_hi;\n\n\tmul_unsigned(src,(uae_u32)m68k_dreg(regs, (extra >> 12) & 7),&dst_hi,&dst_lo);\n\n\tSET_VFLG (0);\n\tSET_CFLG (0);\n\tSET_ZFLG (dst_hi == 0 && dst_lo == 0);\n\tSET_NFLG (((uae_s32)dst_hi) < 0);\n\tif (extra & 0x400)\n\t    m68k_dreg(regs, extra & 7) = dst_hi;\n\telse if (dst_hi != 0) {\n\t    SET_VFLG (1);\n\t}\n\tm68k_dreg(regs, (extra >> 12) & 7) = dst_lo;\n    }\n#endif\n}\nstatic char* ccnames[] =\n{ \"T \",\"F \",\"HI\",\"LS\",\"CC\",\"CS\",\"NE\",\"EQ\",\n  \"VC\",\"VS\",\"PL\",\"MI\",\"GE\",\"LT\",\"GT\",\"LE\" };\n\n// If value is greater than zero, this means we are still processing an EmulOp\n// because the counter is incremented only in m68k_execute(), i.e. interpretive\n// execution only\nstatic int m68k_execute_depth = 0;\n\nvoid m68k_reset (void)\n{\n    m68k_areg (regs, 7) = 0x2000;\n    m68k_setpc (ROMBaseMac + 0x2a);\n    fill_prefetch_0 ();\n    regs.s = 1;\n    regs.m = 0;\n    regs.stopped = 0;\n    regs.t1 = 0;\n    regs.t0 = 0;\n    SET_ZFLG (0);\n    SET_XFLG (0);\n    SET_CFLG (0);\n    SET_VFLG (0);\n    SET_NFLG (0);\n\tSPCFLAGS_INIT( 0 );\n    regs.intmask = 7;\n    regs.vbr = regs.sfc = regs.dfc = 0;\n    fpu_reset();\n\t\n#if FLIGHT_RECORDER\n\tlog_ptr = 0;\n\tmemset(log, 0, sizeof(log));\n#endif\n\n#if ENABLE_MON\n\tstatic bool first_time = true;\n\tif (first_time) {\n\t\tfirst_time = false;\n\t\tmon_add_command(\"regs\", dump_regs, \"regs                    Dump m68k emulator registers\\n\");\n#if FLIGHT_RECORDER\n\t\t// Install \"log\" command in mon\n\t\tmon_add_command(\"log\", dump_log, \"log                      Dump m68k emulation log\\n\");\n#endif\n\t}\n#endif\n}\n\nvoid m68k_emulop_return(void)\n{\n\tSPCFLAGS_SET( SPCFLAG_BRK );\n\tquit_program = true;\n}\n\nvoid m68k_emulop(uae_u32 opcode)\n{\n\t\tstruct M68kRegisters r;\n\t\tint i;\n\n\t\tfor (i=0; i<8; i++) {\n\t\t\tr.d[i] = m68k_dreg(regs, i);\n\t\t\tr.a[i] = m68k_areg(regs, i);\n\t\t}\n\t\tMakeSR();\n\t\tr.sr = regs.sr;\n\t\tEmulOp(opcode, &r);\n\t\tfor (i=0; i<8; i++) {\n\t\t\tm68k_dreg(regs, i) = r.d[i];\n\t\t\tm68k_areg(regs, i) = r.a[i];\n\t\t}\n\t\tregs.sr = r.sr;\n\t\tMakeFromSR();\n}\n\nvoid REGPARAM2 op_illg (uae_u32 opcode)\n{\n\tuaecptr pc = m68k_getpc ();\n\n    if ((opcode & 0xF000) == 0xA000) {\n\tException(0xA,0);\n\treturn;\n    }\n\n    if ((opcode & 0xF000) == 0xF000) {\n\tException(0xB,0);\n\treturn;\n    }\n\n    write_log (\"Illegal instruction: %04x at %08lx\\n\", opcode, pc);\n#if USE_JIT && JIT_DEBUG\n    compiler_dumpstate();\n#endif\n\n    Exception (4,0);\n\treturn;\n}\n\nvoid mmu_op(uae_u32 opcode, uae_u16 extra)\n{\n    if ((opcode & 0xFE0) == 0x0500) {\n\t\t/* PFLUSH */\n\t\tmmusr = 0;\n\t} else if ((opcode & 0x0FD8) == 0x548) {\n\t\t/* PTEST */\n    } else\n\t\top_illg (opcode);\n}\n\nstatic int n_insns = 0, n_spcinsns = 0;\n\nstatic uaecptr last_trace_ad = 0;\n\nstatic void do_trace (void)\n{\n    if (regs.t0 && CPUType >= 2) {\n       uae_u16 opcode;\n       /* should also include TRAP, CHK, SR modification FPcc */\n       /* probably never used so why bother */\n       /* We can afford this to be inefficient... */\n       m68k_setpc (m68k_getpc ());\n       fill_prefetch_0 ();\n       opcode = get_word(m68k_getpc());\n       if (opcode == 0x4e72            /* RTE */\n           || opcode == 0x4e74                 /* RTD */\n           || opcode == 0x4e75                 /* RTS */\n           || opcode == 0x4e77                 /* RTR */\n           || opcode == 0x4e76                 /* TRAPV */\n           || (opcode & 0xffc0) == 0x4e80      /* JSR */\n           || (opcode & 0xffc0) == 0x4ec0      /* JMP */\n           || (opcode & 0xff00) == 0x6100  /* BSR */\n           || ((opcode & 0xf000) == 0x6000     /* Bcc */\n               && cctrue((opcode >> 8) & 0xf))\n           || ((opcode & 0xf0f0) == 0x5050 /* DBcc */\n               && !cctrue((opcode >> 8) & 0xf)\n               && (uae_s16)m68k_dreg(regs, opcode & 7) != 0))\n      {\n \t    last_trace_ad = m68k_getpc ();\n\t\tSPCFLAGS_CLEAR( SPCFLAG_TRACE );\n\t\tSPCFLAGS_SET( SPCFLAG_DOTRACE );\n\t}\n    } else if (regs.t1) {\n       last_trace_ad = m68k_getpc ();\n       SPCFLAGS_CLEAR( SPCFLAG_TRACE );\n       SPCFLAGS_SET( SPCFLAG_DOTRACE );\n    }\n}\n\nint m68k_do_specialties (void)\n{\n#if USE_JIT\n    // Block was compiled\n    SPCFLAGS_CLEAR( SPCFLAG_JIT_END_COMPILE );\n\n    // Retain the request to get out of compiled code until\n    // we reached the toplevel execution, i.e. the one that\n    // can compile then run compiled code. This also means\n    // we processed all (nested) EmulOps\n    if ((m68k_execute_depth == 0) && SPCFLAGS_TEST( SPCFLAG_JIT_EXEC_RETURN ))\n\tSPCFLAGS_CLEAR( SPCFLAG_JIT_EXEC_RETURN );\n#endif\n\t\n    if (SPCFLAGS_TEST( SPCFLAG_DOTRACE )) {\n\tException (9,last_trace_ad);\n    }\n    while (SPCFLAGS_TEST( SPCFLAG_STOP )) {\n\tif (SPCFLAGS_TEST( SPCFLAG_INT | SPCFLAG_DOINT )){\n\t\tSPCFLAGS_CLEAR( SPCFLAG_INT | SPCFLAG_DOINT );\n\t    int intr = intlev ();\n\t    if (intr != -1 && intr > regs.intmask) {\n\t\tInterrupt (intr);\n\t\tregs.stopped = 0;\n\t\tSPCFLAGS_CLEAR( SPCFLAG_STOP );\n\t    }\n\t}\n    }\n    if (SPCFLAGS_TEST( SPCFLAG_TRACE ))\n       do_trace ();\n\n    if (SPCFLAGS_TEST( SPCFLAG_DOINT )) {\n\tSPCFLAGS_CLEAR( SPCFLAG_DOINT );\n\tint intr = intlev ();\n\tif (intr != -1 && intr > regs.intmask) {\n\t    Interrupt (intr);\n\t    regs.stopped = 0;\n\t}\n    }\n    if (SPCFLAGS_TEST( SPCFLAG_INT )) {\n\tSPCFLAGS_CLEAR( SPCFLAG_INT );\n\tSPCFLAGS_SET( SPCFLAG_DOINT );\n    }\n    if (SPCFLAGS_TEST( SPCFLAG_BRK )) {\n\tSPCFLAGS_CLEAR( SPCFLAG_BRK );\n\treturn 1;\n    }\n    return 0;\n}\n\nvoid m68k_do_execute (void)\n{\n\tfor (;;) {\n\t\tuae_u32 opcode = GET_OPCODE;\n#if FLIGHT_RECORDER\n\t\tm68k_record_step(m68k_getpc());\n#endif\n\t\t(*cpufunctbl[opcode])(opcode);\n\t\tcpu_check_ticks();\n\t\tif (SPCFLAGS_TEST(SPCFLAG_ALL_BUT_EXEC_RETURN)) {\n\t\t\tif (m68k_do_specialties())\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid m68k_execute (void)\n{\n#if USE_JIT\n    ++m68k_execute_depth;\n#endif\n    for (;;) {\n\t  if (quit_program)\n\t\tbreak;\n\t  m68k_do_execute();\n    }\n#if USE_JIT\n    --m68k_execute_depth;\n#endif\n}\n\nstatic void m68k_verify (uaecptr addr, uaecptr *nextpc)\n{\n    uae_u32 opcode, val;\n    struct instr *dp;\n\n    opcode = get_iword_1(0);\n    last_op_for_exception_3 = opcode;\n    m68kpc_offset = 2;\n\n    if (cpufunctbl[cft_map (opcode)] == op_illg_1) {\n\topcode = 0x4AFC;\n    }\n    dp = table68k + opcode;\n\n    if (dp->suse) {\n\tif (!verify_ea (dp->sreg, (amodes)dp->smode, (wordsizes)dp->size, &val)) {\n\t    Exception (3, 0);\n\t    return;\n\t}\n    }\n    if (dp->duse) {\n\tif (!verify_ea (dp->dreg, (amodes)dp->dmode, (wordsizes)dp->size, &val)) {\n\t    Exception (3, 0);\n\t    return;\n\t}\n    }\n}\n\nvoid m68k_disasm (uaecptr addr, uaecptr *nextpc, int cnt)\n{\n    uaecptr newpc = 0;\n    m68kpc_offset = addr - m68k_getpc ();\n    while (cnt-- > 0) {\n\tchar instrname[20],*ccpt;\n\tint opwords;\n\tuae_u32 opcode;\n\tstruct mnemolookup *lookup;\n\tstruct instr *dp;\n\tprintf (\"%08lx: \", m68k_getpc () + m68kpc_offset);\n\tfor (opwords = 0; opwords < 5; opwords++){\n\t    printf (\"%04x \", get_iword_1 (m68kpc_offset + opwords*2));\n\t}\n\topcode = get_iword_1 (m68kpc_offset);\n\tm68kpc_offset += 2;\n\tif (cpufunctbl[cft_map (opcode)] == op_illg_1) {\n\t    opcode = 0x4AFC;\n\t}\n\tdp = table68k + opcode;\n\tfor (lookup = lookuptab;lookup->mnemo != dp->mnemo; lookup++)\n\t    ;\n\n\tstrcpy (instrname, lookup->name);\n\tccpt = strstr (instrname, \"cc\");\n\tif (ccpt != 0) {\n\t    strncpy (ccpt, ccnames[dp->cc], 2);\n\t}\n\tprintf (\"%s\", instrname);\n\tswitch (dp->size){\n\t case sz_byte: printf (\".B \"); break;\n\t case sz_word: printf (\".W \"); break;\n\t case sz_long: printf (\".L \"); break;\n\t default: printf (\"   \"); break;\n\t}\n\n\tif (dp->suse) {\n\t    newpc = m68k_getpc () + m68kpc_offset;\n\t    newpc += ShowEA (dp->sreg, (amodes)dp->smode, (wordsizes)dp->size, 0);\n\t}\n\tif (dp->suse && dp->duse)\n\t    printf (\",\");\n\tif (dp->duse) {\n\t    newpc = m68k_getpc () + m68kpc_offset;\n\t    newpc += ShowEA (dp->dreg, (amodes)dp->dmode, (wordsizes)dp->size, 0);\n\t}\n\tif (ccpt != 0) {\n\t    if (cctrue(dp->cc))\n\t\tprintf (\" == %08lx (TRUE)\", newpc);\n\t    else\n\t\tprintf (\" == %08lx (FALSE)\", newpc);\n\t} else if ((opcode & 0xff00) == 0x6100) /* BSR */\n\t    printf (\" == %08lx\", newpc);\n\tprintf (\"\\n\");\n    }\n    if (nextpc)\n\t*nextpc = m68k_getpc () + m68kpc_offset;\n}\n\nvoid m68k_dumpstate (uaecptr *nextpc)\n{\n    int i;\n    for (i = 0; i < 8; i++){\n\tprintf (\"D%d: %08lx \", i, m68k_dreg(regs, i));\n\tif ((i & 3) == 3) printf (\"\\n\");\n    }\n    for (i = 0; i < 8; i++){\n\tprintf (\"A%d: %08lx \", i, m68k_areg(regs, i));\n\tif ((i & 3) == 3) printf (\"\\n\");\n    }\n    if (regs.s == 0) regs.usp = m68k_areg(regs, 7);\n    if (regs.s && regs.m) regs.msp = m68k_areg(regs, 7);\n    if (regs.s && regs.m == 0) regs.isp = m68k_areg(regs, 7);\n    printf (\"USP=%08lx ISP=%08lx MSP=%08lx VBR=%08lx\\n\",\n\t    regs.usp,regs.isp,regs.msp,regs.vbr);\n    printf (\"T=%d%d S=%d M=%d X=%d N=%d Z=%d V=%d C=%d IMASK=%d\\n\",\n\t    regs.t1, regs.t0, regs.s, regs.m,\n\t    GET_XFLG, GET_NFLG, GET_ZFLG, GET_VFLG, GET_CFLG, regs.intmask);\n\t\n\tfpu_dump_registers();\n\tfpu_dump_flags();\n\t\n    m68k_disasm(m68k_getpc (), nextpc, 1);\n    if (nextpc)\n\tprintf (\"next PC: %08lx\\n\", *nextpc);\n}\n","/*\n * UAE - The Un*x Amiga Emulator\n *\n * MC68000 emulation\n *\n * Copyright 1995 Bernd Schmidt\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef NEWCPU_H\n#define NEWCPU_H\n\n#ifndef FLIGHT_RECORDER\n#define FLIGHT_RECORDER 0\n#endif\n\n#include \"m68k.h\"\n#include \"readcpu.h\"\n#include \"spcflags.h\"\n \nextern int areg_byteinc[];\nextern int imm8_table[];\n\nextern int movem_index1[256];\nextern int movem_index2[256];\nextern int movem_next[256];\n\nextern int broken_in;\n\n#ifdef X86_ASSEMBLY\n/* This hack seems to force all register saves (pushl %reg) to be moved to the\n   begining of the function, thus making it possible to cpuopti to remove them\n   since m68k_run_1 will save those registers before calling the instruction\n   handler */\n# define cpuop_tag(tag)\t\t__asm__ __volatile__ ( \"#cpuop_\" tag )\n#else\n# define cpuop_tag(tag)\t\t;\n#endif\n\n#define cpuop_begin()\t\tdo { cpuop_tag(\"begin\"); } while (0)\n#define cpuop_end()\t\t\tdo { cpuop_tag(\"end\"); } while (0)\n\ntypedef void REGPARAM2 cpuop_func (uae_u32) REGPARAM;\n \nstruct cputbl {\n    cpuop_func *handler;\n    uae_u16 specific;\n    uae_u16 opcode;\n};\n\nextern cpuop_func *cpufunctbl[65536] ASM_SYM_FOR_FUNC (\"cpufunctbl\");\n\n#if USE_JIT\ntypedef void compop_func (uae_u32) REGPARAM;\n\nstruct comptbl {\n    compop_func *handler;\n\tuae_u32\t\tspecific;\n\tuae_u32\t\topcode;\n};\n#endif\n\nextern void REGPARAM2 op_illg (uae_u32) REGPARAM;\n\ntypedef char flagtype;\n\nstruct regstruct {\n    uae_u32\t\tregs[16];\n\n    uae_u32\t\tpc;\n    uae_u8 *\tpc_p;\n    uae_u8 *\tpc_oldp;\n\n\tspcflags_t\tspcflags;\n    int\t\t\tintmask;\n\n    uae_u32\t\tvbr, sfc, dfc;\n    uaecptr\t\tusp, isp, msp;\n    uae_u16\t\tsr;\n    flagtype\tt1;\n    flagtype\tt0;\n    flagtype\ts;\n    flagtype\tm;\n    flagtype\tx;\n    flagtype\tstopped;\n\n#if USE_PREFETCH_BUFFER\n    /* Fellow sources say this is 4 longwords. That's impossible. It needs\n     * to be at least a longword. The HRM has some cryptic comment about two\n     * instructions being on the same longword boundary.\n     * The way this is implemented now seems like a good compromise.\n     */\n    uae_u32 prefetch;\n#endif\n};\n\nextern regstruct regs, lastint_regs;\n\n#define m68k_dreg(r,num) ((r).regs[(num)])\n#define m68k_areg(r,num) (((r).regs + 8)[(num)])\n\n#define get_ibyte(o) do_get_mem_byte((uae_u8 *)(regs.pc_p + (o) + 1))\n#define get_iword(o) do_get_mem_word((uae_u16 *)(regs.pc_p + (o)))\n#define get_ilong(o) do_get_mem_long((uae_u32 *)(regs.pc_p + (o)))\n\n#ifdef HAVE_GET_WORD_UNSWAPPED\n#define GET_OPCODE (do_get_mem_word_unswapped (regs.pc_p))\n#else\n#define GET_OPCODE (get_iword (0))\n#endif\n\n#if USE_PREFETCH_BUFFER\nstatic __inline__ uae_u32 get_ibyte_prefetch (uae_s32 o)\n{\n    if (o > 3 || o < 0)\n\treturn do_get_mem_byte((uae_u8 *)(regs.pc_p + o + 1));\n\n    return do_get_mem_byte((uae_u8 *)(((uae_u8 *)&regs.prefetch) + o + 1));\n}\nstatic __inline__ uae_u32 get_iword_prefetch (uae_s32 o)\n{\n    if (o > 3 || o < 0)\n\treturn do_get_mem_word((uae_u16 *)(regs.pc_p + o));\n\n    return do_get_mem_word((uae_u16 *)(((uae_u8 *)&regs.prefetch) + o));\n}\nstatic __inline__ uae_u32 get_ilong_prefetch (uae_s32 o)\n{\n    if (o > 3 || o < 0)\n\treturn do_get_mem_long((uae_u32 *)(regs.pc_p + o));\n    if (o == 0)\n\treturn do_get_mem_long(&regs.prefetch);\n    return (do_get_mem_word (((uae_u16 *)&regs.prefetch) + 1) << 16) | do_get_mem_word ((uae_u16 *)(regs.pc_p + 4));\n}\n#endif\n\n#define m68k_incpc(o) (regs.pc_p += (o))\n\nstatic __inline__ void fill_prefetch_0 (void)\n{\n#if USE_PREFETCH_BUFFER\n    uae_u32 r;\n#ifdef UNALIGNED_PROFITABLE\n    r = *(uae_u32 *)regs.pc_p;\n    regs.prefetch = r;\n#else\n    r = do_get_mem_long ((uae_u32 *)regs.pc_p);\n    do_put_mem_long (&regs.prefetch, r);\n#endif\n#endif\n}\n\n#if 0\nstatic __inline__ void fill_prefetch_2 (void)\n{\n    uae_u32 r = do_get_mem_long (&regs.prefetch) << 16;\n    uae_u32 r2 = do_get_mem_word (((uae_u16 *)regs.pc_p) + 1);\n    r |= r2;\n    do_put_mem_long (&regs.prefetch, r);\n}\n#else\n#define fill_prefetch_2 fill_prefetch_0\n#endif\n\n/* These are only used by the 68020/68881 code, and therefore don't\n * need to handle prefetch.  */\nstatic __inline__ uae_u32 next_ibyte (void)\n{\n    uae_u32 r = get_ibyte (0);\n    m68k_incpc (2);\n    return r;\n}\n\nstatic __inline__ uae_u32 next_iword (void)\n{\n    uae_u32 r = get_iword (0);\n    m68k_incpc (2);\n    return r;\n}\n\nstatic __inline__ uae_u32 next_ilong (void)\n{\n    uae_u32 r = get_ilong (0);\n    m68k_incpc (4);\n    return r;\n}\n\nstatic __inline__ void m68k_setpc (uaecptr newpc)\n{\n#if REAL_ADDRESSING || DIRECT_ADDRESSING\n\tregs.pc_p = get_real_address(newpc);\n#else\n    regs.pc_p = regs.pc_oldp = get_real_address(newpc);\n    regs.pc = newpc;\n#endif\n}\n\nstatic __inline__ uaecptr m68k_getpc (void)\n{\n#if REAL_ADDRESSING || DIRECT_ADDRESSING\n\treturn get_virtual_address(regs.pc_p);\n#else\n    return regs.pc + ((char *)regs.pc_p - (char *)regs.pc_oldp);\n#endif\n}\n\n#define m68k_setpc_fast m68k_setpc\n#define m68k_setpc_bcc  m68k_setpc\n#define m68k_setpc_rte  m68k_setpc\n\nstatic __inline__ void m68k_do_rts(void)\n{\n\t    m68k_setpc(get_long(m68k_areg(regs, 7)));\n\t        m68k_areg(regs, 7) += 4;\n}\n \nstatic __inline__ void m68k_do_bsr(uaecptr oldpc, uae_s32 offset)\n{\n\t    m68k_areg(regs, 7) -= 4;\n\t        put_long(m68k_areg(regs, 7), oldpc);\n\t\t    m68k_incpc(offset);\n}\n \nstatic __inline__ void m68k_do_jsr(uaecptr oldpc, uaecptr dest)\n{\n\t    m68k_areg(regs, 7) -= 4;\n\t        put_long(m68k_areg(regs, 7), oldpc);\n\t\t    m68k_setpc(dest);\n}\n\nstatic __inline__ void m68k_setstopped (int stop)\n{\n    regs.stopped = stop;\n    /* A traced STOP instruction drops through immediately without\n       actually stopping.  */\n    if (stop && (regs.spcflags & SPCFLAG_DOTRACE) == 0)\n    SPCFLAGS_SET( SPCFLAG_STOP );\n}\n\nextern uae_u32 get_disp_ea_020 (uae_u32 base, uae_u32 dp);\nextern uae_u32 get_disp_ea_000 (uae_u32 base, uae_u32 dp);\n\nextern uae_s32 ShowEA (int reg, amodes mode, wordsizes size, char *buf);\n\nextern void MakeSR (void);\nextern void MakeFromSR (void);\nextern void Exception (int, uaecptr);\nextern void dump_counts (void);\nextern int m68k_move2c (int, uae_u32 *);\nextern int m68k_movec2 (int, uae_u32 *);\nextern void m68k_divl (uae_u32, uae_u32, uae_u16, uaecptr);\nextern void m68k_mull (uae_u32, uae_u32, uae_u16);\nextern void m68k_emulop (uae_u32);\nextern void m68k_emulop_return (void);\nextern void init_m68k (void);\nextern void exit_m68k (void);\nextern void m68k_dumpstate (uaecptr *);\nextern void m68k_disasm (uaecptr, uaecptr *, int);\nextern void m68k_reset (void);\nextern void m68k_enter_debugger(void);\nextern int m68k_do_specialties(void);\n\nextern void mmu_op (uae_u32, uae_u16);\n\n/* Opcode of faulting instruction */\nextern uae_u16 last_op_for_exception_3;\n/* PC at fault time */\nextern uaecptr last_addr_for_exception_3;\n/* Address that generated the exception */\nextern uaecptr last_fault_for_exception_3;\n\n#define CPU_OP_NAME(a) op ## a\n\n/* 68020 + 68881 */\nextern struct cputbl op_smalltbl_0_ff[];\n/* 68020 */\nextern struct cputbl op_smalltbl_1_ff[];\n/* 68010 */\nextern struct cputbl op_smalltbl_2_ff[];\n/* 68000 */\nextern struct cputbl op_smalltbl_3_ff[];\n/* 68000 slow but compatible.  */\nextern struct cputbl op_smalltbl_4_ff[];\n\n#if FLIGHT_RECORDER\nextern void m68k_record_step(uaecptr) REGPARAM;\n#endif\nextern void m68k_do_execute(void);\nextern void m68k_execute(void);\n#if USE_JIT\nextern void m68k_compile_execute(void);\n#endif\n#ifdef USE_CPU_EMUL_SERVICES\nextern int32 emulated_ticks;\nextern void cpu_do_check_ticks(void);\n\nstatic inline void cpu_check_ticks(void)\n{\n\tif (--emulated_ticks <= 0)\n\t\tcpu_do_check_ticks();\n}\n#else\n#define cpu_check_ticks()\n#define cpu_do_check_ticks()\n#endif\n \n#endif /* NEWCPU_H */\n","/*\n *  sysdeps.h - System dependent definitions for Unix\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef SYSDEPS_H\n#define SYSDEPS_H\n\n#ifndef __STDC__\n#error \"Your compiler is not ANSI. Get a real one.\"\n#endif\n\n#include \"config.h\"\n#include \"user_strings_unix.h\"\n\n#ifndef STDC_HEADERS\n#error \"You don't have ANSI C header files.\"\n#endif\n\n#ifdef HAVE_UNISTD_H\n# include <sys/types.h>\n# include <unistd.h>\n#endif\n\n#include <netinet/in.h>\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef HAVE_PTHREADS\n# include <pthread.h>\n#endif\n\n#ifdef HAVE_FCNTL_H\n# include <fcntl.h>\n#endif\n\n#ifdef TIME_WITH_SYS_TIME\n# include <sys/time.h>\n# include <time.h>\n#else\n# ifdef HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# else\n#  include <time.h>\n# endif\n#endif\n\n#if defined(__MACH__)\n#include <mach/clock.h>\n#endif\n\n#ifdef ENABLE_NATIVE_M68K\n\n/* Mac and host address space are the same */\n#define REAL_ADDRESSING 1\n\n/* Using 68k natively */\n#define EMULATED_68K 0\n\n/* Mac ROM is not write protected */\n#define ROM_IS_WRITE_PROTECTED 0\n#define USE_SCRATCHMEM_SUBTERFUGE 1\n\n#else\n\n/* Mac and host address space are distinct */\n#ifndef REAL_ADDRESSING\n#define REAL_ADDRESSING 0\n#endif\n\n/* Using 68k emulator */\n#define EMULATED_68K 1\n\n/* The m68k emulator uses a prefetch buffer ? */\n#define USE_PREFETCH_BUFFER 0\n\n/* Mac ROM is write protected when banked memory is used */\n#if REAL_ADDRESSING || DIRECT_ADDRESSING\n# define ROM_IS_WRITE_PROTECTED 0\n# define USE_SCRATCHMEM_SUBTERFUGE 1\n#else\n# define ROM_IS_WRITE_PROTECTED 1\n#endif\n\n#endif\n\n/* Direct Addressing requires Video on SEGV signals in plain X11 mode */\n#if DIRECT_ADDRESSING && (!ENABLE_VOSF && !USE_SDL_VIDEO)\n# undef  ENABLE_VOSF\n# define ENABLE_VOSF 1\n#endif\n\n/* ExtFS is supported */\n#define SUPPORTS_EXTFS 1\n\n/* BSD socket API supported */\n#define SUPPORTS_UDP_TUNNEL 1\n\n/* Use the CPU emulator to check for periodic tasks? */\n#ifdef HAVE_PTHREADS\n#define USE_PTHREADS_SERVICES\n#endif\n#if EMULATED_68K\n#if defined(__NetBSD__)\n#define USE_CPU_EMUL_SERVICES\n#endif\n#endif\n#ifdef USE_CPU_EMUL_SERVICES\n#undef USE_PTHREADS_SERVICES\n#endif\n\n\n/* Data types */\ntypedef unsigned char uint8;\ntypedef signed char int8;\n#if SIZEOF_SHORT == 2\ntypedef unsigned short uint16;\ntypedef short int16;\n#elif SIZEOF_INT == 2\ntypedef unsigned int uint16;\ntypedef int int16;\n#else\n#error \"No 2 byte type, you lose.\"\n#endif\n#if SIZEOF_INT == 4\ntypedef unsigned int uint32;\ntypedef int int32;\n#elif SIZEOF_LONG == 4\ntypedef unsigned long uint32;\ntypedef long int32;\n#else\n#error \"No 4 byte type, you lose.\"\n#endif\n#if SIZEOF_LONG == 8\n#ifndef _UINT64\ntypedef unsigned long uint64;\n#define _UINT64\n#endif\ntypedef long int64;\n#define VAL64(a) (a ## l)\n#define UVAL64(a) (a ## ul)\n#elif SIZEOF_LONG_LONG == 8\n#ifndef _UINT64\ntypedef unsigned long long uint64;\n#define _UINT64\n#endif\ntypedef long long int64;\n#define VAL64(a) (a ## LL)\n#define UVAL64(a) (a ## uLL)\n#else\n#error \"No 8 byte type, you lose.\"\n#endif\n#if SIZEOF_VOID_P == 4\ntypedef uint32 uintptr;\ntypedef int32 intptr;\n#elif SIZEOF_VOID_P == 8\ntypedef uint64 uintptr;\ntypedef int64 intptr;\n#else\n#error \"Unsupported size of pointer\"\n#endif\n\n#ifndef HAVE_LOFF_T\ntypedef off_t loff_t;\n#endif\n#ifndef HAVE_CADDR_T\ntypedef char * caddr_t;\n#endif\n\n/* Time data type for Time Manager emulation */\n#ifdef HAVE_CLOCK_GETTIME\ntypedef struct timespec tm_time_t;\n#elif defined(__MACH__)\ntypedef mach_timespec_t tm_time_t;\n#else\ntypedef struct timeval tm_time_t;\n#endif\n\n/* Define codes for all the float formats that we know of.\n * Though we only handle IEEE format.  */\n#define UNKNOWN_FLOAT_FORMAT 0\n#define IEEE_FLOAT_FORMAT 1\n#define VAX_FLOAT_FORMAT 2\n#define IBM_FLOAT_FORMAT 3\n#define C4X_FLOAT_FORMAT 4\n\n/* UAE CPU data types */\n#define uae_s8 int8\n#define uae_u8 uint8\n#define uae_s16 int16\n#define uae_u16 uint16\n#define uae_s32 int32\n#define uae_u32 uint32\n#define uae_s64 int64\n#define uae_u64 uint64\ntypedef uae_u32 uaecptr;\n\n/* Alignment restrictions */\n#if defined(__i386__) || defined(__powerpc__) || defined(__m68k__) || defined(__x86_64__)\n# define CPU_CAN_ACCESS_UNALIGNED\n#endif\n\n/* Timing functions */\nextern uint64 GetTicks_usec(void);\nextern void Delay_usec(uint32 usec);\n\n/* Spinlocks */\n#ifdef __GNUC__\n\n#if defined(__powerpc__) || defined(__ppc__)\n#define HAVE_TEST_AND_SET 1\nstatic inline int testandset(volatile int *p)\n{\n\tint ret;\n\t__asm__ __volatile__(\"0:    lwarx\t%0,0,%1\\n\"\n\t\t\t\t\t\t \"      xor.\t%0,%3,%0\\n\"\n\t\t\t\t\t\t \"      bne\t\t1f\\n\"\n\t\t\t\t\t\t \"      stwcx.\t%2,0,%1\\n\"\n\t\t\t\t\t\t \"      bne-\t0b\\n\"\n\t\t\t\t\t\t \"1:    \"\n\t\t\t\t\t\t : \"=&r\" (ret)\n\t\t\t\t\t\t : \"r\" (p), \"r\" (1), \"r\" (0)\n\t\t\t\t\t\t : \"cr0\", \"memory\");\n\treturn ret;\n}\n#endif\n\n/* FIXME: SheepShaver occasionnally hangs with those locks */\n#if 0 && (defined(__i386__) || defined(__x86_64__))\n#define HAVE_TEST_AND_SET 1\nstatic inline int testandset(volatile int *p)\n{\n\tlong int ret;\n\t/* Note: the \"xchg\" instruction does not need a \"lock\" prefix */\n\t__asm__ __volatile__(\"xchgl %k0, %1\"\n\t\t\t\t\t\t : \"=r\" (ret), \"=m\" (*p)\n\t\t\t\t\t\t : \"0\" (1), \"m\" (*p)\n\t\t\t\t\t\t : \"memory\");\n\treturn ret;\n}\n#endif\n\n#ifdef __s390__\n#define HAVE_TEST_AND_SET 1\nstatic inline int testandset(volatile int *p)\n{\n\tint ret;\n\n\t__asm__ __volatile__(\"0: cs    %0,%1,0(%2)\\n\"\n\t\t\t\t\t\t \"   jl    0b\"\n\t\t\t\t\t\t : \"=&d\" (ret)\n\t\t\t\t\t\t : \"r\" (1), \"a\" (p), \"0\" (*p) \n\t\t\t\t\t\t : \"cc\", \"memory\" );\n\treturn ret;\n}\n#endif\n\n#ifdef __alpha__\n#define HAVE_TEST_AND_SET 1\nstatic inline int testandset(volatile int *p)\n{\n\tint ret;\n\tunsigned long one;\n\n\t__asm__ __volatile__(\"0:\tmov 1,%2\\n\"\n\t\t\t\t\t\t \"\tldl_l %0,%1\\n\"\n\t\t\t\t\t\t \"\tstl_c %2,%1\\n\"\n\t\t\t\t\t\t \"\tbeq %2,1f\\n\"\n\t\t\t\t\t\t \".subsection 2\\n\"\n\t\t\t\t\t\t \"1:\tbr 0b\\n\"\n\t\t\t\t\t\t \".previous\"\n\t\t\t\t\t\t : \"=r\" (ret), \"=m\" (*p), \"=r\" (one)\n\t\t\t\t\t\t : \"m\" (*p));\n\treturn ret;\n}\n#endif\n\n#ifdef __sparc__\n#define HAVE_TEST_AND_SET 1\nstatic inline int testandset(volatile int *p)\n{\n\tint ret;\n\n\t__asm__ __volatile__(\"ldstub\t[%1], %0\"\n\t\t\t\t\t\t : \"=r\" (ret)\n\t\t\t\t\t\t : \"r\" (p)\n\t\t\t\t\t\t : \"memory\");\n\n\treturn (ret ? 1 : 0);\n}\n#endif\n\n#ifdef __arm__\n#define HAVE_TEST_AND_SET 1\nstatic inline int testandset(volatile int *p)\n{\n\tregister unsigned int ret;\n\t__asm__ __volatile__(\"swp %0, %1, [%2]\"\n\t\t\t\t\t\t : \"=r\"(ret)\n\t\t\t\t\t\t : \"0\"(1), \"r\"(p));\n\t\n\treturn ret;\n}\n#endif\n\n#endif /* __GNUC__ */\n\ntypedef volatile int spinlock_t;\n\nstatic const spinlock_t SPIN_LOCK_UNLOCKED = 0;\n\n#if HAVE_TEST_AND_SET\n#define HAVE_SPINLOCKS 1\nstatic inline void spin_lock(spinlock_t *lock)\n{\n\twhile (testandset(lock));\n}\n\nstatic inline void spin_unlock(spinlock_t *lock)\n{\n\t*lock = 0;\n}\n\nstatic inline int spin_trylock(spinlock_t *lock)\n{\n\treturn !testandset(lock);\n}\n#else\nstatic inline void spin_lock(spinlock_t *lock)\n{\n}\n\nstatic inline void spin_unlock(spinlock_t *lock)\n{\n}\n\nstatic inline int spin_trylock(spinlock_t *lock)\n{\n\treturn 1;\n}\n#endif\n\n/* X11 display fast locks */\n#ifdef HAVE_SPINLOCKS\n#define X11_LOCK_TYPE spinlock_t\n#define X11_LOCK_INIT SPIN_LOCK_UNLOCKED\n#define XDisplayLock() spin_lock(&x_display_lock)\n#define XDisplayUnlock() spin_unlock(&x_display_lock)\n#elif defined(HAVE_PTHREADS)\n#define X11_LOCK_TYPE pthread_mutex_t\n#define X11_LOCK_INIT PTHREAD_MUTEX_INITIALIZER\n#define XDisplayLock() pthread_mutex_lock(&x_display_lock);\n#define XDisplayUnlock() pthread_mutex_unlock(&x_display_lock);\n#else\n#define XDisplayLock()\n#define XDisplayUnlock()\n#endif\n#ifdef X11_LOCK_TYPE\nextern X11_LOCK_TYPE x_display_lock;\n#endif\n\n#ifdef HAVE_PTHREADS\n/* Centralized pthread attribute setup */\nvoid Set_pthread_attr(pthread_attr_t *attr, int priority);\n#endif\n\n/* UAE CPU defines */\n#ifdef WORDS_BIGENDIAN\n\n#ifdef CPU_CAN_ACCESS_UNALIGNED\n\n/* Big-endian CPUs which can do unaligned accesses */\nstatic inline uae_u32 do_get_mem_long(uae_u32 *a) {return *a;}\nstatic inline uae_u32 do_get_mem_word(uae_u16 *a) {return *a;}\nstatic inline void do_put_mem_long(uae_u32 *a, uae_u32 v) {*a = v;}\nstatic inline void do_put_mem_word(uae_u16 *a, uae_u32 v) {*a = v;}\n\n#else /* CPU_CAN_ACCESS_UNALIGNED */\n\n#ifdef sgi\n/* The SGI MIPSPro compilers can do unaligned accesses given enough hints.\n * They will automatically inline these routines. */\n#ifdef __cplusplus\nextern \"C\" { /* only the C compiler does unaligned accesses */\n#endif\nextern uae_u32 do_get_mem_long(uae_u32 *a);\nextern uae_u32 do_get_mem_word(uae_u16 *a);\nextern void do_put_mem_long(uae_u32 *a, uae_u32 v);\nextern void do_put_mem_word(uae_u16 *a, uae_u32 v);\n#ifdef __cplusplus\n}\n#endif\n\n#else /* sgi */\n\n/* Big-endian CPUs which can not do unaligned accesses (this is not the most efficient way to do this...) */\nstatic inline uae_u32 do_get_mem_long(uae_u32 *a) {uint8 *b = (uint8 *)a; return (b[0] << 24) | (b[1] << 16) | (b[2] << 8) | b[3];}\nstatic inline uae_u32 do_get_mem_word(uae_u16 *a) {uint8 *b = (uint8 *)a; return (b[0] << 8) | b[1];}\nstatic inline void do_put_mem_long(uae_u32 *a, uae_u32 v) {uint8 *b = (uint8 *)a; b[0] = v >> 24; b[1] = v >> 16; b[2] = v >> 8; b[3] = v;}\nstatic inline void do_put_mem_word(uae_u16 *a, uae_u32 v) {uint8 *b = (uint8 *)a; b[0] = v >> 8; b[1] = v;}\n#endif /* sgi */\n\n#endif /* CPU_CAN_ACCESS_UNALIGNED */\n\n#else /* WORDS_BIGENDIAN */\n\n#if defined(__i386__) || defined(__x86_64__)\n\n/* Intel x86 */\n#define X86_PPRO_OPT\nstatic inline uae_u32 do_get_mem_long(uae_u32 *a) {uint32 retval; __asm__ (\"bswap %0\" : \"=r\" (retval) : \"0\" (*a) : \"cc\"); return retval;}\n#ifdef X86_PPRO_OPT\nstatic inline uae_u32 do_get_mem_word(uae_u16 *a) {uint32 retval; __asm__ (\"movzwl %w1,%k0\\n\\tshll $16,%k0\\n\\tbswapl %k0\\n\" : \"=&r\" (retval) : \"m\" (*a) : \"cc\"); return retval;}\n#else\nstatic inline uae_u32 do_get_mem_word(uae_u16 *a) {uint32 retval; __asm__ (\"xorl %k0,%k0\\n\\tmovw %w1,%w0\\n\\trolw $8,%w0\" : \"=&r\" (retval) : \"m\" (*a) : \"cc\"); return retval;}\n#endif\n#define HAVE_GET_WORD_UNSWAPPED\n#define do_get_mem_word_unswapped(a) ((uae_u32)*((uae_u16 *)(a)))\nstatic inline void do_put_mem_long(uae_u32 *a, uae_u32 v) {__asm__ (\"bswap %0\" : \"=r\" (v) : \"0\" (v) : \"cc\"); *a = v;}\n#ifdef X86_PPRO_OPT\nstatic inline void do_put_mem_word(uae_u16 *a, uae_u32 v) {__asm__ (\"bswapl %0\" : \"=&r\" (v) : \"0\" (v << 16) : \"cc\"); *a = v;}\n#else\nstatic inline void do_put_mem_word(uae_u16 *a, uae_u32 v) {__asm__ (\"rolw $8,%0\" : \"=r\" (v) : \"0\" (v) : \"cc\"); *a = v;}\n#endif\n#define HAVE_OPTIMIZED_BYTESWAP_32\n/* bswap doesn't affect condition codes */\nstatic inline uae_u32 do_byteswap_32(uae_u32 v) {__asm__ (\"bswap %0\" : \"=r\" (v) : \"0\" (v)); return v;}\n#define HAVE_OPTIMIZED_BYTESWAP_16\n#ifdef X86_PPRO_OPT\nstatic inline uae_u32 do_byteswap_16(uae_u32 v) {__asm__ (\"bswapl %0\" : \"=&r\" (v) : \"0\" (v << 16) : \"cc\"); return v;}\n#else\nstatic inline uae_u32 do_byteswap_16(uae_u32 v) {__asm__ (\"rolw $8,%0\" : \"=r\" (v) : \"0\" (v) : \"cc\"); return v;}\n#endif\n\n#elif defined(CPU_CAN_ACCESS_UNALIGNED)\n\n/* Other little-endian CPUs which can do unaligned accesses */\nstatic inline uae_u32 do_get_mem_long(uae_u32 *a) {uint32 x = *a; return (x >> 24) | (x >> 8) & 0xff00 | (x << 8) & 0xff0000 | (x << 24);}\nstatic inline uae_u32 do_get_mem_word(uae_u16 *a) {uint16 x = *a; return (x >> 8) | (x << 8);}\nstatic inline void do_put_mem_long(uae_u32 *a, uae_u32 v) {*a = (v >> 24) | (v >> 8) & 0xff00 | (v << 8) & 0xff0000 | (v << 24);}\nstatic inline void do_put_mem_word(uae_u16 *a, uae_u32 v) {*a = (v >> 8) | (v << 8);}\n\n#else /* CPU_CAN_ACCESS_UNALIGNED */\n\n/* Other little-endian CPUs which can not do unaligned accesses (this needs optimization) */\nstatic inline uae_u32 do_get_mem_long(uae_u32 *a) {uint8 *b = (uint8 *)a; return (b[0] << 24) | (b[1] << 16) | (b[2] << 8) | b[3];}\nstatic inline uae_u32 do_get_mem_word(uae_u16 *a) {uint8 *b = (uint8 *)a; return (b[0] << 8) | b[1];}\nstatic inline void do_put_mem_long(uae_u32 *a, uae_u32 v) {uint8 *b = (uint8 *)a; b[0] = v >> 24; b[1] = v >> 16; b[2] = v >> 8; b[3] = v;}\nstatic inline void do_put_mem_word(uae_u16 *a, uae_u32 v) {uint8 *b = (uint8 *)a; b[0] = v >> 8; b[1] = v;}\n\n#endif /* CPU_CAN_ACCESS_UNALIGNED */\n\n#endif /* WORDS_BIGENDIAN */\n\n#ifndef HAVE_OPTIMIZED_BYTESWAP_32\nstatic inline uae_u32 do_byteswap_32(uae_u32 v)\n\t{ return (((v >> 24) & 0xff) | ((v >> 8) & 0xff00) | ((v & 0xff) << 24) | ((v & 0xff00) << 8)); }\n#endif\n\n#ifndef HAVE_OPTIMIZED_BYTESWAP_16\nstatic inline uae_u32 do_byteswap_16(uae_u32 v)\n\t{ return (((v >> 8) & 0xff) | ((v & 0xff) << 8)); }\n#endif\n\n#define do_get_mem_byte(a) ((uae_u32)*((uae_u8 *)(a)))\n#define do_put_mem_byte(a, v) (*(uae_u8 *)(a) = (v))\n\n#define call_mem_get_func(func, addr) ((*func)(addr))\n#define call_mem_put_func(func, addr, v) ((*func)(addr, v))\n#define __inline__ inline\n#define CPU_EMU_SIZE 0\n#undef NO_INLINE_MEMORY_ACCESS\n#undef MD_HAVE_MEM_1_FUNCS\n#define ENUMDECL typedef enum\n#define ENUMNAME(name) name\n#define write_log printf\n\n#if defined(X86_ASSEMBLY) || defined(X86_64_ASSEMBLY)\n#define ASM_SYM_FOR_FUNC(a) __asm__(a)\n#else\n#define ASM_SYM_FOR_FUNC(a)\n#endif\n\n#ifndef REGPARAM\n# define REGPARAM\n#endif\n#ifdef REGPARAM\n# define REGPARAM\n#endif\n#define REGPARAM2\n\n#endif\n","/* \n * UAE - The Un*x Amiga Emulator\n * \n * MC68000 emulation - machine dependent bits\n *\n * Copyright 1996 Bernd Schmidt\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef M68K_FLAGS_H\n#define M68K_FLAGS_H\n\n#ifdef OPTIMIZED_FLAGS\n\n#if (defined(__i386__) && defined(X86_ASSEMBLY)) || (defined(__x86_64__) && defined(X86_64_ASSEMBLY))\n\n#ifndef SAHF_SETO_PROFITABLE\n\n/* PUSH/POP instructions are naturally 64-bit sized on x86-64, thus\n   unsigned long hereunder is either 64-bit or 32-bit wide depending\n   on the target.  */\nstruct flag_struct {\n    unsigned long cznv;\n    unsigned long x;\n};\n\n#define FLAGVAL_Z\t0x40\n#define FLAGVAL_N\t0x80\n\n#define SET_ZFLG(y)\t(regflags.cznv = (((uae_u32)regflags.cznv) & ~0x40) | (((y) & 1) << 6))\n#define SET_CFLG(y)\t(regflags.cznv = (((uae_u32)regflags.cznv) & ~1) | ((y) & 1))\n#define SET_VFLG(y)\t(regflags.cznv = (((uae_u32)regflags.cznv) & ~0x800) | (((y) & 1) << 11))\n#define SET_NFLG(y)\t(regflags.cznv = (((uae_u32)regflags.cznv) & ~0x80) | (((y) & 1) << 7))\n#define SET_XFLG(y)\t(regflags.x = (y))\n\n#define GET_ZFLG\t((regflags.cznv >> 6) & 1)\n#define GET_CFLG\t(regflags.cznv & 1)\n#define GET_VFLG\t((regflags.cznv >> 11) & 1)\n#define GET_NFLG\t((regflags.cznv >> 7) & 1)\n#define GET_XFLG\t(regflags.x & 1)\n\n#define CLEAR_CZNV\t(regflags.cznv = 0)\n#define GET_CZNV\t(regflags.cznv)\n#define IOR_CZNV(X)\t(regflags.cznv |= (X))\n#define SET_CZNV(X)\t(regflags.cznv = (X))\n\n#define COPY_CARRY\t(regflags.x = regflags.cznv)\n\nextern struct flag_struct regflags __asm__ (\"regflags\");\n\nstatic __inline__ int cctrue(int cc)\n{\n    uae_u32 cznv = regflags.cznv;\n    switch(cc){\n     case 0: return 1;                       /* T */\n     case 1: return 0;                       /* F */\n     case 2: return (cznv & 0x41) == 0; /* !GET_CFLG && !GET_ZFLG;  HI */\n     case 3: return (cznv & 0x41) != 0; /* GET_CFLG || GET_ZFLG;    LS */\n     case 4: return (cznv & 1) == 0;        /* !GET_CFLG;               CC */\n     case 5: return (cznv & 1) != 0;           /* GET_CFLG;                CS */\n     case 6: return (cznv & 0x40) == 0; /* !GET_ZFLG;               NE */\n     case 7: return (cznv & 0x40) != 0; /* GET_ZFLG;                EQ */\n     case 8: return (cznv & 0x800) == 0;/* !GET_VFLG;               VC */\n     case 9: return (cznv & 0x800) != 0;/* GET_VFLG;                VS */\n     case 10:return (cznv & 0x80) == 0; /* !GET_NFLG;               PL */\n     case 11:return (cznv & 0x80) != 0; /* GET_NFLG;                MI */\n     case 12:return (((cznv << 4) ^ cznv) & 0x800) == 0; /* GET_NFLG == GET_VFLG;             GE */\n     case 13:return (((cznv << 4) ^ cznv) & 0x800) != 0;/* GET_NFLG != GET_VFLG;             LT */\n     case 14:\n\tcznv &= 0x8c0;\n\treturn (((cznv << 4) ^ cznv) & 0x840) == 0; /* !GET_ZFLG && (GET_NFLG == GET_VFLG);  GT */\n     case 15:\n\tcznv &= 0x8c0;\n\treturn (((cznv << 4) ^ cznv) & 0x840) != 0; /* GET_ZFLG || (GET_NFLG != GET_VFLG);   LE */\n    }\n    return 0;\n}\n\n#define optflag_testl(v) \\\n  __asm__ __volatile__ (\"andl %1,%1\\n\\t\" \\\n\t\t\t\"pushf\\n\\t\" \\\n\t\t\t\"pop %0\\n\\t\" \\\n\t\t\t: \"=r\" (regflags.cznv) : \"r\" (v) : \"cc\")\n\n#define optflag_testw(v) \\\n  __asm__ __volatile__ (\"andw %w1,%w1\\n\\t\" \\\n\t\t\t\"pushf\\n\\t\" \\\n\t\t\t\"pop %0\\n\\t\" \\\n\t\t\t: \"=r\" (regflags.cznv) : \"r\" (v) : \"cc\")\n\n#define optflag_testb(v) \\\n  __asm__ __volatile__ (\"andb %b1,%b1\\n\\t\" \\\n\t\t\t\"pushf\\n\\t\" \\\n\t\t\t\"pop %0\\n\\t\" \\\n\t\t\t: \"=r\" (regflags.cznv) : \"q\" (v) : \"cc\")\n\n#define optflag_addl(v, s, d) do { \\\n  __asm__ __volatile__ (\"addl %k2,%k1\\n\\t\" \\\n\t\t\t\"pushf\\n\\t\" \\\n\t\t\t\"pop %0\\n\\t\" \\\n\t\t\t: \"=r\" (regflags.cznv), \"=r\" (v) : \"rmi\" (s), \"1\" (d) : \"cc\"); \\\n    COPY_CARRY; \\\n    } while (0)\n\n#define optflag_addw(v, s, d) do { \\\n  __asm__ __volatile__ (\"addw %w2,%w1\\n\\t\" \\\n\t\t\t\"pushf\\n\\t\" \\\n\t\t\t\"pop %0\\n\\t\" \\\n\t\t\t: \"=r\" (regflags.cznv), \"=r\" (v) : \"rmi\" (s), \"1\" (d) : \"cc\"); \\\n    COPY_CARRY; \\\n    } while (0)\n\n#define optflag_addb(v, s, d) do { \\\n  __asm__ __volatile__ (\"addb %b2,%b1\\n\\t\" \\\n\t\t\t\"pushf\\n\\t\" \\\n\t\t\t\"pop %0\\n\\t\" \\\n\t\t\t: \"=r\" (regflags.cznv), \"=q\" (v) : \"qmi\" (s), \"1\" (d) : \"cc\"); \\\n    COPY_CARRY; \\\n    } while (0)\n\n#define optflag_subl(v, s, d) do { \\\n  __asm__ __volatile__ (\"subl %k2,%k1\\n\\t\" \\\n\t\t\t\"pushf\\n\\t\" \\\n\t\t\t\"pop %0\\n\\t\" \\\n\t\t\t: \"=r\" (regflags.cznv), \"=r\" (v) : \"rmi\" (s), \"1\" (d) : \"cc\"); \\\n    COPY_CARRY; \\\n    } while (0)\n\n#define optflag_subw(v, s, d) do { \\\n  __asm__ __volatile__ (\"subw %w2,%w1\\n\\t\" \\\n\t\t\t\"pushf\\n\\t\" \\\n\t\t\t\"pop %0\\n\\t\" \\\n\t\t\t: \"=r\" (regflags.cznv), \"=r\" (v) : \"rmi\" (s), \"1\" (d) : \"cc\"); \\\n    COPY_CARRY; \\\n    } while (0)\n\n#define optflag_subb(v, s, d) do { \\\n  __asm__ __volatile__ (\"subb %b2,%b1\\n\\t\" \\\n\t\t\t\"pushf\\n\\t\" \\\n\t\t\t\"pop %0\\n\\t\" \\\n\t\t\t: \"=r\" (regflags.cznv), \"=q\" (v) : \"qmi\" (s), \"1\" (d) : \"cc\"); \\\n    COPY_CARRY; \\\n    } while (0)\n\n#define optflag_cmpl(s, d) \\\n  __asm__ __volatile__ (\"cmpl %k1,%k2\\n\\t\" \\\n\t\t\t\"pushf\\n\\t\" \\\n\t\t\t\"pop %0\\n\\t\" \\\n\t\t\t: \"=r\" (regflags.cznv) : \"rmi\" (s), \"r\" (d) : \"cc\")\n\n#define optflag_cmpw(s, d) \\\n  __asm__ __volatile__ (\"cmpw %w1,%w2\\n\\t\" \\\n\t\t\t\"pushf\\n\\t\" \\\n\t\t\t\"pop %0\\n\\t\" \\\n\t\t\t: \"=r\" (regflags.cznv) : \"rmi\" (s), \"r\" (d) : \"cc\")\n\n#define optflag_cmpb(s, d) \\\n  __asm__ __volatile__ (\"cmpb %b1,%b2\\n\\t\" \\\n\t\t\t\"pushf\\n\\t\" \\\n\t\t\t\"pop %0\\n\\t\" \\\n\t\t\t: \"=r\" (regflags.cznv) : \"qmi\" (s), \"q\" (d) : \"cc\")\n\n#else\n\nstruct flag_struct {\n    uae_u32 cznv;\n    uae_u32 x;\n};\n\n#define FLAGVAL_Z\t0x4000\n#define FLAGVAL_N\t0x8000\n\n#define SET_ZFLG(y)\t(regflags.cznv = (regflags.cznv & ~0x4000) | (((y) & 1) << 14))\n#define SET_CFLG(y)\t(regflags.cznv = (regflags.cznv & ~0x100) | (((y) & 1) << 8))\n#define SET_VFLG(y)\t(regflags.cznv = (regflags.cznv & ~0x1) | (((y) & 1)))\n#define SET_NFLG(y)\t(regflags.cznv = (regflags.cznv & ~0x8000) | (((y) & 1) << 15))\n#define SET_XFLG(y)\t(regflags.x = (y))\n\n#define GET_ZFLG\t((regflags.cznv >> 14) & 1)\n#define GET_CFLG\t((regflags.cznv >> 8) & 1)\n#define GET_VFLG\t((regflags.cznv >> 0) & 1)\n#define GET_NFLG\t((regflags.cznv >> 15) & 1)\n#define GET_XFLG\t(regflags.x & 1)\n\n#define CLEAR_CZNV \t(regflags.cznv = 0)\n#define GET_CZNV\t(regflags.cznv)\n#define IOR_CZNV(X)\t(regflags.cznv |= (X))\n#define SET_CZNV(X)\t(regflags.cznv = (X))\n\n#define COPY_CARRY\t(regflags.x = (regflags.cznv)>>8)\n\nextern struct flag_struct regflags __asm__ (\"regflags\");\n\nstatic __inline__ int cctrue(int cc)\n{\n    uae_u32 cznv = regflags.cznv;\n    switch(cc){\n     case 0: return 1;                       /* T */\n     case 1: return 0;                       /* F */\n     case 2: return (cznv & 0x4100) == 0; /* !GET_CFLG && !GET_ZFLG;  HI */\n     case 3: return (cznv & 0x4100) != 0; /* GET_CFLG || GET_ZFLG;    LS */\n     case 4: return (cznv & 0x100) == 0;  /* !GET_CFLG;               CC */\n     case 5: return (cznv & 0x100) != 0;  /* GET_CFLG;                CS */\n     case 6: return (cznv & 0x4000) == 0; /* !GET_ZFLG;               NE */\n     case 7: return (cznv & 0x4000) != 0; /* GET_ZFLG;                EQ */\n     case 8: return (cznv & 0x01) == 0;   /* !GET_VFLG;               VC */\n     case 9: return (cznv & 0x01) != 0;   /* GET_VFLG;                VS */\n     case 10:return (cznv & 0x8000) == 0; /* !GET_NFLG;               PL */\n     case 11:return (cznv & 0x8000) != 0; /* GET_NFLG;                MI */\n     case 12:return (((cznv << 15) ^ cznv) & 0x8000) == 0; /* GET_NFLG == GET_VFLG;             GE */\n     case 13:return (((cznv << 15) ^ cznv) & 0x8000) != 0;/* GET_NFLG != GET_VFLG;             LT */\n     case 14:\n\tcznv &= 0xc001;\n\treturn (((cznv << 15) ^ cznv) & 0xc000) == 0; /* !GET_ZFLG && (GET_NFLG == GET_VFLG);  GT */\n     case 15:\n\tcznv &= 0xc001;\n\treturn (((cznv << 15) ^ cznv) & 0xc000) != 0; /* GET_ZFLG || (GET_NFLG != GET_VFLG);   LE */\n    }\n    abort();\n    return 0;\n}\n\n/* Manually emit LAHF instruction so that 64-bit assemblers can grok it */\n#if defined __x86_64__ && defined __GNUC__\n#define ASM_LAHF \".byte 0x9f\"\n#else\n#define ASM_LAHF \"lahf\"\n#endif\n\n/* Is there any way to do this without declaring *all* memory clobbered?\n   I.e. any way to tell gcc that some byte-sized value is in %al? */\n#define optflag_testl(v) \\\n  __asm__ __volatile__ (\"andl %0,%0\\n\\t\" \\\n\t\t\tASM_LAHF \"\\n\\t\" \\\n\t\t\t\"seto %%al\\n\\t\" \\\n\t\t\t\"movb %%al,regflags\\n\\t\" \\\n\t\t\t\"movb %%ah,regflags+1\\n\\t\" \\\n\t\t\t: : \"r\" (v) : \"%eax\",\"cc\",\"memory\")\n\n#define optflag_testw(v) \\\n  __asm__ __volatile__ (\"andw %w0,%w0\\n\\t\" \\\n\t\t\tASM_LAHF \"\\n\\t\" \\\n\t\t\t\"seto %%al\\n\\t\" \\\n\t\t\t\"movb %%al,regflags\\n\\t\" \\\n\t\t\t\"movb %%ah,regflags+1\\n\\t\" \\\n\t\t\t: : \"r\" (v) : \"%eax\",\"cc\",\"memory\")\n\n#define optflag_testb(v) \\\n  __asm__ __volatile__ (\"andb %b0,%b0\\n\\t\" \\\n\t\t\tASM_LAHF \"\\n\\t\" \\\n\t\t\t\"seto %%al\\n\\t\" \\\n\t\t\t\"movb %%al,regflags\\n\\t\" \\\n\t\t\t\"movb %%ah,regflags+1\\n\\t\" \\\n\t\t\t: : \"q\" (v) : \"%eax\",\"cc\",\"memory\")\n\n#define optflag_addl(v, s, d) do { \\\n  __asm__ __volatile__ (\"addl %k1,%k0\\n\\t\" \\\n\t\t\tASM_LAHF \"\\n\\t\" \\\n\t\t\t\"seto %%al\\n\\t\" \\\n\t\t\t\"movb %%al,regflags\\n\\t\" \\\n\t\t\t\"movb %%ah,regflags+1\\n\\t\" \\\n\t\t\t: \"=r\" (v) : \"rmi\" (s), \"0\" (d) : \"%eax\",\"cc\",\"memory\"); \\\n\t\t\tCOPY_CARRY; \\\n\t} while (0)\n\n#define optflag_addw(v, s, d) do { \\\n  __asm__ __volatile__ (\"addw %w1,%w0\\n\\t\" \\\n\t\t\tASM_LAHF \"\\n\\t\" \\\n\t\t\t\"seto %%al\\n\\t\" \\\n\t\t\t\"movb %%al,regflags\\n\\t\" \\\n\t\t\t\"movb %%ah,regflags+1\\n\\t\" \\\n\t\t\t: \"=r\" (v) : \"rmi\" (s), \"0\" (d) : \"%eax\",\"cc\",\"memory\"); \\\n\t\t\tCOPY_CARRY; \\\n    } while (0)\n\n#define optflag_addb(v, s, d) do { \\\n  __asm__ __volatile__ (\"addb %b1,%b0\\n\\t\" \\\n\t\t\tASM_LAHF \"\\n\\t\" \\\n\t\t\t\"seto %%al\\n\\t\" \\\n\t\t\t\"movb %%al,regflags\\n\\t\" \\\n\t\t\t\"movb %%ah,regflags+1\\n\\t\" \\\n\t\t\t: \"=q\" (v) : \"qmi\" (s), \"0\" (d) : \"%eax\",\"cc\",\"memory\"); \\\n\t\t\tCOPY_CARRY; \\\n    } while (0)\n\n#define optflag_subl(v, s, d) do { \\\n  __asm__ __volatile__ (\"subl %k1,%k0\\n\\t\" \\\n\t\t\tASM_LAHF \"\\n\\t\" \\\n\t\t\t\"seto %%al\\n\\t\" \\\n\t\t\t\"movb %%al,regflags\\n\\t\" \\\n\t\t\t\"movb %%ah,regflags+1\\n\\t\" \\\n\t\t\t: \"=r\" (v) : \"rmi\" (s), \"0\" (d) : \"%eax\",\"cc\",\"memory\"); \\\n\t\t\tCOPY_CARRY; \\\n    } while (0)\n\n#define optflag_subw(v, s, d) do { \\\n  __asm__ __volatile__ (\"subw %w1,%w0\\n\\t\" \\\n\t\t\tASM_LAHF \"\\n\\t\" \\\n\t\t\t\"seto %%al\\n\\t\" \\\n\t\t\t\"movb %%al,regflags\\n\\t\" \\\n\t\t\t\"movb %%ah,regflags+1\\n\\t\" \\\n\t\t\t: \"=r\" (v) : \"rmi\" (s), \"0\" (d) : \"%eax\",\"cc\",\"memory\"); \\\n\t\t\tCOPY_CARRY; \\\n    } while (0)\n\n#define optflag_subb(v, s, d) do { \\\n   __asm__ __volatile__ (\"subb %b1,%b0\\n\\t\" \\\n\t\t\tASM_LAHF \"\\n\\t\" \\\n\t\t\t\"seto %%al\\n\\t\" \\\n\t\t\t\"movb %%al,regflags\\n\\t\" \\\n\t\t\t\"movb %%ah,regflags+1\\n\\t\" \\\n\t\t\t: \"=q\" (v) : \"qmi\" (s), \"0\" (d) : \"%eax\",\"cc\",\"memory\"); \\\n\t\t\tCOPY_CARRY; \\\n    } while (0)\n\n#define optflag_cmpl(s, d) \\\n  __asm__ __volatile__ (\"cmpl %k0,%k1\\n\\t\" \\\n\t\t\tASM_LAHF \"\\n\\t\" \\\n\t\t\t\"seto %%al\\n\\t\" \\\n\t\t\t\"movb %%al,regflags\\n\\t\" \\\n\t\t\t\"movb %%ah,regflags+1\\n\\t\" \\\n\t\t\t: : \"rmi\" (s), \"r\" (d) : \"%eax\",\"cc\",\"memory\")\n\n#define optflag_cmpw(s, d) \\\n  __asm__ __volatile__ (\"cmpw %w0,%w1\\n\\t\" \\\n\t\t\tASM_LAHF \"\\n\\t\" \\\n\t\t\t\"seto %%al\\n\\t\" \\\n\t\t\t\"movb %%al,regflags\\n\\t\" \\\n\t\t\t\"movb %%ah,regflags+1\\n\\t\" \\\n\t\t\t: : \"rmi\" (s), \"r\" (d) : \"%eax\",\"cc\",\"memory\");\n\n#define optflag_cmpb(s, d) \\\n  __asm__ __volatile__ (\"cmpb %b0,%b1\\n\\t\" \\\n\t\t\tASM_LAHF \"\\n\\t\" \\\n\t\t\t\"seto %%al\\n\\t\" \\\n\t\t\t\"movb %%al,regflags\\n\\t\" \\\n\t\t\t\"movb %%ah,regflags+1\\n\\t\" \\\n\t\t\t: : \"qmi\" (s), \"q\" (d) : \"%eax\",\"cc\",\"memory\")\n\n#endif\n\n#elif defined(__sparc__) && (defined(SPARC_V8_ASSEMBLY) || defined(SPARC_V9_ASSEMBLY))\n\nstruct flag_struct {\n    unsigned char nzvc;\n    unsigned char x;\n};\n\nextern struct flag_struct regflags;\n\n#define FLAGVAL_Z\t0x04\n#define FLAGVAL_N\t0x08\n\n#define SET_ZFLG(y)\t(regflags.nzvc = (regflags.nzvc & ~0x04) | (((y) & 1) << 2))\n#define SET_CFLG(y)\t(regflags.nzvc = (regflags.nzvc & ~1) | ((y) & 1))\n#define SET_VFLG(y)\t(regflags.nzvc = (regflags.nzvc & ~0x02) | (((y) & 1) << 1))\n#define SET_NFLG(y)\t(regflags.nzvc = (regflags.nzvc & ~0x08) | (((y) & 1) << 3))\n#define SET_XFLG(y)\t(regflags.x = (y))\n\n#define GET_ZFLG\t((regflags.nzvc >> 2) & 1)\n#define GET_CFLG\t(regflags.nzvc & 1)\n#define GET_VFLG\t((regflags.nzvc >> 1) & 1)\n#define GET_NFLG\t((regflags.nzvc >> 3) & 1)\n#define GET_XFLG\t(regflags.x & 1)\n\n#define CLEAR_CZNV \t(regflags.nzvc = 0)\n#define GET_CZNV\t(reflags.nzvc)\n#define IOR_CZNV(X)\t(refglags.nzvc |= (X))\n#define SET_CZNV(X)\t(regflags.nzvc = (X))\n\n#define COPY_CARRY (regflags.x = regflags.nzvc)\n\nstatic __inline__ int cctrue(int cc)\n{\n    uae_u32 nzvc = regflags.nzvc;\n    switch(cc){\n     case 0: return 1;                       /* T */\n     case 1: return 0;                       /* F */\n     case 2: return (nzvc & 0x05) == 0; /* !GET_CFLG && !GET_ZFLG;  HI */\n     case 3: return (nzvc & 0x05) != 0; /* GET_CFLG || GET_ZFLG;    LS */\n     case 4: return (nzvc & 1) == 0;        /* !GET_CFLG;               CC */\n     case 5: return (nzvc & 1) != 0;           /* GET_CFLG;                CS */\n     case 6: return (nzvc & 0x04) == 0; /* !GET_ZFLG;               NE */\n     case 7: return (nzvc & 0x04) != 0; /* GET_ZFLG;                EQ */\n     case 8: return (nzvc & 0x02) == 0;/* !GET_VFLG;               VC */\n     case 9: return (nzvc & 0x02) != 0;/* GET_VFLG;                VS */\n     case 10:return (nzvc & 0x08) == 0; /* !GET_NFLG;               PL */\n     case 11:return (nzvc & 0x08) != 0; /* GET_NFLG;                MI */\n     case 12:return (((nzvc << 2) ^ nzvc) & 0x08) == 0; /* GET_NFLG == GET_VFLG;             GE */\n     case 13:return (((nzvc << 2) ^ nzvc) & 0x08) != 0;/* GET_NFLG != GET_VFLG;             LT */\n     case 14:\n\tnzvc &= 0x0e;\n\treturn (((nzvc << 2) ^ nzvc) & 0x0c) == 0; /* !GET_ZFLG && (GET_NFLG == GET_VFLG);  GT */\n     case 15:\n\tnzvc &= 0x0e;\n\treturn (((nzvc << 2) ^ nzvc) & 0x0c) != 0; /* GET_ZFLG || (GET_NFLG != GET_VFLG);   LE */\n    }\n    return 0;\n}\n\n#ifdef SPARC_V8_ASSEMBLY\n\nstatic inline uae_u32 sparc_v8_flag_add_8(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\tuae_u32 value;\n\t__asm__\t(\"\\n\"\n\t\t\"\tsll\t\t%2, 24, %%o0\\n\"\n\t\t\"\tsll\t\t%3, 24, %%o1\\n\"\n\t\t\"\taddcc\t%%o0, %%o1, %%o0\\n\"\n\t\t\"\taddx\t%%g0, %%g0, %%o1\t! X,C flags\\n\"\n\t\t\"\tsrl\t\t%%o0, 24, %0\\n\"\n\t\t\"\tstb\t\t%%o1, [%1 + 1]\\n\"\n\t\t\"\tbl,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o1, 0x08, %%o1\t! N flag\\n\"\n\t\t\"\tbz,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o1, 0x04, %%o1\t! Z flag\\n\"\n\t\t\"\tbvs,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o1, 0x02, %%o1\t! V flag\\n\"\n\t\t\"\tstb\t\t%%o1, [%1]\\n\"\n\t:\t\"=&r\" (value)\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n\treturn value;\n}\n\nstatic inline uae_u32 sparc_v8_flag_add_16(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\tuae_u32 value;\n\t__asm__\t(\"\\n\"\n\t\t\"\tsll\t\t%2, 16, %%o0\\n\"\n\t\t\"\tsll\t\t%3, 16, %%o1\\n\"\n\t\t\"\taddcc\t%%o0, %%o1, %%o0\\n\"\n\t\t\"\taddx\t%%g0, %%g0, %%o1\t! X,C flags\\n\"\n\t\t\"\tsrl\t\t%%o0, 16, %0\\n\"\n\t\t\"\tstb\t\t%%o1, [%1 + 1]\\n\"\n\t\t\"\tbl,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o1, 0x08, %%o1\t! N flag\\n\"\n\t\t\"\tbz,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o1, 0x04, %%o1\t! Z flag\\n\"\n\t\t\"\tbvs,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o1, 0x02, %%o1\t! V flag\\n\"\n\t\t\"\tstb\t\t%%o1, [%1]\\n\"\n\t:\t\"=&r\" (value)\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n\treturn value;\n}\n\nstatic inline uae_u32 sparc_v8_flag_add_32(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\tuae_u32 value;\n\t__asm__\t(\"\\n\"\n\t\t\"\taddcc\t%2, %3, %0\\n\"\n\t\t\"\taddx\t%%g0, %%g0, %%o0\t! X,C flags\\n\"\n\t\t\"\tstb\t\t%%o0, [%1 + 1]\\n\"\n\t\t\"\tbl,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x08, %%o0\t! N flag\\n\"\n\t\t\"\tbz,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x04, %%o0\t! Z flag\\n\"\n\t\t\"\tbvs,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x02, %%o0\t! V flag\\n\"\n\t\t\"\tstb\t\t%%o0, [%1]\\n\"\n\t:\t\"=&r\" (value)\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\"\n\t);\n\treturn value;\n}\n\nstatic inline uae_u32 sparc_v8_flag_sub_8(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\tuae_u32 value;\n\t__asm__\t(\"\\n\"\n\t\t\"\tsll\t\t%2, 24, %%o0\\n\"\n\t\t\"\tsll\t\t%3, 24, %%o1\\n\"\n\t\t\"\tsubcc\t%%o0, %%o1, %%o0\\n\"\n\t\t\"\taddx\t%%g0, %%g0, %%o1\t! X,C flags\\n\"\n\t\t\"\tsrl\t\t%%o0, 24, %0\\n\"\n\t\t\"\tstb\t\t%%o1, [%1 + 1]\\n\"\n\t\t\"\tbl,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o1, 0x08, %%o1\t! N flag\\n\"\n\t\t\"\tbz,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o1, 0x04, %%o1\t! Z flag\\n\"\n\t\t\"\tbvs,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o1, 0x02, %%o1\t! V flag\\n\"\n\t\t\"\tstb\t\t%%o1, [%1]\\n\"\n\t:\t\"=&r\" (value)\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n\treturn value;\n}\n\nstatic inline uae_u32 sparc_v8_flag_sub_16(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\tuae_u32 value;\n\t__asm__\t(\"\\n\"\n\t\t\"\tsll\t\t%2, 16, %%o0\\n\"\n\t\t\"\tsll\t\t%3, 16, %%o1\\n\"\n\t\t\"\tsubcc\t%%o0, %%o1, %%o0\\n\"\n\t\t\"\taddx\t%%g0, %%g0, %%o1\t! X,C flags\\n\"\n\t\t\"\tsrl\t\t%%o0, 16, %0\\n\"\n\t\t\"\tstb\t\t%%o1, [%1 + 1]\\n\"\n\t\t\"\tbl,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o1, 0x08, %%o1\t! N flag\\n\"\n\t\t\"\tbz,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o1, 0x04, %%o1\t! Z flag\\n\"\n\t\t\"\tbvs,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o1, 0x02, %%o1\t! V flag\\n\"\n\t\t\"\tstb\t\t%%o1, [%1]\\n\"\n\t:\t\"=&r\" (value)\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n\treturn value;\n}\n\nstatic inline uae_u32 sparc_v8_flag_sub_32(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\tuae_u32 value;\n\t__asm__\t(\"\\n\"\n\t\t\"\tsubcc\t%2, %3, %0\\n\"\n\t\t\"\taddx\t%%g0, %%g0, %%o0\t! X,C flags\\n\"\n\t\t\"\tstb\t\t%%o0, [%1 + 1]\\n\"\n\t\t\"\tbl,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x08, %%o0\t! N flag\\n\"\n\t\t\"\tbz,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x04, %%o0\t! Z flag\\n\"\n\t\t\"\tbvs,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x02, %%o0\t! V flag\\n\"\n\t\t\"\tstb\t\t%%o0, [%1]\\n\"\n\t:\t\"=&r\" (value)\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\"\n\t);\n\treturn value;\n}\n\nstatic inline void sparc_v8_flag_cmp_8(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\t__asm__\t(\"\\n\"\n\t\t\"\tsll\t\t%1, 24, %%o0\\n\"\n\t\t\"\tsll\t\t%2, 24, %%o1\\n\"\n\t\t\"\tsubcc\t%%o0, %%o1, %%g0\\n\"\n\t\t\"\taddx\t%%g0, %%g0, %%o0\t! C flag\\n\"\n\t\t\"\tbl,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x08, %%o0\t! N flag\\n\"\n\t\t\"\tbz,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x04, %%o0\t! Z flag\\n\"\n\t\t\"\tbvs,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x02, %%o0\t! V flag\\n\"\n\t\t\"\tstb\t\t%%o0, [%0]\\n\"\n\t:\t/* no outputs */\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n}\n\nstatic inline void sparc_v8_flag_cmp_16(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\t__asm__\t(\"\\n\"\n\t\t\"\tsll\t\t%1, 16, %%o0\\n\"\n\t\t\"\tsll\t\t%2, 16, %%o1\\n\"\n\t\t\"\tsubcc\t%%o0, %%o1, %%g0\\n\"\n\t\t\"\taddx\t%%g0, %%g0, %%o0\t! C flag\\n\"\n\t\t\"\tbl,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x08, %%o0\t! N flag\\n\"\n\t\t\"\tbz,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x04, %%o0\t! Z flag\\n\"\n\t\t\"\tbvs,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x02, %%o0\t! V flag\\n\"\n\t\t\"\tstb\t\t%%o0, [%0]\\n\"\n\t:\t/* no outputs */\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n}\n\nstatic inline void sparc_v8_flag_cmp_32(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\t__asm__\t(\"\\n\"\n\t\t\"\tsubcc\t%1, %2, %%o1\\n\"\n\t\t\"\tsrl\t\t%%o1, 31, %%o0\\n\"\n\t\t\"\tsll\t\t%%o0, 3, %%o0\\n\"\n\t\t\"\taddx\t%%o0, %%g0, %%o0\\n\"\n\t\t\"\tbvs,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x02, %%o0\\n\"\n\t\t\"\tsubcc\t%%g0, %%o1, %%g0\\n\"\n\t\t\"\taddx\t%%g0, 7, %%o1\\n\"\n\t\t\"\tand\t\t%%o1, 0x04, %%o1\\n\"\n\t\t\"\tor\t\t%%o0, %%o1, %%o0\\n\"\n\t\t\"\tstb\t\t%%o0, [%0]\\n\"\n\t:\t/* no outputs */\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n}\n\nstatic inline uae_u32 sparc_v8_flag_addx_8(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\tuae_u32 value;\n\t__asm__\t(\"\\n\"\n\t\t\"\tldub\t[%1 + 1], %%o1\t\t! Get the X Flag\\n\"\n\t\t\"\tsubcc\t%%g0, %%o1, %%g0\t! Set the SPARC carry flag, if X set\\n\"\n\t\t\"\taddxcc\t%2, %3, %0\\n\"\n\t:\t\"=&r\" (value)\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n\treturn value;\n}\n\n#if 0\nVERY SLOW...\nstatic inline uae_u32 sparc_v8_flag_addx_8(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\tuae_u32 value;\n\t__asm__\t(\"\\n\"\n\t\t\"\tsll\t\t%2, 24, %%o0\\n\"\n\t\t\"\tsll\t\t%3, 24, %%o1\\n\"\n\t\t\"\taddcc\t%%o0, %%o1, %%o0\\n\"\n\t\t\"\taddx\t%%g0, %%g0, %%o1\t! X,C flags\\n\"\n\t\t\"\tbvs,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o1, 0x02, %%o1\t! V flag\\n\"\n\t\t\"\tldub\t[%1 + 1], %%o2\\n\"\n\t\t\"\tsubcc\t%%g0, %%o2, %%g0\\n\"\n\t\t\"\taddx\t%%g0, %%g0, %%o2\\n\"\n\t\t\"\tsll\t\t%%o2, 24, %%o2\\n\"\n\t\t\"\taddcc\t%%o0, %%o2, %%o0\\n\"\n\t\t\"\tsrl\t\t%%o0, 24, %0\\n\"\n\t\t\"\taddx\t%%g0, %%g0, %%o2\\n\"\n\t\t\"\tor\t\t%%o1, %%o2, %%o1\t! update X,C flags\\n\"\n\t\t\"\tbl,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o1, 0x08, %%o1\t! N flag\\n\"\n\t\t\"\tldub\t[%1], %%o0\t\t\t! retreive the old NZVC flags (XXX)\\n\"\n\t\t\"\tbvs,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o1, 0x02, %%o1\t! update V flag\\n\"\n\t\t\"\tand\t\t%%o0, 0x04, %%o0\t! (XXX) but keep only Z flag\\n\"\n\t\t\"\tand\t\t%%o1, 1, %%o2\t\t! keep C flag in %%o2\\n\"\n\t\t\"\tbnz,a\t.+8\\n\"\n\t\t\"\tor\t\t%%g0, %%g0, %%o0\t! Z flag cleared if non-zero result\\n\"\n\t\t\"\tstb\t\t%%o2, [%1 + 1]\t\t! store the X flag\\n\"\n\t\t\"\tor\t\t%%o1, %%o0, %%o1\\n\"\n\t\t\"\tstb\t\t%%o1, [%1]\\n\"\n\t:\t\"=&r\" (value)\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\", \"o1\", \"o2\"\n\t);\n\treturn value;\n}\n#endif\n\nstatic inline uae_u32 sparc_v8_flag_addx_32(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\tuae_u32 value;\n\t__asm__\t(\"\\n\"\n\t\t\"\tldub\t[%1 + 1], %%o0\t\t! Get the X Flag\\n\"\n\t\t\"\tsubcc\t%%g0, %%o0, %%g0\t! Set the SPARC carry flag, if X set\\n\"\n\t\t\"\taddxcc\t%2, %3, %0\\n\"\n\t\t\"\tldub\t[%1], %%o0\t\t\t! retreive the old NZVC flags\\n\"\n\t\t\"\tand\t\t%%o0, 0x04, %%o0\t! but keep only Z flag\\n\"\n\t\t\"\taddx\t%%o0, %%g0, %%o0\t! X,C flags\\n\"\n\t\t\"\tbl,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x08, %%o0\t! N flag\\n\"\n\t\t\"\tbvs,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x02, %%o0\t! V flag\\n\"\n\t\t\"\tbnz,a\t.+8\\n\"\n\t\t\"\tand\t\t%%o0, 0x0B, %%o0\t! Z flag cleared if result is non-zero\\n\"\n\t\t\"\tstb\t\t%%o0, [%1]\\n\"\n\t\t\"\tstb\t\t%%o0, [%1 + 1]\\n\"\n\t:\t\"=&r\" (value)\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\"\n\t);\n\treturn value;\n}\n\n#endif /* SPARC_V8_ASSEMBLY */\n\n#ifdef SPARC_V9_ASSEMBLY\n\nstatic inline uae_u32 sparc_v9_flag_add_8(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\tuae_u32 value;\n\t__asm__\t(\"\\n\"\n\t\t\"\tsll\t\t%2, 24, %%o0\\n\"\n\t\t\"\tsll\t\t%3, 24, %%o1\\n\"\n\t\t\"\taddcc\t%%o0, %%o1, %%o0\\n\"\n\t\t\"\trd\t\t%%ccr, %%o1\\n\"\n\t\t\"\tsrl\t\t%%o0, 24, %0\\n\"\n\t\t\"\tstb\t\t%%o1, [%1]\\n\"\n\t\t\"\tstb\t\t%%o1, [%1+1]\\n\"\n\t:\t\"=&r\" (value)\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n\treturn value;\n}\n\nstatic inline uae_u32 sparc_v9_flag_add_16(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\tuae_u32 value;\n\t__asm__\t(\"\\n\"\n\t\t\"\tsll\t\t%2, 16, %%o0\\n\"\n\t\t\"\tsll\t\t%3, 16, %%o1\\n\"\n\t\t\"\taddcc\t%%o0, %%o1, %%o0\\n\"\n\t\t\"\trd\t\t%%ccr, %%o1\\n\"\n\t\t\"\tsrl\t\t%%o0, 16, %0\\n\"\n\t\t\"\tstb\t\t%%o1, [%1]\\n\"\n\t\t\"\tstb\t\t%%o1, [%1+1]\\n\"\n\t:\t\"=&r\" (value)\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n\treturn value;\n}\n\nstatic inline uae_u32 sparc_v9_flag_add_32(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\tuae_u32 value;\n\t__asm__\t(\"\\n\"\n\t\t\"\taddcc\t%2, %3, %0\\n\"\n\t\t\"\trd\t\t%%ccr, %%o0\\n\"\n\t\t\"\tstb\t\t%%o0, [%1]\\n\"\n\t\t\"\tstb\t\t%%o0, [%1+1]\\n\"\n\t:\t\"=&r\" (value)\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\"\n\t);\n\treturn value;\n}\n\nstatic inline uae_u32 sparc_v9_flag_sub_8(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\tuae_u32 value;\n\t__asm__\t(\"\\n\"\n\t\t\"\tsll\t\t%2, 24, %%o0\\n\"\n\t\t\"\tsll\t\t%3, 24, %%o1\\n\"\n\t\t\"\tsubcc\t%%o0, %%o1, %%o0\\n\"\n\t\t\"\trd\t\t%%ccr, %%o1\\n\"\n\t\t\"\tsrl\t\t%%o0, 24, %0\\n\"\n\t\t\"\tstb\t\t%%o1, [%1]\\n\"\n\t\t\"\tstb\t\t%%o1, [%1+1]\\n\"\n\t:\t\"=&r\" (value)\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n\treturn value;\n}\n\nstatic inline uae_u32 sparc_v9_flag_sub_16(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\tuae_u32 value;\n\t__asm__\t(\"\\n\"\n\t\t\"\tsll\t\t%2, 16, %%o0\\n\"\n\t\t\"\tsll\t\t%3, 16, %%o1\\n\"\n\t\t\"\tsubcc\t%%o0, %%o1, %%o0\\n\"\n\t\t\"\trd\t\t%%ccr, %%o1\\n\"\n\t\t\"\tsrl\t\t%%o0, 16, %0\\n\"\n\t\t\"\tstb\t\t%%o1, [%1]\\n\"\n\t\t\"\tstb\t\t%%o1, [%1+1]\\n\"\n\t:\t\"=&r\" (value)\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n\treturn value;\n}\n\nstatic inline uae_u32 sparc_v9_flag_sub_32(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\tuae_u32 value;\n\t__asm__\t(\"\\n\"\n\t\t\"\tsubcc\t%2, %3, %0\\n\"\n\t\t\"\trd\t\t%%ccr, %%o0\\n\"\n\t\t\"\tstb\t\t%%o0, [%1]\\n\"\n\t\t\"\tstb\t\t%%o0, [%1+1]\\n\"\n\t:\t\"=&r\" (value)\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\"\n\t);\n\treturn value;\n}\n\nstatic inline void sparc_v9_flag_cmp_8(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\t__asm__\t(\"\\n\"\n\t\t\"\tsll\t\t%1, 24, %%o0\\n\"\n\t\t\"\tsll\t\t%2, 24, %%o1\\n\"\n\t\t\"\tsubcc\t%%o0, %%o1, %%g0\\n\"\n\t\t\"\trd\t\t%%ccr, %%o0\\n\"\n\t\t\"\tstb\t\t%%o0, [%0]\\n\"\n\t:\t/* no outputs */\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n}\n\nstatic inline void sparc_v9_flag_cmp_16(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\t__asm__\t(\"\\n\"\n\t\t\"\tsll\t\t%1, 16, %%o0\\n\"\n\t\t\"\tsll\t\t%2, 16, %%o1\\n\"\n\t\t\"\tsubcc\t%%o0, %%o1, %%g0\\n\"\n\t\t\"\trd\t\t%%ccr, %%o0\\n\"\n\t\t\"\tstb\t\t%%o0, [%0]\\n\"\n\t:\t/* no outputs */\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n}\n\nstatic inline void sparc_v9_flag_cmp_32(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\t__asm__\t(\"\\n\"\n\t\t\"\tsubcc\t%1, %2, %%g0\\n\"\n#if 0\n\t\t\"\tsubcc\t%1, %2, %%o1\\n\"\n\t\t\"\tsrl\t\t%%o1, 31, %%o0\\n\"\n\t\t\"\tsll\t\t%%o0, 3, %%o0\\n\"\n\t\t\"\taddx\t%%o0, %%g0, %%o0\\n\"\n\t\t\"\tbvs,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x02, %%o0\\n\"\n\t\t\"\tsubcc\t%%g0, %%o1, %%g0\\n\"\n\t\t\"\taddx\t%%g0, 7, %%o1\\n\"\n\t\t\"\tand\t\t%%o1, 0x04, %%o1\\n\"\n\t\t\"\tor\t\t%%o0, %%o1, %%o0\\n\"\n#endif\n#if 0\n\t\t\"\tsubcc\t%1, %2, %%o1\\n\"\n\t\t\"\tsrl\t\t%%o1, 31, %%o0\\n\"\n\t\t\"\tsll\t\t%%o0, 3, %%o0\\n\"\n\t\t\"\taddx\t%%o0, %%g0, %%o0\\n\"\n\t\t\"\tbvs,pt,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x02, %%o0\\n\"\n\t\t\"\tsubcc\t%%g0, %%o1, %%g0\\n\"\n\t\t\"\taddx\t%%g0, 7, %%o1\\n\"\n\t\t\"\tand\t\t%%o1, 0x04, %%o1\\n\"\n\t\t\"\tor\t\t%%o0, %%o1, %%o0\\n\"\n\t\t\"\tstb\t\t%%o0, [%0]\\n\"\n#endif\n\t\t\"\trd\t\t%%ccr, %%o0\\n\"\n\t\t\"\tstb\t\t%%o0, [%0]\\n\"\n\t:\t/* no outputs */\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n}\n\n#if 1\nstatic inline void sparc_v9_flag_test_8(flag_struct *flags, uae_u32 val)\n{\n\t__asm__\t(\"\\n\"\n\t\t\"\tsll\t\t%1, 24, %%o0\\n\"\n\t\t\"\tsubcc\t%%o0, %%g0, %%g0\\n\"\n\t\t\"\trd\t\t%%ccr, %%o0\\n\"\n\t\t\"\tstb\t\t%%o0, [%0]\\n\"\n\t:\t/* no outputs */\n\t:\t\"r\" (flags), \"r\" (val)\n\t:\t\"cc\", \"o0\"\n\t);\n}\n\nstatic inline void sparc_v9_flag_test_16(flag_struct *flags, uae_u32 val)\n{\n\t__asm__\t(\"\\n\"\n\t\t\"\tsll\t\t%1, 16, %%o0\\n\"\n\t\t\"\tsubcc\t%%o0, %%g0, %%g0\\n\"\n\t\t\"\trd\t\t%%ccr, %%o0\\n\"\n\t\t\"\tstb\t\t%%o0, [%0]\\n\"\n\t:\t/* no outputs */\n\t:\t\"r\" (flags), \"r\" (val)\n\t:\t\"cc\", \"o0\"\n\t);\n}\n\nstatic inline void sparc_v9_flag_test_32(flag_struct *flags, uae_u32 val)\n{\n\t__asm__\t(\"\\n\"\n\t\t\"\tsubcc\t%1, %%g0, %%g0\\n\"\n\t\t\"\trd\t\t%%ccr, %%o0\\n\"\n\t\t\"\tstb\t\t%%o0, [%0]\\n\"\n\t:\t/* no outputs */\n\t:\t\"r\" (flags), \"r\" (val)\n\t:\t\"cc\", \"o0\"\n\t);\n}\n#else\nstatic inline void sparc_v9_flag_test_8(flag_struct *flags, uae_u32 val)\n{\n\t__asm__\t(\"\\n\"\n\t\t\"\tsll\t\t%1, 24, %%o0\\n\"\n\t\t\"\tsubcc\t%%o0, %%g0, %%o1\\n\"\n\t\t\"\tsrl\t\t%%o1, 31, %%o0\\n\"\n\t\t\"\tsll\t\t%%o0, 3, %%o0\\n\"\n\t\t\"\taddx\t%%o0, %%g0, %%o0\\n\"\n\t\t\"\tbvs,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x02, %%o0\\n\"\n\t\t\"\tsubcc\t%%g0, %%o1, %%g0\\n\"\n\t\t\"\taddx\t%%g0, 7, %%o1\\n\"\n\t\t\"\tand\t\t%%o1, 0x04, %%o1\\n\"\n\t\t\"\tor\t\t%%o0, %%o1, %%o0\\n\"\n\t\t\"\tstb\t\t%%o0, [%0]\\n\"\n\t:\t/* no outputs */\n\t:\t\"r\" (flags), \"r\" (val)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n}\n\nstatic inline void sparc_v9_flag_test_16(flag_struct *flags, uae_u32 val)\n{\n\t__asm__\t(\"\\n\"\n\t\t\"\tsll\t\t%1, 16, %%o0\\n\"\n\t\t\"\tsubcc\t%%o0, %%g0, %%o1\\n\"\n\t\t\"\tsrl\t\t%%o1, 31, %%o0\\n\"\n\t\t\"\tsll\t\t%%o0, 3, %%o0\\n\"\n\t\t\"\taddx\t%%o0, %%g0, %%o0\\n\"\n\t\t\"\tbvs,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x02, %%o0\\n\"\n\t\t\"\tsubcc\t%%g0, %%o1, %%g0\\n\"\n\t\t\"\taddx\t%%g0, 7, %%o1\\n\"\n\t\t\"\tand\t\t%%o1, 0x04, %%o1\\n\"\n\t\t\"\tor\t\t%%o0, %%o1, %%o0\\n\"\n\t\t\"\tstb\t\t%%o0, [%0]\\n\"\n\t:\t/* no outputs */\n\t:\t\"r\" (flags), \"r\" (val)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n}\n\nstatic inline void sparc_v9_flag_test_32(flag_struct *flags, uae_u32 val)\n{\n\t__asm__\t(\"\\n\"\n\t\t\"\tsubcc\t%1, %%g0, %%o1\\n\"\n\t\t\"\tsrl\t\t%%o1, 31, %%o0\\n\"\n\t\t\"\tsll\t\t%%o0, 3, %%o0\\n\"\n\t\t\"\taddx\t%%o0, %%g0, %%o0\\n\"\n\t\t\"\tbvs,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x02, %%o0\\n\"\n\t\t\"\tsubcc\t%%g0, %%o1, %%g0\\n\"\n\t\t\"\taddx\t%%g0, 7, %%o1\\n\"\n\t\t\"\tand\t\t%%o1, 0x04, %%o1\\n\"\n\t\t\"\tor\t\t%%o0, %%o1, %%o0\\n\"\n\t\t\"\tstb\t\t%%o0, [%0]\\n\"\n\t:\t/* no outputs */\n\t:\t\"r\" (flags), \"r\" (val)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n}\n#endif\n\nstatic inline uae_u32 sparc_v9_flag_addx_8(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\tuae_u32 value;\n\t__asm__\t(\"\\n\"\n\t\t\"\tldub\t[%1 + 1], %%o1\t\t! Get the X Flag\\n\"\n\t\t\"\tsubcc\t%%g0, %%o1, %%g0\t! Set the SPARC carry flag, if X set\\n\"\n\t\t\"\taddxcc\t%2, %3, %0\\n\"\n\t:\t\"=&r\" (value)\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\", \"o1\"\n\t);\n\treturn value;\n}\n\nstatic inline uae_u32 sparc_v9_flag_addx_32(flag_struct *flags, uae_u32 src, uae_u32 dst)\n{\n\tuae_u32 value;\n\t__asm__\t(\"\\n\"\n\t\t\"\tldub\t[%1 + 1], %%o0\t\t! Get the X Flag\\n\"\n\t\t\"\tsubcc\t%%g0, %%o0, %%g0\t! Set the SPARC carry flag, if X set\\n\"\n\t\t\"\taddxcc\t%2, %3, %0\\n\"\n\t\t\"\tldub\t[%1], %%o0\t\t\t! retreive the old NZVC flags\\n\"\n\t\t\"\tand\t\t%%o0, 0x04, %%o0\t! but keep only Z flag\\n\"\n\t\t\"\taddx\t%%o0, %%g0, %%o0\t! X,C flags\\n\"\n\t\t\"\tbl,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x08, %%o0\t! N flag\\n\"\n\t\t\"\tbvs,a\t.+8\\n\"\n\t\t\"\tor\t\t%%o0, 0x02, %%o0\t! V flag\\n\"\n\t\t\"\tbnz,a\t.+8\\n\"\n\t\t\"\tand\t\t%%o0, 0x0B, %%o0\t! Z flag cleared if result is non-zero\\n\"\n\t\t\"\tstb\t\t%%o0, [%1]\\n\"\n\t\t\"\tstb\t\t%%o0, [%1 + 1]\\n\"\n\t:\t\"=&r\" (value)\n\t:\t\"r\" (flags), \"r\" (dst), \"r\" (src)\n\t:\t\"cc\", \"o0\"\n\t);\n\treturn value;\n}\n\n#endif /* SPARC_V9_ASSEMBLY */\n\n#endif\n\n#else\n\nstruct flag_struct {\n    unsigned int c;\n    unsigned int z;\n    unsigned int n;\n    unsigned int v; \n    unsigned int x;\n};\n\nextern struct flag_struct regflags;\n\n#define ZFLG (regflags.z)\n#define NFLG (regflags.n)\n#define CFLG (regflags.c)\n#define VFLG (regflags.v)\n#define XFLG (regflags.x)\n\n#define SET_CFLG(x) (CFLG = (x))\n#define SET_NFLG(x) (NFLG = (x))\n#define SET_VFLG(x) (VFLG = (x))\n#define SET_ZFLG(x) (ZFLG = (x))\n#define SET_XFLG(x) (XFLG = (x))\n\n#define GET_CFLG CFLG\n#define GET_NFLG NFLG\n#define GET_VFLG VFLG\n#define GET_ZFLG ZFLG\n#define GET_XFLG XFLG\n\n#define CLEAR_CZNV do { \\\n SET_CFLG (0); \\\n SET_ZFLG (0); \\\n SET_NFLG (0); \\\n SET_VFLG (0); \\\n} while (0)\n\n#define COPY_CARRY (SET_XFLG (GET_CFLG))\n\nstatic __inline__ int cctrue(const int cc)\n{\n    switch(cc){\n     case 0: return 1;                       /* T */\n     case 1: return 0;                       /* F */\n     case 2: return !CFLG && !ZFLG;          /* HI */\n     case 3: return CFLG || ZFLG;            /* LS */\n     case 4: return !CFLG;                   /* CC */\n     case 5: return CFLG;                    /* CS */\n     case 6: return !ZFLG;                   /* NE */\n     case 7: return ZFLG;                    /* EQ */\n     case 8: return !VFLG;                   /* VC */\n     case 9: return VFLG;                    /* VS */\n     case 10:return !NFLG;                   /* PL */\n     case 11:return NFLG;                    /* MI */\n     case 12:return NFLG == VFLG;            /* GE */\n     case 13:return NFLG != VFLG;            /* LT */\n     case 14:return !ZFLG && (NFLG == VFLG); /* GT */\n     case 15:return ZFLG || (NFLG != VFLG);  /* LE */\n    }\n    return 0;\n}\n\n#endif /* OPTIMIZED_FLAGS */\n\n#endif /* M68K_FLAGS_H */\n","/*\n *  cdrom.cpp - CD-ROM driver\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/*\n *  SEE ALSO\n *    Inside Macintosh: Devices, chapter 1 \"Device Manager\"\n *    Technote DV 05: \"Drive Queue Elements\"\n *    Technote DV 22: \"CD-ROM Driver Calls\"\n *    Technote DV 23: \"Driver Education\"\n *    Technote FL 24: \"Don't Look at ioPosOffset for Devices\"\n *    Technote FL 36: \"Apple Extensions to ISO 9660\"\n */\n\n#include \"sysdeps.h\"\n\n#include <string.h>\n#include <vector>\n\n#ifndef NO_STD_NAMESPACE\nusing std::vector;\n#endif\n\n#include \"cpu_emulation.h\"\n#include \"main.h\"\n#include \"macos_util.h\"\n#include \"sys.h\"\n#include \"prefs.h\"\n#include \"cdrom.h\"\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n// CDROM disk/drive icon\nconst uint8 CDROMIcon[258] = {\n\t0x3f, 0xff, 0xff, 0xf0, 0x40, 0x00, 0x00, 0x08, 0x80, 0x1f, 0xc0, 0x04, 0x80, 0x75, 0x70, 0x04,\n\t0x81, 0xaa, 0xac, 0x04, 0x83, 0x55, 0x56, 0x04, 0x86, 0xaa, 0xab, 0x04, 0x8d, 0x55, 0x55, 0x84,\n\t0x8a, 0xaa, 0xaa, 0xc4, 0x95, 0x5f, 0xd5, 0x44, 0x9a, 0xb0, 0x6a, 0xe4, 0xb5, 0x67, 0x35, 0x64,\n\t0xaa, 0xcf, 0x9a, 0xb4, 0xb5, 0x5c, 0x55, 0x74, 0xaa, 0xd8, 0x5a, 0xb4, 0xb5, 0x58, 0x55, 0x74,\n\t0xaa, 0xc8, 0x9a, 0xb4, 0xb5, 0x67, 0x35, 0x74, 0x9a, 0xb0, 0x6a, 0xf4, 0x95, 0x5f, 0xd5, 0x64,\n\t0x8a, 0xaa, 0xaa, 0xe4, 0x8d, 0x55, 0x55, 0xc4, 0x86, 0xaa, 0xab, 0xc4, 0x83, 0x55, 0x57, 0x84,\n\t0x81, 0xaa, 0xaf, 0x04, 0x80, 0xf5, 0x7e, 0x04, 0x80, 0x3f, 0xf8, 0x04, 0x80, 0x0f, 0xe0, 0x04,\n\t0xff, 0xff, 0xff, 0xfc, 0x80, 0x00, 0x00, 0x04, 0x80, 0x1f, 0xf0, 0x04, 0x7f, 0xff, 0xff, 0xf8,\n\n\t0x3f, 0xff, 0xff, 0xf0, 0x7f, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc,\n\t0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc,\n\t0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc,\n\t0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc,\n\t0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc,\n\t0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc,\n\t0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc,\n\t0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 0xf8,\n\n\t0, 0\n};\n\n\n// Tables for converting bin<->BCD\nstatic const uint8 bin2bcd[256] = {\n\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,\n\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,\n\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29,\n\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,\n\t0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,\n\t0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,\n\t0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,\n\t0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,\n\t0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,\n\t0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n};\n\nstatic const uint8 bcd2bin[256] = {\n\t 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n};\n\n\n// Struct for each drive\nstruct cdrom_drive_info {\n\tcdrom_drive_info() : num(0), fh(NULL), start_byte(0), status(0) {}\n\tcdrom_drive_info(void *fh_) : num(0), fh(fh_), start_byte(0), status(0) {}\n\n\tvoid close_fh(void) { SysAllowRemoval(fh); Sys_close(fh); }\n\n\tint num;\t\t\t// Drive number\n\tvoid *fh;\t\t\t// File handle\n\tint block_size;\t\t// CD-ROM block size\n\tint twok_offset;\t// Offset of beginning of 2K block to last Prime position\n\tloff_t start_byte;\t// Start of HFS partition on disk\n\tbool to_be_mounted;\t// Flag: drive must be mounted in accRun\n\tbool mount_non_hfs;\t// Flag: Issue disk-inserted events for non-HFS disks\n\n\tuint8 toc[804];\t\t// TOC of currently inserted disk\n\tuint8 lead_out[3];\t// MSF address of lead-out track\n\tuint8 stop_at[3];\t// MSF address of audio play stopping point\n\n\tuint8 play_mode;\t// Audio play mode\n\tuint8 power_mode;\t// Power mode\n\tuint32 status;\t\t// Mac address of drive status record\n};\n\n// List of drives handled by this driver\ntypedef vector<cdrom_drive_info> drive_vec;\nstatic drive_vec drives;\n\n// Icon address (Mac address space, set by PatchROM())\nuint32 CDROMIconAddr;\n\n// Flag: Control(accRun) has been called, interrupt routine is now active\nstatic bool acc_run_called = false;\n\n\n/*\n *  Get pointer to drive info or drives.end() if not found\n */\n\nstatic drive_vec::iterator get_drive_info(int num)\n{\n\tdrive_vec::iterator info, end = drives.end();\n\tfor (info = drives.begin(); info != end; ++info) {\n\t\tif (info->num == num)\n\t\t\treturn info;\n\t}\n\treturn info;\n}\n\n\n/*\n *  Find HFS partition, set info->start_byte (0 = no HFS partition)\n */\n\nstatic void find_hfs_partition(cdrom_drive_info &info)\n{\n\tinfo.start_byte = 0;\n\tuint8 *map = new uint8[512];\n\tD(bug(\"Looking for HFS partitions on CD-ROM...\\n\"));\n\n\t// Search first 64 blocks for HFS partition\n\tfor (int i=0; i<64; i++) {\n\t\tif (Sys_read(info.fh, map, i * 512, 512) != 512)\n\t\t\tbreak;\n\t\tD(bug(\" block %d, signature '%c%c' (%02x%02x)\\n\", i, map[0], map[1], map[0], map[1]));\n\n\t\t// Not a partition map block? Then look at next block\n\t\tuint16 sig = (map[0] << 8) | map[1];\n\t\tif (sig != 0x504d)\n\t\t\tcontinue;\n\n\t\t// Partition map block found, Apple HFS partition?\n\t\tif (strcmp((char *)(map + 48), \"Apple_HFS\") == 0) {\n\t\t\tinfo.start_byte = (loff_t)((map[8] << 24) | (map[9] << 16) | (map[10] << 8) | map[11]) << 9;\n\t\t\tuint32 num_blocks = (map[12] << 24) | (map[13] << 16) | (map[14] << 8) | map[15];\n\t\t\tD(bug(\" HFS partition found at %d, %d blocks\\n\", info.start_byte, num_blocks));\n\t\t\tbreak;\n\t\t}\n\t}\n\tdelete[] map;\n}\n\n\n/*\n *  Read TOC of disk and set lead_out\n */\n\nstatic void read_toc(cdrom_drive_info &info)\n{\n\t// Read TOC\n\tmemset(info.toc, 0, sizeof(info.toc));\n\tSysCDReadTOC(info.fh, info.toc);\n\n#if DEBUG\n\t// Dump TOC for debugging\n\tD(bug(\" TOC:\\n  %02x%02x%02x%02x        : %d bytes, first track = %d, last track = %d\\n\", info.toc[0], info.toc[1], info.toc[2], info.toc[3], (info.toc[0] << 8) | info.toc[1], info.toc[2], info.toc[3]));\n\tfor (int i=4; i<804; i+=8) {\n\t\tD(bug(\"  %02x%02x%02x%02x%02x%02x%02x%02x: \", info.toc[i+0], info.toc[i+1], info.toc[i+2], info.toc[i+3], info.toc[i+4], info.toc[i+5], info.toc[i+6], info.toc[i+7]));\n\t\tconst char *type = (info.toc[i+2] == 0xaa ? \"lead-out\" : (info.toc[i+1] & 0x04 ? \"data\" : \"audio\"));\n\t\tD(bug(\"track %d (%s), addr/ctrl 0x%02x, M %d S %d F %d\\n\", info.toc[i+2], type, info.toc[i+1], info.toc[i+5], info.toc[i+6], info.toc[i+7]));\n\t\tif (info.toc[i+2] == 0xaa)\n\t\t\tbreak;\n\t}\n#endif\n\n\t// Find lead-out track\n\tinfo.lead_out[0] = 0;\n\tinfo.lead_out[1] = 0;\n\tinfo.lead_out[2] = 0;\n\tfor (int i=4; i<804; i+=8) {\n\t\tif (info.toc[i+2] == 0xaa) {\n\t\t\tinfo.stop_at[0] = info.lead_out[0] = info.toc[i+5];\n\t\t\tinfo.stop_at[1] = info.lead_out[1] = info.toc[i+6];\n\t\t\tinfo.stop_at[2] = info.lead_out[2] = info.toc[i+7];\n\t\t\tbreak;\n\t\t}\n\t}\n\tD(bug(\" Lead-Out M %d S %d F %d\\n\", info.lead_out[0], info.lead_out[1], info.lead_out[2]));\n}\n\n\n/*\n *  Convert audio positioning type/position to MSF address\n *  Return: false = error\n */\n\nstatic bool position2msf(const cdrom_drive_info &info, uint16 postype, uint32 pos, bool stopping, uint8 &m, uint8 &s, uint8 &f)\n{\n\tswitch (postype) {\n\t\tcase 0:\n\t\t\tm = pos / (60 * 75);\n\t\t\ts = (pos / 75) % 60;\n\t\t\tf = pos % 75;\n\t\t\treturn true;\n\t\tcase 1:\n\t\t\tm = bcd2bin[(pos >> 16) & 0xff];\n\t\t\ts = bcd2bin[(pos >> 8) & 0xff];\n\t\t\tf = bcd2bin[pos & 0xff];\n\t\t\treturn true;\n\t\tcase 2: {\n\t\t\tuint8 track = bcd2bin[pos & 0xff];\n\t\t\tif (stopping)\n\t\t\t\ttrack++;\n\t\t\tfor (int i=4; i<804; i+=8) {\n\t\t\t\tif (info.toc[i+2] == track || info.toc[i+2] == 0xaa) {\n\t\t\t\t\tm = info.toc[i+5];\n\t\t\t\t\ts = info.toc[i+6];\n\t\t\t\t\tf = info.toc[i+7];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n\n/*\n *  Initialization\n */\n\nvoid CDROMInit(void)\n{\n\t// No drives specified in prefs? Then add defaults\n\tif (PrefsFindString(\"cdrom\", 0) == NULL)\n\t\tSysAddCDROMPrefs();\n\n\t// Add drives specified in preferences\n\tint index = 0;\n\tconst char *str;\n\twhile ((str = PrefsFindString(\"cdrom\", index++)) != NULL) {\n\t\tvoid *fh = Sys_open(str, true);\n\t\tif (fh)\n\t\t\tdrives.push_back(cdrom_drive_info(fh));\n\t}\n}\n\n\n/*\n *  Deinitialization\n */\n\nvoid CDROMExit(void)\n{\n\tdrive_vec::iterator info, end = drives.end();\n\tfor (info = drives.begin(); info != end; ++info)\n\t\tinfo->close_fh();\n\tdrives.clear();\n}\n\n\n/*\n *  Disk was inserted, flag for mounting\n */\n\nbool CDROMMountVolume(void *fh)\n{\n\tdrive_vec::iterator info = drives.begin(), end = drives.end();\n\twhile (info != end && info->fh != fh)\n\t\t++info;\n\tif (info != end) {\n\t\tif (SysIsDiskInserted(info->fh)) {\n\t\t\tSysPreventRemoval(info->fh);\n\t\t\tWriteMacInt8(info->status + dsDiskInPlace, 1);\n\t\t\tread_toc(*info);\n\t\t\tfind_hfs_partition(*info);\n\t\t\tif (info->start_byte != 0 || info->mount_non_hfs)\n\t\t\t\tinfo->to_be_mounted = true;\n\t\t}\n\t\treturn true;\n\t} else\n\t\treturn false;\n}\n\n\n/*\n *  Mount volumes for which the to_be_mounted flag is set\n *  (called during interrupt time)\n */\n\nstatic void mount_mountable_volumes(void)\n{\n\tdrive_vec::iterator info, end = drives.end();\n\tfor (info = drives.begin(); info != end; ++info) {\n\n\t\t// Disk in drive?\n\t\tif (ReadMacInt8(info->status + dsDiskInPlace) == 0) {\n\n\t\t\t// No, check if disk was inserted\n\t\t\tif (SysIsDiskInserted(info->fh))\n\t\t\t\tCDROMMountVolume(info->fh);\n\t\t}\n\n\t\t// Mount disk if flagged\n\t\tif (info->to_be_mounted) {\n\t\t\tD(bug(\" mounting drive %d\\n\", info->num));\n\t\t\tM68kRegisters r;\n\t\t\tr.d[0] = info->num;\n\t\t\tr.a[0] = 7;\t// diskEvent\n\t\t\tExecute68kTrap(0xa02f, &r);\t\t// PostEvent()\n\t\t\tinfo->to_be_mounted = false;\n\t\t}\n\t}\n}\n\n\n/*\n *  Driver Open() routine\n */\n\nint16 CDROMOpen(uint32 pb, uint32 dce)\n{\n\tD(bug(\"CDROMOpen\\n\"));\n\n\t// Set up DCE\n\tWriteMacInt32(dce + dCtlPosition, 0);\n\tacc_run_called = false;\n\n\t// Install drives\n\tdrive_vec::iterator info, end = drives.end();\n\tfor (info = drives.begin(); info != end; ++info) {\n\n\t\tinfo->num = FindFreeDriveNumber(1);\n\t\tinfo->to_be_mounted = false;\n\n\t\tif (info->fh) {\n\t\t\tinfo->mount_non_hfs = true;\n\t\t\tinfo->block_size = 512;\n\t\t\tinfo->twok_offset = -1;\n\t\t\tinfo->play_mode = 0x09;\n\t\t\tinfo->power_mode = 0;\n\n\t\t\t// Allocate drive status record\n\t\t\tM68kRegisters r;\n\t\t\tr.d[0] = SIZEOF_DrvSts;\n\t\t\tExecute68kTrap(0xa71e, &r);\t\t// NewPtrSysClear()\n\t\t\tif (r.a[0] == 0)\n\t\t\t\tcontinue;\n\t\t\tinfo->status = r.a[0];\n\t\t\tD(bug(\" DrvSts at %08lx\\n\", info->status));\n\n\t\t\t// Set up drive status\n\t\t\tWriteMacInt8(info->status + dsWriteProt, 0x80);\n\t\t\tWriteMacInt8(info->status + dsInstalled, 1);\n\t\t\tWriteMacInt8(info->status + dsSides, 1);\n\n\t\t\t// Disk in drive?\n\t\t\tif (SysIsDiskInserted(info->fh)) {\n\t\t\t\tSysPreventRemoval(info->fh);\n\t\t\t\tWriteMacInt8(info->status + dsDiskInPlace, 1);\n\t\t\t\tread_toc(*info);\n\t\t\t\tfind_hfs_partition(*info);\n\t\t\t\tinfo->to_be_mounted = true;\n\t\t\t}\n\n\t\t\t// Add drive to drive queue\n\t\t\tD(bug(\" adding drive %d\\n\", info->num));\n\t\t\tr.d[0] = (info->num << 16) | (CDROMRefNum & 0xffff);\n\t\t\tr.a[0] = info->status + dsQLink;\n\t\t\tExecute68kTrap(0xa04e, &r);\t\t// AddDrive()\n\t\t}\n\t}\n\treturn noErr;\n}\n\n\n/*\n *  Driver Prime() routine\n */\n\nint16 CDROMPrime(uint32 pb, uint32 dce)\n{\n\tWriteMacInt32(pb + ioActCount, 0);\n\n\t// Drive valid and disk inserted?\n\tdrive_vec::iterator info = get_drive_info(ReadMacInt16(pb + ioVRefNum));\n\tif (info == drives.end())\n\t\treturn nsDrvErr;\n\tif (ReadMacInt8(info->status + dsDiskInPlace) == 0)\n\t\treturn offLinErr;\n\n\t// Get parameters\n\tvoid *buffer = Mac2HostAddr(ReadMacInt32(pb + ioBuffer));\n\tsize_t length = ReadMacInt32(pb + ioReqCount);\n\tloff_t position = ReadMacInt32(dce + dCtlPosition);\n\tif ((length & (info->block_size - 1)) || (position & (info->block_size - 1)))\n\t\treturn paramErr;\n\tinfo->twok_offset = (position + info->start_byte) & 0x7ff;\n\n\tsize_t actual = 0;\n\tif ((ReadMacInt16(pb + ioTrap) & 0xff) == aRdCmd) {\n\n\t\t// Read\n\t\tactual = Sys_read(info->fh, buffer, position + info->start_byte, length);\n\t\tif (actual != length) {\n\n\t\t\t// Read error, tried to read HFS root block?\n\t\t\tif (length == 0x200 && position == 0x400) {\n\n\t\t\t\t// Yes, fake (otherwise audio CDs won't get mounted)\n\t\t\t\tmemset(buffer, 0, 0x200);\n\t\t\t\tactual = 0x200;\n\t\t\t} else {\n\t\t\t\treturn readErr;\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn wPrErr;\n\t}\n\n\t// Update ParamBlock and DCE\n\tWriteMacInt32(pb + ioActCount, actual);\n\tWriteMacInt32(dce + dCtlPosition, ReadMacInt32(dce + dCtlPosition) + actual);\n\treturn noErr;\n}\n\n\n/*\n *  Driver Control() routine\n */\n\nint16 CDROMControl(uint32 pb, uint32 dce)\n{\n\tuint16 code = ReadMacInt16(pb + csCode);\n\tD(bug(\"CDROMControl %d\\n\", code));\n\n\t// General codes\n\tswitch (code) {\n\t\tcase 1:\t\t// KillIO\n\t\t\treturn noErr;\n\n\t\tcase 65: {\t// Periodic action (accRun, \"insert\" disks on startup)\n\t\t\tmount_mountable_volumes();\n\t\t\tWriteMacInt16(dce + dCtlFlags, ReadMacInt16(dce + dCtlFlags) & ~0x2000);\t// Disable periodic action\n\t\t\tacc_run_called = true;\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase 81:\t// Set poll freq\n\t\t\tWriteMacInt16(dce + dCtlDelay, ReadMacInt16(pb + csParam));\n\t\t\treturn noErr;\n\t}\n\n\t// Drive valid?\n\tdrive_vec::iterator info = get_drive_info(ReadMacInt16(pb + ioVRefNum));\n\tif (info == drives.end()) {\n\t\tif (drives.empty()) {\n\t\t\treturn nsDrvErr;\n\t\t} else {\n\t\t\tinfo = drives.begin();\t// This is needed for Apple's Audio CD program\n\t\t}\n\t}\n\n\t// Drive-specific codes\n\tswitch (code) {\n\t\tcase 5:\t\t\t// VerifyTheDisc\n\t\t\tif (ReadMacInt8(info->status + dsDiskInPlace) > 0)\n\t\t\t\treturn noErr;\n\t\t\telse\n\t\t\t\treturn offLinErr;\n\n\t\tcase 6:\t\t\t// FormatTheDisc\n\t\t\treturn writErr;\n\n\t\tcase 7:\t\t\t// EjectTheDisc\n\t\t\tif (ReadMacInt8(info->status + dsDiskInPlace) > 0) {\n\t\t\t\tSysAllowRemoval(info->fh);\n\t\t\t\tSysEject(info->fh);\n\t\t\t\tWriteMacInt8(info->status + dsDiskInPlace, 0);\n\t\t\t\tinfo->twok_offset = -1;\n\t\t\t}\n\t\t\treturn noErr;\n\n\t\tcase 21:\t\t// GetDriveIcon\n\t\tcase 22:\t\t// GetMediaIcon\n\t\t\tWriteMacInt32(pb + csParam, CDROMIconAddr);\n\t\t\treturn noErr;\n\n\t\tcase 23:\t\t// GetDriveInfo\n\t\t\tWriteMacInt32(pb + csParam, 0x00000b01);\t// Unspecified external removable SCSI disk\n\t\t\treturn noErr;\n\n\t\tcase 70: {\t\t// SetPowerMode\n\t\t\tuint8 mode = ReadMacInt8(pb + csParam);\n\t\t\tif (mode > 3) {\n\t\t\t\treturn paramErr;\n\t\t\t} else {\n\t\t\t\tinfo->power_mode = mode;\n\t\t\t\treturn noErr;\n\t\t\t}\n\t\t}\n\n\t\tcase 76:\t\t// ModifyPostEvent\n\t\t\tinfo->mount_non_hfs = ReadMacInt16(pb + csParam);\n\t\t\treturn noErr;\n\n\t\tcase 79: {\t\t// Change block size\n\t\t\tuint16 size = ReadMacInt16(pb + csParam);\n\t\t\tD(bug(\" change block size to %d bytes\\n\", size));\n\t\t\tif (size != 512 && size != 2048) {\n\t\t\t\treturn paramErr;\n\t\t\t} else {\n\t\t\t\tinfo->block_size = size;\n\t\t\t\treturn noErr;\n\t\t\t}\n\t\t}\n\n\t\tcase 80:\t\t// SetUserEject\n\t\t\tif (ReadMacInt8(info->status + dsDiskInPlace) > 0) {\n\t\t\t\tif (ReadMacInt16(pb + csParam) == 1)\n\t\t\t\t\tSysAllowRemoval(info->fh);\n\t\t\t\telse\n\t\t\t\t\tSysPreventRemoval(info->fh);\n\t\t\t\treturn noErr;\n\t\t\t} else {\n\t\t\t\treturn offLinErr;\n\t\t\t}\n\n\t\tcase 100: {\t\t// ReadTOC\n\t\t\tif (ReadMacInt8(info->status + dsDiskInPlace) == 0)\n\t\t\t\treturn offLinErr;\n\n\t\t\tint action = ReadMacInt16(pb + csParam);\n\t\t\tD(bug(\" read TOC %d\\n\", action));\n\t\t\tswitch (action) {\n\t\t\t\tcase 1:\t\t// Get first/last track number\n\t\t\t\t\tWriteMacInt8(pb + csParam, bin2bcd[info->toc[2]]);\n\t\t\t\t\tWriteMacInt8(pb + csParam + 1, bin2bcd[info->toc[3]]);\n\t\t\t\t\tWriteMacInt16(pb + csParam + 2, 0);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\t\t// Get lead out MSF starting address\n\t\t\t\t\tWriteMacInt8(pb + csParam, bin2bcd[info->lead_out[0]]);\n\t\t\t\t\tWriteMacInt8(pb + csParam + 1, bin2bcd[info->lead_out[1]]);\n\t\t\t\t\tWriteMacInt8(pb + csParam + 2, bin2bcd[info->lead_out[2]]);\n\t\t\t\t\tWriteMacInt8(pb + csParam + 3, 0);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: {\t\t// Get track starting address\n\t\t\t\t\tuint32 buf = ReadMacInt32(pb + csParam + 2);\n\t\t\t\t\tuint16 buf_size = ReadMacInt16(pb + csParam + 6);\n\t\t\t\t\tint track = bcd2bin[ReadMacInt8(pb + csParam + 8)];\n\n\t\t\t\t\t// Search start track in TOC\n\t\t\t\t\tint i;\n\t\t\t\t\tfor (i=4; i<804; i+=8) {\n\t\t\t\t\t\tif (info->toc[i+2] == track)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fill buffer\n\t\t\t\t\tif (i != 804) {\n\t\t\t\t\t\twhile (buf_size > 0) {\n\t\t\t\t\t\t\tWriteMacInt8(buf, info->toc[i+1] & 0x0f); buf++;\t// Control\n\t\t\t\t\t\t\tWriteMacInt8(buf, bin2bcd[info->toc[i+5]]); buf++;\t// M\n\t\t\t\t\t\t\tWriteMacInt8(buf, bin2bcd[info->toc[i+6]]); buf++;\t// S\n\t\t\t\t\t\t\tWriteMacInt8(buf, bin2bcd[info->toc[i+7]]); buf++;\t// F\n\n\t\t\t\t\t\t\t// Lead-Out? Then stop\n\t\t\t\t\t\t\tif (info->toc[i+2] == 0xaa)\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tbuf_size -= 4;\n\t\t\t\t\t\t\ti += 8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase 5:\t\t// Get session information\n\t\t\t\t\tWriteMacInt16(pb + csParam, 1);\t\t\t\t\t\t\t// First session number\n\t\t\t\t\tWriteMacInt16(pb + csParam + 2, 1);\t\t\t\t\t\t// Last session number\n\t\t\t\t\tWriteMacInt16(pb + csParam + 4, bin2bcd[info->toc[2]]);\t// First track number of last session\n\t\t\t\t\tWriteMacInt8(pb + csParam + 6, info->toc[5] & 0x0f);\t// Control\n\t\t\t\t\tWriteMacInt8(pb + csParam + 7, bin2bcd[info->toc[9]]);\t// M\n\t\t\t\t\tWriteMacInt8(pb + csParam + 8, bin2bcd[info->toc[10]]);\t// S\n\t\t\t\t\tWriteMacInt8(pb + csParam + 9, bin2bcd[info->toc[11]]);\t// F\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"FATAL: .AppleCD/Control(100): unimplemented TOC type\\n\");\n\t\t\t\t\treturn paramErr;\n\t\t\t}\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase 101: {\t\t// ReadTheQSubcode\n\t\t\tif (ReadMacInt8(info->status + dsDiskInPlace) == 0) {\n\t\t\t\tMac_memset(pb + csParam, 0, 10);\n\t\t\t\treturn offLinErr;\n\t\t\t}\n\n\t\t\tuint8 pos[16];\n\t\t\tif (SysCDGetPosition(info->fh, pos)) {\n\t\t\t\tuint32 p = pb + csParam;\n\t\t\t\tWriteMacInt8(p, pos[5] & 0x0f); p++;\t// Control\n\t\t\t\tWriteMacInt8(p, bin2bcd[pos[6]]); p++;\t// Track number\n\t\t\t\tWriteMacInt8(p, bin2bcd[pos[7]]); p++;\t// Index number\n\t\t\t\tWriteMacInt8(p, bin2bcd[pos[13]]); p++;\t// M (rel)\n\t\t\t\tWriteMacInt8(p, bin2bcd[pos[14]]); p++;\t// S (rel)\n\t\t\t\tWriteMacInt8(p, bin2bcd[pos[15]]); p++;\t// F (rel)\n\t\t\t\tWriteMacInt8(p, bin2bcd[pos[9]]); p++;\t// M (abs)\n\t\t\t\tWriteMacInt8(p, bin2bcd[pos[10]]); p++;\t// S (abs)\n\t\t\t\tWriteMacInt8(p, bin2bcd[pos[11]]); p++;\t// F (abs)\n\t\t\t\tWriteMacInt8(p, 0);\n\t\t\t\treturn noErr;\n\t\t\t} else {\n\t\t\t\treturn ioErr;\n\t\t\t}\n\t\t}\n\n\t\tcase 102:\t\t// ReadHeader\n\t\t\tprintf(\"FATAL: .AppleCD/Control(102): unimplemented call\\n\");\n\t\t\treturn controlErr;\n\n\t\tcase 103: {\t\t// AudioTrackSearch\n\t\t\tD(bug(\" AudioTrackSearch postype %d, pos %08x, hold %d\\n\", ReadMacInt16(pb + csParam), ReadMacInt32(pb + csParam + 2), ReadMacInt16(pb + csParam + 6)));\n\t\t\tif (ReadMacInt8(info->status + dsDiskInPlace) == 0)\n\t\t\t\treturn offLinErr;\n\n\t\t\tuint8 start_m, start_s, start_f;\n\t\t\tif (!position2msf(*info, ReadMacInt16(pb + csParam), ReadMacInt32(pb + csParam + 2), false, start_m, start_s, start_f))\n\t\t\t\treturn paramErr;\n\t\t\tinfo->play_mode = ReadMacInt8(pb + csParam + 9) & 0x0f;\n\t\t\tif (!SysCDPlay(info->fh, start_m, start_s, start_f, info->stop_at[0], info->stop_at[1], info->stop_at[2]))\n\t\t\t\treturn paramErr;\n\t\t\tif (ReadMacInt16(pb + csParam + 6) == 0)\t// Hold\n\t\t\t\tSysCDPause(info->fh);\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase 104:\t\t// AudioPlay\n\t\t\tD(bug(\" AudioPlay postype %d, pos %08lx, hold %d\\n\", ReadMacInt16(pb + csParam), ReadMacInt32(pb + csParam + 2), ReadMacInt16(pb + csParam + 6)));\n\t\t\tif (ReadMacInt8(info->status + dsDiskInPlace) == 0)\n\t\t\t\treturn offLinErr;\n\n\t\t\tif (ReadMacInt16(pb + csParam + 6)) {\n\t\t\t\t// Given stopping address\n\t\t\t\tif (!position2msf(*info, ReadMacInt16(pb + csParam), ReadMacInt32(pb + csParam + 2), true, info->stop_at[0], info->stop_at[1], info->stop_at[2]))\n\t\t\t\t\treturn paramErr;\n\t\t\t} else {\n\t\t\t\t// Given starting address\n\t\t\t\tuint8 start_m, start_s, start_f;\n\t\t\t\tif (!position2msf(*info, ReadMacInt16(pb + csParam), ReadMacInt32(pb + csParam + 2), false, start_m, start_s, start_f))\n\t\t\t\t\treturn paramErr;\n\t\t\t\tinfo->play_mode = ReadMacInt8(pb + csParam + 9) & 0x0f;\n\t\t\t\tif (!SysCDPlay(info->fh, start_m, start_s, start_f, info->stop_at[0], info->stop_at[1], info->stop_at[2]))\n\t\t\t\t\treturn paramErr;\n\t\t\t}\n\t\t\treturn noErr;\n\n\t\tcase 105:\t\t// AudioPause\n\t\t\tif (ReadMacInt8(info->status + dsDiskInPlace) == 0)\n\t\t\t\treturn offLinErr;\n\n\t\t\tswitch (ReadMacInt32(pb + csParam)) {\n\t\t\t\tcase 0:\n\t\t\t\t\tif (!SysCDResume(info->fh))\n\t\t\t\t\t\treturn paramErr;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tif (!SysCDPause(info->fh))\n\t\t\t\t\t\treturn paramErr;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn paramErr;\n\t\t\t}\n\t\t\treturn noErr;\n\n\t\tcase 106:\t\t// AudioStop\n\t\t\tD(bug(\" AudioStop postype %d, pos %08lx\\n\", ReadMacInt16(pb + csParam), ReadMacInt32(pb + csParam + 2)));\n\t\t\tif (ReadMacInt8(info->status + dsDiskInPlace) == 0)\n\t\t\t\treturn offLinErr;\n\n\t\t\tif (ReadMacInt16(pb + csParam) == 0 && ReadMacInt32(pb + csParam + 2) == 0) {\n\t\t\t\t// Stop immediately\n\t\t\t\tif (!SysCDStop(info->fh, info->lead_out[0], info->lead_out[1], info->lead_out[2]))\n\t\t\t\t\treturn paramErr;\n\t\t\t} else {\n\t\t\t\t// Given stopping address\n\t\t\t\tif (!position2msf(*info, ReadMacInt16(pb + csParam), ReadMacInt32(pb + csParam + 2), true, info->stop_at[0], info->stop_at[1], info->stop_at[2]))\n\t\t\t\t\treturn paramErr;\n\t\t\t}\n\t\t\treturn noErr;\n\n\t\tcase 107: {\t\t// AudioStatus\n\t\t\tif (ReadMacInt8(info->status + dsDiskInPlace) == 0)\n\t\t\t\treturn offLinErr;\n\n\t\t\tuint8 pos[16];\n\t\t\tif (!SysCDGetPosition(info->fh, pos))\n\t\t\t\treturn paramErr;\n\n\t\t\tuint32 p = pb + csParam;\n\t\t\tswitch (pos[1]) {\n\t\t\t\tcase 0x11:\n\t\t\t\t\tWriteMacInt8(p, 0);\t// Audio play in progress\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x12:\n\t\t\t\t\tWriteMacInt8(p, 1);\t// Audio play paused\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x13:\n\t\t\t\t\tWriteMacInt8(p, 3);\t// Audio play completed\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x14:\n\t\t\t\t\tWriteMacInt8(p, 4);\t// Error occurred\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tWriteMacInt8(p, 5);\t// No audio play operation requested\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t\tWriteMacInt8(p, info->play_mode); p++;\n\t\t\tWriteMacInt8(p, pos[5] & 0x0f); p++;\t// Control\n\t\t\tWriteMacInt8(p, bin2bcd[pos[9]]); p++;\t// M (abs)\n\t\t\tWriteMacInt8(p, bin2bcd[pos[10]]); p++;\t// S (abs)\n\t\t\tWriteMacInt8(p, bin2bcd[pos[11]]); p++;\t// F (abs)\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase 108: {\t\t// AudioScan\n\t\t\tif (ReadMacInt8(info->status + dsDiskInPlace) == 0)\n\t\t\t\treturn offLinErr;\n\n\t\t\tuint8 start_m, start_s, start_f;\n\t\t\tif (!position2msf(*info, ReadMacInt16(pb + csParam), ReadMacInt32(pb + csParam + 2), false, start_m, start_s, start_f))\n\t\t\t\treturn paramErr;\n\n\t\t\tif (!SysCDScan(info->fh, start_m, start_s, start_f, ReadMacInt16(pb + csParam + 6))) {\n\t\t\t\treturn paramErr;\n\t\t\t} else {\n\t\t\t\treturn noErr;\n\t\t\t}\n\t\t}\n\n\t\tcase 109:\t\t// AudioControl\n\t\t\tSysCDSetVolume(info->fh, ReadMacInt8(pb + csParam), ReadMacInt8(pb + csParam + 1));\n\t\t\treturn noErr;\n\n\t\tcase 110:\t\t// ReadMCN\n\t\t\tprintf(\"FATAL: .AppleCD/Control(110): unimplemented call\\n\");\n\t\t\treturn controlErr;\n\n\t\tcase 111:\t\t// ReadISRC\n\t\t\tprintf(\"FATAL: .AppleCD/Control(111): unimplemented call\\n\");\n\t\t\treturn controlErr;\n\n\t\tcase 112: {\t\t// ReadAudioVolume\n\t\t\tuint8 left = 0, right = 0;\n\t\t\tSysCDGetVolume(info->fh, left, right);\n\t\t\tWriteMacInt8(pb + csParam, left);\n\t\t\tWriteMacInt8(pb + csParam + 1, right);\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase 113:\t\t// GetSpindleSpeed\n\t\t\tWriteMacInt16(pb + csParam, 0xff);\n\t\t\treturn noErr;\n\n\t\tcase 114:\t\t// SetSpindleSpeed\n\t\t\treturn noErr;\n\n\t\tcase 115:\t\t// ReadAudio\n\t\t\tprintf(\"FATAL: .AppleCD/Control(115): unimplemented call\\n\");\n\t\t\treturn controlErr;\n\n\t\tcase 116:\t\t// ReadAllSubcodes\n\t\t\tprintf(\"FATAL: .AppleCD/Control(116): unimplemented call\\n\");\n\t\t\treturn controlErr;\n\n\t\tcase 122:\t\t// SetTrackList\n\t\t\tprintf(\"FATAL: .AppleCD/Control(122): unimplemented call\\n\");\n\t\t\treturn controlErr;\n\n\t\tcase 123:\t\t// GetTrackList\n\t\t\tprintf(\"FATAL: .AppleCD/Control(123): unimplemented call\\n\");\n\t\t\treturn controlErr;\n\n\t\tcase 124:\t\t// GetTrackIndex\n\t\t\tprintf(\"FATAL: .AppleCD/Control(124): unimplemented call\\n\");\n\t\t\treturn controlErr;\n\n\t\tcase 125:\t\t// SetPlayMode\n\t\t\tD(bug(\" SetPlayMode %04x\\n\", ReadMacInt16(pb + csParam)));\n\t\t\tprintf(\"FATAL: .AppleCD/Control(125): unimplemented call\\n\");\n\t\t\treturn controlErr;\n\n\t\tcase 126:\t\t// GetPlayMode (Apple's Audio CD program needs this)\n\t\t\tWriteMacInt16(pb + csParam, 0);\n\t\t\treturn noErr;\n\n\t\tdefault:\n\t\t\tprintf(\"WARNING: Unknown CDROMControl(%d)\\n\", code);\n\t\t\treturn controlErr;\n\t}\n}\n\n\n/*\n *  Driver Status() routine\n */\n\nint16 CDROMStatus(uint32 pb, uint32 dce)\n{\n\tdrive_vec::iterator info = get_drive_info(ReadMacInt16(pb + ioVRefNum));\n\tuint16 code = ReadMacInt16(pb + csCode);\n\tD(bug(\"CDROMStatus %d\\n\", code));\n\n\t// General codes (we can get these even if the drive was invalid)\n\tswitch (code) {\n\t\tcase 43: {\t// DriverGestalt\n\t\t\tuint32 sel = ReadMacInt32(pb + csParam);\n\t\t\tD(bug(\" driver gestalt %c%c%c%c\\n\", sel >> 24, sel >> 16,  sel >> 8, sel));\n\t\t\tswitch (sel) {\n\t\t\t\tcase FOURCC('v','e','r','s'):\t// Version\n\t\t\t\t\tWriteMacInt32(pb + csParam + 4, 0x05208000);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOURCC('d','e','v','t'):\t// Device type\n\t\t\t\t\tWriteMacInt32(pb + csParam + 4, FOURCC('c','d','r','m'));\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOURCC('i','n','t','f'):\t// Interface type\n\t\t\t\t\tWriteMacInt32(pb + csParam + 4, EMULATOR_ID_4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOURCC('s','y','n','c'):\t// Only synchronous operation?\n\t\t\t\t\tWriteMacInt32(pb + csParam + 4, 0x01000000);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOURCC('b','o','o','t'):\t// Boot ID\n\t\t\t\t\tif (info != drives.end())\n\t\t\t\t\t\tWriteMacInt16(pb + csParam + 4, info->num);\n\t\t\t\t\telse\n\t\t\t\t\t\tWriteMacInt16(pb + csParam + 4, 0);\n\t\t\t\t\tWriteMacInt16(pb + csParam + 6, (uint16)CDROMRefNum);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOURCC('w','i','d','e'):\t// 64-bit access supported?\n\t\t\t\t\tWriteMacInt16(pb + csParam + 4, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOURCC('p','u','r','g'):\t// Purge flags\n\t\t\t\t\tWriteMacInt32(pb + csParam + 4, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOURCC('e','j','e','c'):\t// Eject flags\n\t\t\t\t\tWriteMacInt32(pb + csParam + 4, 0x00030003);\t// Don't eject on shutdown/restart\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOURCC('f','l','u','s'):\t// Flush flags\n\t\t\t\t\tWriteMacInt16(pb + csParam + 4, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOURCC('v','m','o','p'):\t// Virtual memory attributes\n\t\t\t\t\tWriteMacInt32(pb + csParam + 4, 0);\t// Drive not available for VM\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn statusErr;\n\t\t\t}\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase 97: {\t// WhoIsThere\n\t\t\tuint8 drives_present = 0;\n\t\t\tdrive_vec::iterator info, end = drives.end();\n\t\t\tfor (info = drives.begin(); info != end; ++info) {\n\t\t\t\tif (info->num <= 6)\n\t\t\t\t\tdrives_present |= (1 << info->num);\n\t\t\t}\n\t\t\tWriteMacInt8(pb + csParam + 1, drives_present);\n\t\t\treturn noErr;\n\t\t}\n\t}\n\n\t// Drive valid?\n\tif (info == drives.end()) {\n\t\tif (drives.empty())\n\t\t\treturn nsDrvErr;\n\t\telse\n\t\t\tinfo = drives.begin();\t// This is needed for Apple's Audio CD program\n\t}\n\n\t// Drive-specific codes\n\tswitch (code) {\n\t\tcase 6:\t\t\t// Return format list\n\t\t\tif (ReadMacInt16(pb + csParam) > 0) {\n\t\t\t\tuint32 adr = ReadMacInt32(pb + csParam + 2);\n\t\t\t\tWriteMacInt16(pb + csParam, 1);\t\t\t\t\t\t// 1 format\n\t\t\t\tWriteMacInt32(adr, SysGetFileSize(info->fh) / 512);\t// Number of blocks\n\t\t\t\tWriteMacInt32(adr + 4, 0);\t\t\t\t\t\t\t// heads/track/sectors\n\t\t\t\treturn noErr;\n\t\t\t} else {\n\t\t\t\treturn paramErr;\n\t\t\t}\n\n\t\tcase 8:\t\t\t// DriveStatus\n\t\t\tMac2Mac_memcpy(pb + csParam, info->status, 22);\n\t\t\treturn noErr;\n\n\t\tcase 70:\t\t// GetPowerMode\n\t\t\tWriteMacInt16(pb + csParam, info->power_mode << 8);\n\t\t\treturn noErr;\n\n\t\tcase 95:\t\t// Get2KOffset\n\t\t\tif (info->twok_offset > 0) {\n\t\t\t\tWriteMacInt16(pb + csParam, info->twok_offset);\n\t\t\t\treturn noErr;\n\t\t\t} else {\n\t\t\t\treturn statusErr;\n\t\t\t}\n\n\t\tcase 96:\t\t// Get drive type\n\t\t\tWriteMacInt16(pb + csParam, 3);\t\t\t// Apple CD 300 or newer\n\t\t\treturn noErr;\n\n\t\tcase 98:\t\t// Get block size\n\t\t\tWriteMacInt16(pb + csParam, info->block_size);\n\t\t\treturn noErr;\n\n\t\tcase 120:\t\t// Return device ident\n\t\t\tWriteMacInt32(pb + csParam, 0);\n\t\t\treturn noErr;\n\n\t\tcase 121:\t\t// Get CD features\n\t\t\tWriteMacInt16(pb + csParam, 0x0200);\t// 300 KB/s\n\t\t\tWriteMacInt16(pb + csParam + 2, 0x0c00);\t// SCSI-2, stereo\n\t\t\treturn noErr;\n\n\t\tdefault:\n\t\t\tprintf(\"WARNING: Unknown CDROMStatus(%d)\\n\", code);\n\t\t\treturn statusErr;\n\t}\n}\n\n\n/*\n *  Driver interrupt routine (1Hz) - check for volumes to be mounted\n */\n\nvoid CDROMInterrupt(void)\n{\n\tif (!acc_run_called)\n\t\treturn;\n\n\tmount_mountable_volumes();\n}\n","/*\n *  audio.cpp - Audio support\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *  Portions written by Marc Hellwig\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/*\n *  SEE ALSO\n *    Inside Macintosh: Sound, chapter 5 \"Sound Components\"\n */\n\n#include \"sysdeps.h\"\n#include \"cpu_emulation.h\"\n#include \"macos_util.h\"\n#include \"emul_op.h\"\n#include \"main.h\"\n#include \"audio.h\"\n#include \"audio_defs.h\"\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n// Supported sample rates, sizes and channels\nvector<uint32> audio_sample_rates;\nvector<uint16> audio_sample_sizes;\nvector<uint16> audio_channel_counts;\n\n// Global variables\nstruct audio_status AudioStatus;\t// Current audio status (sample rate etc.)\nbool audio_open = false;\t\t\t// Flag: audio is initialized and ready\nint audio_frames_per_block;\t\t\t// Number of audio frames per block\nuint32 audio_component_flags;\t\t// Component feature flags\nuint32 audio_data = 0;\t\t\t\t// Mac address of global data area\nstatic int open_count = 0;\t\t\t// Open/close nesting count\n\nbool AudioAvailable = false;\t\t// Flag: audio output available (from the software point of view)\n\n\n/*\n *  Reset audio emulation\n */\n\nvoid AudioReset(void)\n{\n\taudio_data = 0;\n}\n\n\n/*\n *  Get audio info\n */\n\nstatic int32 AudioGetInfo(uint32 infoPtr, uint32 selector, uint32 sourceID)\n{\n\tD(bug(\" AudioGetInfo %c%c%c%c, infoPtr %08lx, source ID %08lx\\n\", selector >> 24, (selector >> 16) & 0xff, (selector >> 8) & 0xff, selector & 0xff, infoPtr, sourceID));\n\tM68kRegisters r;\n\n\tswitch (selector) {\n\t\tcase siSampleSize:\n\t\t\tWriteMacInt16(infoPtr, AudioStatus.sample_size);\n\t\t\tbreak;\n\n\t\tcase siSampleSizeAvailable: {\n\t\t\tr.d[0] = audio_sample_sizes.size() * 2;\n\t\t\tExecute68kTrap(0xa122, &r);\t// NewHandle()\n\t\t\tuint32 h = r.a[0];\n\t\t\tif (h == 0)\n\t\t\t\treturn memFullErr;\n\t\t\tWriteMacInt16(infoPtr + sil_count, audio_sample_sizes.size());\n\t\t\tWriteMacInt32(infoPtr + sil_infoHandle, h);\n\t\t\tuint32 sp = ReadMacInt32(h);\n\t\t\tfor (unsigned i=0; i<audio_sample_sizes.size(); i++)\n\t\t\t\tWriteMacInt16(sp + i*2, audio_sample_sizes[i]);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase siNumberChannels:\n\t\t\tWriteMacInt16(infoPtr, AudioStatus.channels);\n\t\t\tbreak;\n\n\t\tcase siChannelAvailable: {\n\t\t\tr.d[0] = audio_channel_counts.size() * 2;\n\t\t\tExecute68kTrap(0xa122, &r);\t// NewHandle()\n\t\t\tuint32 h = r.a[0];\n\t\t\tif (h == 0)\n\t\t\t\treturn memFullErr;\n\t\t\tWriteMacInt16(infoPtr + sil_count, audio_channel_counts.size());\n\t\t\tWriteMacInt32(infoPtr + sil_infoHandle, h);\n\t\t\tuint32 sp = ReadMacInt32(h);\n\t\t\tfor (unsigned i=0; i<audio_channel_counts.size(); i++)\n\t\t\t\tWriteMacInt16(sp + i*2, audio_channel_counts[i]);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase siSampleRate:\n\t\t\tWriteMacInt32(infoPtr, AudioStatus.sample_rate);\n\t\t\tbreak;\n\n\t\tcase siSampleRateAvailable: {\n\t\t\tr.d[0] = audio_sample_rates.size() * 4;\n\t\t\tExecute68kTrap(0xa122, &r);\t// NewHandle()\n\t\t\tuint32 h = r.a[0];\n\t\t\tif (h == 0)\n\t\t\t\treturn memFullErr;\n\t\t\tWriteMacInt16(infoPtr + sil_count, audio_sample_rates.size());\n\t\t\tWriteMacInt32(infoPtr + sil_infoHandle, h);\n\t\t\tuint32 lp = ReadMacInt32(h);\n\t\t\tfor (unsigned i=0; i<audio_sample_rates.size(); i++)\n\t\t\t\tWriteMacInt32(lp + i*4, audio_sample_rates[i]);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase siSpeakerMute:\n\t\t\tWriteMacInt16(infoPtr, audio_get_speaker_mute());\n\t\t\tbreak;\n\n\t\tcase siSpeakerVolume:\n\t\t\tWriteMacInt32(infoPtr, audio_get_speaker_volume());\n\t\t\tbreak;\n\n\t\tcase siHardwareMute:\n\t\t\tWriteMacInt16(infoPtr, audio_get_main_mute());\n\t\t\tbreak;\n\n\t\tcase siHardwareVolume:\n\t\t\tWriteMacInt32(infoPtr, audio_get_main_volume());\n\t\t\tbreak;\n\n\t\tcase siHardwareVolumeSteps:\n\t\t\tWriteMacInt16(infoPtr, 7);\n\t\t\tbreak;\n\n\t\tcase siHardwareBusy:\n\t\t\tWriteMacInt16(infoPtr, AudioStatus.num_sources != 0);\n\t\t\tbreak;\n\n\t\tcase siHardwareFormat:\n\t\t\tWriteMacInt32(infoPtr + scd_flags, 0);\n\t\t\tWriteMacInt32(infoPtr + scd_format, AudioStatus.sample_size == 16 ? FOURCC('t','w','o','s') : FOURCC('r','a','w',' '));\n\t\t\tWriteMacInt16(infoPtr + scd_numChannels, AudioStatus.channels);\n\t\t\tWriteMacInt16(infoPtr + scd_sampleSize, AudioStatus.sample_size);\n\t\t\tWriteMacInt32(infoPtr + scd_sampleRate, AudioStatus.sample_rate);\n\t\t\tWriteMacInt32(infoPtr + scd_sampleCount, audio_frames_per_block);\n\t\t\tWriteMacInt32(infoPtr + scd_buffer, 0);\n\t\t\tWriteMacInt32(infoPtr + scd_reserved, 0);\n\t\t\tbreak;\n\n\t\tdefault:\t// Delegate to Apple Mixer\n\t\t\tif (AudioStatus.mixer == 0)\n\t\t\t\treturn badComponentSelector;\n\t\t\tM68kRegisters r;\n\t\t\tr.a[0] = infoPtr;\n\t\t\tr.d[0] = selector;\n\t\t\tr.a[1] = sourceID;\n\t\t\tr.a[2] = AudioStatus.mixer;\n\t\t\tExecute68k(audio_data + adatGetInfo, &r);\n\t\t\tD(bug(\"  delegated to Apple Mixer, returns %08lx\\n\", r.d[0]));\n\t\t\treturn r.d[0];\n\t}\n\treturn noErr;\n}\n\n\n/*\n *  Set audio info\n */\n\nstatic int32 AudioSetInfo(uint32 infoPtr, uint32 selector, uint32 sourceID)\n{\n\tD(bug(\" AudioSetInfo %c%c%c%c, infoPtr %08lx, source ID %08lx\\n\", selector >> 24, (selector >> 16) & 0xff, (selector >> 8) & 0xff, selector & 0xff, infoPtr, sourceID));\n\tM68kRegisters r;\n\n\tswitch (selector) {\n\t\tcase siSampleSize:\n\t\t\tD(bug(\"  set sample size %08lx\\n\", infoPtr));\n\t\t\tif (AudioStatus.num_sources)\n\t\t\t\treturn siDeviceBusyErr;\n\t\t\tif (infoPtr == AudioStatus.sample_size)\n\t\t\t\treturn noErr;\n\t\t\tfor (unsigned i=0; i<audio_sample_sizes.size(); i++)\n\t\t\t\tif (audio_sample_sizes[i] == infoPtr) {\n\t\t\t\t\tif (audio_set_sample_size(i))\n\t\t\t\t\t\treturn noErr;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn siInvalidSampleSize;\n\t\t\t\t}\n\t\t\treturn siInvalidSampleSize;\n\n\t\tcase siSampleRate:\n\t\t\tD(bug(\"  set sample rate %08lx\\n\", infoPtr));\n\t\t\tif (AudioStatus.num_sources)\n\t\t\t\treturn siDeviceBusyErr;\n\t\t\tif (infoPtr == AudioStatus.sample_rate)\n\t\t\t\treturn noErr;\n\t\t\tfor (unsigned i=0; i<audio_sample_rates.size(); i++)\n\t\t\t\tif (audio_sample_rates[i] == infoPtr) {\n\t\t\t\t\tif (audio_set_sample_rate(i))\n\t\t\t\t\t\treturn noErr;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn siInvalidSampleRate;\n\t\t\t\t}\n\t\t\treturn siInvalidSampleRate;\n\n\t\tcase siNumberChannels:\n\t\t\tD(bug(\"  set number of channels %08lx\\n\", infoPtr));\n\t\t\tif (AudioStatus.num_sources)\n\t\t\t\treturn siDeviceBusyErr;\n\t\t\tif (infoPtr == AudioStatus.channels)\n\t\t\t\treturn noErr;\n\t\t\tfor (unsigned i=0; i<audio_channel_counts.size(); i++)\n\t\t\t\tif (audio_channel_counts[i] == infoPtr) {\n\t\t\t\t\tif (audio_set_channels(i))\n\t\t\t\t\t\treturn noErr;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn badChannel;\n\t\t\t\t}\n\t\t\treturn badChannel;\n\n\t\tcase siSpeakerMute:\n\t\t\taudio_set_speaker_mute((uint16)infoPtr);\n\t\t\tbreak;\n\n\t\tcase siSpeakerVolume:\n\t\t\tD(bug(\"  set speaker volume %08lx\\n\", infoPtr));\n\t\t\taudio_set_speaker_volume(infoPtr);\n\t\t\tbreak;\n\n\t\tcase siHardwareMute:\n\t\t\taudio_set_main_mute((uint16)infoPtr);\n\t\t\tbreak;\n\n\t\tcase siHardwareVolume:\n\t\t\tD(bug(\"  set hardware volume %08lx\\n\", infoPtr));\n\t\t\taudio_set_main_volume(infoPtr);\n\t\t\tbreak;\n\n\t\tdefault:\t// Delegate to Apple Mixer\n\t\t\tif (AudioStatus.mixer == 0)\n\t\t\t\treturn badComponentSelector;\n\t\t\tr.a[0] = infoPtr;\n\t\t\tr.d[0] = selector;\n\t\t\tr.a[1] = sourceID;\n\t\t\tr.a[2] = AudioStatus.mixer;\n\t\t\tExecute68k(audio_data + adatSetInfo, &r);\n\t\t\tD(bug(\"  delegated to Apple Mixer, returns %08lx\\n\", r.d[0]));\n\t\t\treturn r.d[0];\n\t}\n\treturn noErr;\n}\n\n\n/*\n *  Sound output component dispatch\n */\n\nint32 AudioDispatch(uint32 params, uint32 globals)\n{\n\tD(bug(\"AudioDispatch params %08lx (size %d), what %d\\n\", params, ReadMacInt8(params + cp_paramSize), (int16)ReadMacInt16(params + cp_what)));\n\tM68kRegisters r;\n\tuint32 p = params + cp_params;\n\tint16 selector = (int16)ReadMacInt16(params + cp_what);\n\n\tswitch (selector) {\n\n\t\t// General component functions\n\t\tcase kComponentOpenSelect:\n\t\t\tif (audio_data == 0) {\n\n\t\t\t\t// Allocate global data area\n\t\t\t\tr.d[0] = SIZEOF_adat;\n\t\t\t\tExecute68kTrap(0xa040, &r);\t// ResrvMem()\n\t\t\t\tr.d[0] = SIZEOF_adat;\n\t\t\t\tExecute68kTrap(0xa31e, &r);\t// NewPtrClear()\n\t\t\t\tif (r.a[0] == 0)\n\t\t\t\t\treturn memFullErr;\n\t\t\t\taudio_data = r.a[0];\n\t\t\t\tD(bug(\" global data at %08lx\\n\", audio_data));\n\n\t\t\t\t// Put in 68k routines\n\t\t\t\tint p = audio_data + adatDelegateCall;\n\t\t\t\tWriteMacInt16(p, 0x598f); p += 2;\t// subq.l\t#4,sp\n\t\t\t\tWriteMacInt16(p, 0x2f09); p += 2;\t// move.l\ta1,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f08); p += 2;\t// move.l\ta0,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x7024); p += 2;\t// moveq\t#$24,d0\n\t\t\t\tWriteMacInt16(p, 0xa82a); p += 2;\t// ComponentDispatch\n\t\t\t\tWriteMacInt16(p, 0x201f); p += 2;\t// move.l\t(sp)+,d0\n\t\t\t\tWriteMacInt16(p, M68K_RTS); p += 2;\t// rts\n\t\t\t\tif (p - audio_data != adatOpenMixer)\n\t\t\t\t\tgoto adat_error;\n\t\t\t\tWriteMacInt16(p, 0x558f); p += 2;\t// subq.l\t#2,sp\n\t\t\t\tWriteMacInt16(p, 0x2f09); p += 2;\t// move.l\ta1,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f00); p += 2;\t// move.l\td0,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f08); p += 2;\t// move.l\ta0,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x203c); p += 2;\t// move.l\t#$06140018,d0\n\t\t\t\tWriteMacInt32(p, 0x06140018); p+= 4;\n\t\t\t\tWriteMacInt16(p, 0xa800); p += 2;\t// SoundDispatch\n\t\t\t\tWriteMacInt16(p, 0x301f); p += 2;\t// move.w\t(sp)+,d0\n\t\t\t\tWriteMacInt16(p, 0x48c0); p += 2;\t// ext.l\td0\n\t\t\t\tWriteMacInt16(p, M68K_RTS); p += 2;\t// rts\n\t\t\t\tif (p - audio_data != adatCloseMixer)\n\t\t\t\t\tgoto adat_error;\n\t\t\t\tWriteMacInt16(p, 0x558f); p += 2;\t// subq.l\t#2,sp\n\t\t\t\tWriteMacInt16(p, 0x2f08); p += 2;\t// move.l\ta0,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x203c); p += 2;\t// move.l\t#$02180018,d0\n\t\t\t\tWriteMacInt32(p, 0x02180018); p+= 4;\n\t\t\t\tWriteMacInt16(p, 0xa800); p += 2;\t// SoundDispatch\n\t\t\t\tWriteMacInt16(p, 0x301f); p += 2;\t// move.w\t(sp)+,d0\n\t\t\t\tWriteMacInt16(p, 0x48c0); p += 2;\t// ext.l\td0\n\t\t\t\tWriteMacInt16(p, M68K_RTS); p += 2;\t// rts\n\t\t\t\tif (p - audio_data != adatGetInfo)\n\t\t\t\t\tgoto adat_error;\n\t\t\t\tWriteMacInt16(p, 0x598f); p += 2;\t// subq.l\t#4,sp\n\t\t\t\tWriteMacInt16(p, 0x2f0a); p += 2;\t// move.l\ta2,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f09); p += 2;\t// move.l\ta1,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f00); p += 2;\t// move.l\td0,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f08); p += 2;\t// move.l\ta0,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f3c); p += 2;\t// move.l\t#$000c0103,-(sp)\n\t\t\t\tWriteMacInt32(p, 0x000c0103); p+= 4;\n\t\t\t\tWriteMacInt16(p, 0x7000); p += 2;\t// moveq\t#0,d0\n\t\t\t\tWriteMacInt16(p, 0xa82a); p += 2;\t// ComponentDispatch\n\t\t\t\tWriteMacInt16(p, 0x201f); p += 2;\t// move.l\t(sp)+,d0\n\t\t\t\tWriteMacInt16(p, M68K_RTS); p += 2;\t// rts\n\t\t\t\tif (p - audio_data != adatSetInfo)\n\t\t\t\t\tgoto adat_error;\n\t\t\t\tWriteMacInt16(p, 0x598f); p += 2;\t// subq.l\t#4,sp\n\t\t\t\tWriteMacInt16(p, 0x2f0a); p += 2;\t// move.l\ta2,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f09); p += 2;\t// move.l\ta1,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f00); p += 2;\t// move.l\td0,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f08); p += 2;\t// move.l\ta0,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f3c); p += 2;\t// move.l\t#$000c0104,-(sp)\n\t\t\t\tWriteMacInt32(p, 0x000c0104); p+= 4;\n\t\t\t\tWriteMacInt16(p, 0x7000); p += 2;\t// moveq\t#0,d0\n\t\t\t\tWriteMacInt16(p, 0xa82a); p += 2;\t// ComponentDispatch\n\t\t\t\tWriteMacInt16(p, 0x201f); p += 2;\t// move.l\t(sp)+,d0\n\t\t\t\tWriteMacInt16(p, M68K_RTS); p += 2;\t// rts\n\t\t\t\tif (p - audio_data != adatPlaySourceBuffer)\n\t\t\t\t\tgoto adat_error;\n\t\t\t\tWriteMacInt16(p, 0x598f); p += 2;\t// subq.l\t#4,sp\n\t\t\t\tWriteMacInt16(p, 0x2f0a); p += 2;\t// move.l\ta2,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f09); p += 2;\t// move.l\ta1,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f08); p += 2;\t// move.l\ta0,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f00); p += 2;\t// move.l\td0,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f3c); p += 2;\t// move.l\t#$000c0108,-(sp)\n\t\t\t\tWriteMacInt32(p, 0x000c0108); p+= 4;\n\t\t\t\tWriteMacInt16(p, 0x7000); p += 2;\t// moveq\t#0,d0\n\t\t\t\tWriteMacInt16(p, 0xa82a); p += 2;\t// ComponentDispatch\n\t\t\t\tWriteMacInt16(p, 0x201f); p += 2;\t// move.l\t(sp)+,d0\n\t\t\t\tWriteMacInt16(p, M68K_RTS); p += 2;\t// rts\n\t\t\t\tif (p - audio_data != adatGetSourceData)\n\t\t\t\t\tgoto adat_error;\n\t\t\t\tWriteMacInt16(p, 0x598f); p += 2;\t// subq.l\t#4,sp\n\t\t\t\tWriteMacInt16(p, 0x2f09); p += 2;\t// move.l\ta1,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f08); p += 2;\t// move.l\ta0,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f3c); p += 2;\t// move.l\t#$00040004,-(sp)\n\t\t\t\tWriteMacInt32(p, 0x00040004); p+= 4;\n\t\t\t\tWriteMacInt16(p, 0x7000); p += 2;\t// moveq\t#0,d0\n\t\t\t\tWriteMacInt16(p, 0xa82a); p += 2;\t// ComponentDispatch\n\t\t\t\tWriteMacInt16(p, 0x201f); p += 2;\t// move.l\t(sp)+,d0\n\t\t\t\tWriteMacInt16(p, M68K_RTS); p += 2;\t// rts\n\t\t\t\tif (p - audio_data != adatStartSource)\n\t\t\t\t\tgoto adat_error;\n\t\t\t\tWriteMacInt16(p, 0x598f); p += 2;\t// subq.l\t#4,sp\n\t\t\t\tWriteMacInt16(p, 0x2f09); p += 2;\t// move.l\ta1,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x3f00); p += 2;\t// move.w\td0,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f08); p += 2;\t// move.l\ta0,-(sp)\n\t\t\t\tWriteMacInt16(p, 0x2f3c); p += 2;\t// move.l\t#$00060105,-(sp)\n\t\t\t\tWriteMacInt32(p, 0x00060105); p+= 4;\n\t\t\t\tWriteMacInt16(p, 0x7000); p += 2;\t// moveq\t#0,d0\n\t\t\t\tWriteMacInt16(p, 0xa82a); p += 2;\t// ComponentDispatch\n\t\t\t\tWriteMacInt16(p, 0x201f); p += 2;\t// move.l\t(sp)+,d0\n\t\t\t\tWriteMacInt16(p, M68K_RTS); p += 2;\t// rts\n\t\t\t\tif (p - audio_data != adatData)\n\t\t\t\t\tgoto adat_error;\n\t\t\t}\n\t\t\tAudioAvailable = true;\n\t\t\tif (open_count == 0)\n\t\t\t\taudio_enter_stream();\n\t\t\topen_count++;\n\t\t\treturn noErr;\n\nadat_error:\tprintf(\"FATAL: audio component data block initialization error\\n\");\n\t\t\tQuitEmulator();\n\t\t\treturn openErr;\n\n\t\tcase kComponentCloseSelect:\n\t\t\topen_count--;\n\t\t\tif (open_count == 0) {\n\t\t\t\tif (audio_data) {\n\t\t\t\t\tif (AudioStatus.mixer) {\n\t\t\t\t\t\t// Close Apple Mixer\n\t\t\t\t\t\tr.a[0] = AudioStatus.mixer;\n\t\t\t\t\t\tExecute68k(audio_data + adatCloseMixer, &r);\n\t\t\t\t\t\tAudioStatus.mixer = 0;\n\t\t\t\t\t\treturn r.d[0];\n\t\t\t\t\t}\n\t\t\t\t\tr.a[0] = audio_data;\n\t\t\t\t\tExecute68kTrap(0xa01f, &r);\t// DisposePtr()\n\t\t\t\t\taudio_data = 0;\n\t\t\t\t}\n\t\t\t\tAudioStatus.num_sources = 0;\n\t\t\t\taudio_exit_stream();\n\t\t\t}\n\t\t\treturn noErr;\n\n\t\tcase kComponentCanDoSelect:\n\t\t\tswitch ((int16)ReadMacInt16(p)) {\n\t\t\t\tcase kComponentOpenSelect:\n\t\t\t\tcase kComponentCloseSelect:\n\t\t\t\tcase kComponentCanDoSelect:\n\t\t\t\tcase kComponentVersionSelect:\n\t\t\t\tcase kComponentRegisterSelect:\n\t\t\t\tcase kSoundComponentInitOutputDeviceSelect:\n\t\t\t\tcase kSoundComponentGetSourceSelect:\n\t\t\t\tcase kSoundComponentGetInfoSelect:\n\t\t\t\tcase kSoundComponentSetInfoSelect:\n\t\t\t\tcase kSoundComponentStartSourceSelect:\n\t\t\t\t\treturn 1;\n\t\t\t\tdefault:\n\t\t\t\t\treturn 0;\n\t\t\t}\n\n\t\tcase kComponentVersionSelect:\n\t\t\treturn 0x00010003;\n\n\t\tcase kComponentRegisterSelect:\n\t\t\treturn noErr;\n\n\t\t// Sound component functions (not delegated)\n\t\tcase kSoundComponentInitOutputDeviceSelect:\n\t\t\tD(bug(\" InitOutputDevice\\n\"));\n\t\t\tif (!audio_open)\n\t\t\t\treturn noHardwareErr;\n\t\t\tif (AudioStatus.mixer)\n\t\t\t\treturn noErr;\n\n\t\t\t// Init sound component data\n\t\t\tWriteMacInt32(audio_data + adatData + scd_flags, 0);\n\t\t\tWriteMacInt32(audio_data + adatData + scd_format, AudioStatus.sample_size == 16 ? FOURCC('t','w','o','s') : FOURCC('r','a','w',' '));\n\t\t\tWriteMacInt16(audio_data + adatData + scd_numChannels, AudioStatus.channels);\n\t\t\tWriteMacInt16(audio_data + adatData + scd_sampleSize, AudioStatus.sample_size);\n\t\t\tWriteMacInt32(audio_data + adatData + scd_sampleRate, AudioStatus.sample_rate);\n\t\t\tWriteMacInt32(audio_data + adatData + scd_sampleCount, audio_frames_per_block);\n\t\t\tWriteMacInt32(audio_data + adatData + scd_buffer, 0);\n\t\t\tWriteMacInt32(audio_data + adatData + scd_reserved, 0);\n\t\t\tWriteMacInt32(audio_data + adatStreamInfo, 0);\n\n\t\t\t// Open Apple Mixer\n\t\t\tr.a[0] = audio_data + adatMixer;\n\t\t\tr.d[0] = 0;\n\t\t\tr.a[1] = audio_data + adatData;\n\t\t\tExecute68k(audio_data + adatOpenMixer, &r);\n\t\t\tAudioStatus.mixer = ReadMacInt32(audio_data + adatMixer);\n\t\t\tD(bug(\" OpenMixer() returns %08lx, mixer %08lx\\n\", r.d[0], AudioStatus.mixer));\n\t\t\treturn r.d[0];\n\n\t\tcase kSoundComponentGetSourceSelect:\n\t\t\tD(bug(\" GetSource source %08lx\\n\", ReadMacInt32(p)));\n\t\t\tWriteMacInt32(ReadMacInt32(p), AudioStatus.mixer);\n\t\t\treturn noErr;\n\n\t\t// Sound component functions (delegated)\n\t\tcase kSoundComponentAddSourceSelect:\n\t\t\tD(bug(\" AddSource\\n\"));\n\t\t\tAudioStatus.num_sources++;\n\t\t\tgoto delegate;\n\n\t\tcase kSoundComponentRemoveSourceSelect:\n\t\t\tD(bug(\" RemoveSource\\n\"));\n\t\t\tAudioStatus.num_sources--;\n\t\t\tgoto delegate;\n\n\t\tcase kSoundComponentGetInfoSelect:\n\t\t\treturn AudioGetInfo(ReadMacInt32(p), ReadMacInt32(p + 4), ReadMacInt32(p + 8));\n\n\t\tcase kSoundComponentSetInfoSelect:\n\t\t\treturn AudioSetInfo(ReadMacInt32(p), ReadMacInt32(p + 4), ReadMacInt32(p + 8));\n\n\t\tcase kSoundComponentStartSourceSelect:\n\t\t\tD(bug(\" StartSource count %d\\n\", ReadMacInt16(p + 4)));\n\t\t\tD(bug(\" starting Apple Mixer\\n\"));\n\t\t\tr.d[0] = ReadMacInt16(p + 4);\n\t\t\tr.a[0] = ReadMacInt32(p);\n\t\t\tr.a[1] = AudioStatus.mixer;\n\t\t\tExecute68k(audio_data + adatStartSource, &r);\n\t\t\tD(bug(\" returns %08lx\\n\", r.d[0]));\n\t\t\treturn noErr;\n\n\t\tcase kSoundComponentStopSourceSelect:\n\t\t\tD(bug(\" StopSource\\n\"));\n\t\t\tgoto delegate;\n\n\t\tcase kSoundComponentPauseSourceSelect:\n\t\t\tD(bug(\" PauseSource\\n\"));\ndelegate:\t// Delegate call to Apple Mixer\n\t\t\tD(bug(\" delegating call to Apple Mixer\\n\"));\n\t\t\tr.a[0] = AudioStatus.mixer;\n\t\t\tr.a[1] = params;\n\t\t\tExecute68k(audio_data + adatDelegateCall, &r);\n\t\t\tD(bug(\" returns %08lx\\n\", r.d[0]));\n\t\t\treturn r.d[0];\n\n\t\tcase kSoundComponentPlaySourceBufferSelect:\n\t\t\tD(bug(\" PlaySourceBuffer flags %08lx\\n\", ReadMacInt32(p)));\n\t\t\tr.d[0] = ReadMacInt32(p);\n\t\t\tr.a[0] = ReadMacInt32(p + 4);\n\t\t\tr.a[1] = ReadMacInt32(p + 8);\n\t\t\tr.a[2] = AudioStatus.mixer;\n\t\t\tExecute68k(audio_data + adatPlaySourceBuffer, &r);\n\t\t\tD(bug(\" returns %08lx\\n\", r.d[0]));\n\t\t\treturn r.d[0];\n\n\t\tdefault:\n\t\t\tif (selector >= 0x100)\n\t\t\t\tgoto delegate;\n\t\t\telse\n\t\t\t\treturn badComponentSelector;\n\t}\n}\n\n\n/*\n *  Sound input driver Open() routine\n */\n\nint16 SoundInOpen(uint32 pb, uint32 dce)\n{\n\tD(bug(\"SoundInOpen\\n\"));\n\treturn noErr;\n}\n\n\n/*\n *  Sound input driver Prime() routine\n */\n\nint16 SoundInPrime(uint32 pb, uint32 dce)\n{\n\tD(bug(\"SoundInPrime\\n\"));\n\t//!!\n\treturn paramErr;\n}\n\n\n/*\n *  Sound input driver Control() routine\n */\n\nint16 SoundInControl(uint32 pb, uint32 dce)\n{\n\tuint16 code = ReadMacInt16(pb + csCode);\n\tD(bug(\"SoundInControl %d\\n\", code));\n\n\tif (code == 1) {\n\t\tD(bug(\" SoundInKillIO\\n\"));\n\t\t//!!\n\t\treturn noErr;\n\t}\n\n\tif (code != 2)\n\t\treturn -231;\t// siUnknownInfoType\n\n\tuint32 *param = (uint32 *)Mac2HostAddr(pb + csParam);\n\tuint32 selector = param[0];\n\tD(bug(\" selector %c%c%c%c\\n\", selector >> 24, selector >> 16, selector >> 8, selector));\n\n\tswitch (selector) {\n\t\tdefault:\n\t\t\treturn -231;\t// siUnknownInfoType\n\t}\n}\n\n\n/*\n *  Sound input driver Status() routine\n */\n\nint16 SoundInStatus(uint32 pb, uint32 dce)\n{\n\tuint16 code = ReadMacInt16(pb + csCode);\n\tD(bug(\"SoundInStatus %d\\n\", code));\n\tif (code != 2)\n\t\treturn -231;\t// siUnknownInfoType\n\n\tuint32 *param = (uint32 *)Mac2HostAddr(pb + csParam);\n\tuint32 selector = param[0];\n\tD(bug(\" selector %c%c%c%c\\n\", selector >> 24, selector >> 16, selector >> 8, selector));\n\tswitch (selector) {\n#if 0\n\t\tcase siDeviceName: {\n\t\t\tconst char *str = GetString(STR_SOUND_IN_NAME);\n\t\t\tparam[0] = 0;\n\t\t\tmemcpy((void *)param[1], str, strlen(str));\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase siDeviceIcon: {\n\t\t\tM68kRegisters r;\n\t\t\tstatic const uint8 proc[] = {\n\t\t\t\t0x55, 0x8f,\t\t\t\t\t\t\t// \tsubq.l\t#2,sp\n\t\t\t\t0xa9, 0x94,\t\t\t\t\t\t\t// \tCurResFile\n\t\t\t\t0x42, 0x67,\t\t\t\t\t\t\t// \tclr.w\t-(sp)\n\t\t\t\t0xa9, 0x98,\t\t\t\t\t\t\t// \tUseResFile\n\t\t\t\t0x59, 0x8f,\t\t\t\t\t\t\t// \tsubq.l\t#4,sp\n\t\t\t\t0x48, 0x79, 0x49, 0x43, 0x4e, 0x23,\t// \tmove.l\t#'ICN#',-(sp)\n\t\t\t\t0x3f, 0x3c, 0xbf, 0x76,\t\t\t\t// \tmove.w\t#-16522,-(sp)\n\t\t\t\t0xa9, 0xa0,\t\t\t\t\t\t\t// \tGetResource\n\t\t\t\t0x24, 0x5f,\t\t\t\t\t\t\t// \tmove.l\t(sp)+,a2\n\t\t\t\t0xa9, 0x98,\t\t\t\t\t\t\t// \tUseResFile\n\t\t\t\t0x20, 0x0a,\t\t\t\t\t\t\t// \tmove.l\ta2,d0\n\t\t\t\t0x66, 0x04,\t\t\t\t\t\t\t// \tbne\t\t1\n\t\t\t\t0x70, 0x00,\t\t\t\t\t\t\t//  moveq\t#0,d0\n\t\t\t\tM68K_RTS >> 8, M68K_RTS & 0xff,\n\t\t\t\t0x2f, 0x0a,\t\t\t\t\t\t\t//1 move.l\ta2,-(sp)\n\t\t\t\t0xa9, 0x92,\t\t\t\t\t\t\t//  DetachResource\n\t\t\t\t0x20, 0x4a,\t\t\t\t\t\t\t//  move.l\ta2,a0\n\t\t\t\t0xa0, 0x4a,\t\t\t\t\t\t\t//\tHNoPurge\n\t\t\t\t0x70, 0x01,\t\t\t\t\t\t\t//\tmoveq\t#1,d0\n\t\t\t\tM68K_RTS >> 8, M68K_RTS & 0xff\n\t\t\t};\n\t\t\tExecute68k(Host2MacAddr((uint8 *)proc), &r);\n\t\t\tif (r.d[0]) {\n\t\t\t\tparam[0] = 4;\t\t// Length of returned data\n\t\t\t\tparam[1] = r.a[2];\t// Handle to icon suite\n\t\t\t\treturn noErr;\n\t\t\t} else\n\t\t\t\treturn -192;\t\t// resNotFound\n\t\t}\n#endif\n\t\tdefault:\n\t\t\treturn -231;\t// siUnknownInfoType\n\t}\n}\n\n\n/*\n *  Sound input driver Close() routine\n */\n\nint16 SoundInClose(uint32 pb, uint32 dce)\n{\n\tD(bug(\"SoundInClose\\n\"));\n\treturn noErr;\n}\n","/*\n *  emul_op.cpp - 68k opcodes for ROM patches\n *\n *  Basilisk II (C) Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include <string.h>\n#include <stdio.h>\n\n#include \"sysdeps.h\"\n#include \"cpu_emulation.h\"\n#include \"main.h\"\n#include \"macos_util.h\"\n#include \"rom_patches.h\"\n#include \"rsrc_patches.h\"\n#include \"xpram.h\"\n#include \"adb.h\"\n#include \"timer.h\"\n#include \"clip.h\"\n#include \"serial.h\"\n#include \"sony.h\"\n#include \"disk.h\"\n#include \"cdrom.h\"\n#include \"scsi.h\"\n#include \"video.h\"\n#include \"audio.h\"\n#include \"ether.h\"\n#include \"extfs.h\"\n#include \"emul_op.h\"\n\n#ifdef ENABLE_MON\n#include \"mon.h\"\n#endif\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n/*\n *  Execute EMUL_OP opcode (called by 68k emulator or Illegal Instruction trap handler)\n */\n\nvoid EmulOp(uint16 opcode, M68kRegisters *r)\n{\n\tD(bug(\"EmulOp %04x\\n\", opcode));\n\tswitch (opcode) {\n\t\tcase M68K_EMUL_BREAK: {\t\t\t\t// Breakpoint\n\t\t\tprintf(\"*** Breakpoint\\n\");\n\t\t\tprintf(\"d0 %08x d1 %08x d2 %08x d3 %08x\\n\"\n\t\t\t\t   \"d4 %08x d5 %08x d6 %08x d7 %08x\\n\"\n\t\t\t\t   \"a0 %08x a1 %08x a2 %08x a3 %08x\\n\"\n\t\t\t\t   \"a4 %08x a5 %08x a6 %08x a7 %08x\\n\"\n\t\t\t\t   \"sr %04x\\n\",\n\t\t\t\t   r->d[0], r->d[1], r->d[2], r->d[3], r->d[4], r->d[5], r->d[6], r->d[7],\n\t\t\t\t   r->a[0], r->a[1], r->a[2], r->a[3], r->a[4], r->a[5], r->a[6], r->a[7],\n\t\t\t\t   r->sr);\n\t\t\tVideoQuitFullScreen();\n#ifdef ENABLE_MON\n\t\t\tconst char *arg[4] = {\"mon\", \"-m\", \"-r\", NULL};\n\t\t\tmon(3, arg);\n#endif\n\t\t\tQuitEmulator();\n\t\t\tbreak;\n\t\t}\n\n\t\tcase M68K_EMUL_OP_SHUTDOWN:\t\t\t// Quit emulator\n\t\t\tQuitEmulator();\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_RESET: {\t\t\t// MacOS reset\n\t\t\tD(bug(\"*** RESET ***\\n\"));\n\t\t\tTimerReset();\n\t\t\tEtherReset();\n\t\t\tAudioReset();\n\n\t\t\t// Create BootGlobs at top of memory\n\t\t\tMac_memset(RAMBaseMac + RAMSize - 4096, 0, 4096);\n\t\t\tuint32 boot_globs = RAMBaseMac + RAMSize - 0x1c;\n\t\t\tWriteMacInt32(boot_globs + 0x00, RAMBaseMac);\t// First RAM bank\n\t\t\tWriteMacInt32(boot_globs + 0x04, RAMSize);\n\t\t\tWriteMacInt32(boot_globs + 0x08, 0xffffffff);\t// End of bank table\n\t\t\tWriteMacInt32(boot_globs + 0x0c, 0);\n\n\t\t\t// Setup registers for boot routine\n\t\t\tr->d[0] = ReadMacInt32(ROMBaseMac + UniversalInfo + 0x18);\t// AddrMapFlags\n\t\t\tr->d[1] = ReadMacInt32(ROMBaseMac + UniversalInfo + 0x1c);\t// UnivROMFlags\n\t\t\tr->d[2] = ReadMacInt32(ROMBaseMac + UniversalInfo + 0x10);\t// HWCfgFlags/IDs\n\t\t\tif (FPUType)\n\t\t\t\tr->d[2] |= 0x10000000;\t\t\t\t\t\t\t\t\t// Set FPU flag if FPU present\n\t\t\telse\n\t\t\t\tr->d[2] &= 0xefffffff;\t\t\t\t\t\t\t\t\t// Clear FPU flag if no FPU present\n\t\t\tr->a[0] = ROMBaseMac + UniversalInfo + ReadMacInt32(ROMBaseMac + UniversalInfo);// AddrMap\n\t\t\tr->a[1] = ROMBaseMac + UniversalInfo;\t\t\t\t\t\t// UniversalInfo\n\t\t\tr->a[6] = boot_globs;\t\t\t\t\t\t\t\t\t\t// BootGlobs\n\t\t\tr->a[7] = RAMBaseMac + 0x10000;\t\t\t\t\t\t\t\t// Boot stack\n\t\t\tbreak;\n\t\t}\n\n\t\tcase M68K_EMUL_OP_CLKNOMEM: {\t\t// Clock/PRAM operations\n\t\t\tbool is_read = r->d[1] & 0x80;\n\t\t\tif ((r->d[1] & 0x78) == 0x38) {\n\t\t\t\t// XPRAM\n\t\t\t\tuint8 reg = (r->d[1] << 5) & 0xe0 | (r->d[1] >> 10) & 0x1f;\n\t\t\t\tif (is_read) {\n\t\t\t\t\tr->d[2] = XPRAM[reg];\n\t\t\t\t\tbool localtalk = !(XPRAM[0xe0] || XPRAM[0xe1]);\t// LocalTalk enabled?\n\t\t\t\t\tswitch (reg) {\n\t\t\t\t\t\tcase 0x08:\n\t\t\t\t\t\t\tif (ROMVersion != ROM_VERSION_32)\n\t\t\t\t\t\t\t\tr->d[2] &= 0xf8;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x8a:\n\t\t\t\t\t\t\tr->d[2] |= 0x05;\t// 32bit mode is always enabled\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0xe0:\t\t\t\t// Disable LocalTalk (use EtherTalk instead)\n\t\t\t\t\t\t\tif (localtalk)\n\t\t\t\t\t\t\t\tr->d[2] = 0x00;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0xe1:\n\t\t\t\t\t\t\tif (localtalk)\n\t\t\t\t\t\t\t\tr->d[2] = 0xf1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0xe2:\n\t\t\t\t\t\t\tif (localtalk)\n\t\t\t\t\t\t\t\tr->d[2] = 0x00;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0xe3:\n\t\t\t\t\t\t\tif (localtalk)\n\t\t\t\t\t\t\t\tr->d[2] = 0x0a;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tD(bug(\"Read XPRAM %02x->%02lx\\n\", reg, r->d[2]));\n\t\t\t\t} else {\n\t\t\t\t\tD(bug(\"Write XPRAM %02x<-%02lx\\n\", reg, r->d[2] & 0xff));\n\t\t\t\t\tif (reg == 0x8a && !TwentyFourBitAddressing)\n\t\t\t\t\t\tr->d[2] |= 0x05;\t// 32bit mode is always enabled if possible\n\t\t\t\t\tXPRAM[reg] = r->d[2];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// PRAM, RTC and other clock registers\n\t\t\t\tuint8 reg = (r->d[1] >> 2) & 0x1f;\n\t\t\t\tif (reg >= 0x10 || (reg >= 0x08 && reg < 0x0c)) {\n\t\t\t\t\tif (is_read) {\n\t\t\t\t\t\tr->d[2] = XPRAM[reg];\n\t\t\t\t\t\tD(bug(\"Read XPRAM %02x->%02x\\n\", reg, XPRAM[reg]));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tD(bug(\"Write PRAM %02x<-%02lx\\n\", reg, r->d[2]));\n\t\t\t\t\t\tXPRAM[reg] = r->d[2];\n\t\t\t\t\t}\n\t\t\t\t} else if (reg < 0x08 && is_read) {\n\t\t\t\t\tuint32 t = TimerDateTime();\n\t\t\t\t\tuint8 b = t;\n\t\t\t\t\tswitch (reg & 3) {\n\t\t\t\t\t\tcase 1: b = t >> 8; break;\n\t\t\t\t\t\tcase 2: b = t >> 16; break;\n\t\t\t\t\t\tcase 3: b = t >> 24; break;\n\t\t\t\t\t}\n\t\t\t\t\tr->d[2] = b;\n\t\t\t\t} else\n\t\t\t\t\tD(bug(\"RTC %s op %d, d1 %08lx d2 %08lx\\n\", is_read ? \"read\" : \"write\", reg, r->d[1], r->d[2]));\n\t\t\t}\n\t\t\tr->d[0] = 0;\n\t\t\tr->d[1] = r->d[2];\n\t\t\tbreak;\n\t\t}\n\n\t\tcase M68K_EMUL_OP_READ_XPRAM:\t\t// Read from XPRAM (ROM10/11)\n\t\t\tD(bug(\"Read XPRAM %02lx\\n\", r->d[1]));\n\t\t\tr->d[1] = XPRAM[r->d[1] & 0xff];\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_READ_XPRAM2:\t\t// Read from XPRAM (ROM15)\n\t\t\tD(bug(\"Read XPRAM %02lx\\n\", r->d[0]));\n\t\t\tr->d[0] = XPRAM[r->d[0] & 0xff];\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_PATCH_BOOT_GLOBS:\t// Patch BootGlobs at startup\n\t\t\tD(bug(\"Patch BootGlobs\\n\"));\n\t\t\tWriteMacInt32(r->a[4] - 20, RAMBaseMac + RAMSize);\t\t\t// MemTop\n\t\t\tWriteMacInt8(r->a[4] - 26, 0);\t\t\t\t\t\t\t\t// No MMU\n\t\t\tWriteMacInt8(r->a[4] - 25, ReadMacInt8(r->a[4] - 25) | 1);\t// No MMU\n\t\t\tr->a[6] = RAMBaseMac + RAMSize;\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_FIX_BOOTSTACK:\t// Set boot stack to 3/4 of RAM (7.5)\n\t\t\tr->a[1] = RAMBaseMac + RAMSize * 3 / 4;\n\t\t\tD(bug(\"Fix boot stack %08x\\n\", r->a[1]));\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_FIX_MEMSIZE: {\t// Set correct logical and physical memory size\n\t\t\tD(bug(\"Fix MemSize\\n\"));\n\t\t\tuint32 diff = ReadMacInt32(0x1ef8) - ReadMacInt32(0x1ef4);\t// Difference between logical and physical size\n\t\t\tWriteMacInt32(0x1ef8, RAMSize);\t\t\t// Physical RAM size\n\t\t\tWriteMacInt32(0x1ef4, RAMSize - diff);\t// Logical RAM size\n\t\t\tbreak;\n\t\t}\n\n\t\tcase M68K_EMUL_OP_ADBOP:\t\t\t// ADBOp() replacement\n\t\t\tADBOp(r->d[0], Mac2HostAddr(ReadMacInt32(r->a[0])));\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_INSTIME:\t\t\t// InsTime() replacement\n\t\t\tr->d[0] = InsTime(r->a[0], r->d[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_RMVTIME:\t\t\t// RmvTime() replacement\n\t\t\tr->d[0] = RmvTime(r->a[0]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_PRIMETIME:\t\t// PrimeTime() replacement\n\t\t\tr->d[0] = PrimeTime(r->a[0], r->d[0]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_MICROSECONDS: \t// Microseconds() replacement\n\t\t\tMicroseconds(r->a[0], r->d[0]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_INSTALL_DRIVERS: {// Patch to install our own drivers during startup\n\t\t\t// Install drivers\n\t\t\tD(bug(\"InstallDrivers\\n\"));\n\t\t\tInstallDrivers(r->a[0]);\n\n\t\t\t// Install PutScrap() patch\n\t\t\tM68kRegisters r;\n\t\t\tif (PutScrapPatch) {\n\t\t\t\tr.d[0] = 0xa9fe;\n\t\t\t\tr.a[0] = PutScrapPatch;\n\t\t\t\tExecute68kTrap(0xa647, &r);\t// SetToolTrap()\n\t\t\t}\n\n\t\t\t// Install GetScrap() patch\n\t\t\tif (GetScrapPatch) {\n\t\t\t\tr.d[0] = 0xa9fd;\n\t\t\t\tr.a[0] = GetScrapPatch;\n\t\t\t\tExecute68kTrap(0xa647, &r);\t// SetToolTrap()\n\t\t\t}\n\n\t\t\t// Setup fake ASC registers\n\t\t\tif (ROMVersion == ROM_VERSION_32) {\n\t\t\t\tr.d[0] = 0x1000;\n\t\t\t\tExecute68kTrap(0xa71e, &r);\t\t// NewPtrSysClear()\n\t\t\t\tuint32 asc_regs = r.a[0];\n\t\t\t\tD(bug(\"ASC registers at %08lx\\n\", asc_regs));\n\t\t\t\tWriteMacInt8(asc_regs + 0x800, 0x0f);\t// Set ASC version number\n\t\t\t\tWriteMacInt32(0xcc0, asc_regs);\t\t\t// Set ASCBase\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase M68K_EMUL_OP_SERD:\t\t\t\t// Install serial drivers\n\t\t\tD(bug(\"InstallSERD\\n\"));\n\t\t\tInstallSERD();\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_SONY_OPEN:\t\t// Floppy driver functions\n\t\t\tr->d[0] = SonyOpen(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_SONY_PRIME:\n\t\t\tr->d[0] = SonyPrime(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_SONY_CONTROL:\n\t\t\tr->d[0] = SonyControl(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_SONY_STATUS:\n\t\t\tr->d[0] = SonyStatus(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_DISK_OPEN:\t\t// Disk driver functions\n\t\t\tr->d[0] = DiskOpen(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_DISK_PRIME:\n\t\t\tr->d[0] = DiskPrime(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_DISK_CONTROL:\n\t\t\tr->d[0] = DiskControl(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_DISK_STATUS:\n\t\t\tr->d[0] = DiskStatus(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_CDROM_OPEN:\t\t// CD-ROM driver functions\n\t\t\tr->d[0] = CDROMOpen(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_CDROM_PRIME:\n\t\t\tr->d[0] = CDROMPrime(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_CDROM_CONTROL:\n\t\t\tr->d[0] = CDROMControl(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_CDROM_STATUS:\n\t\t\tr->d[0] = CDROMStatus(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_VIDEO_OPEN:\t\t// Video driver functions\n\t\t\tr->d[0] = VideoDriverOpen(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_VIDEO_CONTROL:\n\t\t\tr->d[0] = VideoDriverControl(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_VIDEO_STATUS:\n\t\t\tr->d[0] = VideoDriverStatus(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_SERIAL_OPEN:\t\t// Serial driver functions\n\t\t\tr->d[0] = SerialOpen(r->a[0], r->a[1], r->d[0]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_SERIAL_PRIME:\n\t\t\tr->d[0] = SerialPrime(r->a[0], r->a[1], r->d[0]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_SERIAL_CONTROL:\n\t\t\tr->d[0] = SerialControl(r->a[0], r->a[1], r->d[0]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_SERIAL_STATUS:\n\t\t\tr->d[0] = SerialStatus(r->a[0], r->a[1], r->d[0]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_SERIAL_CLOSE:\n\t\t\tr->d[0] = SerialClose(r->a[0], r->a[1], r->d[0]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_ETHER_OPEN:\t\t// Ethernet driver functions\n\t\t\tr->d[0] = EtherOpen(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_ETHER_CONTROL:\n\t\t\tr->d[0] = EtherControl(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_ETHER_READ_PACKET:\n\t\t\tEtherReadPacket(r->a[0], r->a[3], r->d[3], r->d[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_SOUNDIN_OPEN:\t\t// Sound input driver functions\n\t\t\tr->d[0] = SoundInOpen(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_SOUNDIN_PRIME:\n\t\t\tr->d[0] = SoundInPrime(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_SOUNDIN_CONTROL:\n\t\t\tr->d[0] = SoundInControl(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_SOUNDIN_STATUS:\n\t\t\tr->d[0] = SoundInStatus(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_SOUNDIN_CLOSE:\n\t\t\tr->d[0] = SoundInClose(r->a[0], r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_SCSI_DISPATCH: {\t// SCSIDispatch() replacement\n\t\t\tuint32 ret = ReadMacInt32(r->a[7]);\t\t// Get return address\n\t\t\tuint16 sel = ReadMacInt16(r->a[7] + 4);\t// Get selector\n\t\t\tr->a[7] += 6;\n\t\t\tint stack = 0;\n\t\t\tswitch (sel) {\n\t\t\t\tcase 0:\t\t// SCSIReset\n\t\t\t\t\tWriteMacInt16(r->a[7], SCSIReset());\n\t\t\t\t\tstack = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\t\t// SCSIGet\n\t\t\t\t\tWriteMacInt16(r->a[7], SCSIGet());\n\t\t\t\t\tstack = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\t\t// SCSISelect\n\t\t\t\tcase 11:\t// SCSISelAtn\n\t\t\t\t\tWriteMacInt16(r->a[7] + 2, SCSISelect(ReadMacInt16(r->a[7]) & 0xff));\n\t\t\t\t\tstack = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\t\t// SCSICmd\n\t\t\t\t\tWriteMacInt16(r->a[7] + 6, SCSICmd(ReadMacInt16(r->a[7]), Mac2HostAddr(ReadMacInt32(r->a[7] + 2))));\n\t\t\t\t\tstack = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\t\t// SCSIComplete\n\t\t\t\t\tWriteMacInt16(r->a[7] + 12, SCSIComplete(ReadMacInt32(r->a[7]), ReadMacInt32(r->a[7] + 4), ReadMacInt32(r->a[7] + 8)));\n\t\t\t\t\tstack = 12;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\t\t// SCSIRead\n\t\t\t\tcase 8:\t\t// SCSIRBlind\n\t\t\t\t\tWriteMacInt16(r->a[7] + 4, SCSIRead(ReadMacInt32(r->a[7])));\n\t\t\t\t\tstack = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\t\t// SCSIWrite\n\t\t\t\tcase 9:\t\t// SCSIWBlind\n\t\t\t\t\tWriteMacInt16(r->a[7] + 4, SCSIWrite(ReadMacInt32(r->a[7])));\n\t\t\t\t\tstack = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\t// SCSIStat\n\t\t\t\t\tWriteMacInt16(r->a[7], SCSIStat());\n\t\t\t\t\tstack = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 12:\t// SCSIMsgIn\n\t\t\t\t\tWriteMacInt16(r->a[7] + 4, 0);\n\t\t\t\t\tstack = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 13:\t// SCSIMsgOut\n\t\t\t\t\tWriteMacInt16(r->a[7] + 2, 0);\n\t\t\t\t\tstack = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 14:\t// SCSIMgrBusy\n\t\t\t\t\tWriteMacInt16(r->a[7], SCSIMgrBusy());\n\t\t\t\t\tstack = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"FATAL: SCSIDispatch(%d): illegal selector\\n\", sel);\n\t\t\t\t\tQuitEmulator();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr->a[0] = ret;\t\t\t// \"rtd\" emulation, a0 = return address, a1 = new stack pointer\n\t\t\tr->a[1] = r->a[7] + stack;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase M68K_EMUL_OP_IRQ:\t\t\t// Level 1 interrupt\n\t\t\tr->d[0] = 0;\n\n\t\t\tif (InterruptFlags & INTFLAG_60HZ) {\n\t\t\t\tClearInterruptFlag(INTFLAG_60HZ);\n\n\t\t\t\t// Increment Ticks variable\n\t\t\t\tWriteMacInt32(0x16a, ReadMacInt32(0x16a) + 1);\n\n\t\t\t\tif (HasMacStarted()) {\n\n\t\t\t\t\t// Mac has started, execute all 60Hz interrupt functions\n\t\t\t\t\tTimerInterrupt();\n\t\t\t\t\tVideoInterrupt();\n\n\t\t\t\t\t// Call DoVBLTask(0)\n\t\t\t\t\tif (ROMVersion == ROM_VERSION_32) {\n\t\t\t\t\t\tM68kRegisters r2;\n\t\t\t\t\t\tr2.d[0] = 0;\n\t\t\t\t\t\tExecute68kTrap(0xa072, &r2);\n\t\t\t\t\t}\n\n\t\t\t\t\tr->d[0] = 1;\t\t\t// Flag: 68k interrupt routine executes VBLTasks etc.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (InterruptFlags & INTFLAG_1HZ) {\n\t\t\t\tClearInterruptFlag(INTFLAG_1HZ);\n\t\t\t\tif (HasMacStarted()) {\n\t\t\t\t\tSonyInterrupt();\n\t\t\t\t\tDiskInterrupt();\n\t\t\t\t\tCDROMInterrupt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (InterruptFlags & INTFLAG_SERIAL) {\n\t\t\t\tClearInterruptFlag(INTFLAG_SERIAL);\n\t\t\t\tSerialInterrupt();\n\t\t\t}\n\n\t\t\tif (InterruptFlags & INTFLAG_ETHER) {\n\t\t\t\tClearInterruptFlag(INTFLAG_ETHER);\n\t\t\t\tEtherInterrupt();\n\t\t\t}\n\n\t\t\tif (InterruptFlags & INTFLAG_AUDIO) {\n\t\t\t\tClearInterruptFlag(INTFLAG_AUDIO);\n\t\t\t\tAudioInterrupt();\n\t\t\t}\n\n\t\t\tif (InterruptFlags & INTFLAG_ADB) {\n\t\t\t\tClearInterruptFlag(INTFLAG_ADB);\n\t\t\t\tif (HasMacStarted())\n\t\t\t\t\tADBInterrupt();\n\t\t\t}\n\n\t\t\tif (InterruptFlags & INTFLAG_NMI) {\n\t\t\t\tClearInterruptFlag(INTFLAG_NMI);\n\t\t\t\tif (HasMacStarted())\n\t\t\t\t\tTriggerNMI();\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_PUT_SCRAP: {\t\t// PutScrap() patch\n\t\t\tvoid *scrap = Mac2HostAddr(ReadMacInt32(r->a[7] + 4));\n\t\t\tuint32 type = ReadMacInt32(r->a[7] + 8);\n\t\t\tint32 length = ReadMacInt32(r->a[7] + 12);\n\t\t\tPutScrap(type, scrap, length);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase M68K_EMUL_OP_GET_SCRAP: {\t\t// GetScrap() patch\n\t\t\tvoid **scrap_handle = (void **)Mac2HostAddr(ReadMacInt32(r->a[7] + 4));\n\t\t\tuint32 type = ReadMacInt32(r->a[7] + 8);\n\t\t\tint32 length = ReadMacInt32(r->a[7] + 12);\n\t\t\tGetScrap(scrap_handle, type, length);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase M68K_EMUL_OP_CHECKLOAD: {\t\t// vCheckLoad() patch (resource loader)\n\t\t\tuint32 type = r->d[1];\n\t\t\tint16 id = ReadMacInt16(r->a[2]);\n\t\t\tif (r->a[0] == 0)\n\t\t\t\tbreak;\n\t\t\tuint32 adr = ReadMacInt32(r->a[0]);\n\t\t\tif (adr == 0)\n\t\t\t\tbreak;\n\t\t\tuint8 *p = Mac2HostAddr(adr);\n\t\t\tuint32 size = ReadMacInt32(adr - 8) & 0xffffff;\n\t\t\tCheckLoad(type, id, p, size);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase M68K_EMUL_OP_AUDIO:\t\t\t// Audio component dispatch function\n\t\t\tr->d[0] = AudioDispatch(r->a[3], r->a[4]);\n\t\t\tbreak;\n\n#if SUPPORTS_EXTFS\n\t\tcase M68K_EMUL_OP_EXTFS_COMM:\t\t// External file system routines\n\t\t\tWriteMacInt16(r->a[7] + 14, ExtFSComm(ReadMacInt16(r->a[7] + 12), ReadMacInt32(r->a[7] + 8), ReadMacInt32(r->a[7] + 4)));\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_EXTFS_HFS:\n\t\t\tWriteMacInt16(r->a[7] + 20, ExtFSHFS(ReadMacInt32(r->a[7] + 16), ReadMacInt16(r->a[7] + 14), ReadMacInt32(r->a[7] + 10), ReadMacInt32(r->a[7] + 6), ReadMacInt16(r->a[7] + 4)));\n\t\t\tbreak;\n#endif\n\n\t\tcase M68K_EMUL_OP_BLOCK_MOVE:\t\t// BlockMove() cache flushing\n\t\t\tFlushCodeCache(Mac2HostAddr(r->a[0]), r->a[1]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_DEBUGUTIL:\n\t\t//\tprintf(\"DebugUtil d0=%08lx  a5=%08lx\\n\", r->d[0], r->a[5]);\n\t\t\tr->d[0] = DebugUtil(r->d[0]);\n\t\t\tbreak;\n\n\t\tcase M68K_EMUL_OP_IDLE_TIME:\t// SynchIdleTime() patch\n\t\t\t// Sleep if no events pending\n\t\t\tif (ReadMacInt32(0x14c) == 0)\n\t\t\t\tidle_wait();\n\t\t\tr->a[0] = ReadMacInt32(0x2b6);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"FATAL: EMUL_OP called with bogus opcode %08x\\n\", opcode);\n\t\t\tprintf(\"d0 %08x d1 %08x d2 %08x d3 %08x\\n\"\n\t\t\t\t   \"d4 %08x d5 %08x d6 %08x d7 %08x\\n\"\n\t\t\t\t   \"a0 %08x a1 %08x a2 %08x a3 %08x\\n\"\n\t\t\t\t   \"a4 %08x a5 %08x a6 %08x a7 %08x\\n\"\n\t\t\t\t   \"sr %04x\\n\",\n\t\t\t\t   r->d[0], r->d[1], r->d[2], r->d[3], r->d[4], r->d[5], r->d[6], r->d[7],\n\t\t\t\t   r->a[0], r->a[1], r->a[2], r->a[3], r->a[4], r->a[5], r->a[6], r->a[7],\n\t\t\t\t   r->sr);\n#ifdef ENABLE_MON\n\t\t\tconst char *arg[4] = {\"mon\", \"-m\", \"-r\", NULL};\n\t\t\tmon(3, arg);\n#endif\n\t\t\tQuitEmulator();\n\t\t\tbreak;\n\t}\n}\n","/*\n *  fpu/mathlib.h - Floating-point math support library\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  MC68881/68040 fpu emulation\n *  \n *  Original UAE FPU, copyright 1996 Herman ten Brugge\n *  Rewrite for x86, copyright 1999-2001 Lauri Pesonen\n *  New framework, copyright 2000-2001 Gwenole Beauchesne\n *  Adapted for JIT compilation (c) Bernd Meyer, 2000-2001\n *  \n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef FPU_MATHLIB_H\n#define FPU_MATHLIB_H\n\n/* NOTE: this file shall be included only from fpu/fpu_*.cpp */\n#undef\tPUBLIC\n#define PUBLIC\textern\n\n#undef\tPRIVATE\n#define PRIVATE\tstatic\n\n#undef\tFFPU\n#define FFPU\t/**/\n\n#undef\tFPU\n#define\tFPU\t\tfpu.\n\n// Define the following macro if branches are expensive. If so,\n// integer-based isnan() and isinf() functions are implemented.\n// TODO: move to Makefile.in\n#define BRANCHES_ARE_EXPENSIVE 1\n\n// Use ISO C99 extended-precision math functions (glibc 2.1+)\n#define FPU_USE_ISO_C99 1\n\n// NOTE: this is irrelevant on Win32 platforms since the MS libraries\n// don't support extended-precision floating-point computations\n#ifdef WIN32\n#undef FPU_USE_ISO_C99\n#endif\n\n// Use faster implementation of math functions, but this could cause\n// some incorrect results (?)\n// TODO: actually implement the slower but safer versions\n#define FPU_FAST_MATH 1\n\n#if FPU_USE_ISO_C99\n// NOTE: no prior <math.h> shall be included at this point\n#define __USE_ISOC99 1 // for glibc 2.2.X and newer\n#define __USE_ISOC9X 1 // for glibc 2.1.X\n#include <math.h>\n#else\n#include <cmath>\nusing namespace std;\n#endif\n\n/* -------------------------------------------------------------------------- */\n/* --- Floating-point register types                                      --- */\n/* -------------------------------------------------------------------------- */\n\n// Single : S 8*E 23*F\n#define FP_SINGLE_EXP_MAX\t\t0xff\n#define FP_SINGLE_EXP_BIAS\t\t0x7f\n\n// Double : S 11*E 52*F\n#define FP_DOUBLE_EXP_MAX\t\t0x7ff\n#define FP_DOUBLE_EXP_BIAS\t\t0x3ff\n\n// Extended : S 15*E 64*F\n#define FP_EXTENDED_EXP_MAX\t\t0x7fff\n#define FP_EXTENDED_EXP_BIAS\t0x3fff\n\n// Zeroes\t\t\t\t\t\t: E = 0 & F = 0\n// Infinities\t\t\t\t\t: E = MAX & F = 0\n// Not-A-Number\t\t\t\t\t: E = MAX & F # 0\n\n/* -------------------------------------------------------------------------- */\n/* --- Floating-point type shapes (IEEE-compliant)                        --- */\n/* -------------------------------------------------------------------------- */\n\n// Taken from glibc 2.2.x: ieee754.h\n\n// IEEE-754 float format\nunion fpu_single_shape {\n\t\n\tfpu_single value;\n\n\t/* This is the IEEE 754 single-precision format.  */\n\tstruct {\n#ifdef WORDS_BIGENDIAN\n\t\tunsigned int negative:1;\n\t\tunsigned int exponent:8;\n\t\tunsigned int mantissa:23;\n#else\n\t\tunsigned int mantissa:23;\n\t\tunsigned int exponent:8;\n\t\tunsigned int negative:1;\n#endif\n\t} ieee;\n\n\t/* This format makes it easier to see if a NaN is a signalling NaN.  */\n\tstruct {\n#ifdef WORDS_BIGENDIAN\n\t\tunsigned int negative:1;\n\t\tunsigned int exponent:8;\n\t\tunsigned int quiet_nan:1;\n\t\tunsigned int mantissa:22;\n#else\n\t\tunsigned int mantissa:22;\n\t\tunsigned int quiet_nan:1;\n\t\tunsigned int exponent:8;\n\t\tunsigned int negative:1;\n#endif\n\t} ieee_nan;\n};\n\n// IEEE-754 double format\nunion fpu_double_shape {\n\tfpu_double value;\n\t\n\t/* This is the IEEE 754 double-precision format.  */\n\tstruct {\n#ifdef WORDS_BIGENDIAN\n\t\tunsigned int negative:1;\n\t\tunsigned int exponent:11;\n\t\t/* Together these comprise the mantissa.  */\n\t\tunsigned int mantissa0:20;\n\t\tunsigned int mantissa1:32;\n#else\n#\tif HOST_FLOAT_WORDS_BIG_ENDIAN\n\t\tunsigned int mantissa0:20;\n\t\tunsigned int exponent:11;\n\t\tunsigned int negative:1;\n\t\tunsigned int mantissa1:32;\n#\telse\n\t\t/* Together these comprise the mantissa.  */\n\t\tunsigned int mantissa1:32;\n\t\tunsigned int mantissa0:20;\n\t\tunsigned int exponent:11;\n\t\tunsigned int negative:1;\n#\tendif\n#endif\n\t} ieee;\n\n\t/* This format makes it easier to see if a NaN is a signalling NaN.  */\n\tstruct {\n#ifdef WORDS_BIGENDIAN\n\t\tunsigned int negative:1;\n\t\tunsigned int exponent:11;\n\t\tunsigned int quiet_nan:1;\n\t\t/* Together these comprise the mantissa.  */\n\t\tunsigned int mantissa0:19;\n\t\tunsigned int mantissa1:32;\n#else\n#\tif HOST_FLOAT_WORDS_BIG_ENDIAN\n\t\tunsigned int mantissa0:19;\n\t\tunsigned int quiet_nan:1;\n\t\tunsigned int exponent:11;\n\t\tunsigned int negative:1;\n\t\tunsigned int mantissa1:32;\n#\telse\n\t\t/* Together these comprise the mantissa.  */\n\t\tunsigned int mantissa1:32;\n\t\tunsigned int mantissa0:19;\n\t\tunsigned int quiet_nan:1;\n\t\tunsigned int exponent:11;\n\t\tunsigned int negative:1;\n#\tendif\n#endif\n\t} ieee_nan;\n\n\t/* This format is used to extract the sign_exponent and mantissa parts only */\n\tstruct {\n#if HOST_FLOAT_WORDS_BIG_ENDIAN\n\t\tunsigned int msw:32;\n\t\tunsigned int lsw:32;\n#else\n\t\tunsigned int lsw:32;\n\t\tunsigned int msw:32;\n#endif\n\t} parts;\n};\n\n#ifdef USE_LONG_DOUBLE\n// IEEE-854 long double format\nunion fpu_extended_shape {\n\tfpu_extended value;\n\t\n\t/* This is the IEEE 854 double-extended-precision format.  */\n\tstruct {\n#ifdef WORDS_BIGENDIAN\n\t\tunsigned int negative:1;\n\t\tunsigned int exponent:15;\n\t\tunsigned int empty:16;\n\t\tunsigned int mantissa0:32;\n\t\tunsigned int mantissa1:32;\n#else\n#\tif HOST_FLOAT_WORDS_BIG_ENDIAN\n\t\tunsigned int exponent:15;\n\t\tunsigned int negative:1;\n\t\tunsigned int empty:16;\n\t\tunsigned int mantissa0:32;\n\t\tunsigned int mantissa1:32;\n#\telse\n\t\tunsigned int mantissa1:32;\n\t\tunsigned int mantissa0:32;\n\t\tunsigned int exponent:15;\n\t\tunsigned int negative:1;\n\t\tunsigned int empty:16;\n#\tendif\n#endif\n\t} ieee;\n\n\t/* This is for NaNs in the IEEE 854 double-extended-precision format.  */\n\tstruct {\n#ifdef WORDS_BIGENDIAN\n\t\tunsigned int negative:1;\n\t\tunsigned int exponent:15;\n\t\tunsigned int empty:16;\n\t\tunsigned int one:1;\n\t\tunsigned int quiet_nan:1;\n\t\tunsigned int mantissa0:30;\n\t\tunsigned int mantissa1:32;\n#else\n#\tif HOST_FLOAT_WORDS_BIG_ENDIAN\n\t\tunsigned int exponent:15;\n\t\tunsigned int negative:1;\n\t\tunsigned int empty:16;\n\t\tunsigned int mantissa0:30;\n\t\tunsigned int quiet_nan:1;\n\t\tunsigned int one:1;\n\t\tunsigned int mantissa1:32;\n#\telse\n\t\tunsigned int mantissa1:32;\n\t\tunsigned int mantissa0:30;\n\t\tunsigned int quiet_nan:1;\n\t\tunsigned int one:1;\n\t\tunsigned int exponent:15;\n\t\tunsigned int negative:1;\n\t\tunsigned int empty:16;\n#\tendif\n#endif\n\t} ieee_nan;\n\t\n\t/* This format is used to extract the sign_exponent and mantissa parts only */\n\tstruct {\n#if HOST_FLOAT_WORDS_BIG_ENDIAN\n\t\tunsigned int sign_exponent:16;\n\t\tunsigned int empty:16;\n\t\tunsigned int msw:32;\n\t\tunsigned int lsw:32;\n#else\n\t\tunsigned int lsw:32;\n\t\tunsigned int msw:32;\n\t\tunsigned int sign_exponent:16;\n\t\tunsigned int empty:16;\n#endif\n\t} parts;\n};\n#endif\n\n#ifdef USE_QUAD_DOUBLE\n// IEEE-854 quad double format\nunion fpu_extended_shape {\n\tfpu_extended value;\n\t\n\t/* This is the IEEE 854 quad-precision format.  */\n\tstruct {\n#ifdef WORDS_BIGENDIAN\n\t\tunsigned int negative:1;\n\t\tunsigned int exponent:15;\n\t\tunsigned int mantissa0:16;\n\t\tunsigned int mantissa1:32;\n\t\tunsigned int mantissa2:32;\n\t\tunsigned int mantissa3:32;\n#else\n\t\tunsigned int mantissa3:32;\n\t\tunsigned int mantissa2:32;\n\t\tunsigned int mantissa1:32;\n\t\tunsigned int mantissa0:16;\n\t\tunsigned int exponent:15;\n\t\tunsigned int negative:1;\n#endif\n\t} ieee;\n\n\t/* This is for NaNs in the IEEE 854 quad-precision format.  */\n\tstruct {\n#ifdef WORDS_BIGENDIAN\n\t\tunsigned int negative:1;\n\t\tunsigned int exponent:15;\n\t\tunsigned int quiet_nan:1;\n\t\tunsigned int mantissa0:15;\n\t\tunsigned int mantissa1:30;\n\t\tunsigned int mantissa2:32;\n\t\tunsigned int mantissa3:32;\n#else\n\t\tunsigned int mantissa3:32;\n\t\tunsigned int mantissa2:32;\n\t\tunsigned int mantissa1:32;\n\t\tunsigned int mantissa0:15;\n\t\tunsigned int quiet_nan:1;\n\t\tunsigned int exponent:15;\n\t\tunsigned int negative:1;\n#endif\n\t} ieee_nan;\n\n\t/* This format is used to extract the sign_exponent and mantissa parts only */\n#if HOST_FLOAT_WORDS_BIG_ENDIAN\n\tstruct {\n\t\tuae_u64 msw;\n\t\tuae_u64 lsw;\n\t} parts64;\n\tstruct {\n\t\tuae_u32 w0;\n\t\tuae_u32 w1;\n\t\tuae_u32 w2;\n\t\tuae_u32 w3;\n\t} parts32;\n#else\n\tstruct {\n\t\tuae_u64 lsw;\n\t\tuae_u64 msw;\n\t} parts64;\n\tstruct {\n\t\tuae_u32 w3;\n\t\tuae_u32 w2;\n\t\tuae_u32 w1;\n\t\tuae_u32 w0;\n\t} parts32;\n#endif\n};\n#endif\n\n// Declare and initialize a pointer to a shape of the requested FP type\n#define fp_declare_init_shape(psvar, rfvar, ftype) \\\n\tfpu_ ## ftype ## _shape * psvar = (fpu_ ## ftype ## _shape *)( &rfvar )\n\n/* -------------------------------------------------------------------------- */\n/* --- Extra Math Functions                                               --- */\n/* --- (most of them had to be defined before including <fpu/flags.h>)    --- */\n/* -------------------------------------------------------------------------- */\n\n#undef isnan\n#if 0 && defined(HAVE_ISNANL)\n# define isnan(x) isnanl((x))\n#else\n# define isnan(x) fp_do_isnan((x))\n#endif\n\nPRIVATE inline bool FFPU fp_do_isnan(fpu_register const & r)\n{\n#ifdef BRANCHES_ARE_EXPENSIVE\n#ifndef USE_LONG_DOUBLE\n\tfp_declare_init_shape(sxp, r, double);\n\tuae_s32 hx = sxp->parts.msw;\n\tuae_s32 lx = sxp->parts.lsw;\n\thx &= 0x7fffffff;\n\thx |= (uae_u32)(lx | (-lx)) >> 31;\n\thx = 0x7ff00000 - hx;\n\treturn (int)(((uae_u32)hx) >> 31);\n#elif USE_QUAD_DOUBLE\n\tfp_declare_init_shape(sxp, r, extended);\n\tuae_s64 hx = sxp->parts64.msw;\n\tuae_s64 lx = sxp->parts64.lsw;\n\thx &= 0x7fffffffffffffffLL;\n\thx |= (uae_u64)(lx | (-lx)) >> 63;\n\thx = 0x7fff000000000000LL - hx;\n\treturn (int)((uae_u64)hx >> 63);\n#else\n\tfp_declare_init_shape(sxp, r, extended);\n\tuae_s32 se = sxp->parts.sign_exponent;\n\tuae_s32 hx = sxp->parts.msw;\n\tuae_s32 lx = sxp->parts.lsw;\n\tse = (se & 0x7fff) << 1;\n\tlx |= hx & 0x7fffffff;\n\tse |= (uae_u32)(lx | (-lx)) >> 31;\n\tse = 0xfffe - se;\n\t// TODO: check whether rshift count is 16 or 31\n\treturn (int)(((uae_u32)(se)) >> 16);\n#endif\n#else\n#if USE_LONG_DOUBLE || USE_QUAD_DOUBLE\n\tfp_declare_init_shape(sxp, r, extended);\n\treturn\t(sxp->ieee_nan.exponent == FP_EXTENDED_EXP_MAX)\n#else\n\tfp_declare_init_shape(sxp, r, double);\n\treturn\t(sxp->ieee_nan.exponent == FP_DOUBLE_EXP_MAX)\n#endif\n\t\t&&\t(sxp->ieee_nan.mantissa0 != 0)\n\t\t&&\t(sxp->ieee_nan.mantissa1 != 0)\n#ifdef USE_QUAD_DOUBLE\n\t\t&&\t(sxp->ieee_nan.mantissa2 != 0)\n\t\t&&\t(sxp->ieee_nan.mantissa3 != 0)\n#endif\n\t\t;\n#endif\n}\n\n#undef isinf\n#if 0 && defined(HAVE_ISINFL)\n# define isinf(x) isinfl((x))\n#else\n# define isinf(x) fp_do_isinf((x))\n#endif\n\nPRIVATE inline bool FFPU fp_do_isinf(fpu_register const & r)\n{\n#ifdef BRANCHES_ARE_EXPENSIVE\n#ifndef USE_LONG_DOUBLE\n\tfp_declare_init_shape(sxp, r, double);\n\tuae_s32 hx = sxp->parts.msw;\n\tuae_s32 lx = sxp->parts.lsw;\n\tlx |= (hx & 0x7fffffff) ^ 0x7ff00000;\n\tlx |= -lx;\n\treturn ~(lx >> 31) & (hx >> 30);\n#elif USE_QUAD_DOUBLE\n\tfp_declare_init_shape(sxp, r, extended);\n\tuae_s64 hx = sxp->parts64.msw;\n\tuae_s64 lx = sxp->parts64.lsw;\n\tlx |= (hx & 0x7fffffffffffffffLL) ^ 0x7fff000000000000LL;\n\tlx |= -lx;\n\treturn ~(lx >> 63) & (hx >> 62);\n#else\n\tfp_declare_init_shape(sxp, r, extended);\n\tuae_s32 se = sxp->parts.sign_exponent;\n\tuae_s32 hx = sxp->parts.msw;\n\tuae_s32 lx = sxp->parts.lsw;\n\t/* This additional ^ 0x80000000 is necessary because in Intel's\n\t   internal representation of the implicit one is explicit.\n\t   NOTE: anyway, this is equivalent to & 0x7fffffff in that case.  */\n#ifdef __i386__\n\tlx |= (hx ^ 0x80000000) | ((se & 0x7fff) ^ 0x7fff);\n#else\n\tlx |= (hx & 0x7fffffff) | ((se & 0x7fff) ^ 0x7fff);\n#endif\n\tlx |= -lx;\n\tse &= 0x8000;\n\treturn ~(lx >> 31) & (1 - (se >> 14));\n#endif\n#else\n#if USE_LONG_DOUBLE || USE_QUAD_DOUBLE\n\tfp_declare_init_shape(sxp, r, extended);\n\treturn\t(sxp->ieee_nan.exponent == FP_EXTENDED_EXP_MAX)\n#else\n\tfp_declare_init_shape(sxp, r, double);\n\treturn\t(sxp->ieee_nan.exponent == FP_DOUBLE_EXP_MAX)\n#endif\n\t\t&&\t(sxp->ieee_nan.mantissa0 == 0)\n\t\t&&\t(sxp->ieee_nan.mantissa1 == 0)\n#ifdef USE_QUAD_DOUBLE\n\t\t&&\t(sxp->ieee_nan.mantissa2 == 0)\n\t\t&&\t(sxp->ieee_nan.mantissa3 == 0)\n#endif\n\t\t;\n#endif\n}\n\n#undef isneg\n#define isneg(x) fp_do_isneg((x))\n\nPRIVATE inline bool FFPU fp_do_isneg(fpu_register const & r)\n{\n#if USE_LONG_DOUBLE || USE_QUAD_DOUBLE\n\tfp_declare_init_shape(sxp, r, extended);\n#else\n\tfp_declare_init_shape(sxp, r, double);\n#endif\n\treturn sxp->ieee.negative;\n}\n\n#undef iszero\n#define iszero(x) fp_do_iszero((x))\n\nPRIVATE inline bool FFPU fp_do_iszero(fpu_register const & r)\n{\n\t// TODO: BRANCHES_ARE_EXPENSIVE\n#if USE_LONG_DOUBLE || USE_QUAD_DOUBLE\n\tfp_declare_init_shape(sxp, r, extended);\n#else\n\tfp_declare_init_shape(sxp, r, double);\n#endif\n\treturn\t(sxp->ieee.exponent == 0)\n\t\t&&\t(sxp->ieee.mantissa0 == 0)\n\t\t&&\t(sxp->ieee.mantissa1 == 0)\n#ifdef USE_QUAD_DOUBLE\n\t\t&&\t(sxp->ieee.mantissa2 == 0)\n\t\t&&\t(sxp->ieee.mantissa3 == 0)\n#endif\n\t\t;\n}\n\nPRIVATE inline void FFPU get_dest_flags(fpu_register const & r)\n{\n\tfl_dest.negative\t= isneg(r);\n\tfl_dest.zero\t\t= iszero(r);\n\tfl_dest.infinity\t= isinf(r);\n\tfl_dest.nan\t\t\t= isnan(r);\n\tfl_dest.in_range\t= !fl_dest.zero && !fl_dest.infinity && !fl_dest.nan;\n}\n\nPRIVATE inline void FFPU get_source_flags(fpu_register const & r)\n{\n\tfl_source.negative\t= isneg(r);\n\tfl_source.zero\t\t= iszero(r);\n\tfl_source.infinity\t= isinf(r);\n\tfl_source.nan\t\t= isnan(r);\n\tfl_source.in_range\t= !fl_source.zero && !fl_source.infinity && !fl_source.nan;\n}\n\nPRIVATE inline void FFPU make_nan(fpu_register & r)\n{\n\t// FIXME: is that correct ?\n#if USE_LONG_DOUBLE || USE_QUAD_DOUBLE\n\tfp_declare_init_shape(sxp, r, extended);\n\tsxp->ieee.exponent\t= FP_EXTENDED_EXP_MAX;\n\tsxp->ieee.mantissa0\t= 0xffffffff;\n#else\n\tfp_declare_init_shape(sxp, r, double);\n\tsxp->ieee.exponent\t= FP_DOUBLE_EXP_MAX;\n\tsxp->ieee.mantissa0\t= 0xfffff;\n#endif\n\tsxp->ieee.mantissa1\t= 0xffffffff;\n#ifdef USE_QUAD_DOUBLE\n\tsxp->ieee.mantissa2\t= 0xffffffff;\n\tsxp->ieee.mantissa3\t= 0xffffffff;\n#endif\n}\n\nPRIVATE inline void FFPU make_zero_positive(fpu_register & r)\n{\n#if 1\n\tr = +0.0;\n#else\n#if USE_LONG_DOUBLE || USE_QUAD_DOUBLE\n\tfp_declare_init_shape(sxp, r, extended);\n#else\n\tfp_declare_init_shape(sxp, r, double);\n#endif\n\tsxp->ieee.negative\t= 0;\n\tsxp->ieee.exponent\t= 0;\n\tsxp->ieee.mantissa0\t= 0;\n\tsxp->ieee.mantissa1\t= 0;\n#ifdef USE_QUAD_DOUBLE\n\tsxp->ieee.mantissa2\t= 0;\n\tsxp->ieee.mantissa3\t= 0;\n#endif\n#endif\n}\n\nPRIVATE inline void FFPU make_zero_negative(fpu_register & r)\n{\n#if 1\n\tr = -0.0;\n#else\n#if USE_LONG_DOUBLE || USE_QUAD_DOUBLE\n\tfp_declare_init_shape(sxp, r, extended);\n#else\n\tfp_declare_init_shape(sxp, r, double);\n#endif\n\tsxp->ieee.negative\t= 1;\n\tsxp->ieee.exponent\t= 0;\n\tsxp->ieee.mantissa0\t= 0;\n\tsxp->ieee.mantissa1\t= 0;\n#ifdef USE_QUAD_DOUBLE\n\tsxp->ieee.mantissa2\t= 0;\n\tsxp->ieee.mantissa3\t= 0;\n#endif\n#endif\n}\n\nPRIVATE inline void FFPU make_inf_positive(fpu_register & r)\n{\n#if USE_LONG_DOUBLE || USE_QUAD_DOUBLE\n\tfp_declare_init_shape(sxp, r, extended);\n\tsxp->ieee_nan.exponent\t= FP_EXTENDED_EXP_MAX;\n#else\n\tfp_declare_init_shape(sxp, r, double);\n\tsxp->ieee_nan.exponent\t= FP_DOUBLE_EXP_MAX;\n#endif\n\tsxp->ieee_nan.negative\t= 0;\n\tsxp->ieee_nan.mantissa0\t= 0;\n\tsxp->ieee_nan.mantissa1\t= 0;\n#ifdef USE_QUAD_DOUBLE\n\tsxp->ieee_nan.mantissa2 = 0;\n\tsxp->ieee_nan.mantissa3 = 0;\n#endif\n}\n\nPRIVATE inline void FFPU make_inf_negative(fpu_register & r)\n{\n#if USE_LONG_DOUBLE || USE_QUAD_DOUBLE\n\tfp_declare_init_shape(sxp, r, extended);\n\tsxp->ieee_nan.exponent\t= FP_EXTENDED_EXP_MAX;\n#else\n\tfp_declare_init_shape(sxp, r, double);\n\tsxp->ieee_nan.exponent\t= FP_DOUBLE_EXP_MAX;\n#endif\n\tsxp->ieee_nan.negative\t= 1;\n\tsxp->ieee_nan.mantissa0\t= 0;\n\tsxp->ieee_nan.mantissa1\t= 0;\n#ifdef USE_QUAD_DOUBLE\n\tsxp->ieee_nan.mantissa2 = 0;\n\tsxp->ieee_nan.mantissa3 = 0;\n#endif\n}\n\nPRIVATE inline fpu_register FFPU fast_fgetexp(fpu_register const & r)\n{\n#if USE_LONG_DOUBLE || USE_QUAD_DOUBLE\n\tfp_declare_init_shape(sxp, r, extended);\n\treturn (sxp->ieee.exponent - FP_EXTENDED_EXP_BIAS);\n#else\n\tfp_declare_init_shape(sxp, r, double);\n\treturn (sxp->ieee.exponent - FP_DOUBLE_EXP_BIAS);\n#endif\n}\n\n// Normalize to range 1..2\nPRIVATE inline void FFPU fast_remove_exponent(fpu_register & r)\n{\n#if USE_LONG_DOUBLE || USE_QUAD_DOUBLE\n\tfp_declare_init_shape(sxp, r, extended);\n\tsxp->ieee.exponent = FP_EXTENDED_EXP_BIAS;\n#else\n\tfp_declare_init_shape(sxp, r, double);\n\tsxp->ieee.exponent = FP_DOUBLE_EXP_BIAS;\n#endif\n}\n\n// The sign of the quotient is the exclusive-OR of the sign bits\n// of the source and destination operands.\nPRIVATE inline uae_u32 FFPU get_quotient_sign(fpu_register const & ra, fpu_register const & rb)\n{\n#if USE_LONG_DOUBLE || USE_QUAD_DOUBLE\n\tfp_declare_init_shape(sap, ra, extended);\n\tfp_declare_init_shape(sbp, rb, extended);\n#else\n\tfp_declare_init_shape(sap, ra, double);\n\tfp_declare_init_shape(sbp, rb, double);\n#endif\n\treturn ((sap->ieee.negative ^ sbp->ieee.negative) ? FPSR_QUOTIENT_SIGN : 0);\n}\n\n/* -------------------------------------------------------------------------- */\n/* --- Math functions                                                     --- */\n/* -------------------------------------------------------------------------- */\n\n#if FPU_USE_ISO_C99 && (USE_LONG_DOUBLE || USE_QUAD_DOUBLE)\n# ifdef HAVE_LOGL\n#  define fp_log\tlogl\n# endif\n# ifdef HAVE_LOG10L\n#  define fp_log10\tlog10l\n# endif\n# ifdef HAVE_EXPL\n#  define fp_exp\texpl\n# endif\n# ifdef HAVE_POWL\n#  define fp_pow\tpowl\n# endif\n# ifdef HAVE_FABSL\n#  define fp_fabs\tfabsl\n# endif\n# ifdef HAVE_SQRTL\n#  define fp_sqrt\tsqrtl\n# endif\n# ifdef HAVE_SINL\n#  define fp_sin\tsinl\n# endif\n# ifdef HAVE_COSL\n#  define fp_cos\tcosl\n# endif\n# ifdef HAVE_TANL\n#  define fp_tan\ttanl\n# endif\n# ifdef HAVE_SINHL\n#  define fp_sinh\tsinhl\n# endif\n# ifdef HAVE_COSHL\n#  define fp_cosh\tcoshl\n# endif\n# ifdef HAVE_TANHL\n#  define fp_tanh\ttanhl\n# endif\n# ifdef HAVE_ASINL\n#  define fp_asin\tasinl\n# endif\n# ifdef HAVE_ACOSL\n#  define fp_acos\tacosl\n# endif\n# ifdef HAVE_ATANL\n#  define fp_atan\tatanl\n# endif\n# ifdef HAVE_ASINHL\n#  define fp_asinh\tasinhl\n# endif\n# ifdef HAVE_ACOSHL\n#  define fp_acosh\tacoshl\n# endif\n# ifdef HAVE_ATANHL\n#  define fp_atanh\tatanhl\n# endif\n# ifdef HAVE_FLOORL\n#  define fp_floor\tfloorl\n# endif\n# ifdef HAVE_CEILL\n#  define fp_ceil\tceill\n# endif\n#endif\n\n#ifndef fp_log\n# define fp_log\t\tlog\n#endif\n#ifndef fp_log10\n# define fp_log10\tlog10\n#endif\n#ifndef fp_exp\n# define fp_exp\t\texp\n#endif\n#ifndef fp_pow\n# define fp_pow\t\tpow\n#endif\n#ifndef fp_fabs\n# define fp_fabs\tfabs\n#endif\n#ifndef fp_sqrt\n# define fp_sqrt\tsqrt\n#endif\n#ifndef fp_sin\n# define fp_sin\t\tsin\n#endif\n#ifndef fp_cos\n# define fp_cos\t\tcos\n#endif\n#ifndef fp_tan\n# define fp_tan\t\ttan\n#endif\n#ifndef fp_sinh\n# define fp_sinh\tsinh\n#endif\n#ifndef fp_cosh\n# define fp_cosh\tcosh\n#endif\n#ifndef fp_tanh\n# define fp_tanh\ttanh\n#endif\n#ifndef fp_asin\n# define fp_asin\tasin\n#endif\n#ifndef fp_acos\n# define fp_acos\tacos\n#endif\n#ifndef fp_atan\n# define fp_atan\tatan\n#endif\n#ifndef fp_asinh\n# define fp_asinh\tasinh\n#endif\n#ifndef fp_acosh\n# define fp_acosh\tacosh\n#endif\n#ifndef fp_atanh\n# define fp_atanh\tatanh\n#endif\n#ifndef fp_floor\n# define fp_floor\tfloor\n#endif\n#ifndef fp_ceil\n# define fp_ceil\tceil\n#endif\n\n#if defined(FPU_IEEE) && defined(USE_X87_ASSEMBLY)\n// Assembly optimized support functions. Taken from glibc 2.2.2\n\n#undef fp_log\n#define fp_log fp_do_log\n\n#ifndef FPU_FAST_MATH\n// FIXME: unimplemented\nPRIVATE fpu_extended fp_do_log(fpu_extended x);\n#else\nPRIVATE inline fpu_extended fp_do_log(fpu_extended x)\n{\n\tfpu_extended value;\n\t__asm__ __volatile__(\"fldln2; fxch; fyl2x\" : \"=t\" (value) : \"0\" (x) : \"st(1)\");\n\treturn value;\n}\n#endif\n\n#undef fp_log10\n#define fp_log10 fp_do_log10\n\n#ifndef FPU_FAST_MATH\n// FIXME: unimplemented\nPRIVATE fpu_extended fp_do_log10(fpu_extended x);\n#else\nPRIVATE inline fpu_extended fp_do_log10(fpu_extended x)\n{\n\tfpu_extended value;\n\t__asm__ __volatile__(\"fldlg2; fxch; fyl2x\" : \"=t\" (value) : \"0\" (x) : \"st(1)\");\n\treturn value;\n}\n#endif\n\n#undef fp_exp\n#define fp_exp fp_do_exp\n\n#ifndef FPU_FAST_MATH\n// FIXME: unimplemented\nPRIVATE fpu_extended fp_do_exp(fpu_extended x);\n#else\nPRIVATE inline fpu_extended fp_do_exp(fpu_extended x)\n{\n\tfpu_extended value, exponent;\n\t__asm__ __volatile__(\"fldl2e                    # e^x = 2^(x * log2(e))\\n\\t\"\n\t\t\t\t \"fmul      %%st(1)         # x * log2(e)\\n\\t\"\n\t\t\t\t \"fst       %%st(1)\\n\\t\"\n\t\t\t\t \"frndint                   # int(x * log2(e))\\n\\t\"\n\t\t\t\t \"fxch\\n\\t\"\n\t\t\t\t \"fsub      %%st(1)         # fract(x * log2(e))\\n\\t\"\n\t\t\t\t \"f2xm1                     # 2^(fract(x * log2(e))) - 1\\n\\t\"\n\t\t\t\t : \"=t\" (value), \"=u\" (exponent) : \"0\" (x));\n\tvalue += 1.0;\n\t__asm__ __volatile__(\"fscale\" : \"=t\" (value) : \"0\" (value), \"u\" (exponent));\n\treturn value;\n}\n#endif\n\n#undef fp_pow\n#define fp_pow fp_do_pow\n\nPRIVATE fpu_extended fp_do_pow(fpu_extended x, fpu_extended y);\n\n#undef fp_fabs\n#define fp_fabs fp_do_fabs\n\nPRIVATE inline fpu_extended fp_do_fabs(fpu_extended x)\n{\n\tfpu_extended value;\n\t__asm__ __volatile__(\"fabs\" : \"=t\" (value) : \"0\" (x));\n\treturn value;\n}\n\n#undef fp_sqrt\n#define fp_sqrt fp_do_sqrt\n\nPRIVATE inline fpu_extended fp_do_sqrt(fpu_extended x)\n{\n\tfpu_extended value;\n\t__asm__ __volatile__(\"fsqrt\" : \"=t\" (value) : \"0\" (x));\n\treturn value;\n}\n\n#undef fp_sin\n#define fp_sin fp_do_sin\n\nPRIVATE inline fpu_extended fp_do_sin(fpu_extended x)\n{\n\tfpu_extended value;\n\t__asm__ __volatile__(\"fsin\" : \"=t\" (value) : \"0\" (x));\n\treturn value;\n}\n\n#undef fp_cos\n#define fp_cos fp_do_cos\n\nPRIVATE inline fpu_extended fp_do_cos(fpu_extended x)\n{\n\tfpu_extended value;\n\t__asm__ __volatile__(\"fcos\" : \"=t\" (value) : \"0\" (x));\n\treturn value;\n}\n\n#undef fp_tan\n#define fp_tan fp_do_tan\n\nPRIVATE inline fpu_extended fp_do_tan(fpu_extended x)\n{\n\tfpu_extended value;\n\t__asm__ __volatile__(\"fptan\" : \"=t\" (value) : \"0\" (x));\n\treturn value;\n}\n\n#undef fp_expm1\n#define fp_expm1 fp_do_expm1\n\n// Returns: exp(X) - 1.0\nPRIVATE inline fpu_extended fp_do_expm1(fpu_extended x)\n{\n\tfpu_extended value, exponent, temp;\n\t__asm__ __volatile__(\"fldl2e                    # e^x - 1 = 2^(x * log2(e)) - 1\\n\\t\"\n\t\t\t\t \"fmul      %%st(1)         # x * log2(e)\\n\\t\"\n\t\t\t\t \"fst       %%st(1)\\n\\t\"\n\t\t\t\t \"frndint                   # int(x * log2(e))\\n\\t\"\n\t\t\t\t \"fxch\\n\\t\"\n\t\t\t\t \"fsub      %%st(1)         # fract(x * log2(e))\\n\\t\"\n\t\t\t\t \"f2xm1                     # 2^(fract(x * log2(e))) - 1\\n\\t\"\n\t\t\t\t \"fscale                    # 2^(x * log2(e)) - 2^(int(x * log2(e)))\\n\\t\"\n\t\t\t\t : \"=t\" (value), \"=u\" (exponent) : \"0\" (x));\n\t__asm__ __volatile__(\"fscale\" : \"=t\" (temp) : \"0\" (1.0), \"u\" (exponent));\n\ttemp -= 1.0;\n\treturn temp + value ? temp + value : x;\n}\n\n#undef fp_sgn1\n#define fp_sgn1 fp_do_sgn1\n\nPRIVATE inline fpu_extended fp_do_sgn1(fpu_extended x)\n{\n#if USE_LONG_DOUBLE || USE_QUAD_DOUBLE\n\tfp_declare_init_shape(sxp, x, extended);\n\tsxp->ieee_nan.exponent\t= FP_EXTENDED_EXP_MAX;\n\tsxp->ieee_nan.one\t\t= 1;\n#else\n\tfp_declare_init_shape(sxp, x, double);\n\tsxp->ieee_nan.exponent  = FP_DOUBLE_EXP_MAX;\n#endif\n\tsxp->ieee_nan.quiet_nan\t= 0;\n\tsxp->ieee_nan.mantissa0\t= 0;\n\tsxp->ieee_nan.mantissa1\t= 0;\n\treturn x;\n}\n\n#undef fp_sinh\n#define fp_sinh fp_do_sinh\n\n#ifndef FPU_FAST_MATH\n// FIXME: unimplemented\nPRIVATE fpu_extended fp_do_sinh(fpu_extended x);\n#else\nPRIVATE inline fpu_extended fp_do_sinh(fpu_extended x)\n{\n\tfpu_extended exm1 = fp_expm1(fp_fabs(x));\n\treturn 0.5 * (exm1 / (exm1 + 1.0) + exm1) * fp_sgn1(x);\n}\n#endif\n\n#undef fp_cosh\n#define fp_cosh fp_do_cosh\n\n#ifndef FPU_FAST_MATH\n// FIXME: unimplemented\nPRIVATE fpu_extended fp_do_cosh(fpu_extended x);\n#else\nPRIVATE inline fpu_extended fp_do_cosh(fpu_extended x)\n{\n\tfpu_extended ex = fp_exp(x);\n\treturn 0.5 * (ex + 1.0 / ex);\n}\n#endif\n\n#undef fp_tanh\n#define fp_tanh fp_do_tanh\n\n#ifndef FPU_FAST_MATH\n// FIXME: unimplemented\nPRIVATE fpu_extended fp_do_tanh(fpu_extended x);\n#else\nPRIVATE inline fpu_extended fp_do_tanh(fpu_extended x)\n{\n\tfpu_extended exm1 = fp_expm1(-fp_fabs(x + x));\n\treturn exm1 / (exm1 + 2.0) * fp_sgn1(-x);\n}\n#endif\n\n#undef fp_atan2\n#define fp_atan2 fp_do_atan2\n\nPRIVATE inline fpu_extended fp_do_atan2(fpu_extended y, fpu_extended x)\n{\n\tfpu_extended value;\n\t__asm__ __volatile__(\"fpatan\" : \"=t\" (value) : \"0\" (x), \"u\" (y) : \"st(1)\");\n\treturn value;\n}\n\n#undef fp_asin\n#define fp_asin fp_do_asin\n\nPRIVATE inline fpu_extended fp_do_asin(fpu_extended x)\n{\n\treturn fp_atan2(x, fp_sqrt(1.0 - x * x));\n}\n\n#undef fp_acos\n#define fp_acos fp_do_acos\n\nPRIVATE inline fpu_extended fp_do_acos(fpu_extended x)\n{\n\treturn fp_atan2(fp_sqrt(1.0 - x * x), x);\n}\n\n#undef fp_atan\n#define fp_atan fp_do_atan\n\nPRIVATE inline fpu_extended fp_do_atan(fpu_extended x)\n{\n\tfpu_extended value;\n\t__asm__ __volatile__(\"fld1; fpatan\" : \"=t\" (value) : \"0\" (x) : \"st(1)\");\n\treturn value;\n}\n\n#undef fp_log1p\n#define fp_log1p fp_do_log1p\n\n// Returns: ln(1.0 + X)\nPRIVATE fpu_extended fp_do_log1p(fpu_extended x);\n\n#undef fp_asinh\n#define fp_asinh fp_do_asinh\n\nPRIVATE inline fpu_extended fp_do_asinh(fpu_extended x)\n{\n\tfpu_extended y = fp_fabs(x);\n\treturn (fp_log1p(y * y / (fp_sqrt(y * y + 1.0) + 1.0) + y) * fp_sgn1(x));\n}\n\n#undef fp_acosh\n#define fp_acosh fp_do_acosh\n\nPRIVATE inline fpu_extended fp_do_acosh(fpu_extended x)\n{\n\treturn fp_log(x + fp_sqrt(x - 1.0) * fp_sqrt(x + 1.0));\n}\n\n#undef fp_atanh\n#define fp_atanh fp_do_atanh\n\nPRIVATE inline fpu_extended fp_do_atanh(fpu_extended x)\n{\n\tfpu_extended y = fp_fabs(x);\n\treturn -0.5 * fp_log1p(-(y + y) / (1.0 + y)) * fp_sgn1(x);\n}\n\n#undef fp_floor\n#define fp_floor fp_do_floor\n\nPRIVATE inline fpu_extended fp_do_floor(fpu_extended x)\n{\n\tvolatile unsigned int cw;\n\t__asm__ __volatile__(\"fnstcw %0\" : \"=m\" (cw));\n\tvolatile unsigned int cw_temp = (cw & 0xf3ff) | 0x0400; // rounding down\n\t__asm__ __volatile__(\"fldcw %0\" : : \"m\" (cw_temp));\n\tfpu_extended value;\n\t__asm__ __volatile__(\"frndint\" : \"=t\" (value) : \"0\" (x));\n\t__asm__ __volatile__(\"fldcw %0\" : : \"m\" (cw));\n\treturn value;\n}\n\n#undef fp_ceil\n#define fp_ceil fp_do_ceil\n\nPRIVATE inline fpu_extended fp_do_ceil(fpu_extended x)\n{\n\tvolatile unsigned int cw;\n\t__asm__ __volatile__(\"fnstcw %0\" : \"=m\" (cw));\n\tvolatile unsigned int cw_temp = (cw & 0xf3ff) | 0x0800; // rounding up\n\t__asm__ __volatile__(\"fldcw %0\" : : \"m\" (cw_temp));\n\tfpu_extended value;\n\t__asm__ __volatile__(\"frndint\" : \"=t\" (value) : \"0\" (x));\n\t__asm__ __volatile__(\"fldcw %0\" : : \"m\" (cw));\n\treturn value;\n}\n\n#define DEFINE_ROUND_FUNC(rounding_mode_str, rounding_mode)\t\t\t\t\t\t\\\nPRIVATE inline fpu_extended fp_do_round_to_ ## rounding_mode_str(fpu_extended x)\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvolatile unsigned int cw;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t__asm__ __volatile__(\"fnstcw %0\" : \"=m\" (cw));\t\t\t\t\t\t\t\t\t\t\\\n\tvolatile unsigned int cw_temp = (cw & 0xf3ff) | (rounding_mode);\t\t\t\\\n\t__asm__ __volatile__(\"fldcw %0\" : : \"m\" (cw_temp));\t\t\t\t\t\t\t\t\t\\\n\tfpu_extended value;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t__asm__ __volatile__(\"frndint\" : \"=t\" (value) : \"0\" (x));\t\t\t\t\t\t\t\\\n\t__asm__ __volatile__(\"fldcw %0\" : : \"m\" (cw));\t\t\t\t\t\t\t\t\t\t\\\n\treturn value;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n}\n\n#undef fp_round_to_minus_infinity\n#define fp_round_to_minus_infinity fp_do_round_to_minus_infinity\n\nDEFINE_ROUND_FUNC(minus_infinity, 0x400)\n\n#undef fp_round_to_plus_infinity\n#define fp_round_to_plus_infinity fp_do_round_to_plus_infinity\n\nDEFINE_ROUND_FUNC(plus_infinity, 0x800)\n\n#undef fp_round_to_zero\n#define fp_round_to_zero fp_do_round_to_zero\n\nDEFINE_ROUND_FUNC(zero, 0xc00)\n\n#undef fp_round_to_nearest\n#define fp_round_to_nearest fp_do_round_to_nearest\n\nDEFINE_ROUND_FUNC(nearest, 0x000)\n\n#endif /* USE_X87_ASSEMBLY */\n\n#ifndef fp_round_to_minus_infinity\n#define fp_round_to_minus_infinity(x) fp_floor(x)\n#endif\n\n#ifndef fp_round_to_plus_infinity\n#define fp_round_to_plus_infinity(x) fp_ceil(x)\n#endif\n\n#ifndef fp_round_to_zero\n#define fp_round_to_zero(x) ((int)(x))\n#endif\n\n#ifndef fp_round_to_nearest\n#define fp_round_to_nearest(x) ((int)((x) + 0.5))\n#endif\n\n#endif /* FPU_MATHLIB_H */\n","/*\n *  fpu/flags.h - Floating-point flags\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  MC68881/68040 fpu emulation\n *  \n *  Original UAE FPU, copyright 1996 Herman ten Brugge\n *  Rewrite for x86, copyright 1999-2000 Lauri Pesonen\n *  New framework, copyright 2000 Gwenole Beauchesne\n *  Adapted for JIT compilation (c) Bernd Meyer, 2000\n *  \n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef FPU_FLAGS_H\n#define FPU_FLAGS_H\n\n/* NOTE: this file shall be included only from fpu/fpu_*.cpp */\n#undef\tPUBLIC\n#define PUBLIC\textern\n\n#undef\tPRIVATE\n#define PRIVATE\tstatic\n\n#undef\tFFPU\n#define FFPU\t/**/\n\n#undef\tFPU\n#define\tFPU\t\tfpu.\n\n/* Defaults to generic flags */\n#define FPU_USE_GENERIC_FLAGS\n\n/* -------------------------------------------------------------------------- */\n/* --- Selection of floating-point flags handling mode                    --- */\n/* -------------------------------------------------------------------------- */\n\n/* Optimized i386 fpu core must use native flags */\n#if defined(FPU_X86) && defined(USE_X87_ASSEMBLY)\n# undef FPU_USE_GENERIC_FLAGS\n# define FPU_USE_X86_FLAGS\n#endif\n\n/* Old UAE FPU core can use native flags */\n#if defined(FPU_UAE) && defined(USE_X87_ASSEMBLY)\n# undef FPU_USE_GENERIC_FLAGS\n# define FPU_USE_X86_FLAGS\n#endif\n\n/* IEEE-based implementation must use lazy flag evaluation */\n#if defined(FPU_IEEE)\n# undef FPU_USE_GENERIC_FLAGS\n# define FPU_USE_LAZY_FLAGS\n#endif\n\n/* JIT Compilation for FPU only works with lazy evaluation of FPU flags */\n#if defined(FPU_IEEE) && defined(USE_X87_ASSEMBLY) && defined(USE_JIT_FPU)\n# undef FPU_USE_GENERIC_FLAGS\n# define FPU_USE_LAZY_FLAGS\n#endif\n\n#ifdef FPU_IMPLEMENTATION\n\n/* -------------------------------------------------------------------------- */\n/* --- Native X86 Floating-Point Flags                                    --- */\n/* -------------------------------------------------------------------------- */\n\n/* FPU_X86 has its own set of lookup functions */\n\n#ifdef FPU_USE_X86_FLAGS\n\n#define FPU_USE_NATIVE_FLAGS\n\n#define NATIVE_FFLAG_NEGATIVE\t0x0200\n#define NATIVE_FFLAG_ZERO\t\t0x4000\n#define NATIVE_FFLAG_INFINITY\t0x0500\n#define NATIVE_FFLAG_NAN\t\t0x0100\n\n/* Translation tables between native and m68k floating-point flags */\nPRIVATE uae_u32 to_m68k_fpcond[0x48];\nPRIVATE uae_u32 to_host_fpcond[0x10];\n\n/* Truth table for floating-point condition codes */\nPRIVATE uae_u32 fpcond_truth_table[32][8]; // 32 m68k conditions x 8 host condition codes\n\n/* Initialization */\nPUBLIC void FFPU fpu_init_native_fflags(void);\n\n#ifdef FPU_UAE\n\n/* Native to m68k floating-point condition codes */\nPRIVATE inline uae_u32 FFPU get_fpccr(void)\n\t{ return to_m68k_fpcond[(FPU fpsr.condition_codes >> 8) & 0x47]; }\n\n/* M68k to native floating-point condition codes */\nPRIVATE inline void FFPU set_fpccr(uae_u32 new_fpcond)\n\t/* Precondition: new_fpcond is only valid for floating-point condition codes */\n\t{ FPU fpsr.condition_codes = to_host_fpcond[new_fpcond >> 24]; }\n\n/* Make FPSR according to the value passed in argument */\nPRIVATE inline void FFPU make_fpsr(fpu_register const & r)\n\t{ uae_u16 sw; __asm__ __volatile__ (\"fxam\\n\\tfnstsw %0\" : \"=r\" (sw) : \"f\" (r)); FPU fpsr.condition_codes = sw; }\n\n/* Return the corresponding ID of the current floating-point condition codes */\n/* NOTE: only valid for evaluation of a condition */\nPRIVATE inline int FFPU host_fpcond_id(void)\n\t{ return ((FPU fpsr.condition_codes >> 12) & 4) | ((FPU fpsr.condition_codes >> 8) & 3); }\n\n/* Return true if the floating-point condition is satisfied */\nPRIVATE inline bool FFPU fpcctrue(int condition)\n\t{ return fpcond_truth_table[condition][host_fpcond_id()]; }\n\n#endif /* FPU_UAE */\n\n/* Return the address of the floating-point condition codes truth table */\nstatic inline uae_u8 * const FFPU address_of_fpcond_truth_table(void)\n\t{ return ((uae_u8*)&fpcond_truth_table[0][0]); }\n\n#endif /* FPU_X86_USE_NATIVE_FLAGS */\n\n/* -------------------------------------------------------------------------- */\n/* --- Use Original M68K FPU Mappings                                     --- */\n/* -------------------------------------------------------------------------- */\n\n#ifdef FPU_USE_GENERIC_FLAGS\n\n#undef FPU_USE_NATIVE_FLAGS\n\n#define NATIVE_FFLAG_NEGATIVE\t0x08000000\n#define NATIVE_FFLAG_ZERO\t\t0x04000000\n#define NATIVE_FFLAG_INFINITY\t0x02000000\n#define NATIVE_FFLAG_NAN\t\t0x01000000\n\n/* Initialization - NONE */\nPRIVATE inline void FFPU fpu_init_native_fflags(void)\n\t{ }\n\n/* Native to m68k floating-point condition codes - SELF */\nPRIVATE inline uae_u32 FFPU get_fpccr(void)\n\t{ return FPU fpsr.condition_codes; }\n\n/* M68k to native floating-point condition codes - SELF */\nPRIVATE inline void FFPU set_fpccr(uae_u32 new_fpcond)\n\t{ FPU fpsr.condition_codes = new_fpcond; }\n\n#endif /* FPU_USE_GENERIC_FLAGS */\n\n/* -------------------------------------------------------------------------- */\n/* --- Use Lazy Flags Evaluation                                          --- */\n/* -------------------------------------------------------------------------- */\n\n#ifdef FPU_USE_LAZY_FLAGS\n\n#undef FPU_USE_NATIVE_FLAGS\n\n#define NATIVE_FFLAG_NEGATIVE\t0x08000000\n#define NATIVE_FFLAG_ZERO\t\t0x04000000\n#define NATIVE_FFLAG_INFINITY\t0x02000000\n#define NATIVE_FFLAG_NAN\t\t0x01000000\n\n/* Initialization - NONE */\nPRIVATE inline void FFPU fpu_init_native_fflags(void)\n\t{ }\n\n/* Native to m68k floating-point condition codes - SELF */\nPRIVATE inline uae_u32 FFPU get_fpccr(void)\n{\n\tuae_u32 fpccr = 0;\n\tif (isnan(FPU result))\n\t\tfpccr |= FPSR_CCB_NAN;\n\telse if (FPU result == 0.0)\n\t\tfpccr |= FPSR_CCB_ZERO;\n\telse if (FPU result < 0.0)\n\t\tfpccr |= FPSR_CCB_NEGATIVE;\n\tif (isinf(FPU result))\n\t\tfpccr |= FPSR_CCB_INFINITY;\n\treturn fpccr;\n}\n\n/* M68k to native floating-point condition codes - SELF */\nPRIVATE inline void FFPU set_fpccr(uae_u32 new_fpcond)\n{\n\tif (new_fpcond & FPSR_CCB_NAN)\n\t\tmake_nan(FPU result);\n\telse if (new_fpcond & FPSR_CCB_ZERO)\n\t\tFPU result = 0.0;\n\telse if (new_fpcond & FPSR_CCB_NEGATIVE)\n\t\tFPU result = -1.0;\n\telse\n\t\tFPU result = +1.0;\n\t/* gb-- where is Infinity ? */\n}\n\n/* Make FPSR according to the value passed in argument */\nPRIVATE inline void FFPU make_fpsr(fpu_register const & r)\n\t{ FPU result = r; }\n\n#endif /* FPU_USE_LAZY_FLAGS */\n\n#endif\n\n/* -------------------------------------------------------------------------- */\n/* --- Common methods                                                     --- */\n/* -------------------------------------------------------------------------- */\n\n/* Return the address of the floating-point condition codes register */\nstatic inline uae_u32 * const FFPU address_of_fpccr(void)\n\t{ return ((uae_u32 *)& FPU fpsr.condition_codes); }\n\n#endif /* FPU_FLAGS_H */\n","/*\n *  fpu/fpu_ieee.cpp\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  MC68881/68040 fpu emulation\n *\n *  Original UAE FPU, copyright 1996 Herman ten Brugge\n *  Rewrite for x86, copyright 1999-2000 Lauri Pesonen\n *  New framework, copyright 2000 Gwenole Beauchesne\n *  Adapted for JIT compilation (c) Bernd Meyer, 2000\n *  \n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/*\n * Following fixes by Lauri Pesonen, July 1999:\n *\n * FMOVEM list handling:\n *  The lookup tables did not work correctly, rewritten.\n * FINT:\n *  (int) cast does not work, fixed.\n *  Further, now honors the FPU fpcr rounding modes.\n * FINTRZ:\n *  (int) cast cannot be used, fixed.\n * FGETEXP:\n *  Input argument value 0 returned erroneous value.\n * FMOD:\n *  (int) cast cannot be used. Replaced by proper rounding.\n *  Quotient byte handling was missing.\n * FREM:\n *  (int) cast cannot be used. Replaced by proper rounding.\n *  Quotient byte handling was missing.\n * FSCALE:\n *  Input argument value 0 was not handled correctly.\n * FMOVEM Control Registers to/from address FPU registers An:\n *  A bug caused the code never been called.\n * FMOVEM Control Registers pre-decrement:\n *  Moving of control regs from memory to FPP was not handled properly,\n *  if not all of the three FPU registers were moved.\n * Condition code \"Not Greater Than or Equal\":\n *  Returned erroneous value.\n * FSINCOS:\n *  Cosine must be loaded first if same register.\n * FMOVECR:\n *  Status register was not updated (yes, this affects it).\n * FMOVE <ea> -> reg:\n *  Status register was not updated (yes, this affects it).\n * FMOVE reg -> reg:\n *  Status register was not updated.\n * FDBcc:\n *  The loop termination condition was wrong.\n *  Possible leak from int16 to int32 fixed.\n * get_fp_value:\n *  Immediate addressing mode && Operation Length == Byte -> \n *  Use the low-order byte of the extension word.\n * Now FPU fpcr high 16 bits are always read as zeroes, no matter what was\n * written to them.\n *\n * Other:\n * - Optimized single/double/extended to/from conversion functions.\n *   Huge speed boost, but not (necessarily) portable to other systems.\n *   Enabled/disabled by #define FPU_HAVE_IEEE_DOUBLE 1\n * - Optimized versions of FSCALE, FGETEXP, FGETMAN\n * - Conversion routines now handle NaN and infinity better.\n * - Some constants precalculated. Not all compilers can optimize the\n *   expressions previously used.\n *\n * TODO:\n * - Floating point exceptions.\n * - More Infinity/NaN/overflow/underflow checking.\n * - FPU instruction_address (only needed when exceptions are implemented)\n * - Should be written in assembly to support long doubles.\n * - Precision rounding single/double\n */\n\n#include \"sysdeps.h\"\n#include <stdio.h>\n#include \"memory.h\"\n#include \"readcpu.h\"\n#include \"newcpu.h\"\n#include \"main.h\"\n#define FPU_IMPLEMENTATION\n#include \"fpu/fpu.h\"\n#include \"fpu/fpu_ieee.h\"\n\n/* Global FPU context */\nfpu_t fpu;\n\n/* -------------------------------------------------------------------------- */\n/* --- Scopes Definition                                                  --- */\n/* -------------------------------------------------------------------------- */\n\n#undef\tPUBLIC\n#define PUBLIC\t/**/\n\n#undef\tPRIVATE\n#define PRIVATE\tstatic\n\n#undef\tFFPU\n#define FFPU\t/**/\n\n#undef\tFPU\n#define\tFPU\t\tfpu.\n\n/* -------------------------------------------------------------------------- */\n/* --- Native Support                                                     --- */\n/* -------------------------------------------------------------------------- */\n\n#include \"fpu/mathlib.h\"\n#include \"fpu/flags.h\"\n#include \"fpu/exceptions.h\"\n#include \"fpu/rounding.h\"\n#include \"fpu/impl.h\"\n\n#include \"fpu/mathlib.cpp\"\n#include \"fpu/flags.cpp\"\n#include \"fpu/exceptions.cpp\"\n#include \"fpu/rounding.cpp\"\n\n/* -------------------------------------------------------------------------- */\n/* --- Debugging                                                          --- */\n/* -------------------------------------------------------------------------- */\n\nPUBLIC void FFPU fpu_dump_registers(void)\n{\n\tfor (int i = 0; i < 8; i++){\n\t\tprintf (\"FP%d: %g \", i, fpu_get_register(i));\n\t\tif ((i & 3) == 3)\n\t\t\tprintf (\"\\n\");\n\t}\n}\n\nPUBLIC void FFPU fpu_dump_flags(void)\n{\n\tprintf (\"N=%d Z=%d I=%d NAN=%d\\n\",\n\t\t(get_fpsr() & FPSR_CCB_NEGATIVE) != 0,\n\t\t(get_fpsr() & FPSR_CCB_ZERO)!= 0,\n\t\t(get_fpsr() & FPSR_CCB_INFINITY) != 0,\n\t\t(get_fpsr() & FPSR_CCB_NAN) != 0);\n}\n\nPRIVATE void FFPU dump_registers(const char * str)\n{\n#if FPU_DEBUG && FPU_DUMP_REGISTERS\n\tchar temp_str[512];\n\n\tsprintf(temp_str, \"%s: %.04f, %.04f, %.04f, %.04f, %.04f, %.04f, %.04f, %.04f\\n\",\n\t\tstr,\n\t\tfpu_get_register(0), fpu_get_register(1), fpu_get_register(2),\n\t\tfpu_get_register(3), fpu_get_register(4), fpu_get_register(5),\n\t\tfpu_get_register(6), fpu_get_register(7) );\n\t\n\tfpu_debug((temp_str));\n#endif\n}\n\nPRIVATE void FFPU dump_first_bytes(uae_u8 * buffer, uae_s32 actual)\n{\n#if FPU_DEBUG && FPU_DUMP_FIRST_BYTES\n\tchar temp_buf1[256], temp_buf2[10];\n\tint bytes = sizeof(temp_buf1)/3-1-3;\n\tif (actual < bytes)\n\t\tbytes = actual;\n\t\n\ttemp_buf1[0] = 0;\n\tfor (int  i = 0; i < bytes; i++) {\n\t\tsprintf(temp_buf2, \"%02x \", (uae_u32)buffer[i]);\n\t\tstrcat(temp_buf1, temp_buf2);\n\t}\n\t\n\tstrcat(temp_buf1, \"\\n\");\n\tfpu_debug((temp_buf1));\n#endif\n}\n\n// Quotient Byte is loaded with the sign and least significant\n// seven bits of the quotient.\nPRIVATE inline void FFPU make_quotient(fpu_register const & quotient, uae_u32 sign)\n{\n\tuae_u32 lsb = (uae_u32)fp_fabs(quotient) & 0x7f;\n\tFPU fpsr.quotient = sign | (lsb << 16);\n}\n\n// to_single\nPRIVATE inline fpu_register FFPU make_single(uae_u32 value)\n{\n#if 1\n\t// Use a single, otherwise some checks for NaN, Inf, Zero would have to\n\t// be performed\n\tfpu_single result = 0; // = 0 to workaround a compiler bug on SPARC\n\tfp_declare_init_shape(srp, result, single);\n\tsrp->ieee.negative\t= (value >> 31) & 1;\n\tsrp->ieee.exponent\t= (value >> 23) & FP_SINGLE_EXP_MAX;\n\tsrp->ieee.mantissa\t= value & 0x007fffff;\n\tfpu_debug((\"make_single (%X) = %.04f\\n\",value,(double)result));\n\treturn result;\n#elif 0 /* Original code */\n\tif ((value & 0x7fffffff) == 0)\n\t\treturn (0.0);\n\t\n\tfpu_register result;\n\tuae_u32 * p = (uae_u32 *)&result;\n\n\tuae_u32 sign = (value & 0x80000000);\n\tuae_u32 exp  = ((value & 0x7F800000) >> 23) + 1023 - 127;\n\n\tp[FLO] = value << 29;\n\tp[FHI] = sign | (exp << 20) | ((value & 0x007FFFFF) >> 3);\n\n\tfpu_debug((\"make_single (%X) = %.04f\\n\",value,(double)result));\n\t\n\treturn(result);\n#endif\n}\n\n// from_single\nPRIVATE inline uae_u32 FFPU extract_single(fpu_register const & src)\n{\n#if 1\n\tfpu_single input = (fpu_single) src;\n\tfp_declare_init_shape(sip, input, single);\n\tuae_u32 result\t= (sip->ieee.negative << 31)\n\t\t\t\t\t| (sip->ieee.exponent << 23)\n\t\t\t\t\t| sip->ieee.mantissa;\n\tfpu_debug((\"extract_single (%.04f) = %X\\n\",(double)src,result));\n\treturn result;\n#elif 0 /* Original code */\n\tif (src == 0.0)\n\t\treturn 0;\n\t\n\tuae_u32 result;\n\tuae_u32 *p = (uae_u32 *)&src;\n\n\tuae_u32 sign = (p[FHI] & 0x80000000);\n\tuae_u32 exp  = (p[FHI] & 0x7FF00000) >> 20;\n\n\tif(exp + 127 < 1023) {\n\t\texp = 0;\n\t} else if(exp > 1023 + 127) {\n\t\texp = 255;\n\t} else {\n\t\texp = exp + 127 - 1023;\n\t}\n\n\tresult = sign | (exp << 23) | ((p[FHI] & 0x000FFFFF) << 3) | (p[FLO] >> 29);\n\n\tfpu_debug((\"extract_single (%.04f) = %X\\n\",(double)src,result));\n\n\treturn (result);\n#endif\n}\n\n// to_exten\nPRIVATE inline fpu_register FFPU make_extended(uae_u32 wrd1, uae_u32 wrd2, uae_u32 wrd3)\n{\n\t// is it zero?\n\tif ((wrd1 & 0x7fff0000) == 0 && wrd2 == 0 && wrd3 == 0)\n\t\treturn 0.0;\n\n\tfpu_register result;\n#if USE_QUAD_DOUBLE\n\t// is it NaN?\n\tif ((wrd1 & 0x7fff0000) == 0x7fff0000 && wrd2 != 0 && wrd3 != 0) {\n\t\tmake_nan(result);\n\t\treturn result;\n\t}\n\t// is it inf?\n\tif ((wrd1 & 0x7ffff000) == 0x7fff0000 && wrd2 == 0 && wrd3 == 0) {\n\t\tif ((wrd1 & 0x80000000) == 0)\n\t\t\tmake_inf_positive(result);\n\t\telse\n\t\t\tmake_inf_negative(result);\n\t\treturn result;\n\t}\n\tfp_declare_init_shape(srp, result, extended);\n\tsrp->ieee.negative  = (wrd1 >> 31) & 1;\n\tsrp->ieee.exponent  = (wrd1 >> 16) & FP_EXTENDED_EXP_MAX;\n\tsrp->ieee.mantissa0 = (wrd2 >> 16) & 0xffff;\n\tsrp->ieee.mantissa1 = ((wrd2 & 0xffff) << 16) | ((wrd3 >> 16) & 0xffff);\n\tsrp->ieee.mantissa2 = (wrd3 & 0xffff) << 16;\n\tsrp->ieee.mantissa3 = 0;\n#elif USE_LONG_DOUBLE\n\tfp_declare_init_shape(srp, result, extended);\n\tsrp->ieee.negative\t= (wrd1 >> 31) & 1;\n\tsrp->ieee.exponent\t= (wrd1 >> 16) & FP_EXTENDED_EXP_MAX;\n\tsrp->ieee.mantissa0\t= wrd2;\n\tsrp->ieee.mantissa1\t= wrd3;\n#else\n\tuae_u32 sgn = (wrd1 >> 31) & 1;\n\tuae_u32 exp = (wrd1 >> 16) & 0x7fff;\n\n\t// the explicit integer bit is not set, must normalize\n\tif ((wrd2 & 0x80000000) == 0) {\n\t\tfpu_debug((\"make_extended denormalized mantissa (%X,%X,%X)\\n\",wrd1,wrd2,wrd3));\n\t\tif (wrd2 | wrd3) {\n\t\t\t// mantissa, not fraction.\n\t\t\tuae_u64 man = ((uae_u64)wrd2 << 32) | wrd3;\n\t\t\twhile (exp > 0 && (man & UVAL64(0x8000000000000000)) == 0) {\n\t\t\t\tman <<= 1;\n\t\t\t\texp--;\n\t\t\t}\n\t\t\twrd2 = (uae_u32)(man >> 32);\n\t\t\twrd3 = (uae_u32)(man & 0xFFFFFFFF);\n\t\t}\n\t\telse if (exp != 0x7fff) // zero\n\t\t\texp = FP_EXTENDED_EXP_BIAS - FP_DOUBLE_EXP_BIAS;\n\t}\n\n\tif (exp < FP_EXTENDED_EXP_BIAS - FP_DOUBLE_EXP_BIAS)\n\t\texp = 0;\n\telse if (exp > FP_EXTENDED_EXP_BIAS + FP_DOUBLE_EXP_BIAS)\n\t\texp = FP_DOUBLE_EXP_MAX;\n\telse\n\t\texp += FP_DOUBLE_EXP_BIAS - FP_EXTENDED_EXP_BIAS;\n\t\n\tfp_declare_init_shape(srp, result, double);\n\tsrp->ieee.negative  = sgn;\n\tsrp->ieee.exponent  = exp;\n\t// drop the explicit integer bit\n\tsrp->ieee.mantissa0 = (wrd2 & 0x7fffffff) >> 11;\n\tsrp->ieee.mantissa1 = (wrd2 << 21) | (wrd3 >> 11);\n#endif\n\tfpu_debug((\"make_extended (%X,%X,%X) = %.04f\\n\",wrd1,wrd2,wrd3,(double)result));\n\treturn result;\n}\n\n/*\n\tWould be so much easier with full size floats :(\n\t... this is so vague.\n*/\n// make_extended_no_normalize\nPRIVATE inline void FFPU make_extended_no_normalize(\n\tuae_u32 wrd1, uae_u32 wrd2, uae_u32 wrd3, fpu_register & result\n)\n{\n\t// is it zero?\n\tif ((wrd1 && 0x7fff0000) == 0 && wrd2 == 0 && wrd3 == 0) {\n\t\tmake_zero_positive(result);\n\t\treturn;\n\t}\n\t// is it NaN?\n\tif ((wrd1 & 0x7fff0000) == 0x7fff0000 && wrd2 != 0 && wrd3 != 0) {\n\t\tmake_nan(result);\n\t\treturn;\n\t}\n#if USE_QUAD_DOUBLE\n\t// is it inf?\n\tif ((wrd1 & 0x7ffff000) == 0x7fff0000 && wrd2 == 0 && wrd3 == 0) {\n\t\tif ((wrd1 & 0x80000000) == 0)\n\t\t\tmake_inf_positive(result);\n\t\telse\n\t\t\tmake_inf_negative(result);\n\t\treturn;\n\t}\n\tfp_declare_init_shape(srp, result, extended);\n\tsrp->ieee.negative  = (wrd1 >> 31) & 1;\n\tsrp->ieee.exponent  = (wrd1 >> 16) & FP_EXTENDED_EXP_MAX;\n\tsrp->ieee.mantissa0 = (wrd2 >> 16) & 0xffff;\n\tsrp->ieee.mantissa1 = ((wrd2 & 0xffff) << 16) | ((wrd3 >> 16) & 0xffff);\n\tsrp->ieee.mantissa2 = (wrd3 & 0xffff) << 16;\n\tsrp->ieee.mantissa3 = 0;\n#elif USE_LONG_DOUBLE\n\tfp_declare_init_shape(srp, result, extended);\n\tsrp->ieee.negative\t= (wrd1 >> 31) & 1;\n\tsrp->ieee.exponent\t= (wrd1 >> 16) & FP_EXTENDED_EXP_MAX;\n\tsrp->ieee.mantissa0\t= wrd2;\n\tsrp->ieee.mantissa1\t= wrd3;\n#else\n\tuae_u32 exp = (wrd1 >> 16) & 0x7fff;\n\tif (exp < FP_EXTENDED_EXP_BIAS - FP_DOUBLE_EXP_BIAS)\n\t\texp = 0;\n\telse if (exp > FP_EXTENDED_EXP_BIAS + FP_DOUBLE_EXP_BIAS)\n\t\texp = FP_DOUBLE_EXP_MAX;\n\telse\n\t\texp += FP_DOUBLE_EXP_BIAS - FP_EXTENDED_EXP_BIAS;\n\t\n\tfp_declare_init_shape(srp, result, double);\n\tsrp->ieee.negative  = (wrd1 >> 31) & 1;\n\tsrp->ieee.exponent  = exp;\n\t// drop the explicit integer bit\n\tsrp->ieee.mantissa0 = (wrd2 & 0x7fffffff) >> 11;\n\tsrp->ieee.mantissa1 = (wrd2 << 21) | (wrd3 >> 11);\n#endif\n\tfpu_debug((\"make_extended (%X,%X,%X) = %.04f\\n\",wrd1,wrd2,wrd3,(double)result));\n}\n\n// from_exten\nPRIVATE inline void FFPU extract_extended(fpu_register const & src,\n\tuae_u32 * wrd1, uae_u32 * wrd2, uae_u32 * wrd3\n)\n{\n\tif (src == 0.0) {\n\t\t*wrd1 = *wrd2 = *wrd3 = 0;\n\t\treturn;\n\t}\n#if USE_QUAD_DOUBLE\n\t// FIXME: deal with denormals?\n\tfp_declare_init_shape(srp, src, extended);\n\t*wrd1 = (srp->ieee.negative << 31) | (srp->ieee.exponent << 16);\n\t// always set the explicit integer bit.\n\t*wrd2 = 0x80000000 | (srp->ieee.mantissa0 << 15) | ((srp->ieee.mantissa1 & 0xfffe0000) >> 17);\n\t*wrd3 = (srp->ieee.mantissa1 << 15) | ((srp->ieee.mantissa2 & 0xfffe0000) >> 17);\n#elif USE_LONG_DOUBLE\n\tuae_u32 *p = (uae_u32 *)&src;\n#ifdef WORDS_BIGENDIAN\n\t*wrd1 = p[0];\n\t*wrd2 = p[1];\n\t*wrd3 = p[2];\n#else\n\t*wrd3 = p[0];\n\t*wrd2 = p[1];\n\t*wrd1 = ( (uae_u32)*((uae_u16 *)&p[2]) ) << 16;\n#endif\n#else\n\tfp_declare_init_shape(srp, src, double);\n\tfpu_debug((\"extract_extended (%d,%d,%X,%X)\\n\",\n\t\t\t   srp->ieee.negative , srp->ieee.exponent,\n\t\t\t   srp->ieee.mantissa0, srp->ieee.mantissa1));\n\n\tuae_u32 exp = srp->ieee.exponent;\n\n\tif (exp == FP_DOUBLE_EXP_MAX)\n\t\texp = FP_EXTENDED_EXP_MAX;\n\telse\n\t\texp += FP_EXTENDED_EXP_BIAS - FP_DOUBLE_EXP_BIAS;\n\n\t*wrd1 = (srp->ieee.negative << 31) | (exp << 16);\n\t// always set the explicit integer bit.\n\t*wrd2 = 0x80000000 | (srp->ieee.mantissa0 << 11) | ((srp->ieee.mantissa1 & 0xffe00000) >> 21);\n\t*wrd3 = srp->ieee.mantissa1 << 11;\n#endif\n\tfpu_debug((\"extract_extended (%.04f) = %X,%X,%X\\n\",(double)src,*wrd1,*wrd2,*wrd3));\n}\n\n// to_double\nPRIVATE inline fpu_register FFPU make_double(uae_u32 wrd1, uae_u32 wrd2)\n{\n\tunion {\n\t\tfpu_double value;\n\t\tuae_u32    parts[2];\n\t} dest;\n#ifdef WORDS_BIGENDIAN\n\tdest.parts[0] = wrd1;\n\tdest.parts[1] = wrd2;\n#else\n\tdest.parts[0] = wrd2;\n\tdest.parts[1] = wrd1;\n#endif\n\tfpu_debug((\"make_double (%X,%X) = %.04f\\n\",wrd1,wrd2,dest.value));\n\treturn (fpu_register)(dest.value);\n}\n\n// from_double\nPRIVATE inline void FFPU extract_double(fpu_register const & src, \n\tuae_u32 * wrd1, uae_u32 * wrd2\n)\n{\n\tunion {\n\t\tfpu_double value;\n\t\tuae_u32    parts[2];\n\t} dest;\n\tdest.value = (fpu_double)src;\n#ifdef WORDS_BIGENDIAN\n\t*wrd1 = dest.parts[0];\n\t*wrd2 = dest.parts[1];\n#else\n\t*wrd2 = dest.parts[0];\n\t*wrd1 = dest.parts[1];\n#endif\n\tfpu_debug((\"extract_double (%.04f) = %X,%X\\n\",(double)src,*wrd1,*wrd2));\n}\n\n// to_pack\nPRIVATE inline fpu_register FFPU make_packed(uae_u32 wrd1, uae_u32 wrd2, uae_u32 wrd3)\n{\n\tfpu_double d;\n\tchar *cp;\n\tchar str[100];\n\n\tcp = str;\n\tif (wrd1 & 0x80000000)\n\t\t*cp++ = '-';\n\t*cp++ = (char)((wrd1 & 0xf) + '0');\n\t*cp++ = '.';\n\t*cp++ = (char)(((wrd2 >> 28) & 0xf) + '0');\n\t*cp++ = (char)(((wrd2 >> 24) & 0xf) + '0');\n\t*cp++ = (char)(((wrd2 >> 20) & 0xf) + '0');\n\t*cp++ = (char)(((wrd2 >> 16) & 0xf) + '0');\n\t*cp++ = (char)(((wrd2 >> 12) & 0xf) + '0');\n\t*cp++ = (char)(((wrd2 >> 8) & 0xf) + '0');\n\t*cp++ = (char)(((wrd2 >> 4) & 0xf) + '0');\n\t*cp++ = (char)(((wrd2 >> 0) & 0xf) + '0');\n\t*cp++ = (char)(((wrd3 >> 28) & 0xf) + '0');\n\t*cp++ = (char)(((wrd3 >> 24) & 0xf) + '0');\n\t*cp++ = (char)(((wrd3 >> 20) & 0xf) + '0');\n\t*cp++ = (char)(((wrd3 >> 16) & 0xf) + '0');\n\t*cp++ = (char)(((wrd3 >> 12) & 0xf) + '0');\n\t*cp++ = (char)(((wrd3 >> 8) & 0xf) + '0');\n\t*cp++ = (char)(((wrd3 >> 4) & 0xf) + '0');\n\t*cp++ = (char)(((wrd3 >> 0) & 0xf) + '0');\n\t*cp++ = 'E';\n\tif (wrd1 & 0x40000000)\n\t\t*cp++ = '-';\n\t*cp++ = (char)(((wrd1 >> 24) & 0xf) + '0');\n\t*cp++ = (char)(((wrd1 >> 20) & 0xf) + '0');\n\t*cp++ = (char)(((wrd1 >> 16) & 0xf) + '0');\n\t*cp = 0;\n\tsscanf(str, \"%le\", &d);\n\n\tfpu_debug((\"make_packed str = %s\\n\",str));\n\n\tfpu_debug((\"make_packed(%X,%X,%X) = %.04f\\n\",wrd1,wrd2,wrd3,(double)d));\n\treturn d;\n}\n\n// from_pack\nPRIVATE inline void FFPU extract_packed(fpu_register const & src, uae_u32 * wrd1, uae_u32 * wrd2, uae_u32 * wrd3)\n{\n\tint i;\n\tint t;\n\tchar *cp;\n\tchar str[100];\n\n\tsprintf(str, \"%.16e\", src);\n\n\tfpu_debug((\"extract_packed(%.04f,%s)\\n\",(double)src,str));\n\n\tcp = str;\n\t*wrd1 = *wrd2 = *wrd3 = 0;\n\tif (*cp == '-') {\n\t\tcp++;\n\t\t*wrd1 = 0x80000000;\n\t}\n\tif (*cp == '+')\n\t\tcp++;\n\t*wrd1 |= (*cp++ - '0');\n\tif (*cp == '.')\n\t\tcp++;\n\tfor (i = 0; i < 8; i++) {\n\t\t*wrd2 <<= 4;\n\t\tif (*cp >= '0' && *cp <= '9')\n\t\t*wrd2 |= *cp++ - '0';\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\t*wrd3 <<= 4;\n\t\tif (*cp >= '0' && *cp <= '9')\n\t\t*wrd3 |= *cp++ - '0';\n\t}\n\tif (*cp == 'e' || *cp == 'E') {\n\t\tcp++;\n\t\tif (*cp == '-') {\n\t\t\tcp++;\n\t\t\t*wrd1 |= 0x40000000;\n\t\t}\n\t\tif (*cp == '+')\n\t\t\tcp++;\n\t\tt = 0;\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (*cp >= '0' && *cp <= '9')\n\t\t\t\tt = (t << 4) | (*cp++ - '0');\n\t\t}\n\t\t*wrd1 |= t << 16;\n\t}\n\n\tfpu_debug((\"extract_packed(%.04f) = %X,%X,%X\\n\",(double)src,*wrd1,*wrd2,*wrd3));\n}\n\nPRIVATE inline int FFPU get_fp_value (uae_u32 opcode, uae_u16 extra, fpu_register & src)\n{\n\tuaecptr tmppc;\n\tuae_u16 tmp;\n\tint size;\n\tint mode;\n\tint reg;\n\tuae_u32 ad = 0;\n\tstatic int sz1[8] = {4, 4, 12, 12, 2, 8, 1, 0};\n\tstatic int sz2[8] = {4, 4, 12, 12, 2, 8, 2, 0};\n\n\t// fpu_debug((\"get_fp_value(%X,%X)\\n\",(int)opcode,(int)extra));\n\t// dump_first_bytes( regs.pc_p-4, 16 );\n\n\tif ((extra & 0x4000) == 0) {\n\t\tsrc = FPU registers[(extra >> 10) & 7];\n\t\treturn 1;\n\t}\n\tmode = (opcode >> 3) & 7;\n\treg = opcode & 7;\n\tsize = (extra >> 10) & 7;\n\n\tfpu_debug((\"get_fp_value mode=%d, reg=%d, size=%d\\n\",(int)mode,(int)reg,(int)size));\n\n\tswitch (mode) {\n\tcase 0:\n\t\tswitch (size) {\n\t\tcase 6:\n\t\t\tsrc = (fpu_register) (uae_s8) m68k_dreg (regs, reg);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tsrc = (fpu_register) (uae_s16) m68k_dreg (regs, reg);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tsrc = (fpu_register) (uae_s32) m68k_dreg (regs, reg);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tsrc = make_single(m68k_dreg (regs, reg));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\tcase 1:\n\t\treturn 0;\n\tcase 2:\n\t\tad = m68k_areg (regs, reg);\n\t\tbreak;\n\tcase 3:\n\t\tad = m68k_areg (regs, reg);\n\t\tm68k_areg (regs, reg) += reg == 7 ? sz2[size] : sz1[size];\n\t\tbreak;\n\tcase 4:\n\t\tm68k_areg (regs, reg) -= reg == 7 ? sz2[size] : sz1[size];\n\t\tad = m68k_areg (regs, reg);\n\t\tbreak;\n\tcase 5:\n\t\tad = m68k_areg (regs, reg) + (uae_s32) (uae_s16) next_iword();\n\t\tbreak;\n\tcase 6:\n\t\tad = get_disp_ea_020 (m68k_areg (regs, reg), next_iword());\n\t\tbreak;\n\tcase 7:\n\t\tswitch (reg) {\n\t\tcase 0:\n\t\t\tad = (uae_s32) (uae_s16) next_iword();\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tad = next_ilong();\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tad = m68k_getpc ();\n\t\t\tad += (uae_s32) (uae_s16) next_iword();\n\t\t\tfpu_debug((\"get_fp_value next_iword()=%X\\n\",ad-m68k_getpc()-2));\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ttmppc = m68k_getpc ();\n\t\t\ttmp = (uae_u16)next_iword();\n\t\t\tad = get_disp_ea_020 (tmppc, tmp);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tad = m68k_getpc ();\n\t\t\tm68k_setpc (ad + sz2[size]);\n\t\t\t// Immediate addressing mode && Operation Length == Byte -> \n\t\t\t// Use the low-order byte of the extension word.\n\t\t\tif(size == 6) ad++;\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfpu_debug((\"get_fp_value m68k_getpc()=%X\\n\",m68k_getpc()));\n\tfpu_debug((\"get_fp_value ad=%X\\n\",ad));\n\tfpu_debug((\"get_fp_value get_long (ad)=%X\\n\",get_long (ad)));\n\tdump_first_bytes( get_real_address(ad)-64, 64 );\n\tdump_first_bytes( get_real_address(ad), 64 );\n\n\tswitch (size) {\n\tcase 0:\n\t\tsrc = (fpu_register) (uae_s32) get_long (ad);\n\t\tbreak;\n\tcase 1:\n\t\tsrc = make_single(get_long (ad));\n\t\tbreak;\n\tcase 2: {\n\t\tuae_u32 wrd1, wrd2, wrd3;\n\t\twrd1 = get_long (ad);\n\t\tad += 4;\n\t\twrd2 = get_long (ad);\n\t\tad += 4;\n\t\twrd3 = get_long (ad);\n\t\tsrc = make_extended(wrd1, wrd2, wrd3);\n\t\tbreak;\n\t}\n\tcase 3: {\n\t\tuae_u32 wrd1, wrd2, wrd3;\n\t\twrd1 = get_long (ad);\n\t\tad += 4;\n\t\twrd2 = get_long (ad);\n\t\tad += 4;\n\t\twrd3 = get_long (ad);\n\t\tsrc = make_packed(wrd1, wrd2, wrd3);\n\t\tbreak;\n\t}\n\tcase 4:\n\t\tsrc = (fpu_register) (uae_s16) get_word(ad);\n\t\tbreak;\n\tcase 5: {\n\t\tuae_u32 wrd1, wrd2;\n\t\twrd1 = get_long (ad);\n\t\tad += 4;\n\t\twrd2 = get_long (ad);\n\t\tsrc = make_double(wrd1, wrd2);\n\t\tbreak;\n\t}\n\tcase 6:\n\t\tsrc = (fpu_register) (uae_s8) get_byte(ad);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\t\n\t// fpu_debug((\"get_fp_value result = %.04f\\n\",(float)src));\n\treturn 1;\n}\n\n/* Convert the FP value to integer according to the current m68k rounding mode */\nPRIVATE inline uae_s32 FFPU toint(fpu_register const & src)\n{\n\tfpu_register result;\n\tswitch (get_fpcr() & 0x30) {\n\tcase FPCR_ROUND_ZERO:\n\t\tresult = fp_round_to_zero(src);\n\t\tbreak;\n\tcase FPCR_ROUND_MINF:\n\t\tresult = fp_round_to_minus_infinity(src);\n\t\tbreak;\n\tcase FPCR_ROUND_NEAR:\n\t\tresult = fp_round_to_nearest(src);\n\t\tbreak;\n\tcase FPCR_ROUND_PINF:\n\t\tresult = fp_round_to_plus_infinity(src);\n\t\tbreak;\n\tdefault:\n\t\tresult = src; /* should never be reached */\n\t\tbreak;\n\t}\n\treturn (uae_s32)result;\n}\n\nPRIVATE inline int FFPU put_fp_value (uae_u32 opcode, uae_u16 extra, fpu_register const & value)\n{\n\tuae_u16 tmp;\n\tuaecptr tmppc;\n\tint size;\n\tint mode;\n\tint reg;\n\tuae_u32 ad;\n\tstatic int sz1[8] = {4, 4, 12, 12, 2, 8, 1, 0};\n\tstatic int sz2[8] = {4, 4, 12, 12, 2, 8, 2, 0};\n\n\t// fpu_debug((\"put_fp_value(%.04f,%X,%X)\\n\",(float)value,(int)opcode,(int)extra));\n\n\tif ((extra & 0x4000) == 0) {\n\t\tint dest_reg = (extra >> 10) & 7;\n\t\tFPU registers[dest_reg] = value;\n\t\tmake_fpsr(FPU registers[dest_reg]);\n\t\treturn 1;\n\t}\n\tmode = (opcode >> 3) & 7;\n\treg = opcode & 7;\n\tsize = (extra >> 10) & 7;\n\tad = 0xffffffff;\n\tswitch (mode) {\n\tcase 0:\n\t\tswitch (size) {\n\t\tcase 6:\n\t\t\tm68k_dreg (regs, reg) = ((toint(value) & 0xff)\n\t\t\t\t\t\t\t\t\t | (m68k_dreg (regs, reg) & ~0xff));\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tm68k_dreg (regs, reg) = ((toint(value) & 0xffff)\n\t\t\t\t\t\t\t\t\t | (m68k_dreg (regs, reg) & ~0xffff));\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tm68k_dreg (regs, reg) = toint(value);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tm68k_dreg (regs, reg) = extract_single(value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\tcase 1:\n\t\treturn 0;\n\tcase 2:\n\t\tad = m68k_areg (regs, reg);\n\t\tbreak;\n\tcase 3:\n\t\tad = m68k_areg (regs, reg);\n\t\tm68k_areg (regs, reg) += reg == 7 ? sz2[size] : sz1[size];\n\t\tbreak;\n\tcase 4:\n\t\tm68k_areg (regs, reg) -= reg == 7 ? sz2[size] : sz1[size];\n\t\tad = m68k_areg (regs, reg);\n\t\tbreak;\n\tcase 5:\n\t\tad = m68k_areg (regs, reg) + (uae_s32) (uae_s16) next_iword();\n\t\tbreak;\n\tcase 6:\n\t\tad = get_disp_ea_020 (m68k_areg (regs, reg), next_iword());\n\t\tbreak;\n\tcase 7:\n\t\tswitch (reg) {\n\t\tcase 0:\n\t\t\tad = (uae_s32) (uae_s16) next_iword();\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tad = next_ilong();\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tad = m68k_getpc ();\n\t\t\tad += (uae_s32) (uae_s16) next_iword();\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ttmppc = m68k_getpc ();\n\t\t\ttmp = (uae_u16)next_iword();\n\t\t\tad = get_disp_ea_020 (tmppc, tmp);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tad = m68k_getpc ();\n\t\t\tm68k_setpc (ad + sz2[size]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\tswitch (size) {\n\tcase 0:\n\t\tput_long (ad, toint(value));\n\t\tbreak;\n\tcase 1:\n\t\tput_long (ad, extract_single(value));\n\t\tbreak;\n\tcase 2: {\n\t\tuae_u32 wrd1, wrd2, wrd3;\n\t\textract_extended(value, &wrd1, &wrd2, &wrd3);\n\t\tput_long (ad, wrd1);\n\t\tad += 4;\n\t\tput_long (ad, wrd2);\n\t\tad += 4;\n\t\tput_long (ad, wrd3);\n\t\tbreak;\n\t}\n\tcase 3: {\n\t\tuae_u32 wrd1, wrd2, wrd3;\n\t\textract_packed(value, &wrd1, &wrd2, &wrd3);\n\t\tput_long (ad, wrd1);\n\t\tad += 4;\n\t\tput_long (ad, wrd2);\n\t\tad += 4;\n\t\tput_long (ad, wrd3);\n\t\tbreak;\n\t}\n\tcase 4:\n\t\tput_word(ad, (uae_s16) toint(value));\n\t\tbreak;\n\tcase 5: {\n\t\tuae_u32 wrd1, wrd2;\n\t\textract_double(value, &wrd1, &wrd2);\n\t\tput_long (ad, wrd1);\n\t\tad += 4;\n\t\tput_long (ad, wrd2);\n\t\tbreak;\n\t}\n\tcase 6:\n\t\tput_byte(ad, (uae_s8) toint(value));\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nPRIVATE inline int FFPU get_fp_ad(uae_u32 opcode, uae_u32 * ad)\n{\n\tuae_u16 tmp;\n\tuaecptr tmppc;\n\tint mode;\n\tint reg;\n\n\tmode = (opcode >> 3) & 7;\n\treg = opcode & 7;\n\tswitch (mode) {\n\tcase 0:\n\tcase 1:\n\t\treturn 0;\n\tcase 2:\n\t\t*ad = m68k_areg (regs, reg);\n\t\tbreak;\n\tcase 3:\n\t\t*ad = m68k_areg (regs, reg);\n\t\tbreak;\n\tcase 4:\n\t\t*ad = m68k_areg (regs, reg);\n\t\tbreak;\n\tcase 5:\n\t\t*ad = m68k_areg (regs, reg) + (uae_s32) (uae_s16) next_iword();\n\t\tbreak;\n\tcase 6:\n\t\t*ad = get_disp_ea_020 (m68k_areg (regs, reg), next_iword());\n\t\tbreak;\n\tcase 7:\n\t\tswitch (reg) {\n\t\tcase 0:\n\t\t\t*ad = (uae_s32) (uae_s16) next_iword();\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*ad = next_ilong();\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*ad = m68k_getpc ();\n\t\t\t*ad += (uae_s32) (uae_s16) next_iword();\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ttmppc = m68k_getpc ();\n\t\t\ttmp = (uae_u16)next_iword();\n\t\t\t*ad = get_disp_ea_020 (tmppc, tmp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n#if FPU_DEBUG\n# define CONDRET(s,x) fpu_debug((\"fpp_cond %s = %d\\n\",s,(uint32)(x))); return (x)\n#else\n# define CONDRET(s,x) return (x)\n#endif\n\nPRIVATE inline int FFPU fpp_cond(int condition)\n{\n\tint N\t= (FPU result < 0.0);\n\tint Z\t= (FPU result == 0.0);\n\tint NaN\t= isnan(FPU result);\n\t\n\tif (NaN)\n\t\tN = Z = 0;\n\n\tswitch (condition) {\n\tcase 0x00:\tCONDRET(\"False\",0);\n\tcase 0x01:\tCONDRET(\"Equal\",Z);\n\tcase 0x02:\tCONDRET(\"Ordered Greater Than\",!(NaN || Z || N));\n\tcase 0x03:\tCONDRET(\"Ordered Greater Than or Equal\",Z || !(NaN || N));\n\tcase 0x04:\tCONDRET(\"Ordered Less Than\",N && !(NaN || Z));\n\tcase 0x05:\tCONDRET(\"Ordered Less Than or Equal\",Z || (N && !NaN));\n\tcase 0x06:\tCONDRET(\"Ordered Greater or Less Than\",!(NaN || Z));\n\tcase 0x07:\tCONDRET(\"Ordered\",!NaN);\n\tcase 0x08:\tCONDRET(\"Unordered\",NaN);\n\tcase 0x09:\tCONDRET(\"Unordered or Equal\",NaN || Z);\n\tcase 0x0a:\tCONDRET(\"Unordered or Greater Than\",NaN || !(N || Z));\n\tcase 0x0b:\tCONDRET(\"Unordered or Greater or Equal\",NaN || Z || !N);\n\tcase 0x0c:\tCONDRET(\"Unordered or Less Than\",NaN || (N && !Z));\n\tcase 0x0d:\tCONDRET(\"Unordered or Less or Equal\",NaN || Z || N);\n\tcase 0x0e:\tCONDRET(\"Not Equal\",!Z);\n\tcase 0x0f:\tCONDRET(\"True\",1);\n\tcase 0x10:\tCONDRET(\"Signaling False\",0);\n\tcase 0x11:\tCONDRET(\"Signaling Equal\",Z);\n\tcase 0x12:\tCONDRET(\"Greater Than\",!(NaN || Z || N));\n\tcase 0x13:\tCONDRET(\"Greater Than or Equal\",Z || !(NaN || N));\n\tcase 0x14:\tCONDRET(\"Less Than\",N && !(NaN || Z));\n\tcase 0x15:\tCONDRET(\"Less Than or Equal\",Z || (N && !NaN));\n\tcase 0x16:\tCONDRET(\"Greater or Less Than\",!(NaN || Z));\n\tcase 0x17:\tCONDRET(\"Greater, Less or Equal\",!NaN);\n\tcase 0x18:\tCONDRET(\"Not Greater, Less or Equal\",NaN);\n\tcase 0x19:\tCONDRET(\"Not Greater or Less Than\",NaN || Z);\n\tcase 0x1a:\tCONDRET(\"Not Less Than or Equal\",NaN || !(N || Z));\n\tcase 0x1b:\tCONDRET(\"Not Less Than\",NaN || Z || !N);\n\tcase 0x1c:\tCONDRET(\"Not Greater Than or Equal\", NaN || (N && !Z));\n\tcase 0x1d:\tCONDRET(\"Not Greater Than\",NaN || Z || N);\n\tcase 0x1e:\tCONDRET(\"Signaling Not Equal\",!Z);\n\tcase 0x1f:\tCONDRET(\"Signaling True\",1);\n\tdefault:\tCONDRET(\"\",-1);\n\t}\n}\n\nvoid FFPU fpuop_dbcc(uae_u32 opcode, uae_u32 extra)\n{\n\tfpu_debug((\"fdbcc_opp %X, %X at %08lx\\n\", (uae_u32)opcode, (uae_u32)extra, m68k_getpc ()));\n\n\tuaecptr pc = (uae_u32) m68k_getpc ();\n\tuae_s32 disp = (uae_s32) (uae_s16) next_iword();\n\tint cc = fpp_cond(extra & 0x3f);\n\tif (cc == -1) {\n\t\tm68k_setpc (pc - 4);\n\t\top_illg (opcode);\n\t} else if (!cc) {\n\t\tint reg = opcode & 0x7;\n\n\t\t// this may have leaked.\n\t\t/*\n\t\tm68k_dreg (regs, reg) = ((m68k_dreg (regs, reg) & ~0xffff)\n\t\t\t\t| ((m68k_dreg (regs, reg) - 1) & 0xffff));\n\t\t*/\n\t\tm68k_dreg (regs, reg) = ((m68k_dreg (regs, reg) & 0xffff0000)\n\t\t\t\t| (((m68k_dreg (regs, reg) & 0xffff) - 1) & 0xffff));\n\n\n\t\t// condition reversed.\n\t\t// if ((m68k_dreg (regs, reg) & 0xffff) == 0xffff)\n\t\tif ((m68k_dreg (regs, reg) & 0xffff) != 0xffff)\n\t\tm68k_setpc (pc + disp);\n\t}\n}\n\nvoid FFPU fpuop_scc(uae_u32 opcode, uae_u32 extra)\n{\n\tfpu_debug((\"fscc_opp %X, %X at %08lx\\n\", (uae_u32)opcode, (uae_u32)extra, m68k_getpc ()));\n\t\n\tuae_u32 ad;\n\tint cc = fpp_cond(extra & 0x3f);\n\tif (cc == -1) {\n\t\tm68k_setpc (m68k_getpc () - 4);\n\t\top_illg (opcode);\n\t}\n\telse if ((opcode & 0x38) == 0) {\n\t\tm68k_dreg (regs, opcode & 7) = (m68k_dreg (regs, opcode & 7) & ~0xff) |\n\t\t(cc ? 0xff : 0x00);\n\t}\n\telse if (get_fp_ad(opcode, &ad) == 0) {\n\t\tm68k_setpc (m68k_getpc () - 4);\n\t\top_illg (opcode);\n\t}\n\telse\n\t\tput_byte(ad, cc ? 0xff : 0x00);\n}\n\nvoid FFPU fpuop_trapcc(uae_u32 opcode, uaecptr oldpc)\n{\n\tfpu_debug((\"ftrapcc_opp %X at %08lx\\n\", (uae_u32)opcode, m68k_getpc ()));\n\t\n\tint cc = fpp_cond(opcode & 0x3f);\n\tif (cc == -1) {\n\t\tm68k_setpc (oldpc);\n\t\top_illg (opcode);\n\t}\n\tif (cc)\n\t\tException(7, oldpc - 2);\n}\n\n// NOTE that we get here also when there is a FNOP (nontrapping false, displ 0)\nvoid FFPU fpuop_bcc(uae_u32 opcode, uaecptr pc, uae_u32 extra)\n{\n\tfpu_debug((\"fbcc_opp %X, %X at %08lx, jumpto=%X\\n\", (uae_u32)opcode, (uae_u32)extra, m68k_getpc (), extra ));\n\n\tint cc = fpp_cond(opcode & 0x3f);\n\tif (cc == -1) {\n\t\tm68k_setpc (pc);\n\t\top_illg (opcode);\n\t}\n\telse if (cc) {\n\t\tif ((opcode & 0x40) == 0)\n\t\t\textra = (uae_s32) (uae_s16) extra;\n\t\tm68k_setpc (pc + extra);\n\t}\n}\n\n// FSAVE has no post-increment\n// 0x1f180000 == IDLE state frame, coprocessor version number 1F\nvoid FFPU fpuop_save(uae_u32 opcode)\n{\n\tfpu_debug((\"fsave_opp at %08lx\\n\", m68k_getpc ()));\n\n\tuae_u32 ad;\n\tint incr = (opcode & 0x38) == 0x20 ? -1 : 1;\n\tint i;\n\n\tif (get_fp_ad(opcode, &ad) == 0) {\n\t\tm68k_setpc (m68k_getpc () - 2);\n\t\top_illg (opcode);\n\t\treturn;\n\t}\n\n\tif (CPUType == 4) {\n\t\t// Put 4 byte 68040 IDLE frame.\n\t\tif (incr < 0) {\n\t\t\tad -= 4;\n\t\t\tput_long (ad, 0x41000000);\n\t\t}\n\t\telse {\n\t\t\tput_long (ad, 0x41000000);\n\t\t\tad += 4;\n\t\t}\n\t} else {\n\t\t// Put 28 byte 68881 IDLE frame.\n\t\tif (incr < 0) {\n\t\t\tfpu_debug((\"fsave_opp pre-decrement\\n\"));\n\t\t\tad -= 4;\n\t\t\t// What's this? Some BIU flags, or (incorrectly placed) command/condition?\n\t\t\tput_long (ad, 0x70000000);\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tad -= 4;\n\t\t\t\tput_long (ad, 0x00000000);\n\t\t\t}\n\t\t\tad -= 4;\n\t\t\tput_long (ad, 0x1f180000); // IDLE, vers 1f\n\t\t}\n\t\telse {\n\t\t\tput_long (ad, 0x1f180000); // IDLE, vers 1f\n\t\t\tad += 4;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tput_long (ad, 0x00000000);\n\t\t\t\tad += 4;\n\t\t\t}\n\t\t\t// What's this? Some BIU flags, or (incorrectly placed) command/condition?\n\t\t\tput_long (ad, 0x70000000);\n\t\t\tad += 4;\n\t\t}\n\t}\n\tif ((opcode & 0x38) == 0x18) {\n\t\tm68k_areg (regs, opcode & 7) = ad; // Never executed on a 68881\n\t\tfpu_debug((\"PROBLEM: fsave_opp post-increment\\n\"));\n\t}\n\tif ((opcode & 0x38) == 0x20) {\n\t\tm68k_areg (regs, opcode & 7) = ad;\n\t\tfpu_debug((\"fsave_opp pre-decrement %X -> A%d\\n\",ad,opcode & 7));\n\t}\n}\n\n// FRESTORE has no pre-decrement\nvoid FFPU fpuop_restore(uae_u32 opcode)\n{\n\tfpu_debug((\"frestore_opp at %08lx\\n\", m68k_getpc ()));\n\n\tuae_u32 ad;\n\tuae_u32 d;\n\tint incr = (opcode & 0x38) == 0x20 ? -1 : 1;\n\n\tif (get_fp_ad(opcode, &ad) == 0) {\n\t\tm68k_setpc (m68k_getpc () - 2);\n\t\top_illg (opcode);\n\t\treturn;\n\t}\n\n\tif (CPUType == 4) {\n\t\t// 68040\n\t\tif (incr < 0) {\n\t\t\tfpu_debug((\"PROBLEM: frestore_opp incr < 0\\n\"));\n\t\t\t// this may be wrong, but it's never called.\n\t\t\tad -= 4;\n\t\t\td = get_long (ad);\n\t\t\tif ((d & 0xff000000) != 0) { // Not a NULL frame?\n\t\t\t\tif ((d & 0x00ff0000) == 0) { // IDLE\n\t\t\t\t\tfpu_debug((\"frestore_opp found IDLE frame at %X\\n\",ad-4));\n\t\t\t\t}\n\t\t\t\telse if ((d & 0x00ff0000) == 0x00300000) { // UNIMP\n\t\t\t\t\tfpu_debug((\"PROBLEM: frestore_opp found UNIMP frame at %X\\n\",ad-4));\n\t\t\t\t\tad -= 44;\n\t\t\t\t}\n\t\t\t\telse if ((d & 0x00ff0000) == 0x00600000) { // BUSY\n\t\t\t\t\tfpu_debug((\"PROBLEM: frestore_opp found BUSY frame at %X\\n\",ad-4));\n\t\t\t\t\tad -= 92;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\td = get_long (ad);\n\t\t\tfpu_debug((\"frestore_opp frame at %X = %X\\n\",ad,d));\n\t\t\tad += 4;\n\t\t\tif ((d & 0xff000000) != 0) { // Not a NULL frame?\n\t\t\t\tif ((d & 0x00ff0000) == 0) { // IDLE\n\t\t\t\t\tfpu_debug((\"frestore_opp found IDLE frame at %X\\n\",ad-4));\n\t\t\t\t}\n\t\t\t\telse if ((d & 0x00ff0000) == 0x00300000) { // UNIMP\n\t\t\t\t\tfpu_debug((\"PROBLEM: frestore_opp found UNIMP frame at %X\\n\",ad-4));\n\t\t\t\t\tad += 44;\n\t\t\t\t}\n\t\t\t\telse if ((d & 0x00ff0000) == 0x00600000) { // BUSY\n\t\t\t\t\tfpu_debug((\"PROBLEM: frestore_opp found BUSY frame at %X\\n\",ad-4));\n\t\t\t\t\tad += 92;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// 68881\n\t\tif (incr < 0) {\n\t\t\tfpu_debug((\"PROBLEM: frestore_opp incr < 0\\n\"));\n\t\t\t// this may be wrong, but it's never called.\n\t\t\tad -= 4;\n\t\t\td = get_long (ad);\n\t\t\tif ((d & 0xff000000) != 0) {\n\t\t\t\tif ((d & 0x00ff0000) == 0x00180000)\n\t\t\t\t\tad -= 6 * 4;\n\t\t\t\telse if ((d & 0x00ff0000) == 0x00380000)\n\t\t\t\t\tad -= 14 * 4;\n\t\t\t\telse if ((d & 0x00ff0000) == 0x00b40000)\n\t\t\t\t\tad -= 45 * 4;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\td = get_long (ad);\n\t\t\tfpu_debug((\"frestore_opp frame at %X = %X\\n\",ad,d));\n\t\t\tad += 4;\n\t\t\tif ((d & 0xff000000) != 0) { // Not a NULL frame?\n\t\t\t\tif ((d & 0x00ff0000) == 0x00180000) { // IDLE\n\t\t\t\t\tfpu_debug((\"frestore_opp found IDLE frame at %X\\n\",ad-4));\n\t\t\t\t\tad += 6 * 4;\n\t\t\t\t}\n\t\t\t\telse if ((d & 0x00ff0000) == 0x00380000) {// UNIMP? shouldn't it be 3C?\n\t\t\t\t\tad += 14 * 4;\n\t\t\t\t\tfpu_debug((\"PROBLEM: frestore_opp found UNIMP? frame at %X\\n\",ad-4));\n\t\t\t\t}\n\t\t\t\telse if ((d & 0x00ff0000) == 0x00b40000) {// BUSY\n\t\t\t\t\tfpu_debug((\"PROBLEM: frestore_opp found BUSY frame at %X\\n\",ad-4));\n\t\t\t\t\tad += 45 * 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif ((opcode & 0x38) == 0x18) {\n\t\tm68k_areg (regs, opcode & 7) = ad;\n\t\tfpu_debug((\"frestore_opp post-increment %X -> A%d\\n\",ad,opcode & 7));\n\t}\n\tif ((opcode & 0x38) == 0x20) {\n\t\tm68k_areg (regs, opcode & 7) = ad; // Never executed on a 68881\n\t\tfpu_debug((\"PROBLEM: frestore_opp pre-decrement\\n\"));\n\t}\n}\n\nvoid FFPU fpuop_arithmetic(uae_u32 opcode, uae_u32 extra)\n{\n\tint reg;\n\tfpu_register src;\n\n\tfpu_debug((\"FPP %04lx %04x at %08lx\\n\", opcode & 0xffff, extra & 0xffff,\n\t\t\t   m68k_getpc () - 4));\n\n\tdump_registers( \"START\");\n\n\tswitch ((extra >> 13) & 0x7) {\n\tcase 3:\n\t\tfpu_debug((\"FMOVE -> <ea>\\n\"));\n\t\tif (put_fp_value (opcode, extra, FPU registers[(extra >> 7) & 7]) == 0) {\n\t\t\tm68k_setpc (m68k_getpc () - 4);\n\t\t\top_illg (opcode);\n\t\t}\n\t\tdump_registers( \"END  \");\n\t\treturn;\n\tcase 4:\n\tcase 5:\n\t\tif ((opcode & 0x38) == 0) {\n\t\t\tif (extra & 0x2000) { // dr bit\n\t\t\t\tif (extra & 0x1000) {\n\t\t\t\t\t// according to the manual, the msb bits are always zero.\n\t\t\t\t\tm68k_dreg (regs, opcode & 7) = get_fpcr() & 0xFFFF;\n\t\t\t\t\tfpu_debug((\"FMOVEM FPU fpcr (%X) -> D%d\\n\", get_fpcr(), opcode & 7));\n\t\t\t\t}\n\t\t\t\tif (extra & 0x0800) {\n\t\t\t\t\tm68k_dreg (regs, opcode & 7) = get_fpsr();\n\t\t\t\t\tfpu_debug((\"FMOVEM FPU fpsr (%X) -> D%d\\n\", get_fpsr(), opcode & 7));\n\t\t\t\t}\n\t\t\t\tif (extra & 0x0400) {\n\t\t\t\t\tm68k_dreg (regs, opcode & 7) = FPU instruction_address;\n\t\t\t\t\tfpu_debug((\"FMOVEM FPU instruction_address (%X) -> D%d\\n\", FPU instruction_address, opcode & 7));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (extra & 0x1000) {\n\t\t\t\t\tset_fpcr( m68k_dreg (regs, opcode & 7) );\n\t\t\t\t\tfpu_debug((\"FMOVEM D%d (%X) -> FPU fpcr\\n\", opcode & 7, get_fpcr()));\n\t\t\t\t}\n\t\t\t\tif (extra & 0x0800) {\n\t\t\t\t\tset_fpsr( m68k_dreg (regs, opcode & 7) );\n\t\t\t\t\tfpu_debug((\"FMOVEM D%d (%X) -> FPU fpsr\\n\", opcode & 7, get_fpsr()));\n\t\t\t\t}\n\t\t\t\tif (extra & 0x0400) {\n\t\t\t\t\tFPU instruction_address = m68k_dreg (regs, opcode & 7);\n\t\t\t\t\tfpu_debug((\"FMOVEM D%d (%X) -> FPU instruction_address\\n\", opcode & 7, FPU instruction_address));\n\t\t\t\t}\n\t\t\t}\n//\t\t} else if ((opcode & 0x38) == 1) {\n\t\t}\n\t\telse if ((opcode & 0x38) == 8) { \n\t\t\tif (extra & 0x2000) { // dr bit\n\t\t\t\tif (extra & 0x1000) {\n\t\t\t\t\t// according to the manual, the msb bits are always zero.\n\t\t\t\t\tm68k_areg (regs, opcode & 7) = get_fpcr() & 0xFFFF;\n\t\t\t\t\tfpu_debug((\"FMOVEM FPU fpcr (%X) -> A%d\\n\", get_fpcr(), opcode & 7));\n\t\t\t\t}\n\t\t\t\tif (extra & 0x0800) {\n\t\t\t\t\tm68k_areg (regs, opcode & 7) = get_fpsr();\n\t\t\t\t\tfpu_debug((\"FMOVEM FPU fpsr (%X) -> A%d\\n\", get_fpsr(), opcode & 7));\n\t\t\t\t}\n\t\t\t\tif (extra & 0x0400) {\n\t\t\t\t\tm68k_areg (regs, opcode & 7) = FPU instruction_address;\n\t\t\t\t\tfpu_debug((\"FMOVEM FPU instruction_address (%X) -> A%d\\n\", FPU instruction_address, opcode & 7));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (extra & 0x1000) {\n\t\t\t\t\tset_fpcr( m68k_areg (regs, opcode & 7) );\n\t\t\t\t\tfpu_debug((\"FMOVEM A%d (%X) -> FPU fpcr\\n\", opcode & 7, get_fpcr()));\n\t\t\t\t}\n\t\t\t\tif (extra & 0x0800) {\n\t\t\t\t\tset_fpsr( m68k_areg (regs, opcode & 7) );\n\t\t\t\t\tfpu_debug((\"FMOVEM A%d (%X) -> FPU fpsr\\n\", opcode & 7, get_fpsr()));\n\t\t\t\t}\n\t\t\t\tif (extra & 0x0400) {\n\t\t\t\t\tFPU instruction_address = m68k_areg (regs, opcode & 7);\n\t\t\t\t\tfpu_debug((\"FMOVEM A%d (%X) -> FPU instruction_address\\n\", opcode & 7, FPU instruction_address));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((opcode & 0x3f) == 0x3c) {\n\t\t\tif ((extra & 0x2000) == 0) {\n\t\t\t\tif (extra & 0x1000) {\n\t\t\t\t\tset_fpcr( next_ilong() );\n\t\t\t\t\tfpu_debug((\"FMOVEM #<%X> -> FPU fpcr\\n\", get_fpcr()));\n\t\t\t\t}\n\t\t\t\tif (extra & 0x0800) {\n\t\t\t\t\tset_fpsr( next_ilong() );\n\t\t\t\t\tfpu_debug((\"FMOVEM #<%X> -> FPU fpsr\\n\", get_fpsr()));\n\t\t\t\t}\n\t\t\t\tif (extra & 0x0400) {\n\t\t\t\t\tFPU instruction_address = next_ilong();\n\t\t\t\t\tfpu_debug((\"FMOVEM #<%X> -> FPU instruction_address\\n\", FPU instruction_address));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (extra & 0x2000) {\n\t\t\t/* FMOVEM FPP->memory */\n\t\t\tuae_u32 ad;\n\t\t\tint incr = 0;\n\n\t\t\tif (get_fp_ad(opcode, &ad) == 0) {\n\t\t\t\tm68k_setpc (m68k_getpc () - 4);\n\t\t\t\top_illg (opcode);\n\t\t\t\tdump_registers( \"END  \");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ((opcode & 0x38) == 0x20) {\n\t\t\t\tif (extra & 0x1000)\n\t\t\t\t\tincr += 4;\n\t\t\t\tif (extra & 0x0800)\n\t\t\t\t\tincr += 4;\n\t\t\t\tif (extra & 0x0400)\n\t\t\t\t\tincr += 4;\n\t\t\t}\n\t\t\tad -= incr;\n\t\t\tif (extra & 0x1000) {\n\t\t\t\t// according to the manual, the msb bits are always zero.\n\t\t\t\tput_long (ad, get_fpcr() & 0xFFFF);\n\t\t\t\tfpu_debug((\"FMOVEM FPU fpcr (%X) -> mem %X\\n\", get_fpcr(), ad ));\n\t\t\t\tad += 4;\n\t\t\t}\n\t\t\tif (extra & 0x0800) {\n\t\t\t\tput_long (ad, get_fpsr());\n\t\t\t\tfpu_debug((\"FMOVEM FPU fpsr (%X) -> mem %X\\n\", get_fpsr(), ad ));\n\t\t\t\tad += 4;\n\t\t\t}\n\t\t\tif (extra & 0x0400) {\n\t\t\t\tput_long (ad, FPU instruction_address);\n\t\t\t\tfpu_debug((\"FMOVEM FPU instruction_address (%X) -> mem %X\\n\", FPU instruction_address, ad ));\n\t\t\t\tad += 4;\n\t\t\t}\n\t\t\tad -= incr;\n\t\t\tif ((opcode & 0x38) == 0x18) // post-increment?\n\t\t\t\tm68k_areg (regs, opcode & 7) = ad;\n\t\t\tif ((opcode & 0x38) == 0x20) // pre-decrement?\n\t\t\t\tm68k_areg (regs, opcode & 7) = ad;\n\t\t}\n\t\telse {\n\t\t\t/* FMOVEM memory->FPP */\n\t\t\tuae_u32 ad;\n\n\t\t\tif (get_fp_ad(opcode, &ad) == 0) {\n\t\t\t\tm68k_setpc (m68k_getpc () - 4);\n\t\t\t\top_illg (opcode);\n\t\t\t\tdump_registers( \"END  \");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// ad = (opcode & 0x38) == 0x20 ? ad - 12 : ad;\n\t\t\tint incr = 0;\n\t\t\tif((opcode & 0x38) == 0x20) {\n\t\t\t\tif (extra & 0x1000)\n\t\t\t\t\tincr += 4;\n\t\t\t\tif (extra & 0x0800)\n\t\t\t\t\tincr += 4;\n\t\t\t\tif (extra & 0x0400)\n\t\t\t\t\tincr += 4;\n\t\t\t\tad = ad - incr;\n\t\t\t}\n\n\t\t\tif (extra & 0x1000) {\n\t\t\t\tset_fpcr( get_long (ad) );\n\t\t\t\tfpu_debug((\"FMOVEM mem %X (%X) -> FPU fpcr\\n\", ad, get_fpcr() ));\n\t\t\t\tad += 4;\n\t\t\t}\n\t\t\tif (extra & 0x0800) {\n\t\t\t\tset_fpsr( get_long (ad) );\n\t\t\t\tfpu_debug((\"FMOVEM mem %X (%X) -> FPU fpsr\\n\", ad, get_fpsr() ));\n\t\t\t\tad += 4;\n\t\t\t}\n\t\t\tif (extra & 0x0400) {\n\t\t\t\tFPU instruction_address = get_long (ad);\n\t\t\t\tfpu_debug((\"FMOVEM mem %X (%X) -> FPU instruction_address\\n\", ad, FPU instruction_address ));\n\t\t\t\tad += 4;\n\t\t\t}\n\t\t\tif ((opcode & 0x38) == 0x18) // post-increment?\n\t\t\t\tm68k_areg (regs, opcode & 7) = ad;\n\t\t\tif ((opcode & 0x38) == 0x20) // pre-decrement?\n//\t\t\t\tm68k_areg (regs, opcode & 7) = ad - 12;\n\t\t\t\tm68k_areg (regs, opcode & 7) = ad - incr;\n\t\t}\n\t\tdump_registers( \"END  \");\n\t\treturn;\n\tcase 6:\n\tcase 7: {\n\t\tuae_u32 ad, list = 0;\n\t\tint incr = 0;\n\t\tif (extra & 0x2000) {\n\t\t\t/* FMOVEM FPP->memory */\n\t\t\tfpu_debug((\"FMOVEM FPP->memory\\n\"));\n\n\t\t\tif (get_fp_ad(opcode, &ad) == 0) {\n\t\t\t\tm68k_setpc (m68k_getpc () - 4);\n\t\t\t\top_illg (opcode);\n\t\t\t\tdump_registers( \"END  \");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tswitch ((extra >> 11) & 3) {\n\t\t\tcase 0:\t/* static pred */\n\t\t\t\tlist = extra & 0xff;\n\t\t\t\tincr = -1;\n\t\t\t\tbreak;\n\t\t\tcase 1:\t/* dynamic pred */\n\t\t\t\tlist = m68k_dreg (regs, (extra >> 4) & 3) & 0xff;\n\t\t\t\tincr = -1;\n\t\t\t\tbreak;\n\t\t\tcase 2:\t/* static postinc */\n\t\t\t\tlist = extra & 0xff;\n\t\t\t\tincr = 1;\n\t\t\t\tbreak;\n\t\t\tcase 3:\t/* dynamic postinc */\n\t\t\t\tlist = m68k_dreg (regs, (extra >> 4) & 3) & 0xff;\n\t\t\t\tincr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (incr < 0) {\n\t\t\t\tfor(reg=7; reg>=0; reg--) {\n\t\t\t\t\tuae_u32 wrd1, wrd2, wrd3;\n\t\t\t\t\tif( list & 0x80 ) {\n\t\t\t\t\t\textract_extended(FPU registers[reg],&wrd1, &wrd2, &wrd3);\n\t\t\t\t\t\tad -= 4;\n\t\t\t\t\t\tput_long (ad, wrd3);\n\t\t\t\t\t\tad -= 4;\n\t\t\t\t\t\tput_long (ad, wrd2);\n\t\t\t\t\t\tad -= 4;\n\t\t\t\t\t\tput_long (ad, wrd1);\n\t\t\t\t\t}\n\t\t\t\t\tlist <<= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(reg=0; reg<8; reg++) {\n\t\t\t\t\tuae_u32 wrd1, wrd2, wrd3;\n\t\t\t\t\tif( list & 0x80 ) {\n\t\t\t\t\t\textract_extended(FPU registers[reg],&wrd1, &wrd2, &wrd3);\n\t\t\t\t\t\tput_long (ad, wrd1);\n\t\t\t\t\t\tad += 4;\n\t\t\t\t\t\tput_long (ad, wrd2);\n\t\t\t\t\t\tad += 4;\n\t\t\t\t\t\tput_long (ad, wrd3);\n\t\t\t\t\t\tad += 4;\n\t\t\t\t\t}\n\t\t\t\t\tlist <<= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((opcode & 0x38) == 0x18) // post-increment?\n\t\t\t\tm68k_areg (regs, opcode & 7) = ad;\n\t\t\tif ((opcode & 0x38) == 0x20) // pre-decrement?\n\t\t\t\tm68k_areg (regs, opcode & 7) = ad;\n\t\t}\n\t\telse {\n\t\t\t/* FMOVEM memory->FPP */\n\t\t\tfpu_debug((\"FMOVEM memory->FPP\\n\"));\n\n\t\t\tif (get_fp_ad(opcode, &ad) == 0) {\n\t\t\t\tm68k_setpc (m68k_getpc () - 4);\n\t\t\t\top_illg (opcode);\n\t\t\t\tdump_registers( \"END  \");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tswitch ((extra >> 11) & 3) {\n\t\t\tcase 0:\t/* static pred */\n\t\t\t\tfpu_debug((\"memory->FMOVEM FPP not legal mode.\\n\"));\n\t\t\t\tlist = extra & 0xff;\n\t\t\t\tincr = -1;\n\t\t\t\tbreak;\n\t\t\tcase 1:\t/* dynamic pred */\n\t\t\t\tfpu_debug((\"memory->FMOVEM FPP not legal mode.\\n\"));\n\t\t\t\tlist = m68k_dreg (regs, (extra >> 4) & 3) & 0xff;\n\t\t\t\tincr = -1;\n\t\t\t\tbreak;\n\t\t\tcase 2:\t/* static postinc */\n\t\t\t\tlist = extra & 0xff;\n\t\t\t\tincr = 1;\n\t\t\t\tbreak;\n\t\t\tcase 3:\t/* dynamic postinc */\n\t\t\t\tlist = m68k_dreg (regs, (extra >> 4) & 3) & 0xff;\n\t\t\t\tincr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/**/\n\t\t\tif (incr < 0) {\n\t\t\t\t// not reached\n\t\t\t\tfor(reg=7; reg>=0; reg--) {\n\t\t\t\t\tuae_u32 wrd1, wrd2, wrd3;\n\t\t\t\t\tif( list & 0x80 ) {\n\t\t\t\t\t\tad -= 4;\n\t\t\t\t\t\twrd3 = get_long (ad);\n\t\t\t\t\t\tad -= 4;\n\t\t\t\t\t\twrd2 = get_long (ad);\n\t\t\t\t\t\tad -= 4;\n\t\t\t\t\t\twrd1 = get_long (ad);\n\t\t\t\t\t\t// FPU registers[reg] = make_extended(wrd1, wrd2, wrd3);\n\t\t\t\t\t\tmake_extended_no_normalize (wrd1, wrd2, wrd3, FPU registers[reg]);\n\t\t\t\t\t}\n\t\t\t\t\tlist <<= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(reg=0; reg<8; reg++) {\n\t\t\t\t\tuae_u32 wrd1, wrd2, wrd3;\n\t\t\t\t\tif( list & 0x80 ) {\n\t\t\t\t\t\twrd1 = get_long (ad);\n\t\t\t\t\t\tad += 4;\n\t\t\t\t\t\twrd2 = get_long (ad);\n\t\t\t\t\t\tad += 4;\n\t\t\t\t\t\twrd3 = get_long (ad);\n\t\t\t\t\t\tad += 4;\n\t\t\t\t\t\t// FPU registers[reg] = make_extended(wrd1, wrd2, wrd3);\n\t\t\t\t\t\tmake_extended_no_normalize (wrd1, wrd2, wrd3, FPU registers[reg]);\n\t\t\t\t\t}\n\t\t\t\t\tlist <<= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((opcode & 0x38) == 0x18) // post-increment?\n\t\t\t\tm68k_areg (regs, opcode & 7) = ad;\n\t\t\tif ((opcode & 0x38) == 0x20) // pre-decrement?\n\t\t\t\tm68k_areg (regs, opcode & 7) = ad;\n\t\t}\n\t\tdump_registers( \"END  \");\n\t\treturn;\n\t}\n\tcase 0:\n\tcase 2:\n\t\treg = (extra >> 7) & 7;\n\t\tif ((extra & 0xfc00) == 0x5c00) {\n\t\t\tfpu_debug((\"FMOVECR memory->FPP\\n\"));\n\t\t\tswitch (extra & 0x7f) {\n\t\t\tcase 0x00:\n\t\t\t\t// FPU registers[reg] = 4.0 * atan(1.0);\n\t\t\t\tFPU registers[reg] = 3.1415926535897932384626433832795;\n\t\t\t\tfpu_debug((\"FP const: Pi\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x0b:\n\t\t\t\t// FPU registers[reg] = log10 (2.0);\n\t\t\t\tFPU registers[reg] = 0.30102999566398119521373889472449;\n\t\t\t\tfpu_debug((\"FP const: Log 10 (2)\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x0c:\n\t\t\t\t// FPU registers[reg] = exp (1.0);\n\t\t\t\tFPU registers[reg] = 2.7182818284590452353602874713527;\n\t\t\t\tfpu_debug((\"FP const: e\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x0d:\n\t\t\t\t// FPU registers[reg] = log (exp (1.0)) / log (2.0);\n\t\t\t\tFPU registers[reg] = 1.4426950408889634073599246810019;\n\t\t\t\tfpu_debug((\"FP const: Log 2 (e)\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x0e:\n\t\t\t\t// FPU registers[reg] = log (exp (1.0)) / log (10.0);\n\t\t\t\tFPU registers[reg] = 0.43429448190325182765112891891661;\n\t\t\t\tfpu_debug((\"FP const: Log 10 (e)\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x0f:\n\t\t\t\tFPU registers[reg] = 0.0;\n\t\t\t\tfpu_debug((\"FP const: zero\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x30:\n\t\t\t\t// FPU registers[reg] = log (2.0);\n\t\t\t\tFPU registers[reg] = 0.69314718055994530941723212145818;\n\t\t\t\tfpu_debug((\"FP const: ln(2)\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x31:\n\t\t\t\t// FPU registers[reg] = log (10.0);\n\t\t\t\tFPU registers[reg] = 2.3025850929940456840179914546844;\n\t\t\t\tfpu_debug((\"FP const: ln(10)\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x32:\n\t\t\t\t// ??\n\t\t\t\tFPU registers[reg] = 1.0e0;\n\t\t\t\tfpu_debug((\"FP const: 1.0e0\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x33:\n\t\t\t\tFPU registers[reg] = 1.0e1;\n\t\t\t\tfpu_debug((\"FP const: 1.0e1\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x34:\n\t\t\t\tFPU registers[reg] = 1.0e2;\n\t\t\t\tfpu_debug((\"FP const: 1.0e2\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x35:\n\t\t\t\tFPU registers[reg] = 1.0e4;\n\t\t\t\tfpu_debug((\"FP const: 1.0e4\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x36:\n\t\t\t\tFPU registers[reg] = 1.0e8;\n\t\t\t\tfpu_debug((\"FP const: 1.0e8\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x37:\n\t\t\t\tFPU registers[reg] = 1.0e16;\n\t\t\t\tfpu_debug((\"FP const: 1.0e16\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x38:\n\t\t\t\tFPU registers[reg] = 1.0e32;\n\t\t\t\tfpu_debug((\"FP const: 1.0e32\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x39:\n\t\t\t\tFPU registers[reg] = 1.0e64;\n\t\t\t\tfpu_debug((\"FP const: 1.0e64\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x3a:\n\t\t\t\tFPU registers[reg] = 1.0e128;\n\t\t\t\tfpu_debug((\"FP const: 1.0e128\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x3b:\n\t\t\t\tFPU registers[reg] = 1.0e256;\n\t\t\t\tfpu_debug((\"FP const: 1.0e256\\n\"));\n\t\t\t\tbreak;\n#if USE_LONG_DOUBLE || USE_QUAD_DOUBLE\n\t\t\tcase 0x3c:\n\t\t\t\tFPU registers[reg] = 1.0e512L;\n\t\t\t\tfpu_debug((\"FP const: 1.0e512\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x3d:\n\t\t\t\tFPU registers[reg] = 1.0e1024L;\n\t\t\t\tfpu_debug((\"FP const: 1.0e1024\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x3e:\n\t\t\t\tFPU registers[reg] = 1.0e2048L;\n\t\t\t\tfpu_debug((\"FP const: 1.0e2048\\n\"));\n\t\t\t\tbreak;\n\t\t\tcase 0x3f:\n\t\t\t\tFPU registers[reg] = 1.0e4096L;\n\t\t\t\tfpu_debug((\"FP const: 1.0e4096\\n\"));\n#endif\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tm68k_setpc (m68k_getpc () - 4);\n\t\t\t\top_illg (opcode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// these *do* affect the status reg\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tdump_registers( \"END  \");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (get_fp_value (opcode, extra, src) == 0) {\n\t\t\tm68k_setpc (m68k_getpc () - 4);\n\t\t\top_illg (opcode);\n\t\t\tdump_registers( \"END  \");\n\t\t\treturn;\n\t\t}\n\t\tfpu_debug((\"returned from get_fp_value m68k_getpc()=%X\\n\",m68k_getpc()));\n\t\t\n\t\tif (FPU is_integral) {\n\t\t\t// 68040-specific operations\n\t\t\tswitch (extra & 0x7f) {\n\t\t\tcase 0x40:\t\t/* FSMOVE */\n\t\t\t\tfpu_debug((\"FSMOVE %.04f\\n\",(double)src));\n\t\t\t\tFPU registers[reg] = (float)src;\n\t\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\t\tbreak;\n\t\t\tcase 0x44:\t\t/* FDMOVE */\n\t\t\t\tfpu_debug((\"FDMOVE %.04f\\n\",(double)src));\n\t\t\t\tFPU registers[reg] = (double)src;\n\t\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\t\tbreak;\n\t\t\tcase 0x41:\t\t/* FSSQRT */\n\t\t\t\tfpu_debug((\"FSQRT %.04f\\n\",(double)src));\n\t\t\t\tFPU registers[reg] = (float)fp_sqrt (src);\n\t\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\t\tbreak;\n\t\t\tcase 0x45:\t\t/* FDSQRT */\n\t\t\t\tfpu_debug((\"FSQRT %.04f\\n\",(double)src));\n\t\t\t\tFPU registers[reg] = (double)fp_sqrt (src);\n\t\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\t\tbreak;\n\t\t\tcase 0x58:\t\t/* FSABS */\n\t\t\t\tfpu_debug((\"FSABS %.04f\\n\",(double)src));\n\t\t\t\tFPU registers[reg] = (float)fp_fabs(src);\n\t\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\t\tbreak;\n\t\t\tcase 0x5c:\t\t/* FDABS */\n\t\t\t\tfpu_debug((\"FDABS %.04f\\n\",(double)src));\n\t\t\t\tFPU registers[reg] = (double)fp_fabs(src);\n\t\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\t\tbreak;\n\t\t\tcase 0x5a:\t\t/* FSNEG */\n\t\t\t\tfpu_debug((\"FSNEG %.04f\\n\",(double)src));\n\t\t\t\tFPU registers[reg] = (float)-src;\n\t\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\t\tbreak;\n\t\t\tcase 0x5e:\t\t/* FDNEG */\n\t\t\t\tfpu_debug((\"FDNEG %.04f\\n\",(double)src));\n\t\t\t\tFPU registers[reg] = (double)-src;\n\t\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\t\tbreak;\n\t\t\tcase 0x60:\t\t/* FSDIV */\n\t\t\t\tfpu_debug((\"FSDIV %.04f\\n\",(double)src));\n\t\t\t\tFPU registers[reg] = (float)(FPU registers[reg] / src);\n\t\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\t\tbreak;\n\t\t\tcase 0x64:\t\t/* FDDIV */\n\t\t\t\tfpu_debug((\"FDDIV %.04f\\n\",(double)src));\n\t\t\t\tFPU registers[reg] = (double)(FPU registers[reg] / src);\n\t\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\t\tbreak;\n\t\t\tcase 0x62:\t\t/* FSADD */\n\t\t\t\tfpu_debug((\"FSADD %.04f\\n\",(double)src));\n\t\t\t\tFPU registers[reg] = (float)(FPU registers[reg] + src);\n\t\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\t\tbreak;\n\t\t\tcase 0x66:\t\t/* FDADD */\n\t\t\t\tfpu_debug((\"FDADD %.04f\\n\",(double)src));\n\t\t\t\tFPU registers[reg] = (double)(FPU registers[reg] + src);\n\t\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\t\tbreak;\n\t\t\tcase 0x68:\t\t/* FSSUB */\n\t\t\t\tfpu_debug((\"FSSUB %.04f\\n\",(double)src));\n\t\t\t\tFPU registers[reg] = (float)(FPU registers[reg] - src);\n\t\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\t\tbreak;\n\t\t\tcase 0x6c:\t\t/* FDSUB */\n\t\t\t\tfpu_debug((\"FDSUB %.04f\\n\",(double)src));\n\t\t\t\tFPU registers[reg] = (double)(FPU registers[reg] - src);\n\t\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\t\tbreak;\n\t\t\tcase 0x63:\t\t/* FSMUL */\n\t\t\tcase 0x67:\t\t/* FDMUL */\n\t\t\t\tfpu_debug((\"FMUL %.04f\\n\",(double)src));\n\t\t\t\tget_dest_flags(FPU registers[reg]);\n\t\t\t\tget_source_flags(src);\n\t\t\t\tif(fl_dest.in_range && fl_source.in_range) {\n\t\t\t\t\tif ((extra & 0x7f) == 0x63)\n\t\t\t\t\t\tFPU registers[reg] = (float)(FPU registers[reg] * src);\n\t\t\t\t\telse\n\t\t\t\t\t\tFPU registers[reg] = (double)(FPU registers[reg] * src);\n\t\t\t\t}\n\t\t\t\telse if (fl_dest.nan || fl_source.nan || \n\t\t\t\t\t\t fl_dest.zero && fl_source.infinity || \n\t\t\t\t\t\t fl_dest.infinity && fl_source.zero ) {\n\t\t\t\t\tmake_nan( FPU registers[reg] );\n\t\t\t\t}\n\t\t\t\telse if (fl_dest.zero || fl_source.zero ) {\n\t\t\t\t\tif (fl_dest.negative && !fl_source.negative ||\n\t\t\t\t\t\t!fl_dest.negative && fl_source.negative)  {\n\t\t\t\t\t\tmake_zero_negative(FPU registers[reg]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmake_zero_positive(FPU registers[reg]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif( fl_dest.negative && !fl_source.negative ||\n\t\t\t\t\t\t!fl_dest.negative && fl_source.negative)  {\n\t\t\t\t\t\tmake_inf_negative(FPU registers[reg]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmake_inf_positive(FPU registers[reg]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Continue decode-execute 6888x instructions below\n\t\t\t\tgoto process_6888x_instructions;\n\t\t\t}\n\t\t\tfpu_debug((\"END m68k_getpc()=%X\\n\",m68k_getpc()));\n\t\t\tdump_registers( \"END  \");\n\t\t\treturn;\n\t\t}\n\n\tprocess_6888x_instructions:\t\t\n\t\tswitch (extra & 0x7f) {\n\t\tcase 0x00:\t\t/* FMOVE */\n\t\t\tfpu_debug((\"FMOVE %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = src;\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x01:\t\t/* FINT */\n\t\t\tfpu_debug((\"FINT %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = toint(src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x02:\t\t/* FSINH */\n\t\t\tfpu_debug((\"FSINH %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_sinh (src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x03:\t\t/* FINTRZ */\n\t\t\tfpu_debug((\"FINTRZ %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_round_to_zero(src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x04:\t\t/* FSQRT */\n\t\t\tfpu_debug((\"FSQRT %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_sqrt (src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x06:\t\t/* FLOGNP1 */\n\t\t\tfpu_debug((\"FLOGNP1 %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_log (src + 1.0);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x08:\t\t/* FETOXM1 */\n\t\t\tfpu_debug((\"FETOXM1 %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_exp (src) - 1.0;\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x09:\t\t/* FTANH */\n\t\t\tfpu_debug((\"FTANH %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_tanh (src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x0a:\t\t/* FATAN */\n\t\t\tfpu_debug((\"FATAN %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_atan (src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x0c:\t\t/* FASIN */\n\t\t\tfpu_debug((\"FASIN %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_asin (src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x0d:\t\t/* FATANH */\n\t\t\tfpu_debug((\"FATANH %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_atanh (src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x0e:\t\t/* FSIN */\n\t\t\tfpu_debug((\"FSIN %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_sin (src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x0f:\t\t/* FTAN */\n\t\t\tfpu_debug((\"FTAN %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_tan (src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x10:\t\t/* FETOX */\n\t\t\tfpu_debug((\"FETOX %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_exp (src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x11:\t\t/* FTWOTOX */\n\t\t\tfpu_debug((\"FTWOTOX %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_pow(2.0, src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x12:\t\t/* FTENTOX */\n\t\t\tfpu_debug((\"FTENTOX %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_pow(10.0, src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x14:\t\t/* FLOGN */\n\t\t\tfpu_debug((\"FLOGN %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_log (src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x15:\t\t/* FLOG10 */\n\t\t\tfpu_debug((\"FLOG10 %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_log10 (src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x16:\t\t/* FLOG2 */\n\t\t\tfpu_debug((\"FLOG2 %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_log (src) / fp_log (2.0);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x18:\t\t/* FABS */\n\t\t\tfpu_debug((\"FABS %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_fabs(src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x19:\t\t/* FCOSH */\n\t\t\tfpu_debug((\"FCOSH %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_cosh(src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x1a:\t\t/* FNEG */\n\t\t\tfpu_debug((\"FNEG %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = -src;\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x1c:\t\t/* FACOS */\n\t\t\tfpu_debug((\"FACOS %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_acos(src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x1d:\t\t/* FCOS */\n\t\t\tfpu_debug((\"FCOS %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = fp_cos(src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x1e:\t\t/* FGETEXP */\n\t\t\tfpu_debug((\"FGETEXP %.04f\\n\",(double)src));\n\t\t\tif( isinf(src) ) {\n\t\t\t\tmake_nan( FPU registers[reg] );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFPU registers[reg] = fast_fgetexp( src );\n\t\t\t}\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x1f:\t\t/* FGETMAN */\n\t\t\tfpu_debug((\"FGETMAN %.04f\\n\",(double)src));\n\t\t\tif( src == 0 ) {\n\t\t\t\tFPU registers[reg] = 0;\n\t\t\t}\n\t\t\telse if( isinf(src) ) {\n\t\t\t\tmake_nan( FPU registers[reg] );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFPU registers[reg] = src;\n\t\t\t\tfast_remove_exponent( FPU registers[reg] );\n\t\t\t}\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x20:\t\t/* FDIV */\n\t\t\tfpu_debug((\"FDIV %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] /= src;\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x21:\t\t/* FMOD */\n\t\t\tfpu_debug((\"FMOD %.04f\\n\",(double)src));\n\t\t\t// FPU registers[reg] = FPU registers[reg] - (fpu_register) ((int) (FPU registers[reg] / src)) * src;\n\t\t\t{\n\t\t\t\tfpu_register quot = fp_round_to_zero(FPU registers[reg] / src);\n\t\t\t\tuae_u32 sign = get_quotient_sign(FPU registers[reg],src);\n\t\t\t\tFPU registers[reg] = FPU registers[reg] - quot * src;\n\t\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\t\tmake_quotient(quot, sign);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x23:\t\t/* FMUL */\n\t\t\tfpu_debug((\"FMUL %.04f\\n\",(double)src));\n\t\t\tget_dest_flags(FPU registers[reg]);\n\t\t\tget_source_flags(src);\n\t\t\tif(fl_dest.in_range && fl_source.in_range) {\n\t\t\t\tFPU registers[reg] *= src;\n\t\t\t}\n\t\t\telse if (fl_dest.nan || fl_source.nan || \n\t\t\t\t\t fl_dest.zero && fl_source.infinity || \n\t\t\t\t\t fl_dest.infinity && fl_source.zero ) {\n\t\t\t\tmake_nan( FPU registers[reg] );\n\t\t\t}\n\t\t\telse if (fl_dest.zero || fl_source.zero ) {\n\t\t\t\tif (fl_dest.negative && !fl_source.negative ||\n\t\t\t\t\t!fl_dest.negative && fl_source.negative)  {\n\t\t\t\t\tmake_zero_negative(FPU registers[reg]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmake_zero_positive(FPU registers[reg]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif( fl_dest.negative && !fl_source.negative ||\n\t\t\t\t\t!fl_dest.negative && fl_source.negative)  {\n\t\t\t\t\tmake_inf_negative(FPU registers[reg]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmake_inf_positive(FPU registers[reg]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x24:\t\t/* FSGLDIV */\n\t\t\tfpu_debug((\"FSGLDIV %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = (float)(FPU registers[reg] / src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x25:\t\t/* FREM */\n\t\t\tfpu_debug((\"FREM %.04f\\n\",(double)src));\n\t\t\t// FPU registers[reg] = FPU registers[reg] - (double) ((int) (FPU registers[reg] / src + 0.5)) * src;\n\t\t\t{\n\t\t\t\tfpu_register quot = fp_round_to_nearest(FPU registers[reg] / src);\n\t\t\t\tuae_u32 sign = get_quotient_sign(FPU registers[reg],src);\n\t\t\t\tFPU registers[reg] = FPU registers[reg] - quot * src;\n\t\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\t\tmake_quotient(quot,sign);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x26:\t\t/* FSCALE */\n\t\t\tfpu_debug((\"FSCALE %.04f\\n\",(double)src));\n\t\t\t// TODO: overflow flags\n\t\t\tget_dest_flags(FPU registers[reg]);\n\t\t\tget_source_flags(src);\n\t\t\tif (fl_source.in_range && fl_dest.in_range) {\n\t\t\t\t// When the absolute value of the source operand is >= 2^14,\n\t\t\t\t// an overflow or underflow always results.\n\t\t\t\t// Here (int) cast is okay.\n\t\t\t\tint scale_factor = (int)fp_round_to_zero(src);\n#if USE_LONG_DOUBLE || USE_QUAD_DOUBLE\n\t\t\t\tfp_declare_init_shape(sxp, FPU registers[reg], extended);\n\t\t\t\tsxp->ieee.exponent += scale_factor;\n#else\n\t\t\t\tfp_declare_init_shape(sxp, FPU registers[reg], double);\n\t\t\t\tuae_u32 exp = sxp->ieee.exponent + scale_factor;\n\t\t\t\tif (exp < FP_EXTENDED_EXP_BIAS - FP_DOUBLE_EXP_BIAS)\n\t\t\t\t\texp = 0;\n\t\t\t\telse if (exp > FP_EXTENDED_EXP_BIAS + FP_DOUBLE_EXP_BIAS)\n\t\t\t\t\texp = FP_DOUBLE_EXP_MAX;\n\t\t\t\telse\n\t\t\t\t\texp += FP_DOUBLE_EXP_BIAS - FP_EXTENDED_EXP_BIAS;\n\t\t\t\tsxp->ieee.exponent = exp;\n#endif\n\t\t\t}\n\t\t\telse if (fl_source.infinity) {\n\t\t\t\t// Returns NaN for any Infinity source\n\t\t\t\tmake_nan( FPU registers[reg] );\n\t\t\t}\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x27:\t\t/* FSGLMUL */\n\t\t\tfpu_debug((\"FSGLMUL %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] = (float)(FPU registers[reg] * src);\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x28:\t\t/* FSUB */\n\t\t\tfpu_debug((\"FSUB %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] -= src;\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x22:\t\t/* FADD */\n\t\t\tfpu_debug((\"FADD %.04f\\n\",(double)src));\n\t\t\tFPU registers[reg] += src;\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x30:\t\t/* FSINCOS */\n\t\tcase 0x31:\n\t\tcase 0x32:\n\t\tcase 0x33:\n\t\tcase 0x34:\n\t\tcase 0x35:\n\t\tcase 0x36:\n\t\tcase 0x37:\n\t\t\tfpu_debug((\"FSINCOS %.04f\\n\",(double)src));\n\t\t\t// Cosine must be calculated first if same register\n\t\t\tFPU registers[extra & 7] = fp_cos(src);\n\t\t\tFPU registers[reg] = fp_sin (src);\n\t\t\t// Set FPU fpsr according to the sine result\n\t\t\tmake_fpsr(FPU registers[reg]);\n\t\t\tbreak;\n\t\tcase 0x38:\t\t/* FCMP */\n\t\t\tfpu_debug((\"FCMP %.04f\\n\",(double)src));\n\t\t\tset_fpsr(0);\n\t\t\tmake_fpsr(FPU registers[reg] - src);\n\t\t\tbreak;\n\t\tcase 0x3a:\t\t/* FTST */\n\t\t\tfpu_debug((\"FTST %.04f\\n\",(double)src));\n\t\t\tset_fpsr(0);\n\t\t\tmake_fpsr(src);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfpu_debug((\"ILLEGAL F OP %X\\n\",opcode));\n\t\t\tm68k_setpc (m68k_getpc () - 4);\n\t\t\top_illg (opcode);\n\t\t\tbreak;\n\t\t}\n\t\tfpu_debug((\"END m68k_getpc()=%X\\n\",m68k_getpc()));\n\t\tdump_registers( \"END  \");\n\t\treturn;\n\t}\n\t\n\tfpu_debug((\"ILLEGAL F OP 2 %X\\n\",opcode));\n\tm68k_setpc (m68k_getpc () - 4);\n\top_illg (opcode);\n\tdump_registers( \"END  \");\n}\n\n/* -------------------------- Initialization -------------------------- */\n\nPRIVATE uae_u8 m_fpu_state_original[108]; // 90/94/108\n\nPUBLIC void FFPU fpu_init (bool integral_68040)\n{\n\tfpu_debug((\"fpu_init\\n\"));\n\t\n\tstatic bool initialized_lookup_tables = false;\n\tif (!initialized_lookup_tables) {\n\t\tfpu_init_native_fflags();\n\t\tfpu_init_native_exceptions();\n\t\tfpu_init_native_accrued_exceptions();\n\t\tinitialized_lookup_tables = true;\n\t}\n\n\tFPU is_integral = integral_68040;\n\tFPU instruction_address = 0;\n\tFPU fpsr.quotient = 0;\n\tset_fpcr(0);\n\tset_fpsr(0);\n\n#if defined(FPU_USE_X86_ROUNDING)\n\t// Initial state after boot, reset and frestore(null frame)\n\tx86_control_word = CW_INITIAL;\n#elif defined(USE_X87_ASSEMBLY)\n\tvolatile unsigned short int cw;\n\t__asm__ __volatile__(\"fnstcw %0\" : \"=m\" (cw));\n\tcw &= ~0x0300; cw |= 0x0300; // CW_PC_EXTENDED\n\tcw &= ~0x0C00; cw |= 0x0000; // CW_RC_NEAR\n\t__asm__ __volatile__(\"fldcw %0\" : : \"m\" (cw));\n#endif\n\n\tFPU result = 1;\n\t\n\tfor (int i = 0; i < 8; i++)\n\t\tmake_nan(FPU registers[i]);\n}\n\nPUBLIC void FFPU fpu_exit (void)\n{\n\tfpu_debug((\"fpu_exit\\n\"));\n}\n\nPUBLIC void FFPU fpu_reset (void)\n{\n\tfpu_debug((\"fpu_reset\\n\"));\n\tfpu_exit();\n\tfpu_init(FPU is_integral);\n}\n","/*\n *  fpu/exceptions.h - system-dependant FPU exceptions management\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  MC68881/68040 fpu emulation\n *  \n *  Original UAE FPU, copyright 1996 Herman ten Brugge\n *  Rewrite for x86, copyright 1999-2000 Lauri Pesonen\n *  New framework, copyright 2000 Gwenole Beauchesne\n *  Adapted for JIT compilation (c) Bernd Meyer, 2000\n *  \n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef FPU_EXCEPTIONS_H\n#define FPU_EXCEPTIONS_H\n\n/* NOTE: this file shall be included only from fpu/fpu_*.cpp */\n#undef\tPUBLIC\n#define PUBLIC\textern\n\n#undef\tPRIVATE\n#define PRIVATE\tstatic\n\n#undef\tFFPU\n#define FFPU\t/**/\n\n#undef\tFPU\n#define\tFPU\t\tfpu.\n\n/* Defaults to generic exceptions */\n#define FPU_USE_GENERIC_EXCEPTIONS\n#define FPU_USE_GENERIC_ACCRUED_EXCEPTIONS\n\n/* -------------------------------------------------------------------------- */\n/* --- Selection of floating-point exceptions handling mode               --- */\n/* -------------------------------------------------------------------------- */\n\n/* Optimized i386 fpu core must use native exceptions */\n#if defined(FPU_X86) && defined(USE_X87_ASSEMBLY)\n# undef FPU_USE_GENERIC_EXCEPTIONS\n# define FPU_USE_X86_EXCEPTIONS\n#endif\n\n/* Optimized i386 fpu core must use native accrued exceptions */\n#if defined(FPU_X86) && defined(USE_X87_ASSEMBLY)\n# undef FPU_USE_GENERIC_ACCRUED_EXCEPTIONS\n# define FPU_USE_X86_ACCRUED_EXCEPTIONS\n#endif\n\n/* -------------------------------------------------------------------------- */\n/* --- Native X86 Exceptions                                              --- */\n/* -------------------------------------------------------------------------- */\n\n#ifdef FPU_USE_X86_EXCEPTIONS\n\n/* Extend the SW_* codes */\n#define SW_FAKE_BSUN SW_SF\n\n/* Shorthand */\n#define SW_EXCEPTION_MASK (SW_ES|SW_SF|SW_PE|SW_UE|SW_OE|SW_ZE|SW_DE|SW_IE)\n// #define SW_EXCEPTION_MASK (SW_SF|SW_PE|SW_UE|SW_OE|SW_ZE|SW_DE|SW_IE)\n\n/* Lookup tables */\nPRIVATE uae_u32 exception_host2mac[ 0x80 ];\nPRIVATE uae_u32 exception_mac2host[ 0x100 ];\n\n/* Initialize native exception management */\nPUBLIC void FFPU fpu_init_native_exceptions(void);\n\n/* Return m68k floating-point exception status */\nPRIVATE inline uae_u32 FFPU get_exception_status(void)\n\t{ return exception_host2mac[FPU fpsr.exception_status & (SW_FAKE_BSUN|SW_PE|SW_UE|SW_OE|SW_ZE|SW_DE|SW_IE)]; }\n\n/* Set new exception status. Assumes mask against FPSR_EXCEPTION to be already performed */\nPRIVATE inline void FFPU set_exception_status(uae_u32 new_status)\n\t{ FPU fpsr.exception_status = exception_mac2host[new_status >> 8]; }\n\n#endif /* FPU_USE_X86_EXCEPTIONS */\n\n#ifdef FPU_USE_X86_ACCRUED_EXCEPTIONS\n\n/* Lookup tables */\nPRIVATE uae_u32 accrued_exception_host2mac[ 0x40 ];\nPRIVATE uae_u32 accrued_exception_mac2host[ 0x20 ];\n\n/* Initialize native accrued exception management */\nPUBLIC void FFPU fpu_init_native_accrued_exceptions(void);\n\n/* Return m68k accrued exception byte */\nPRIVATE inline uae_u32 FFPU get_accrued_exception(void)\n\t{ return accrued_exception_host2mac[FPU fpsr.accrued_exception & (SW_PE|SW_UE|SW_OE|SW_ZE|SW_DE|SW_IE)]; }\n\n/* Set new accrued exception byte */\nPRIVATE inline void FFPU set_accrued_exception(uae_u32 new_status)\n\t{ FPU fpsr.accrued_exception = accrued_exception_mac2host[(new_status & 0xF8) >> 3]; }\n\n#endif /* FPU_USE_X86_ACCRUED_EXCEPTIONS */\n\n/* -------------------------------------------------------------------------- */\n/* --- Default Exceptions Handling                                        --- */\n/* -------------------------------------------------------------------------- */\n\n#ifdef FPU_USE_GENERIC_EXCEPTIONS\n\n/* Initialize native exception management */\nstatic inline void FFPU fpu_init_native_exceptions(void)\n\t{ }\n\n/* Return m68k floating-point exception status */\nPRIVATE inline uae_u32 FFPU get_exception_status(void)\n\t{ return FPU fpsr.exception_status; }\n\n/* Set new exception status. Assumes mask against FPSR_EXCEPTION to be already performed */\nPRIVATE inline void FFPU set_exception_status(uae_u32 new_status)\n\t{ FPU fpsr.exception_status = new_status; }\n\n#endif /* FPU_USE_GENERIC_EXCEPTIONS */\n\n#ifdef FPU_USE_GENERIC_ACCRUED_EXCEPTIONS\n\n/* Initialize native accrued exception management */\nPRIVATE inline void FFPU fpu_init_native_accrued_exceptions(void)\n\t{ }\n\n/* Return m68k accrued exception byte */\nPRIVATE inline uae_u32 FFPU get_accrued_exception(void)\n\t{ return FPU fpsr.accrued_exception; }\n\n/* Set new accrued exception byte */\nPRIVATE inline void FFPU set_accrued_exception(uae_u32 new_status)\n\t{ FPU fpsr.accrued_exception = new_status; }\n\n#endif /* FPU_USE_GENERIC_ACCRUED_EXCEPTIONS */\n\n#endif /* FPU_EXCEPTIONS_H */\n","#include \"sysdeps.h\"\n#include \"m68k.h\"\n#include \"memory.h\"\n#include \"readcpu.h\"\n#include \"newcpu.h\"\n#include \"compiler/compemu.h\"\n#include \"fpu/fpu.h\"\n#include \"cputbl.h\"\n#define SET_CFLG_ALWAYS(x) SET_CFLG(x)\n#define SET_NFLG_ALWAYS(x) SET_NFLG(x)\n#define CPUFUNC_FF(x) x##_ff\n#define CPUFUNC_NF(x) x##_nf\n#define CPUFUNC(x) CPUFUNC_FF(x)\n#ifdef NOFLAGS\n# include \"noflags.h\"\n#endif\n\n#if !defined(PART_1) && !defined(PART_2) && !defined(PART_3) && !defined(PART_4) && !defined(PART_5) && !defined(PART_6) && !defined(PART_7) && !defined(PART_8)\n#define PART_1 1\n#define PART_2 1\n#define PART_3 1\n#define PART_4 1\n#define PART_5 1\n#define PART_6 1\n#define PART_7 1\n#define PART_8 1\n#endif\n\n#ifdef PART_1\nvoid REGPARAM2 CPUFUNC(op_0_0)(uae_u32 opcode) /* OR.B #<data>.B,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10_0)(uae_u32 opcode) /* OR.B #<data>.B,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_18_0)(uae_u32 opcode) /* OR.B #<data>.B,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20_0)(uae_u32 opcode) /* OR.B #<data>.B,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_28_0)(uae_u32 opcode) /* OR.B #<data>.B,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30_0)(uae_u32 opcode) /* OR.B #<data>.B,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_38_0)(uae_u32 opcode) /* OR.B #<data>.B,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_39_0)(uae_u32 opcode) /* OR.B #<data>.B,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3c_0)(uae_u32 opcode) /* ORSR.B #<data>.W */\n{\n\tcpuop_begin();\n{\tMakeSR();\n{\tuae_s16 src = get_iword(2);\n\tsrc &= 0xFF;\n\tregs.sr |= src;\n\tMakeFromSR();\n}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_40_0)(uae_u32 opcode) /* OR.W #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_50_0)(uae_u32 opcode) /* OR.W #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_58_0)(uae_u32 opcode) /* OR.W #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg(regs, dstreg) += 2;\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_60_0)(uae_u32 opcode) /* OR.W #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_68_0)(uae_u32 opcode) /* OR.W #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_70_0)(uae_u32 opcode) /* OR.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s16 dst = get_word(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_78_0)(uae_u32 opcode) /* OR.W #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_79_0)(uae_u32 opcode) /* OR.W #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_7c_0)(uae_u32 opcode) /* ORSR.W #<data>.W */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel18; }\n{\tMakeSR();\n{\tuae_s16 src = get_iword(2);\n\tregs.sr |= src;\n\tMakeFromSR();\n}}}m68k_incpc(4);\nendlabel18: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80_0)(uae_u32 opcode) /* OR.L #<data>.L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_90_0)(uae_u32 opcode) /* OR.L #<data>.L,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_98_0)(uae_u32 opcode) /* OR.L #<data>.L,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg(regs, dstreg) += 4;\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a0_0)(uae_u32 opcode) /* OR.L #<data>.L,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a8_0)(uae_u32 opcode) /* OR.L #<data>.L,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0_0)(uae_u32 opcode) /* OR.L #<data>.L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{m68k_incpc(6);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 dst = get_long(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b8_0)(uae_u32 opcode) /* OR.L #<data>.L,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b9_0)(uae_u32 opcode) /* OR.L #<data>.L,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = get_ilong(6);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(10);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d0_0)(uae_u32 opcode) /* CHK2.B #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=(uae_s32)(uae_s8)get_byte(dsta); upper = (uae_s32)(uae_s8)get_byte(dsta+1);\n\tif ((extra & 0x8000) == 0) reg = (uae_s32)(uae_s8)reg;\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel27; }\n}\n}}}m68k_incpc(4);\nendlabel27: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e8_0)(uae_u32 opcode) /* CHK2.B #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=(uae_s32)(uae_s8)get_byte(dsta); upper = (uae_s32)(uae_s8)get_byte(dsta+1);\n\tif ((extra & 0x8000) == 0) reg = (uae_s32)(uae_s8)reg;\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel28; }\n}\n}}}m68k_incpc(6);\nendlabel28: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_f0_0)(uae_u32 opcode) /* CHK2.B #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=(uae_s32)(uae_s8)get_byte(dsta); upper = (uae_s32)(uae_s8)get_byte(dsta+1);\n\tif ((extra & 0x8000) == 0) reg = (uae_s32)(uae_s8)reg;\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel29; }\n}\n}}}}endlabel29: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_f8_0)(uae_u32 opcode) /* CHK2.B #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=(uae_s32)(uae_s8)get_byte(dsta); upper = (uae_s32)(uae_s8)get_byte(dsta+1);\n\tif ((extra & 0x8000) == 0) reg = (uae_s32)(uae_s8)reg;\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel30; }\n}\n}}}m68k_incpc(6);\nendlabel30: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_f9_0)(uae_u32 opcode) /* CHK2.B #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=(uae_s32)(uae_s8)get_byte(dsta); upper = (uae_s32)(uae_s8)get_byte(dsta+1);\n\tif ((extra & 0x8000) == 0) reg = (uae_s32)(uae_s8)reg;\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel31; }\n}\n}}}m68k_incpc(8);\nendlabel31: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_fa_0)(uae_u32 opcode) /* CHK2.B #<data>.W,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_getpc () + 4;\n\tdsta += (uae_s32)(uae_s16)get_iword(4);\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=(uae_s32)(uae_s8)get_byte(dsta); upper = (uae_s32)(uae_s8)get_byte(dsta+1);\n\tif ((extra & 0x8000) == 0) reg = (uae_s32)(uae_s8)reg;\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel32; }\n}\n}}}m68k_incpc(6);\nendlabel32: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_fb_0)(uae_u32 opcode) /* CHK2.B #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=(uae_s32)(uae_s8)get_byte(dsta); upper = (uae_s32)(uae_s8)get_byte(dsta+1);\n\tif ((extra & 0x8000) == 0) reg = (uae_s32)(uae_s8)reg;\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel33; }\n}\n}}}}endlabel33: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_100_0)(uae_u32 opcode) /* BTST.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= 31;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_108_0)(uae_u32 opcode) /* MVPMR.W (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr memp = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_u16 val = (get_byte(memp) << 8) + get_byte(memp + 2);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((val) & 0xffff);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_110_0)(uae_u32 opcode) /* BTST.B Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_118_0)(uae_u32 opcode) /* BTST.B Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_120_0)(uae_u32 opcode) /* BTST.B Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_128_0)(uae_u32 opcode) /* BTST.B Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_130_0)(uae_u32 opcode) /* BTST.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_138_0)(uae_u32 opcode) /* BTST.B Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_139_0)(uae_u32 opcode) /* BTST.B Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_13a_0)(uae_u32 opcode) /* BTST.B Dn,(d16,PC) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n\tuae_u32 dstreg = 2;\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_getpc () + 2;\n\tdsta += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_13b_0)(uae_u32 opcode) /* BTST.B Dn,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n\tuae_u32 dstreg = 3;\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_13c_0)(uae_u32 opcode) /* BTST.B Dn,#<data>.B */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuae_s8 dst = get_ibyte(2);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_140_0)(uae_u32 opcode) /* BCHG.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= 31;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tm68k_dreg(regs, dstreg) = (dst);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_148_0)(uae_u32 opcode) /* MVPMR.L (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr memp = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_u32 val = (get_byte(memp) << 24) + (get_byte(memp + 2) << 16)\n              + (get_byte(memp + 4) << 8) + get_byte(memp + 6);\n\tm68k_dreg(regs, dstreg) = (val);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_150_0)(uae_u32 opcode) /* BCHG.B Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_158_0)(uae_u32 opcode) /* BCHG.B Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_160_0)(uae_u32 opcode) /* BCHG.B Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_168_0)(uae_u32 opcode) /* BCHG.B Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_170_0)(uae_u32 opcode) /* BCHG.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_178_0)(uae_u32 opcode) /* BCHG.B Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_179_0)(uae_u32 opcode) /* BCHG.B Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_17a_0)(uae_u32 opcode) /* BCHG.B Dn,(d16,PC) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n\tuae_u32 dstreg = 2;\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_getpc () + 2;\n\tdsta += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_17b_0)(uae_u32 opcode) /* BCHG.B Dn,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n\tuae_u32 dstreg = 3;\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_180_0)(uae_u32 opcode) /* BCLR.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= 31;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tm68k_dreg(regs, dstreg) = (dst);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_188_0)(uae_u32 opcode) /* MVPRM.W Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n\tuaecptr memp = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n\tput_byte(memp, src >> 8); put_byte(memp + 2, src);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_190_0)(uae_u32 opcode) /* BCLR.B Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_198_0)(uae_u32 opcode) /* BCLR.B Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1a0_0)(uae_u32 opcode) /* BCLR.B Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1a8_0)(uae_u32 opcode) /* BCLR.B Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1b0_0)(uae_u32 opcode) /* BCLR.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1b8_0)(uae_u32 opcode) /* BCLR.B Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1b9_0)(uae_u32 opcode) /* BCLR.B Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1ba_0)(uae_u32 opcode) /* BCLR.B Dn,(d16,PC) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n\tuae_u32 dstreg = 2;\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_getpc () + 2;\n\tdsta += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1bb_0)(uae_u32 opcode) /* BCLR.B Dn,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n\tuae_u32 dstreg = 3;\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1c0_0)(uae_u32 opcode) /* BSET.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= 31;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tm68k_dreg(regs, dstreg) = (dst);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_1c8_0)(uae_u32 opcode) /* MVPRM.L Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n\tuaecptr memp = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n\tput_byte(memp, src >> 24); put_byte(memp + 2, src >> 16);\n\tput_byte(memp + 4, src >> 8); put_byte(memp + 6, src);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_1d0_0)(uae_u32 opcode) /* BSET.B Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1d8_0)(uae_u32 opcode) /* BSET.B Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1e0_0)(uae_u32 opcode) /* BSET.B Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1e8_0)(uae_u32 opcode) /* BSET.B Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1f0_0)(uae_u32 opcode) /* BSET.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1f8_0)(uae_u32 opcode) /* BSET.B Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1f9_0)(uae_u32 opcode) /* BSET.B Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1fa_0)(uae_u32 opcode) /* BSET.B Dn,(d16,PC) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n\tuae_u32 dstreg = 2;\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_getpc () + 2;\n\tdsta += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1fb_0)(uae_u32 opcode) /* BSET.B Dn,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n\tuae_u32 dstreg = 3;\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_200_0)(uae_u32 opcode) /* AND.B #<data>.B,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_210_0)(uae_u32 opcode) /* AND.B #<data>.B,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_218_0)(uae_u32 opcode) /* AND.B #<data>.B,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_220_0)(uae_u32 opcode) /* AND.B #<data>.B,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_228_0)(uae_u32 opcode) /* AND.B #<data>.B,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_230_0)(uae_u32 opcode) /* AND.B #<data>.B,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_238_0)(uae_u32 opcode) /* AND.B #<data>.B,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_239_0)(uae_u32 opcode) /* AND.B #<data>.B,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_23c_0)(uae_u32 opcode) /* ANDSR.B #<data>.W */\n{\n\tcpuop_begin();\n{\tMakeSR();\n{\tuae_s16 src = get_iword(2);\n\tsrc |= 0xFF00;\n\tregs.sr &= src;\n\tMakeFromSR();\n}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_240_0)(uae_u32 opcode) /* AND.W #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_250_0)(uae_u32 opcode) /* AND.W #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_258_0)(uae_u32 opcode) /* AND.W #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg(regs, dstreg) += 2;\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_260_0)(uae_u32 opcode) /* AND.W #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_268_0)(uae_u32 opcode) /* AND.W #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_270_0)(uae_u32 opcode) /* AND.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s16 dst = get_word(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_278_0)(uae_u32 opcode) /* AND.W #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_279_0)(uae_u32 opcode) /* AND.W #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_27c_0)(uae_u32 opcode) /* ANDSR.W #<data>.W */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel96; }\n{\tMakeSR();\n{\tuae_s16 src = get_iword(2);\n\tregs.sr &= src;\n\tMakeFromSR();\n}}}m68k_incpc(4);\nendlabel96: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_280_0)(uae_u32 opcode) /* AND.L #<data>.L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_290_0)(uae_u32 opcode) /* AND.L #<data>.L,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_298_0)(uae_u32 opcode) /* AND.L #<data>.L,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg(regs, dstreg) += 4;\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2a0_0)(uae_u32 opcode) /* AND.L #<data>.L,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2a8_0)(uae_u32 opcode) /* AND.L #<data>.L,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2b0_0)(uae_u32 opcode) /* AND.L #<data>.L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{m68k_incpc(6);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 dst = get_long(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2b8_0)(uae_u32 opcode) /* AND.L #<data>.L,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2b9_0)(uae_u32 opcode) /* AND.L #<data>.L,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = get_ilong(6);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(10);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2d0_0)(uae_u32 opcode) /* CHK2.W #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=(uae_s32)(uae_s16)get_word(dsta); upper = (uae_s32)(uae_s16)get_word(dsta+2);\n\tif ((extra & 0x8000) == 0) reg = (uae_s32)(uae_s16)reg;\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel105; }\n}\n}}}m68k_incpc(4);\nendlabel105: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2e8_0)(uae_u32 opcode) /* CHK2.W #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=(uae_s32)(uae_s16)get_word(dsta); upper = (uae_s32)(uae_s16)get_word(dsta+2);\n\tif ((extra & 0x8000) == 0) reg = (uae_s32)(uae_s16)reg;\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel106; }\n}\n}}}m68k_incpc(6);\nendlabel106: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2f0_0)(uae_u32 opcode) /* CHK2.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=(uae_s32)(uae_s16)get_word(dsta); upper = (uae_s32)(uae_s16)get_word(dsta+2);\n\tif ((extra & 0x8000) == 0) reg = (uae_s32)(uae_s16)reg;\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel107; }\n}\n}}}}endlabel107: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2f8_0)(uae_u32 opcode) /* CHK2.W #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=(uae_s32)(uae_s16)get_word(dsta); upper = (uae_s32)(uae_s16)get_word(dsta+2);\n\tif ((extra & 0x8000) == 0) reg = (uae_s32)(uae_s16)reg;\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel108; }\n}\n}}}m68k_incpc(6);\nendlabel108: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2f9_0)(uae_u32 opcode) /* CHK2.W #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=(uae_s32)(uae_s16)get_word(dsta); upper = (uae_s32)(uae_s16)get_word(dsta+2);\n\tif ((extra & 0x8000) == 0) reg = (uae_s32)(uae_s16)reg;\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel109; }\n}\n}}}m68k_incpc(8);\nendlabel109: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2fa_0)(uae_u32 opcode) /* CHK2.W #<data>.W,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_getpc () + 4;\n\tdsta += (uae_s32)(uae_s16)get_iword(4);\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=(uae_s32)(uae_s16)get_word(dsta); upper = (uae_s32)(uae_s16)get_word(dsta+2);\n\tif ((extra & 0x8000) == 0) reg = (uae_s32)(uae_s16)reg;\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel110; }\n}\n}}}m68k_incpc(6);\nendlabel110: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2fb_0)(uae_u32 opcode) /* CHK2.W #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=(uae_s32)(uae_s16)get_word(dsta); upper = (uae_s32)(uae_s16)get_word(dsta+2);\n\tif ((extra & 0x8000) == 0) reg = (uae_s32)(uae_s16)reg;\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel111; }\n}\n}}}}endlabel111: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_400_0)(uae_u32 opcode) /* SUB.B #<data>.B,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_410_0)(uae_u32 opcode) /* SUB.B #<data>.B,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_418_0)(uae_u32 opcode) /* SUB.B #<data>.B,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_420_0)(uae_u32 opcode) /* SUB.B #<data>.B,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_428_0)(uae_u32 opcode) /* SUB.B #<data>.B,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_430_0)(uae_u32 opcode) /* SUB.B #<data>.B,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_438_0)(uae_u32 opcode) /* SUB.B #<data>.B,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_439_0)(uae_u32 opcode) /* SUB.B #<data>.B,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_440_0)(uae_u32 opcode) /* SUB.W #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_450_0)(uae_u32 opcode) /* SUB.W #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_458_0)(uae_u32 opcode) /* SUB.W #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg(regs, dstreg) += 2;\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_460_0)(uae_u32 opcode) /* SUB.W #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_468_0)(uae_u32 opcode) /* SUB.W #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_470_0)(uae_u32 opcode) /* SUB.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_478_0)(uae_u32 opcode) /* SUB.W #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_479_0)(uae_u32 opcode) /* SUB.W #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_480_0)(uae_u32 opcode) /* SUB.L #<data>.L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_490_0)(uae_u32 opcode) /* SUB.L #<data>.L,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_498_0)(uae_u32 opcode) /* SUB.L #<data>.L,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg(regs, dstreg) += 4;\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a0_0)(uae_u32 opcode) /* SUB.L #<data>.L,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a8_0)(uae_u32 opcode) /* SUB.L #<data>.L,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4b0_0)(uae_u32 opcode) /* SUB.L #<data>.L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{m68k_incpc(6);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4b8_0)(uae_u32 opcode) /* SUB.L #<data>.L,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4b9_0)(uae_u32 opcode) /* SUB.L #<data>.L,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = get_ilong(6);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(10);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4d0_0)(uae_u32 opcode) /* CHK2.L #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=get_long(dsta); upper = get_long(dsta+4);\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel136; }\n}\n}}}m68k_incpc(4);\nendlabel136: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4e8_0)(uae_u32 opcode) /* CHK2.L #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=get_long(dsta); upper = get_long(dsta+4);\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel137; }\n}\n}}}m68k_incpc(6);\nendlabel137: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4f0_0)(uae_u32 opcode) /* CHK2.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=get_long(dsta); upper = get_long(dsta+4);\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel138; }\n}\n}}}}endlabel138: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4f8_0)(uae_u32 opcode) /* CHK2.L #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=get_long(dsta); upper = get_long(dsta+4);\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel139; }\n}\n}}}m68k_incpc(6);\nendlabel139: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4f9_0)(uae_u32 opcode) /* CHK2.L #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=get_long(dsta); upper = get_long(dsta+4);\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel140; }\n}\n}}}m68k_incpc(8);\nendlabel140: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4fa_0)(uae_u32 opcode) /* CHK2.L #<data>.W,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_getpc () + 4;\n\tdsta += (uae_s32)(uae_s16)get_iword(4);\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=get_long(dsta); upper = get_long(dsta+4);\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel141; }\n}\n}}}m68k_incpc(6);\nendlabel141: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4fb_0)(uae_u32 opcode) /* CHK2.L #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n\t{uae_s32 upper,lower,reg = regs.regs[(extra >> 12) & 15];\n\tlower=get_long(dsta); upper = get_long(dsta+4);\n\tSET_ZFLG (upper == reg || lower == reg);\n\tSET_CFLG_ALWAYS (lower <= upper ? reg < lower || reg > upper : reg > upper || reg < lower);\n\tif ((extra & 0x800) && GET_CFLG) { Exception(6,oldpc); goto endlabel142; }\n}\n}}}}endlabel142: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_600_0)(uae_u32 opcode) /* ADD.B #<data>.B,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_610_0)(uae_u32 opcode) /* ADD.B #<data>.B,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_618_0)(uae_u32 opcode) /* ADD.B #<data>.B,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_620_0)(uae_u32 opcode) /* ADD.B #<data>.B,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_628_0)(uae_u32 opcode) /* ADD.B #<data>.B,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_630_0)(uae_u32 opcode) /* ADD.B #<data>.B,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_638_0)(uae_u32 opcode) /* ADD.B #<data>.B,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_639_0)(uae_u32 opcode) /* ADD.B #<data>.B,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_640_0)(uae_u32 opcode) /* ADD.W #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_650_0)(uae_u32 opcode) /* ADD.W #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_658_0)(uae_u32 opcode) /* ADD.W #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg(regs, dstreg) += 2;\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_660_0)(uae_u32 opcode) /* ADD.W #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_668_0)(uae_u32 opcode) /* ADD.W #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_670_0)(uae_u32 opcode) /* ADD.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_678_0)(uae_u32 opcode) /* ADD.W #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_679_0)(uae_u32 opcode) /* ADD.W #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_680_0)(uae_u32 opcode) /* ADD.L #<data>.L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_690_0)(uae_u32 opcode) /* ADD.L #<data>.L,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_698_0)(uae_u32 opcode) /* ADD.L #<data>.L,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg(regs, dstreg) += 4;\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_6a0_0)(uae_u32 opcode) /* ADD.L #<data>.L,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_6a8_0)(uae_u32 opcode) /* ADD.L #<data>.L,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_6b0_0)(uae_u32 opcode) /* ADD.L #<data>.L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{m68k_incpc(6);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_6b8_0)(uae_u32 opcode) /* ADD.L #<data>.L,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_6b9_0)(uae_u32 opcode) /* ADD.L #<data>.L,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = get_ilong(6);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(10);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_6c0_0)(uae_u32 opcode) /* RTM.L Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{m68k_incpc(2);\n\top_illg(opcode);\n}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_6c8_0)(uae_u32 opcode) /* RTM.L An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{m68k_incpc(2);\n\top_illg(opcode);\n}\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6d0_0)(uae_u32 opcode) /* CALLM.L (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{m68k_incpc(2);\n\top_illg(opcode);\n}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6e8_0)(uae_u32 opcode) /* CALLM.L (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{m68k_incpc(2);\n\top_illg(opcode);\n}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6f0_0)(uae_u32 opcode) /* CALLM.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{m68k_incpc(2);\n\top_illg(opcode);\n}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6f8_0)(uae_u32 opcode) /* CALLM.L (xxx).W */\n{\n\tcpuop_begin();\n{m68k_incpc(2);\n\top_illg(opcode);\n}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6f9_0)(uae_u32 opcode) /* CALLM.L (xxx).L */\n{\n\tcpuop_begin();\n{m68k_incpc(2);\n\top_illg(opcode);\n}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6fa_0)(uae_u32 opcode) /* CALLM.L (d16,PC) */\n{\n\tcpuop_begin();\n{m68k_incpc(2);\n\top_illg(opcode);\n}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6fb_0)(uae_u32 opcode) /* CALLM.L (d8,PC,Xn) */\n{\n\tcpuop_begin();\n{m68k_incpc(2);\n\top_illg(opcode);\n}\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_800_0)(uae_u32 opcode) /* BTST.L #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= 31;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_810_0)(uae_u32 opcode) /* BTST.B #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_818_0)(uae_u32 opcode) /* BTST.B #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_820_0)(uae_u32 opcode) /* BTST.B #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_828_0)(uae_u32 opcode) /* BTST.B #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_830_0)(uae_u32 opcode) /* BTST.B #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_838_0)(uae_u32 opcode) /* BTST.B #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_839_0)(uae_u32 opcode) /* BTST.B #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_83a_0)(uae_u32 opcode) /* BTST.B #<data>.W,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_getpc () + 4;\n\tdsta += (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_83b_0)(uae_u32 opcode) /* BTST.B #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_83c_0)(uae_u32 opcode) /* BTST.B #<data>.W,#<data>.B */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s8 dst = get_ibyte(4);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_840_0)(uae_u32 opcode) /* BCHG.L #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= 31;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tm68k_dreg(regs, dstreg) = (dst);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_850_0)(uae_u32 opcode) /* BCHG.B #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_858_0)(uae_u32 opcode) /* BCHG.B #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_860_0)(uae_u32 opcode) /* BCHG.B #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_868_0)(uae_u32 opcode) /* BCHG.B #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_870_0)(uae_u32 opcode) /* BCHG.B #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_878_0)(uae_u32 opcode) /* BCHG.B #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_879_0)(uae_u32 opcode) /* BCHG.B #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_87a_0)(uae_u32 opcode) /* BCHG.B #<data>.W,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_getpc () + 4;\n\tdsta += (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_87b_0)(uae_u32 opcode) /* BCHG.B #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_880_0)(uae_u32 opcode) /* BCLR.L #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= 31;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tm68k_dreg(regs, dstreg) = (dst);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_890_0)(uae_u32 opcode) /* BCLR.B #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_898_0)(uae_u32 opcode) /* BCLR.B #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8a0_0)(uae_u32 opcode) /* BCLR.B #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8a8_0)(uae_u32 opcode) /* BCLR.B #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8b0_0)(uae_u32 opcode) /* BCLR.B #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8b8_0)(uae_u32 opcode) /* BCLR.B #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8b9_0)(uae_u32 opcode) /* BCLR.B #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8ba_0)(uae_u32 opcode) /* BCLR.B #<data>.W,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_getpc () + 4;\n\tdsta += (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8bb_0)(uae_u32 opcode) /* BCLR.B #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8c0_0)(uae_u32 opcode) /* BSET.L #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= 31;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tm68k_dreg(regs, dstreg) = (dst);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8d0_0)(uae_u32 opcode) /* BSET.B #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8d8_0)(uae_u32 opcode) /* BSET.B #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8e0_0)(uae_u32 opcode) /* BSET.B #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8e8_0)(uae_u32 opcode) /* BSET.B #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8f0_0)(uae_u32 opcode) /* BSET.B #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8f8_0)(uae_u32 opcode) /* BSET.B #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8f9_0)(uae_u32 opcode) /* BSET.B #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8fa_0)(uae_u32 opcode) /* BSET.B #<data>.W,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_getpc () + 4;\n\tdsta += (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8fb_0)(uae_u32 opcode) /* BSET.B #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a00_0)(uae_u32 opcode) /* EOR.B #<data>.B,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a10_0)(uae_u32 opcode) /* EOR.B #<data>.B,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a18_0)(uae_u32 opcode) /* EOR.B #<data>.B,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a20_0)(uae_u32 opcode) /* EOR.B #<data>.B,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a28_0)(uae_u32 opcode) /* EOR.B #<data>.B,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a30_0)(uae_u32 opcode) /* EOR.B #<data>.B,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a38_0)(uae_u32 opcode) /* EOR.B #<data>.B,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a39_0)(uae_u32 opcode) /* EOR.B #<data>.B,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a3c_0)(uae_u32 opcode) /* EORSR.B #<data>.W */\n{\n\tcpuop_begin();\n{\tMakeSR();\n{\tuae_s16 src = get_iword(2);\n\tsrc &= 0xFF;\n\tregs.sr ^= src;\n\tMakeFromSR();\n}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a40_0)(uae_u32 opcode) /* EOR.W #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a50_0)(uae_u32 opcode) /* EOR.W #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a58_0)(uae_u32 opcode) /* EOR.W #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg(regs, dstreg) += 2;\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a60_0)(uae_u32 opcode) /* EOR.W #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a68_0)(uae_u32 opcode) /* EOR.W #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a70_0)(uae_u32 opcode) /* EOR.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s16 dst = get_word(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a78_0)(uae_u32 opcode) /* EOR.W #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a79_0)(uae_u32 opcode) /* EOR.W #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\n#endif\n\n#ifdef PART_2\nvoid REGPARAM2 CPUFUNC(op_a7c_0)(uae_u32 opcode) /* EORSR.W #<data>.W */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel234; }\n{\tMakeSR();\n{\tuae_s16 src = get_iword(2);\n\tregs.sr ^= src;\n\tMakeFromSR();\n}}}m68k_incpc(4);\nendlabel234: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a80_0)(uae_u32 opcode) /* EOR.L #<data>.L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a90_0)(uae_u32 opcode) /* EOR.L #<data>.L,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a98_0)(uae_u32 opcode) /* EOR.L #<data>.L,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg(regs, dstreg) += 4;\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_aa0_0)(uae_u32 opcode) /* EOR.L #<data>.L,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_aa8_0)(uae_u32 opcode) /* EOR.L #<data>.L,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ab0_0)(uae_u32 opcode) /* EOR.L #<data>.L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{m68k_incpc(6);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 dst = get_long(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ab8_0)(uae_u32 opcode) /* EOR.L #<data>.L,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ab9_0)(uae_u32 opcode) /* EOR.L #<data>.L,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = get_ilong(6);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(10);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ad0_0)(uae_u32 opcode) /* CAS.B #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s8)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(m68k_dreg(regs, rc))) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_byte(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ad8_0)(uae_u32 opcode) /* CAS.B #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s8)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(m68k_dreg(regs, rc))) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_byte(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ae0_0)(uae_u32 opcode) /* CAS.B #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s8)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(m68k_dreg(regs, rc))) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_byte(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ae8_0)(uae_u32 opcode) /* CAS.B #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s8)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(m68k_dreg(regs, rc))) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_byte(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_af0_0)(uae_u32 opcode) /* CAS.B #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s8)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(m68k_dreg(regs, rc))) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_byte(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_af8_0)(uae_u32 opcode) /* CAS.B #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s8)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(m68k_dreg(regs, rc))) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_byte(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_af9_0)(uae_u32 opcode) /* CAS.B #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s8 dst = get_byte(dsta);\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s8)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(m68k_dreg(regs, rc))) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_byte(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c00_0)(uae_u32 opcode) /* CMP.B #<data>.B,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c10_0)(uae_u32 opcode) /* CMP.B #<data>.B,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c18_0)(uae_u32 opcode) /* CMP.B #<data>.B,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c20_0)(uae_u32 opcode) /* CMP.B #<data>.B,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c28_0)(uae_u32 opcode) /* CMP.B #<data>.B,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c30_0)(uae_u32 opcode) /* CMP.B #<data>.B,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c38_0)(uae_u32 opcode) /* CMP.B #<data>.B,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c39_0)(uae_u32 opcode) /* CMP.B #<data>.B,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c3a_0)(uae_u32 opcode) /* CMP.B #<data>.B,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_getpc () + 4;\n\tdsta += (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c3b_0)(uae_u32 opcode) /* CMP.B #<data>.B,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s8 src = get_ibyte(2);\n{m68k_incpc(4);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c40_0)(uae_u32 opcode) /* CMP.W #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c50_0)(uae_u32 opcode) /* CMP.W #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c58_0)(uae_u32 opcode) /* CMP.W #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg(regs, dstreg) += 2;\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c60_0)(uae_u32 opcode) /* CMP.W #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c68_0)(uae_u32 opcode) /* CMP.W #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c70_0)(uae_u32 opcode) /* CMP.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c78_0)(uae_u32 opcode) /* CMP.W #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c79_0)(uae_u32 opcode) /* CMP.W #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c7a_0)(uae_u32 opcode) /* CMP.W #<data>.W,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_getpc () + 4;\n\tdsta += (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c7b_0)(uae_u32 opcode) /* CMP.W #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c80_0)(uae_u32 opcode) /* CMP.L #<data>.L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c90_0)(uae_u32 opcode) /* CMP.L #<data>.L,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c98_0)(uae_u32 opcode) /* CMP.L #<data>.L,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg(regs, dstreg) += 4;\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ca0_0)(uae_u32 opcode) /* CMP.L #<data>.L,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ca8_0)(uae_u32 opcode) /* CMP.L #<data>.L,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_cb0_0)(uae_u32 opcode) /* CMP.L #<data>.L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{m68k_incpc(6);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_cb8_0)(uae_u32 opcode) /* CMP.L #<data>.L,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_cb9_0)(uae_u32 opcode) /* CMP.L #<data>.L,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = get_ilong(6);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(10);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_cba_0)(uae_u32 opcode) /* CMP.L #<data>.L,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_getpc () + 6;\n\tdsta += (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_cbb_0)(uae_u32 opcode) /* CMP.L #<data>.L,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s32 src = get_ilong(2);\n{m68k_incpc(6);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_cd0_0)(uae_u32 opcode) /* CAS.W #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s16)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(m68k_dreg(regs, rc))) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_word(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_cd8_0)(uae_u32 opcode) /* CAS.W #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg(regs, dstreg) += 2;\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s16)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(m68k_dreg(regs, rc))) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_word(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ce0_0)(uae_u32 opcode) /* CAS.W #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s16)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(m68k_dreg(regs, rc))) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_word(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ce8_0)(uae_u32 opcode) /* CAS.W #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s16 dst = get_word(dsta);\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s16)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(m68k_dreg(regs, rc))) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_word(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_cf0_0)(uae_u32 opcode) /* CAS.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s16 dst = get_word(dsta);\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s16)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(m68k_dreg(regs, rc))) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_word(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_cf8_0)(uae_u32 opcode) /* CAS.W #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s16 dst = get_word(dsta);\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s16)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(m68k_dreg(regs, rc))) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_word(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_cf9_0)(uae_u32 opcode) /* CAS.W #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s16 dst = get_word(dsta);\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s16)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(m68k_dreg(regs, rc))) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_word(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_cfc_0)(uae_u32 opcode) /* CAS2.W #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 extra = get_ilong(2);\n\tuae_u32 rn1 = regs.regs[(extra >> 28) & 15];\n\tuae_u32 rn2 = regs.regs[(extra >> 12) & 15];\n\tuae_u16 dst1 = get_word(rn1), dst2 = get_word(rn2);\n{uae_u32 newv = ((uae_s16)(dst1)) - ((uae_s16)(m68k_dreg(regs, (extra >> 16) & 7)));\n{\tint flgs = ((uae_s16)(m68k_dreg(regs, (extra >> 16) & 7))) < 0;\n\tint flgo = ((uae_s16)(dst1)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(m68k_dreg(regs, (extra >> 16) & 7))) > ((uae_u16)(dst1)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG) {\n{uae_u32 newv = ((uae_s16)(dst2)) - ((uae_s16)(m68k_dreg(regs, extra & 7)));\n{\tint flgs = ((uae_s16)(m68k_dreg(regs, extra & 7))) < 0;\n\tint flgo = ((uae_s16)(dst2)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(m68k_dreg(regs, extra & 7))) > ((uae_u16)(dst2)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG) {\n\tput_word(rn1, m68k_dreg(regs, (extra >> 22) & 7));\n\tput_word(rn1, m68k_dreg(regs, (extra >> 6) & 7));\n\t}}\n}}}}\tif (! GET_ZFLG) {\n\tm68k_dreg(regs, (extra >> 22) & 7) = (m68k_dreg(regs, (extra >> 22) & 7) & ~0xffff) | (dst1 & 0xffff);\n\tm68k_dreg(regs, (extra >> 6) & 7) = (m68k_dreg(regs, (extra >> 6) & 7) & ~0xffff) | (dst2 & 0xffff);\n\t}\n}}m68k_incpc(6);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_e10_0)(uae_u32 opcode) /* MOVES.B #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel288; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tput_byte(dsta,src);\n}}else{{\tuaecptr srca = m68k_areg(regs, dstreg);\n{\tuae_s8 src = get_byte(srca);\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = (uae_s32)(uae_s8)src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (m68k_dreg(regs, (extra >> 12) & 7) & ~0xff) | ((src) & 0xff);\n\t}\n}}}}}}m68k_incpc(4);\nendlabel288: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_e18_0)(uae_u32 opcode) /* MOVES.B #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel289; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tput_byte(dsta,src);\n}}else{{\tuaecptr srca = m68k_areg(regs, dstreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = (uae_s32)(uae_s8)src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (m68k_dreg(regs, (extra >> 12) & 7) & ~0xff) | ((src) & 0xff);\n\t}\n}}}}}}m68k_incpc(4);\nendlabel289: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_e20_0)(uae_u32 opcode) /* MOVES.B #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel290; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n\tm68k_areg (regs, dstreg) = dsta;\n\tput_byte(dsta,src);\n}}else{{\tuaecptr srca = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, dstreg) = srca;\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = (uae_s32)(uae_s8)src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (m68k_dreg(regs, (extra >> 12) & 7) & ~0xff) | ((src) & 0xff);\n\t}\n}}}}}}m68k_incpc(4);\nendlabel290: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_e28_0)(uae_u32 opcode) /* MOVES.B #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel291; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tput_byte(dsta,src);\n}}else{{\tuaecptr srca = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s8 src = get_byte(srca);\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = (uae_s32)(uae_s8)src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (m68k_dreg(regs, (extra >> 12) & 7) & ~0xff) | ((src) & 0xff);\n\t}\n}}}}}}m68k_incpc(8);\nendlabel291: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_e30_0)(uae_u32 opcode) /* MOVES.B #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel292; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tput_byte(dsta,src);\n}}}else{{{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = (uae_s32)(uae_s8)src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (m68k_dreg(regs, (extra >> 12) & 7) & ~0xff) | ((src) & 0xff);\n\t}\n}}}}}}}endlabel292: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_e38_0)(uae_u32 opcode) /* MOVES.B #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel293; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tput_byte(dsta,src);\n}}else{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s8 src = get_byte(srca);\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = (uae_s32)(uae_s8)src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (m68k_dreg(regs, (extra >> 12) & 7) & ~0xff) | ((src) & 0xff);\n\t}\n}}}}}}m68k_incpc(8);\nendlabel293: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_e39_0)(uae_u32 opcode) /* MOVES.B #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel294; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{\tuaecptr dsta = get_ilong(4);\n\tput_byte(dsta,src);\n}}else{{\tuaecptr srca = get_ilong(8);\n{\tuae_s8 src = get_byte(srca);\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = (uae_s32)(uae_s8)src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (m68k_dreg(regs, (extra >> 12) & 7) & ~0xff) | ((src) & 0xff);\n\t}\n}}}}}}m68k_incpc(12);\nendlabel294: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_e50_0)(uae_u32 opcode) /* MOVES.W #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel295; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tput_word(dsta,src);\n}}else{{\tuaecptr srca = m68k_areg(regs, dstreg);\n{\tuae_s16 src = get_word(srca);\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = (uae_s32)(uae_s16)src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (m68k_dreg(regs, (extra >> 12) & 7) & ~0xffff) | ((src) & 0xffff);\n\t}\n}}}}}}m68k_incpc(4);\nendlabel295: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_e58_0)(uae_u32 opcode) /* MOVES.W #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel296; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 2;\n\tput_word(dsta,src);\n}}else{{\tuaecptr srca = m68k_areg(regs, dstreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, dstreg) += 2;\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = (uae_s32)(uae_s16)src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (m68k_dreg(regs, (extra >> 12) & 7) & ~0xffff) | ((src) & 0xffff);\n\t}\n}}}}}}m68k_incpc(4);\nendlabel296: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_e60_0)(uae_u32 opcode) /* MOVES.W #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel297; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n\tm68k_areg (regs, dstreg) = dsta;\n\tput_word(dsta,src);\n}}else{{\tuaecptr srca = m68k_areg(regs, dstreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, dstreg) = srca;\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = (uae_s32)(uae_s16)src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (m68k_dreg(regs, (extra >> 12) & 7) & ~0xffff) | ((src) & 0xffff);\n\t}\n}}}}}}m68k_incpc(4);\nendlabel297: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_e68_0)(uae_u32 opcode) /* MOVES.W #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel298; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tput_word(dsta,src);\n}}else{{\tuaecptr srca = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s16 src = get_word(srca);\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = (uae_s32)(uae_s16)src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (m68k_dreg(regs, (extra >> 12) & 7) & ~0xffff) | ((src) & 0xffff);\n\t}\n}}}}}}m68k_incpc(8);\nendlabel298: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_e70_0)(uae_u32 opcode) /* MOVES.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel299; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tput_word(dsta,src);\n}}}else{{{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = (uae_s32)(uae_s16)src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (m68k_dreg(regs, (extra >> 12) & 7) & ~0xffff) | ((src) & 0xffff);\n\t}\n}}}}}}}endlabel299: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_e78_0)(uae_u32 opcode) /* MOVES.W #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel300; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tput_word(dsta,src);\n}}else{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s16 src = get_word(srca);\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = (uae_s32)(uae_s16)src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (m68k_dreg(regs, (extra >> 12) & 7) & ~0xffff) | ((src) & 0xffff);\n\t}\n}}}}}}m68k_incpc(8);\nendlabel300: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_e79_0)(uae_u32 opcode) /* MOVES.W #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel301; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{\tuaecptr dsta = get_ilong(4);\n\tput_word(dsta,src);\n}}else{{\tuaecptr srca = get_ilong(8);\n{\tuae_s16 src = get_word(srca);\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = (uae_s32)(uae_s16)src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (m68k_dreg(regs, (extra >> 12) & 7) & ~0xffff) | ((src) & 0xffff);\n\t}\n}}}}}}m68k_incpc(12);\nendlabel301: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_e90_0)(uae_u32 opcode) /* MOVES.L #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel302; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tput_long(dsta,src);\n}}else{{\tuaecptr srca = m68k_areg(regs, dstreg);\n{\tuae_s32 src = get_long(srca);\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (src);\n\t}\n}}}}}}m68k_incpc(4);\nendlabel302: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_e98_0)(uae_u32 opcode) /* MOVES.L #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel303; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 4;\n\tput_long(dsta,src);\n}}else{{\tuaecptr srca = m68k_areg(regs, dstreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, dstreg) += 4;\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (src);\n\t}\n}}}}}}m68k_incpc(4);\nendlabel303: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_ea0_0)(uae_u32 opcode) /* MOVES.L #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel304; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n\tm68k_areg (regs, dstreg) = dsta;\n\tput_long(dsta,src);\n}}else{{\tuaecptr srca = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, dstreg) = srca;\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (src);\n\t}\n}}}}}}m68k_incpc(4);\nendlabel304: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_ea8_0)(uae_u32 opcode) /* MOVES.L #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel305; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tput_long(dsta,src);\n}}else{{\tuaecptr srca = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s32 src = get_long(srca);\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (src);\n\t}\n}}}}}}m68k_incpc(8);\nendlabel305: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_eb0_0)(uae_u32 opcode) /* MOVES.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel306; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tput_long(dsta,src);\n}}}else{{{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (src);\n\t}\n}}}}}}}endlabel306: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_eb8_0)(uae_u32 opcode) /* MOVES.L #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel307; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tput_long(dsta,src);\n}}else{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(6);\n{\tuae_s32 src = get_long(srca);\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (src);\n\t}\n}}}}}}m68k_incpc(8);\nendlabel307: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_eb9_0)(uae_u32 opcode) /* MOVES.L #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel308; }\n{{\tuae_s16 extra = get_iword(2);\n\tif (extra & 0x800)\n{\tuae_u32 src = regs.regs[(extra >> 12) & 15];\n{\tuaecptr dsta = get_ilong(4);\n\tput_long(dsta,src);\n}}else{{\tuaecptr srca = get_ilong(8);\n{\tuae_s32 src = get_long(srca);\n\tif (extra & 0x8000) {\n\tm68k_areg(regs, (extra >> 12) & 7) = src;\n\t} else {\n\tm68k_dreg(regs, (extra >> 12) & 7) = (src);\n\t}\n}}}}}}m68k_incpc(12);\nendlabel308: ;\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_ed0_0)(uae_u32 opcode) /* CAS.L #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s32)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(m68k_dreg(regs, rc))) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_long(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ed8_0)(uae_u32 opcode) /* CAS.L #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg(regs, dstreg) += 4;\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s32)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(m68k_dreg(regs, rc))) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_long(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ee0_0)(uae_u32 opcode) /* CAS.L #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s32)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(m68k_dreg(regs, rc))) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_long(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ee8_0)(uae_u32 opcode) /* CAS.L #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 dst = get_long(dsta);\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s32)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(m68k_dreg(regs, rc))) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_long(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ef0_0)(uae_u32 opcode) /* CAS.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 dst = get_long(dsta);\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s32)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(m68k_dreg(regs, rc))) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_long(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ef8_0)(uae_u32 opcode) /* CAS.L #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 dst = get_long(dsta);\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s32)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(m68k_dreg(regs, rc))) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_long(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ef9_0)(uae_u32 opcode) /* CAS.L #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s32 dst = get_long(dsta);\n{\tint ru = (src >> 6) & 7;\n\tint rc = src & 7;\n{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(m68k_dreg(regs, rc)));\n{\tint flgs = ((uae_s32)(m68k_dreg(regs, rc))) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(m68k_dreg(regs, rc))) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG){\tput_long(dsta,(m68k_dreg(regs, ru)));\n}else{m68k_dreg(regs, rc) = dst;\n}}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_efc_0)(uae_u32 opcode) /* CAS2.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 extra = get_ilong(2);\n\tuae_u32 rn1 = regs.regs[(extra >> 28) & 15];\n\tuae_u32 rn2 = regs.regs[(extra >> 12) & 15];\n\tuae_u32 dst1 = get_long(rn1), dst2 = get_long(rn2);\n{uae_u32 newv = ((uae_s32)(dst1)) - ((uae_s32)(m68k_dreg(regs, (extra >> 16) & 7)));\n{\tint flgs = ((uae_s32)(m68k_dreg(regs, (extra >> 16) & 7))) < 0;\n\tint flgo = ((uae_s32)(dst1)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(m68k_dreg(regs, (extra >> 16) & 7))) > ((uae_u32)(dst1)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG) {\n{uae_u32 newv = ((uae_s32)(dst2)) - ((uae_s32)(m68k_dreg(regs, extra & 7)));\n{\tint flgs = ((uae_s32)(m68k_dreg(regs, extra & 7))) < 0;\n\tint flgo = ((uae_s32)(dst2)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(m68k_dreg(regs, extra & 7))) > ((uae_u32)(dst2)));\n\tSET_NFLG (flgn != 0);\n\tif (GET_ZFLG) {\n\tput_long(rn1, m68k_dreg(regs, (extra >> 22) & 7));\n\tput_long(rn1, m68k_dreg(regs, (extra >> 6) & 7));\n\t}}\n}}}}\tif (! GET_ZFLG) {\n\tm68k_dreg(regs, (extra >> 22) & 7) = dst1;\n\tm68k_dreg(regs, (extra >> 6) & 7) = dst2;\n\t}\n}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1000_0)(uae_u32 opcode) /* MOVE.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1010_0)(uae_u32 opcode) /* MOVE.B (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1018_0)(uae_u32 opcode) /* MOVE.B (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1020_0)(uae_u32 opcode) /* MOVE.B -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1028_0)(uae_u32 opcode) /* MOVE.B (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1030_0)(uae_u32 opcode) /* MOVE.B (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1038_0)(uae_u32 opcode) /* MOVE.B (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1039_0)(uae_u32 opcode) /* MOVE.B (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_103a_0)(uae_u32 opcode) /* MOVE.B (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_103b_0)(uae_u32 opcode) /* MOVE.B (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_103c_0)(uae_u32 opcode) /* MOVE.B #<data>.B,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1080_0)(uae_u32 opcode) /* MOVE.B Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1090_0)(uae_u32 opcode) /* MOVE.B (An),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1098_0)(uae_u32 opcode) /* MOVE.B (An)+,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10a0_0)(uae_u32 opcode) /* MOVE.B -(An),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10a8_0)(uae_u32 opcode) /* MOVE.B (d16,An),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10b0_0)(uae_u32 opcode) /* MOVE.B (d8,An,Xn),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10b8_0)(uae_u32 opcode) /* MOVE.B (xxx).W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10b9_0)(uae_u32 opcode) /* MOVE.B (xxx).L,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10ba_0)(uae_u32 opcode) /* MOVE.B (d16,PC),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10bb_0)(uae_u32 opcode) /* MOVE.B (d8,PC,Xn),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10bc_0)(uae_u32 opcode) /* MOVE.B #<data>.B,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10c0_0)(uae_u32 opcode) /* MOVE.B Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10d0_0)(uae_u32 opcode) /* MOVE.B (An),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10d8_0)(uae_u32 opcode) /* MOVE.B (An)+,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10e0_0)(uae_u32 opcode) /* MOVE.B -(An),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10e8_0)(uae_u32 opcode) /* MOVE.B (d16,An),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10f0_0)(uae_u32 opcode) /* MOVE.B (d8,An,Xn),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10f8_0)(uae_u32 opcode) /* MOVE.B (xxx).W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10f9_0)(uae_u32 opcode) /* MOVE.B (xxx).L,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10fa_0)(uae_u32 opcode) /* MOVE.B (d16,PC),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10fb_0)(uae_u32 opcode) /* MOVE.B (d8,PC,Xn),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10fc_0)(uae_u32 opcode) /* MOVE.B #<data>.B,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1100_0)(uae_u32 opcode) /* MOVE.B Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1110_0)(uae_u32 opcode) /* MOVE.B (An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1118_0)(uae_u32 opcode) /* MOVE.B (An)+,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1120_0)(uae_u32 opcode) /* MOVE.B -(An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1128_0)(uae_u32 opcode) /* MOVE.B (d16,An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1130_0)(uae_u32 opcode) /* MOVE.B (d8,An,Xn),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1138_0)(uae_u32 opcode) /* MOVE.B (xxx).W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1139_0)(uae_u32 opcode) /* MOVE.B (xxx).L,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_113a_0)(uae_u32 opcode) /* MOVE.B (d16,PC),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_113b_0)(uae_u32 opcode) /* MOVE.B (d8,PC,Xn),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_113c_0)(uae_u32 opcode) /* MOVE.B #<data>.B,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1140_0)(uae_u32 opcode) /* MOVE.B Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1150_0)(uae_u32 opcode) /* MOVE.B (An),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1158_0)(uae_u32 opcode) /* MOVE.B (An)+,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1160_0)(uae_u32 opcode) /* MOVE.B -(An),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1168_0)(uae_u32 opcode) /* MOVE.B (d16,An),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1170_0)(uae_u32 opcode) /* MOVE.B (d8,An,Xn),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(0);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1178_0)(uae_u32 opcode) /* MOVE.B (xxx).W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1179_0)(uae_u32 opcode) /* MOVE.B (xxx).L,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(6);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_117a_0)(uae_u32 opcode) /* MOVE.B (d16,PC),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_117b_0)(uae_u32 opcode) /* MOVE.B (d8,PC,Xn),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(0);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_117c_0)(uae_u32 opcode) /* MOVE.B #<data>.B,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1180_0)(uae_u32 opcode) /* MOVE.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1190_0)(uae_u32 opcode) /* MOVE.B (An),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1198_0)(uae_u32 opcode) /* MOVE.B (An)+,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11a0_0)(uae_u32 opcode) /* MOVE.B -(An),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11a8_0)(uae_u32 opcode) /* MOVE.B (d16,An),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11b0_0)(uae_u32 opcode) /* MOVE.B (d8,An,Xn),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n{{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11b8_0)(uae_u32 opcode) /* MOVE.B (xxx).W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11b9_0)(uae_u32 opcode) /* MOVE.B (xxx).L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{m68k_incpc(6);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11ba_0)(uae_u32 opcode) /* MOVE.B (d16,PC),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11bb_0)(uae_u32 opcode) /* MOVE.B (d8,PC,Xn),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 src = get_byte(srca);\n{{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11bc_0)(uae_u32 opcode) /* MOVE.B #<data>.B,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11c0_0)(uae_u32 opcode) /* MOVE.B Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11d0_0)(uae_u32 opcode) /* MOVE.B (An),(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11d8_0)(uae_u32 opcode) /* MOVE.B (An)+,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11e0_0)(uae_u32 opcode) /* MOVE.B -(An),(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11e8_0)(uae_u32 opcode) /* MOVE.B (d16,An),(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11f0_0)(uae_u32 opcode) /* MOVE.B (d8,An,Xn),(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(0);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11f8_0)(uae_u32 opcode) /* MOVE.B (xxx).W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11f9_0)(uae_u32 opcode) /* MOVE.B (xxx).L,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(6);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11fa_0)(uae_u32 opcode) /* MOVE.B (d16,PC),(xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11fb_0)(uae_u32 opcode) /* MOVE.B (d8,PC,Xn),(xxx).W */\n{\n\tcpuop_begin();\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(0);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11fc_0)(uae_u32 opcode) /* MOVE.B #<data>.B,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_13c0_0)(uae_u32 opcode) /* MOVE.B Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_13d0_0)(uae_u32 opcode) /* MOVE.B (An),(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = get_ilong(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_13d8_0)(uae_u32 opcode) /* MOVE.B (An)+,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tuaecptr dsta = get_ilong(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_13e0_0)(uae_u32 opcode) /* MOVE.B -(An),(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = get_ilong(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_13e8_0)(uae_u32 opcode) /* MOVE.B (d16,An),(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = get_ilong(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_13f0_0)(uae_u32 opcode) /* MOVE.B (d8,An,Xn),(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = get_ilong(0);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_13f8_0)(uae_u32 opcode) /* MOVE.B (xxx).W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = get_ilong(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_13f9_0)(uae_u32 opcode) /* MOVE.B (xxx).L,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = get_ilong(6);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(10);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_13fa_0)(uae_u32 opcode) /* MOVE.B (d16,PC),(xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = get_ilong(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_13fb_0)(uae_u32 opcode) /* MOVE.B (d8,PC,Xn),(xxx).L */\n{\n\tcpuop_begin();\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = get_ilong(0);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_13fc_0)(uae_u32 opcode) /* MOVE.B #<data>.B,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = get_ilong(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2000_0)(uae_u32 opcode) /* MOVE.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2008_0)(uae_u32 opcode) /* MOVE.L An,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2010_0)(uae_u32 opcode) /* MOVE.L (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2018_0)(uae_u32 opcode) /* MOVE.L (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2020_0)(uae_u32 opcode) /* MOVE.L -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2028_0)(uae_u32 opcode) /* MOVE.L (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2030_0)(uae_u32 opcode) /* MOVE.L (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2038_0)(uae_u32 opcode) /* MOVE.L (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2039_0)(uae_u32 opcode) /* MOVE.L (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_203a_0)(uae_u32 opcode) /* MOVE.L (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_203b_0)(uae_u32 opcode) /* MOVE.L (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_203c_0)(uae_u32 opcode) /* MOVE.L #<data>.L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_2040_0)(uae_u32 opcode) /* MOVEA.L Dn,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_u32 val = src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_2048_0)(uae_u32 opcode) /* MOVEA.L An,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n{\tuae_u32 val = src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_2050_0)(uae_u32 opcode) /* MOVEA.L (An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 val = src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_2058_0)(uae_u32 opcode) /* MOVEA.L (An)+,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuae_u32 val = src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_2060_0)(uae_u32 opcode) /* MOVEA.L -(An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_u32 val = src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_2068_0)(uae_u32 opcode) /* MOVEA.L (d16,An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 val = src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_2070_0)(uae_u32 opcode) /* MOVEA.L (d8,An,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 val = src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_2078_0)(uae_u32 opcode) /* MOVEA.L (xxx).W,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 val = src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_2079_0)(uae_u32 opcode) /* MOVEA.L (xxx).L,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 val = src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_207a_0)(uae_u32 opcode) /* MOVEA.L (d16,PC),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 val = src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_207b_0)(uae_u32 opcode) /* MOVEA.L (d8,PC,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 val = src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_207c_0)(uae_u32 opcode) /* MOVEA.L #<data>.L,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuae_u32 val = src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_2080_0)(uae_u32 opcode) /* MOVE.L Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2088_0)(uae_u32 opcode) /* MOVE.L An,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2090_0)(uae_u32 opcode) /* MOVE.L (An),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2098_0)(uae_u32 opcode) /* MOVE.L (An)+,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20a0_0)(uae_u32 opcode) /* MOVE.L -(An),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20a8_0)(uae_u32 opcode) /* MOVE.L (d16,An),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20b0_0)(uae_u32 opcode) /* MOVE.L (d8,An,Xn),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20b8_0)(uae_u32 opcode) /* MOVE.L (xxx).W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20b9_0)(uae_u32 opcode) /* MOVE.L (xxx).L,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20ba_0)(uae_u32 opcode) /* MOVE.L (d16,PC),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20bb_0)(uae_u32 opcode) /* MOVE.L (d8,PC,Xn),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20bc_0)(uae_u32 opcode) /* MOVE.L #<data>.L,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20c0_0)(uae_u32 opcode) /* MOVE.L Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 4;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20c8_0)(uae_u32 opcode) /* MOVE.L An,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 4;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20d0_0)(uae_u32 opcode) /* MOVE.L (An),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 4;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20d8_0)(uae_u32 opcode) /* MOVE.L (An)+,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 4;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20e0_0)(uae_u32 opcode) /* MOVE.L -(An),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 4;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20e8_0)(uae_u32 opcode) /* MOVE.L (d16,An),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 4;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20f0_0)(uae_u32 opcode) /* MOVE.L (d8,An,Xn),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 4;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20f8_0)(uae_u32 opcode) /* MOVE.L (xxx).W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 4;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20f9_0)(uae_u32 opcode) /* MOVE.L (xxx).L,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 4;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20fa_0)(uae_u32 opcode) /* MOVE.L (d16,PC),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 4;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20fb_0)(uae_u32 opcode) /* MOVE.L (d8,PC,Xn),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 4;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20fc_0)(uae_u32 opcode) /* MOVE.L #<data>.L,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 4;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2100_0)(uae_u32 opcode) /* MOVE.L Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2108_0)(uae_u32 opcode) /* MOVE.L An,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2110_0)(uae_u32 opcode) /* MOVE.L (An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2118_0)(uae_u32 opcode) /* MOVE.L (An)+,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2120_0)(uae_u32 opcode) /* MOVE.L -(An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2128_0)(uae_u32 opcode) /* MOVE.L (d16,An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2130_0)(uae_u32 opcode) /* MOVE.L (d8,An,Xn),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2138_0)(uae_u32 opcode) /* MOVE.L (xxx).W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2139_0)(uae_u32 opcode) /* MOVE.L (xxx).L,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_213a_0)(uae_u32 opcode) /* MOVE.L (d16,PC),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_213b_0)(uae_u32 opcode) /* MOVE.L (d8,PC,Xn),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_213c_0)(uae_u32 opcode) /* MOVE.L #<data>.L,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2140_0)(uae_u32 opcode) /* MOVE.L Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2148_0)(uae_u32 opcode) /* MOVE.L An,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2150_0)(uae_u32 opcode) /* MOVE.L (An),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n#endif\n\n#ifdef PART_3\nvoid REGPARAM2 CPUFUNC(op_2158_0)(uae_u32 opcode) /* MOVE.L (An)+,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2160_0)(uae_u32 opcode) /* MOVE.L -(An),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2168_0)(uae_u32 opcode) /* MOVE.L (d16,An),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2170_0)(uae_u32 opcode) /* MOVE.L (d8,An,Xn),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(0);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2178_0)(uae_u32 opcode) /* MOVE.L (xxx).W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2179_0)(uae_u32 opcode) /* MOVE.L (xxx).L,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(6);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_217a_0)(uae_u32 opcode) /* MOVE.L (d16,PC),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_217b_0)(uae_u32 opcode) /* MOVE.L (d8,PC,Xn),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(0);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_217c_0)(uae_u32 opcode) /* MOVE.L #<data>.L,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(6);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2180_0)(uae_u32 opcode) /* MOVE.L Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2188_0)(uae_u32 opcode) /* MOVE.L An,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2190_0)(uae_u32 opcode) /* MOVE.L (An),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2198_0)(uae_u32 opcode) /* MOVE.L (An)+,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21a0_0)(uae_u32 opcode) /* MOVE.L -(An),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21a8_0)(uae_u32 opcode) /* MOVE.L (d16,An),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21b0_0)(uae_u32 opcode) /* MOVE.L (d8,An,Xn),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21b8_0)(uae_u32 opcode) /* MOVE.L (xxx).W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21b9_0)(uae_u32 opcode) /* MOVE.L (xxx).L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{m68k_incpc(6);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21ba_0)(uae_u32 opcode) /* MOVE.L (d16,PC),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21bb_0)(uae_u32 opcode) /* MOVE.L (d8,PC,Xn),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n{{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21bc_0)(uae_u32 opcode) /* MOVE.L #<data>.L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{m68k_incpc(6);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21c0_0)(uae_u32 opcode) /* MOVE.L Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21c8_0)(uae_u32 opcode) /* MOVE.L An,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21d0_0)(uae_u32 opcode) /* MOVE.L (An),(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21d8_0)(uae_u32 opcode) /* MOVE.L (An)+,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21e0_0)(uae_u32 opcode) /* MOVE.L -(An),(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21e8_0)(uae_u32 opcode) /* MOVE.L (d16,An),(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21f0_0)(uae_u32 opcode) /* MOVE.L (d8,An,Xn),(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(0);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21f8_0)(uae_u32 opcode) /* MOVE.L (xxx).W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21f9_0)(uae_u32 opcode) /* MOVE.L (xxx).L,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(6);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21fa_0)(uae_u32 opcode) /* MOVE.L (d16,PC),(xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21fb_0)(uae_u32 opcode) /* MOVE.L (d8,PC,Xn),(xxx).W */\n{\n\tcpuop_begin();\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(0);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21fc_0)(uae_u32 opcode) /* MOVE.L #<data>.L,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(6);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_23c0_0)(uae_u32 opcode) /* MOVE.L Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_23c8_0)(uae_u32 opcode) /* MOVE.L An,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_23d0_0)(uae_u32 opcode) /* MOVE.L (An),(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = get_ilong(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_23d8_0)(uae_u32 opcode) /* MOVE.L (An)+,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuaecptr dsta = get_ilong(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_23e0_0)(uae_u32 opcode) /* MOVE.L -(An),(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = get_ilong(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_23e8_0)(uae_u32 opcode) /* MOVE.L (d16,An),(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = get_ilong(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_23f0_0)(uae_u32 opcode) /* MOVE.L (d8,An,Xn),(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = get_ilong(0);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_23f8_0)(uae_u32 opcode) /* MOVE.L (xxx).W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = get_ilong(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_23f9_0)(uae_u32 opcode) /* MOVE.L (xxx).L,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = get_ilong(6);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(10);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_23fa_0)(uae_u32 opcode) /* MOVE.L (d16,PC),(xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = get_ilong(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_23fb_0)(uae_u32 opcode) /* MOVE.L (d8,PC,Xn),(xxx).L */\n{\n\tcpuop_begin();\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = get_ilong(0);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_23fc_0)(uae_u32 opcode) /* MOVE.L #<data>.L,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = get_ilong(6);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(10);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3000_0)(uae_u32 opcode) /* MOVE.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3008_0)(uae_u32 opcode) /* MOVE.W An,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_areg(regs, srcreg);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3010_0)(uae_u32 opcode) /* MOVE.W (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3018_0)(uae_u32 opcode) /* MOVE.W (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3020_0)(uae_u32 opcode) /* MOVE.W -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3028_0)(uae_u32 opcode) /* MOVE.W (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3030_0)(uae_u32 opcode) /* MOVE.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3038_0)(uae_u32 opcode) /* MOVE.W (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3039_0)(uae_u32 opcode) /* MOVE.W (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_303a_0)(uae_u32 opcode) /* MOVE.W (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_303b_0)(uae_u32 opcode) /* MOVE.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_303c_0)(uae_u32 opcode) /* MOVE.W #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_3040_0)(uae_u32 opcode) /* MOVEA.W Dn,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_u32 val = (uae_s32)(uae_s16)src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_3048_0)(uae_u32 opcode) /* MOVEA.W An,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_areg(regs, srcreg);\n{\tuae_u32 val = (uae_s32)(uae_s16)src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_3050_0)(uae_u32 opcode) /* MOVEA.W (An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 val = (uae_s32)(uae_s16)src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_3058_0)(uae_u32 opcode) /* MOVEA.W (An)+,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_u32 val = (uae_s32)(uae_s16)src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_3060_0)(uae_u32 opcode) /* MOVEA.W -(An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_u32 val = (uae_s32)(uae_s16)src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_3068_0)(uae_u32 opcode) /* MOVEA.W (d16,An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 val = (uae_s32)(uae_s16)src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_3070_0)(uae_u32 opcode) /* MOVEA.W (d8,An,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 val = (uae_s32)(uae_s16)src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_3078_0)(uae_u32 opcode) /* MOVEA.W (xxx).W,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 val = (uae_s32)(uae_s16)src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_3079_0)(uae_u32 opcode) /* MOVEA.W (xxx).L,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 val = (uae_s32)(uae_s16)src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_307a_0)(uae_u32 opcode) /* MOVEA.W (d16,PC),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 val = (uae_s32)(uae_s16)src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_307b_0)(uae_u32 opcode) /* MOVEA.W (d8,PC,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 val = (uae_s32)(uae_s16)src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_307c_0)(uae_u32 opcode) /* MOVEA.W #<data>.W,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_u32 val = (uae_s32)(uae_s16)src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_3080_0)(uae_u32 opcode) /* MOVE.W Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3088_0)(uae_u32 opcode) /* MOVE.W An,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_areg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3090_0)(uae_u32 opcode) /* MOVE.W (An),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3098_0)(uae_u32 opcode) /* MOVE.W (An)+,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30a0_0)(uae_u32 opcode) /* MOVE.W -(An),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30a8_0)(uae_u32 opcode) /* MOVE.W (d16,An),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30b0_0)(uae_u32 opcode) /* MOVE.W (d8,An,Xn),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30b8_0)(uae_u32 opcode) /* MOVE.W (xxx).W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30b9_0)(uae_u32 opcode) /* MOVE.W (xxx).L,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30ba_0)(uae_u32 opcode) /* MOVE.W (d16,PC),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30bb_0)(uae_u32 opcode) /* MOVE.W (d8,PC,Xn),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30bc_0)(uae_u32 opcode) /* MOVE.W #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30c0_0)(uae_u32 opcode) /* MOVE.W Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 2;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30c8_0)(uae_u32 opcode) /* MOVE.W An,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_areg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 2;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30d0_0)(uae_u32 opcode) /* MOVE.W (An),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 2;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30d8_0)(uae_u32 opcode) /* MOVE.W (An)+,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 2;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30e0_0)(uae_u32 opcode) /* MOVE.W -(An),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 2;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30e8_0)(uae_u32 opcode) /* MOVE.W (d16,An),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 2;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30f0_0)(uae_u32 opcode) /* MOVE.W (d8,An,Xn),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 2;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30f8_0)(uae_u32 opcode) /* MOVE.W (xxx).W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 2;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30f9_0)(uae_u32 opcode) /* MOVE.W (xxx).L,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 2;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30fa_0)(uae_u32 opcode) /* MOVE.W (d16,PC),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 2;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30fb_0)(uae_u32 opcode) /* MOVE.W (d8,PC,Xn),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 2;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30fc_0)(uae_u32 opcode) /* MOVE.W #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 2;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3100_0)(uae_u32 opcode) /* MOVE.W Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3108_0)(uae_u32 opcode) /* MOVE.W An,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_areg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3110_0)(uae_u32 opcode) /* MOVE.W (An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3118_0)(uae_u32 opcode) /* MOVE.W (An)+,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3120_0)(uae_u32 opcode) /* MOVE.W -(An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3128_0)(uae_u32 opcode) /* MOVE.W (d16,An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3130_0)(uae_u32 opcode) /* MOVE.W (d8,An,Xn),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3138_0)(uae_u32 opcode) /* MOVE.W (xxx).W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3139_0)(uae_u32 opcode) /* MOVE.W (xxx).L,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_313a_0)(uae_u32 opcode) /* MOVE.W (d16,PC),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_313b_0)(uae_u32 opcode) /* MOVE.W (d8,PC,Xn),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_313c_0)(uae_u32 opcode) /* MOVE.W #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3140_0)(uae_u32 opcode) /* MOVE.W Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3148_0)(uae_u32 opcode) /* MOVE.W An,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_areg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3150_0)(uae_u32 opcode) /* MOVE.W (An),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3158_0)(uae_u32 opcode) /* MOVE.W (An)+,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3160_0)(uae_u32 opcode) /* MOVE.W -(An),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3168_0)(uae_u32 opcode) /* MOVE.W (d16,An),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3170_0)(uae_u32 opcode) /* MOVE.W (d8,An,Xn),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(0);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3178_0)(uae_u32 opcode) /* MOVE.W (xxx).W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3179_0)(uae_u32 opcode) /* MOVE.W (xxx).L,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(6);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_317a_0)(uae_u32 opcode) /* MOVE.W (d16,PC),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_317b_0)(uae_u32 opcode) /* MOVE.W (d8,PC,Xn),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(0);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_317c_0)(uae_u32 opcode) /* MOVE.W #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3180_0)(uae_u32 opcode) /* MOVE.W Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3188_0)(uae_u32 opcode) /* MOVE.W An,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_areg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3190_0)(uae_u32 opcode) /* MOVE.W (An),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3198_0)(uae_u32 opcode) /* MOVE.W (An)+,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31a0_0)(uae_u32 opcode) /* MOVE.W -(An),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31a8_0)(uae_u32 opcode) /* MOVE.W (d16,An),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31b0_0)(uae_u32 opcode) /* MOVE.W (d8,An,Xn),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31b8_0)(uae_u32 opcode) /* MOVE.W (xxx).W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31b9_0)(uae_u32 opcode) /* MOVE.W (xxx).L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{m68k_incpc(6);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31ba_0)(uae_u32 opcode) /* MOVE.W (d16,PC),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31bb_0)(uae_u32 opcode) /* MOVE.W (d8,PC,Xn),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31bc_0)(uae_u32 opcode) /* MOVE.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31c0_0)(uae_u32 opcode) /* MOVE.W Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31c8_0)(uae_u32 opcode) /* MOVE.W An,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_areg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31d0_0)(uae_u32 opcode) /* MOVE.W (An),(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31d8_0)(uae_u32 opcode) /* MOVE.W (An)+,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31e0_0)(uae_u32 opcode) /* MOVE.W -(An),(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31e8_0)(uae_u32 opcode) /* MOVE.W (d16,An),(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31f0_0)(uae_u32 opcode) /* MOVE.W (d8,An,Xn),(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(0);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31f8_0)(uae_u32 opcode) /* MOVE.W (xxx).W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31f9_0)(uae_u32 opcode) /* MOVE.W (xxx).L,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(6);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31fa_0)(uae_u32 opcode) /* MOVE.W (d16,PC),(xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31fb_0)(uae_u32 opcode) /* MOVE.W (d8,PC,Xn),(xxx).W */\n{\n\tcpuop_begin();\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(0);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31fc_0)(uae_u32 opcode) /* MOVE.W #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_33c0_0)(uae_u32 opcode) /* MOVE.W Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_33c8_0)(uae_u32 opcode) /* MOVE.W An,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_areg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_33d0_0)(uae_u32 opcode) /* MOVE.W (An),(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = get_ilong(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_33d8_0)(uae_u32 opcode) /* MOVE.W (An)+,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuaecptr dsta = get_ilong(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_33e0_0)(uae_u32 opcode) /* MOVE.W -(An),(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = get_ilong(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_33e8_0)(uae_u32 opcode) /* MOVE.W (d16,An),(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = get_ilong(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_33f0_0)(uae_u32 opcode) /* MOVE.W (d8,An,Xn),(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = get_ilong(0);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_33f8_0)(uae_u32 opcode) /* MOVE.W (xxx).W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = get_ilong(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_33f9_0)(uae_u32 opcode) /* MOVE.W (xxx).L,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = get_ilong(6);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(10);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_33fa_0)(uae_u32 opcode) /* MOVE.W (d16,PC),(xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = get_ilong(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_33fb_0)(uae_u32 opcode) /* MOVE.W (d8,PC,Xn),(xxx).L */\n{\n\tcpuop_begin();\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = get_ilong(0);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_33fc_0)(uae_u32 opcode) /* MOVE.W #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4000_0)(uae_u32 opcode) /* NEGX.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(0)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((newv) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4010_0)(uae_u32 opcode) /* NEGX.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(0)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tput_byte(srca,newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4018_0)(uae_u32 opcode) /* NEGX.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(0)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tput_byte(srca,newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4020_0)(uae_u32 opcode) /* NEGX.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(0)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tput_byte(srca,newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4028_0)(uae_u32 opcode) /* NEGX.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(0)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tput_byte(srca,newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4030_0)(uae_u32 opcode) /* NEGX.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(0)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tput_byte(srca,newv);\n}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4038_0)(uae_u32 opcode) /* NEGX.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(0)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tput_byte(srca,newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4039_0)(uae_u32 opcode) /* NEGX.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(0)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tput_byte(srca,newv);\n}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4040_0)(uae_u32 opcode) /* NEGX.W Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(0)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s16)(newv)) == 0));\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4050_0)(uae_u32 opcode) /* NEGX.W (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(0)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s16)(newv)) == 0));\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tput_word(srca,newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4058_0)(uae_u32 opcode) /* NEGX.W (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(0)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s16)(newv)) == 0));\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tput_word(srca,newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4060_0)(uae_u32 opcode) /* NEGX.W -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(0)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s16)(newv)) == 0));\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tput_word(srca,newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4068_0)(uae_u32 opcode) /* NEGX.W (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(0)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s16)(newv)) == 0));\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tput_word(srca,newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4070_0)(uae_u32 opcode) /* NEGX.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(0)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s16)(newv)) == 0));\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tput_word(srca,newv);\n}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4078_0)(uae_u32 opcode) /* NEGX.W (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(0)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s16)(newv)) == 0));\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tput_word(srca,newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4079_0)(uae_u32 opcode) /* NEGX.W (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(0)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s16)(newv)) == 0));\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tput_word(srca,newv);\n}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4080_0)(uae_u32 opcode) /* NEGX.L Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(0)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s32)(newv)) == 0));\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, srcreg) = (newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4090_0)(uae_u32 opcode) /* NEGX.L (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(0)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s32)(newv)) == 0));\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tput_long(srca,newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4098_0)(uae_u32 opcode) /* NEGX.L (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(0)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s32)(newv)) == 0));\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tput_long(srca,newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_40a0_0)(uae_u32 opcode) /* NEGX.L -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(0)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s32)(newv)) == 0));\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tput_long(srca,newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_40a8_0)(uae_u32 opcode) /* NEGX.L (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(0)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s32)(newv)) == 0));\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tput_long(srca,newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_40b0_0)(uae_u32 opcode) /* NEGX.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(0)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s32)(newv)) == 0));\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tput_long(srca,newv);\n}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_40b8_0)(uae_u32 opcode) /* NEGX.L (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(0)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s32)(newv)) == 0));\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tput_long(srca,newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_40b9_0)(uae_u32 opcode) /* NEGX.L (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(0)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s32)(newv)) == 0));\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tput_long(srca,newv);\n}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_40c0_0)(uae_u32 opcode) /* MVSR2.W Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel645; }\n{{\tMakeSR();\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | ((regs.sr) & 0xffff);\n}}}m68k_incpc(2);\nendlabel645: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_40d0_0)(uae_u32 opcode) /* MVSR2.W (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel646; }\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tMakeSR();\n\tput_word(srca,regs.sr);\n}}}m68k_incpc(2);\nendlabel646: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_40d8_0)(uae_u32 opcode) /* MVSR2.W (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel647; }\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += 2;\n\tMakeSR();\n\tput_word(srca,regs.sr);\n}}}m68k_incpc(2);\nendlabel647: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_40e0_0)(uae_u32 opcode) /* MVSR2.W -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel648; }\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n\tm68k_areg (regs, srcreg) = srca;\n\tMakeSR();\n\tput_word(srca,regs.sr);\n}}}m68k_incpc(2);\nendlabel648: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_40e8_0)(uae_u32 opcode) /* MVSR2.W (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel649; }\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n\tMakeSR();\n\tput_word(srca,regs.sr);\n}}}m68k_incpc(4);\nendlabel649: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_40f0_0)(uae_u32 opcode) /* MVSR2.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel650; }\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n\tMakeSR();\n\tput_word(srca,regs.sr);\n}}}}endlabel650: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_40f8_0)(uae_u32 opcode) /* MVSR2.W (xxx).W */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel651; }\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n\tMakeSR();\n\tput_word(srca,regs.sr);\n}}}m68k_incpc(4);\nendlabel651: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_40f9_0)(uae_u32 opcode) /* MVSR2.W (xxx).L */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel652; }\n{{\tuaecptr srca = get_ilong(2);\n\tMakeSR();\n\tput_word(srca,regs.sr);\n}}}m68k_incpc(6);\nendlabel652: ;\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_4100_0)(uae_u32 opcode) /* CHK.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel653; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel653; }\n}}}m68k_incpc(2);\nendlabel653: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4110_0)(uae_u32 opcode) /* CHK.L (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel654; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel654; }\n}}}}m68k_incpc(2);\nendlabel654: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4118_0)(uae_u32 opcode) /* CHK.L (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel655; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel655; }\n}}}}m68k_incpc(2);\nendlabel655: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4120_0)(uae_u32 opcode) /* CHK.L -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel656; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel656; }\n}}}}m68k_incpc(2);\nendlabel656: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4128_0)(uae_u32 opcode) /* CHK.L (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel657; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel657; }\n}}}}m68k_incpc(4);\nendlabel657: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4130_0)(uae_u32 opcode) /* CHK.L (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel658; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel658; }\n}}}}}endlabel658: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4138_0)(uae_u32 opcode) /* CHK.L (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel659; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel659; }\n}}}}m68k_incpc(4);\nendlabel659: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4139_0)(uae_u32 opcode) /* CHK.L (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel660; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel660; }\n}}}}m68k_incpc(6);\nendlabel660: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_413a_0)(uae_u32 opcode) /* CHK.L (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel661; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel661; }\n}}}}m68k_incpc(4);\nendlabel661: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_413b_0)(uae_u32 opcode) /* CHK.L (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel662; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel662; }\n}}}}}endlabel662: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_413c_0)(uae_u32 opcode) /* CHK.L #<data>.L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s32 src = get_ilong(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel663; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel663; }\n}}}m68k_incpc(6);\nendlabel663: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4180_0)(uae_u32 opcode) /* CHK.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel664; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel664; }\n}}}m68k_incpc(2);\nendlabel664: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4190_0)(uae_u32 opcode) /* CHK.W (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel665; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel665; }\n}}}}m68k_incpc(2);\nendlabel665: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4198_0)(uae_u32 opcode) /* CHK.W (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel666; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel666; }\n}}}}m68k_incpc(2);\nendlabel666: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_41a0_0)(uae_u32 opcode) /* CHK.W -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel667; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel667; }\n}}}}m68k_incpc(2);\nendlabel667: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_41a8_0)(uae_u32 opcode) /* CHK.W (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel668; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel668; }\n}}}}m68k_incpc(4);\nendlabel668: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_41b0_0)(uae_u32 opcode) /* CHK.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel669; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel669; }\n}}}}}endlabel669: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_41b8_0)(uae_u32 opcode) /* CHK.W (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel670; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel670; }\n}}}}m68k_incpc(4);\nendlabel670: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_41b9_0)(uae_u32 opcode) /* CHK.W (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel671; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel671; }\n}}}}m68k_incpc(6);\nendlabel671: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_41ba_0)(uae_u32 opcode) /* CHK.W (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel672; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel672; }\n}}}}m68k_incpc(4);\nendlabel672: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_41bb_0)(uae_u32 opcode) /* CHK.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel673; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel673; }\n}}}}}endlabel673: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_41bc_0)(uae_u32 opcode) /* CHK.W #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 src = get_iword(2);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel674; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel674; }\n}}}m68k_incpc(4);\nendlabel674: ;\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_41d0_0)(uae_u32 opcode) /* LEA.L (An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tm68k_areg(regs, dstreg) = (srca);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_41e8_0)(uae_u32 opcode) /* LEA.L (d16,An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tm68k_areg(regs, dstreg) = (srca);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_41f0_0)(uae_u32 opcode) /* LEA.L (d8,An,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tm68k_areg(regs, dstreg) = (srca);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_41f8_0)(uae_u32 opcode) /* LEA.L (xxx).W,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tm68k_areg(regs, dstreg) = (srca);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_41f9_0)(uae_u32 opcode) /* LEA.L (xxx).L,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tm68k_areg(regs, dstreg) = (srca);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_41fa_0)(uae_u32 opcode) /* LEA.L (d16,PC),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tm68k_areg(regs, dstreg) = (srca);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_41fb_0)(uae_u32 opcode) /* LEA.L (d8,PC,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tm68k_areg(regs, dstreg) = (srca);\n}}}}\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_4200_0)(uae_u32 opcode) /* CLR.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(0)) == 0);\n\tSET_NFLG (((uae_s8)(0)) < 0);\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((0) & 0xff);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4210_0)(uae_u32 opcode) /* CLR.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(0)) == 0);\n\tSET_NFLG (((uae_s8)(0)) < 0);\n\tput_byte(srca,0);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4218_0)(uae_u32 opcode) /* CLR.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(0)) == 0);\n\tSET_NFLG (((uae_s8)(0)) < 0);\n\tput_byte(srca,0);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4220_0)(uae_u32 opcode) /* CLR.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n\tm68k_areg (regs, srcreg) = srca;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(0)) == 0);\n\tSET_NFLG (((uae_s8)(0)) < 0);\n\tput_byte(srca,0);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4228_0)(uae_u32 opcode) /* CLR.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(0)) == 0);\n\tSET_NFLG (((uae_s8)(0)) < 0);\n\tput_byte(srca,0);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4230_0)(uae_u32 opcode) /* CLR.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(0)) == 0);\n\tSET_NFLG (((uae_s8)(0)) < 0);\n\tput_byte(srca,0);\n}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4238_0)(uae_u32 opcode) /* CLR.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(0)) == 0);\n\tSET_NFLG (((uae_s8)(0)) < 0);\n\tput_byte(srca,0);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4239_0)(uae_u32 opcode) /* CLR.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(0)) == 0);\n\tSET_NFLG (((uae_s8)(0)) < 0);\n\tput_byte(srca,0);\n}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4240_0)(uae_u32 opcode) /* CLR.W Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(0)) == 0);\n\tSET_NFLG (((uae_s16)(0)) < 0);\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | ((0) & 0xffff);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4250_0)(uae_u32 opcode) /* CLR.W (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(0)) == 0);\n\tSET_NFLG (((uae_s16)(0)) < 0);\n\tput_word(srca,0);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4258_0)(uae_u32 opcode) /* CLR.W (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += 2;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(0)) == 0);\n\tSET_NFLG (((uae_s16)(0)) < 0);\n\tput_word(srca,0);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4260_0)(uae_u32 opcode) /* CLR.W -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n\tm68k_areg (regs, srcreg) = srca;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(0)) == 0);\n\tSET_NFLG (((uae_s16)(0)) < 0);\n\tput_word(srca,0);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4268_0)(uae_u32 opcode) /* CLR.W (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(0)) == 0);\n\tSET_NFLG (((uae_s16)(0)) < 0);\n\tput_word(srca,0);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4270_0)(uae_u32 opcode) /* CLR.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(0)) == 0);\n\tSET_NFLG (((uae_s16)(0)) < 0);\n\tput_word(srca,0);\n}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4278_0)(uae_u32 opcode) /* CLR.W (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(0)) == 0);\n\tSET_NFLG (((uae_s16)(0)) < 0);\n\tput_word(srca,0);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4279_0)(uae_u32 opcode) /* CLR.W (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(0)) == 0);\n\tSET_NFLG (((uae_s16)(0)) < 0);\n\tput_word(srca,0);\n}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4280_0)(uae_u32 opcode) /* CLR.L Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(0)) == 0);\n\tSET_NFLG (((uae_s32)(0)) < 0);\n\tm68k_dreg(regs, srcreg) = (0);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4290_0)(uae_u32 opcode) /* CLR.L (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(0)) == 0);\n\tSET_NFLG (((uae_s32)(0)) < 0);\n\tput_long(srca,0);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4298_0)(uae_u32 opcode) /* CLR.L (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += 4;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(0)) == 0);\n\tSET_NFLG (((uae_s32)(0)) < 0);\n\tput_long(srca,0);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\n#endif\n\n#ifdef PART_4\nvoid REGPARAM2 CPUFUNC(op_42a0_0)(uae_u32 opcode) /* CLR.L -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n\tm68k_areg (regs, srcreg) = srca;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(0)) == 0);\n\tSET_NFLG (((uae_s32)(0)) < 0);\n\tput_long(srca,0);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_42a8_0)(uae_u32 opcode) /* CLR.L (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(0)) == 0);\n\tSET_NFLG (((uae_s32)(0)) < 0);\n\tput_long(srca,0);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_42b0_0)(uae_u32 opcode) /* CLR.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(0)) == 0);\n\tSET_NFLG (((uae_s32)(0)) < 0);\n\tput_long(srca,0);\n}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_42b8_0)(uae_u32 opcode) /* CLR.L (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(0)) == 0);\n\tSET_NFLG (((uae_s32)(0)) < 0);\n\tput_long(srca,0);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_42b9_0)(uae_u32 opcode) /* CLR.L (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(0)) == 0);\n\tSET_NFLG (((uae_s32)(0)) < 0);\n\tput_long(srca,0);\n}}m68k_incpc(6);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_42c0_0)(uae_u32 opcode) /* MVSR2.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tMakeSR();\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | ((regs.sr & 0xff) & 0xffff);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_42d0_0)(uae_u32 opcode) /* MVSR2.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tMakeSR();\n\tput_word(srca,regs.sr & 0xff);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_42d8_0)(uae_u32 opcode) /* MVSR2.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += 2;\n\tMakeSR();\n\tput_word(srca,regs.sr & 0xff);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_42e0_0)(uae_u32 opcode) /* MVSR2.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n\tm68k_areg (regs, srcreg) = srca;\n\tMakeSR();\n\tput_word(srca,regs.sr & 0xff);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_42e8_0)(uae_u32 opcode) /* MVSR2.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n\tMakeSR();\n\tput_word(srca,regs.sr & 0xff);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_42f0_0)(uae_u32 opcode) /* MVSR2.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n\tMakeSR();\n\tput_word(srca,regs.sr & 0xff);\n}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_42f8_0)(uae_u32 opcode) /* MVSR2.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n\tMakeSR();\n\tput_word(srca,regs.sr & 0xff);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_42f9_0)(uae_u32 opcode) /* MVSR2.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n\tMakeSR();\n\tput_word(srca,regs.sr & 0xff);\n}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_4400_0)(uae_u32 opcode) /* NEG.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{{uae_u32 dst = ((uae_s8)(0)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(0)) < 0;\n\tint flgn = ((uae_s8)(dst)) < 0;\n\tSET_ZFLG (((uae_s8)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((dst) & 0xff);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4410_0)(uae_u32 opcode) /* NEG.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{{uae_u32 dst = ((uae_s8)(0)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(0)) < 0;\n\tint flgn = ((uae_s8)(dst)) < 0;\n\tSET_ZFLG (((uae_s8)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(srca,dst);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4418_0)(uae_u32 opcode) /* NEG.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{{uae_u32 dst = ((uae_s8)(0)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(0)) < 0;\n\tint flgn = ((uae_s8)(dst)) < 0;\n\tSET_ZFLG (((uae_s8)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(srca,dst);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4420_0)(uae_u32 opcode) /* NEG.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{{uae_u32 dst = ((uae_s8)(0)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(0)) < 0;\n\tint flgn = ((uae_s8)(dst)) < 0;\n\tSET_ZFLG (((uae_s8)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(srca,dst);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4428_0)(uae_u32 opcode) /* NEG.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{{uae_u32 dst = ((uae_s8)(0)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(0)) < 0;\n\tint flgn = ((uae_s8)(dst)) < 0;\n\tSET_ZFLG (((uae_s8)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(srca,dst);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4430_0)(uae_u32 opcode) /* NEG.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n{{uae_u32 dst = ((uae_s8)(0)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(0)) < 0;\n\tint flgn = ((uae_s8)(dst)) < 0;\n\tSET_ZFLG (((uae_s8)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(srca,dst);\n}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4438_0)(uae_u32 opcode) /* NEG.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{{uae_u32 dst = ((uae_s8)(0)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(0)) < 0;\n\tint flgn = ((uae_s8)(dst)) < 0;\n\tSET_ZFLG (((uae_s8)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(srca,dst);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4439_0)(uae_u32 opcode) /* NEG.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{{uae_u32 dst = ((uae_s8)(0)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(0)) < 0;\n\tint flgn = ((uae_s8)(dst)) < 0;\n\tSET_ZFLG (((uae_s8)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(srca,dst);\n}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4440_0)(uae_u32 opcode) /* NEG.W Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{{uae_u32 dst = ((uae_s16)(0)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(0)) < 0;\n\tint flgn = ((uae_s16)(dst)) < 0;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | ((dst) & 0xffff);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4450_0)(uae_u32 opcode) /* NEG.W (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{{uae_u32 dst = ((uae_s16)(0)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(0)) < 0;\n\tint flgn = ((uae_s16)(dst)) < 0;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(srca,dst);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4458_0)(uae_u32 opcode) /* NEG.W (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{{uae_u32 dst = ((uae_s16)(0)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(0)) < 0;\n\tint flgn = ((uae_s16)(dst)) < 0;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(srca,dst);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4460_0)(uae_u32 opcode) /* NEG.W -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{{uae_u32 dst = ((uae_s16)(0)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(0)) < 0;\n\tint flgn = ((uae_s16)(dst)) < 0;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(srca,dst);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4468_0)(uae_u32 opcode) /* NEG.W (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{{uae_u32 dst = ((uae_s16)(0)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(0)) < 0;\n\tint flgn = ((uae_s16)(dst)) < 0;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(srca,dst);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4470_0)(uae_u32 opcode) /* NEG.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{{uae_u32 dst = ((uae_s16)(0)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(0)) < 0;\n\tint flgn = ((uae_s16)(dst)) < 0;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(srca,dst);\n}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4478_0)(uae_u32 opcode) /* NEG.W (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{{uae_u32 dst = ((uae_s16)(0)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(0)) < 0;\n\tint flgn = ((uae_s16)(dst)) < 0;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(srca,dst);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4479_0)(uae_u32 opcode) /* NEG.W (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{{uae_u32 dst = ((uae_s16)(0)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(0)) < 0;\n\tint flgn = ((uae_s16)(dst)) < 0;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(srca,dst);\n}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4480_0)(uae_u32 opcode) /* NEG.L Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{{uae_u32 dst = ((uae_s32)(0)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(0)) < 0;\n\tint flgn = ((uae_s32)(dst)) < 0;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, srcreg) = (dst);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4490_0)(uae_u32 opcode) /* NEG.L (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{{uae_u32 dst = ((uae_s32)(0)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(0)) < 0;\n\tint flgn = ((uae_s32)(dst)) < 0;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(srca,dst);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4498_0)(uae_u32 opcode) /* NEG.L (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{{uae_u32 dst = ((uae_s32)(0)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(0)) < 0;\n\tint flgn = ((uae_s32)(dst)) < 0;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(srca,dst);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44a0_0)(uae_u32 opcode) /* NEG.L -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{{uae_u32 dst = ((uae_s32)(0)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(0)) < 0;\n\tint flgn = ((uae_s32)(dst)) < 0;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(srca,dst);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44a8_0)(uae_u32 opcode) /* NEG.L (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{{uae_u32 dst = ((uae_s32)(0)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(0)) < 0;\n\tint flgn = ((uae_s32)(dst)) < 0;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(srca,dst);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44b0_0)(uae_u32 opcode) /* NEG.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{{uae_u32 dst = ((uae_s32)(0)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(0)) < 0;\n\tint flgn = ((uae_s32)(dst)) < 0;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(srca,dst);\n}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44b8_0)(uae_u32 opcode) /* NEG.L (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{{uae_u32 dst = ((uae_s32)(0)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(0)) < 0;\n\tint flgn = ((uae_s32)(dst)) < 0;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(srca,dst);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44b9_0)(uae_u32 opcode) /* NEG.L (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{{uae_u32 dst = ((uae_s32)(0)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(0)) < 0;\n\tint flgn = ((uae_s32)(dst)) < 0;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(srca,dst);\n}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44c0_0)(uae_u32 opcode) /* MV2SR.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n\tMakeSR();\n\tregs.sr &= 0xFF00;\n\tregs.sr |= src & 0xFF;\n\tMakeFromSR();\n}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44d0_0)(uae_u32 opcode) /* MV2SR.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tMakeSR();\n\tregs.sr &= 0xFF00;\n\tregs.sr |= src & 0xFF;\n\tMakeFromSR();\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44d8_0)(uae_u32 opcode) /* MV2SR.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n\tMakeSR();\n\tregs.sr &= 0xFF00;\n\tregs.sr |= src & 0xFF;\n\tMakeFromSR();\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44e0_0)(uae_u32 opcode) /* MV2SR.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n\tMakeSR();\n\tregs.sr &= 0xFF00;\n\tregs.sr |= src & 0xFF;\n\tMakeFromSR();\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44e8_0)(uae_u32 opcode) /* MV2SR.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n\tMakeSR();\n\tregs.sr &= 0xFF00;\n\tregs.sr |= src & 0xFF;\n\tMakeFromSR();\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44f0_0)(uae_u32 opcode) /* MV2SR.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n\tMakeSR();\n\tregs.sr &= 0xFF00;\n\tregs.sr |= src & 0xFF;\n\tMakeFromSR();\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44f8_0)(uae_u32 opcode) /* MV2SR.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n\tMakeSR();\n\tregs.sr &= 0xFF00;\n\tregs.sr |= src & 0xFF;\n\tMakeFromSR();\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44f9_0)(uae_u32 opcode) /* MV2SR.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n\tMakeSR();\n\tregs.sr &= 0xFF00;\n\tregs.sr |= src & 0xFF;\n\tMakeFromSR();\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44fa_0)(uae_u32 opcode) /* MV2SR.B (d16,PC) */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n\tMakeSR();\n\tregs.sr &= 0xFF00;\n\tregs.sr |= src & 0xFF;\n\tMakeFromSR();\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44fb_0)(uae_u32 opcode) /* MV2SR.B (d8,PC,Xn) */\n{\n\tcpuop_begin();\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n\tMakeSR();\n\tregs.sr &= 0xFF00;\n\tregs.sr |= src & 0xFF;\n\tMakeFromSR();\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44fc_0)(uae_u32 opcode) /* MV2SR.B #<data>.B */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n\tMakeSR();\n\tregs.sr &= 0xFF00;\n\tregs.sr |= src & 0xFF;\n\tMakeFromSR();\n}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4600_0)(uae_u32 opcode) /* NOT.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(dst)) == 0);\n\tSET_NFLG (((uae_s8)(dst)) < 0);\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((dst) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4610_0)(uae_u32 opcode) /* NOT.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(dst)) == 0);\n\tSET_NFLG (((uae_s8)(dst)) < 0);\n\tput_byte(srca,dst);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4618_0)(uae_u32 opcode) /* NOT.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(dst)) == 0);\n\tSET_NFLG (((uae_s8)(dst)) < 0);\n\tput_byte(srca,dst);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4620_0)(uae_u32 opcode) /* NOT.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(dst)) == 0);\n\tSET_NFLG (((uae_s8)(dst)) < 0);\n\tput_byte(srca,dst);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4628_0)(uae_u32 opcode) /* NOT.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(dst)) == 0);\n\tSET_NFLG (((uae_s8)(dst)) < 0);\n\tput_byte(srca,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4630_0)(uae_u32 opcode) /* NOT.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(dst)) == 0);\n\tSET_NFLG (((uae_s8)(dst)) < 0);\n\tput_byte(srca,dst);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4638_0)(uae_u32 opcode) /* NOT.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(dst)) == 0);\n\tSET_NFLG (((uae_s8)(dst)) < 0);\n\tput_byte(srca,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4639_0)(uae_u32 opcode) /* NOT.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(dst)) == 0);\n\tSET_NFLG (((uae_s8)(dst)) < 0);\n\tput_byte(srca,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4640_0)(uae_u32 opcode) /* NOT.W Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_NFLG (((uae_s16)(dst)) < 0);\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | ((dst) & 0xffff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4650_0)(uae_u32 opcode) /* NOT.W (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_NFLG (((uae_s16)(dst)) < 0);\n\tput_word(srca,dst);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4658_0)(uae_u32 opcode) /* NOT.W (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_NFLG (((uae_s16)(dst)) < 0);\n\tput_word(srca,dst);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4660_0)(uae_u32 opcode) /* NOT.W -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_NFLG (((uae_s16)(dst)) < 0);\n\tput_word(srca,dst);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4668_0)(uae_u32 opcode) /* NOT.W (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_NFLG (((uae_s16)(dst)) < 0);\n\tput_word(srca,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4670_0)(uae_u32 opcode) /* NOT.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_NFLG (((uae_s16)(dst)) < 0);\n\tput_word(srca,dst);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4678_0)(uae_u32 opcode) /* NOT.W (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_NFLG (((uae_s16)(dst)) < 0);\n\tput_word(srca,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4679_0)(uae_u32 opcode) /* NOT.W (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_NFLG (((uae_s16)(dst)) < 0);\n\tput_word(srca,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4680_0)(uae_u32 opcode) /* NOT.L Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_NFLG (((uae_s32)(dst)) < 0);\n\tm68k_dreg(regs, srcreg) = (dst);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4690_0)(uae_u32 opcode) /* NOT.L (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_NFLG (((uae_s32)(dst)) < 0);\n\tput_long(srca,dst);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4698_0)(uae_u32 opcode) /* NOT.L (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_NFLG (((uae_s32)(dst)) < 0);\n\tput_long(srca,dst);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46a0_0)(uae_u32 opcode) /* NOT.L -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_NFLG (((uae_s32)(dst)) < 0);\n\tput_long(srca,dst);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46a8_0)(uae_u32 opcode) /* NOT.L (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_NFLG (((uae_s32)(dst)) < 0);\n\tput_long(srca,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46b0_0)(uae_u32 opcode) /* NOT.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_NFLG (((uae_s32)(dst)) < 0);\n\tput_long(srca,dst);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46b8_0)(uae_u32 opcode) /* NOT.L (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_NFLG (((uae_s32)(dst)) < 0);\n\tput_long(srca,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46b9_0)(uae_u32 opcode) /* NOT.L (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_NFLG (((uae_s32)(dst)) < 0);\n\tput_long(srca,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46c0_0)(uae_u32 opcode) /* MV2SR.W Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel773; }\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n\tregs.sr = src;\n\tMakeFromSR();\n}}}m68k_incpc(2);\nendlabel773: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46d0_0)(uae_u32 opcode) /* MV2SR.W (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel774; }\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tregs.sr = src;\n\tMakeFromSR();\n}}}}m68k_incpc(2);\nendlabel774: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46d8_0)(uae_u32 opcode) /* MV2SR.W (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel775; }\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n\tregs.sr = src;\n\tMakeFromSR();\n}}}}m68k_incpc(2);\nendlabel775: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46e0_0)(uae_u32 opcode) /* MV2SR.W -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel776; }\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n\tregs.sr = src;\n\tMakeFromSR();\n}}}}m68k_incpc(2);\nendlabel776: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46e8_0)(uae_u32 opcode) /* MV2SR.W (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel777; }\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n\tregs.sr = src;\n\tMakeFromSR();\n}}}}m68k_incpc(4);\nendlabel777: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46f0_0)(uae_u32 opcode) /* MV2SR.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel778; }\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n\tregs.sr = src;\n\tMakeFromSR();\n}}}}}endlabel778: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46f8_0)(uae_u32 opcode) /* MV2SR.W (xxx).W */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel779; }\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n\tregs.sr = src;\n\tMakeFromSR();\n}}}}m68k_incpc(4);\nendlabel779: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46f9_0)(uae_u32 opcode) /* MV2SR.W (xxx).L */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel780; }\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n\tregs.sr = src;\n\tMakeFromSR();\n}}}}m68k_incpc(6);\nendlabel780: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46fa_0)(uae_u32 opcode) /* MV2SR.W (d16,PC) */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel781; }\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n\tregs.sr = src;\n\tMakeFromSR();\n}}}}m68k_incpc(4);\nendlabel781: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46fb_0)(uae_u32 opcode) /* MV2SR.W (d8,PC,Xn) */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel782; }\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n\tregs.sr = src;\n\tMakeFromSR();\n}}}}}endlabel782: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46fc_0)(uae_u32 opcode) /* MV2SR.W #<data>.W */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel783; }\n{{\tuae_s16 src = get_iword(2);\n\tregs.sr = src;\n\tMakeFromSR();\n}}}m68k_incpc(4);\nendlabel783: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4800_0)(uae_u32 opcode) /* NBCD.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuae_u16 newv_lo = - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = - (src & 0xF0);\n\tuae_u16 newv;\n\tint cflg;\n\tif (newv_lo > 9) { newv_lo -= 6; }\n\tnewv = newv_hi + newv_lo;\n\tcflg = (newv & 0x1F0) > 0x90;\n\tif (cflg) newv -= 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((newv) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4808_0)(uae_u32 opcode) /* LINK.L An,#<data>.L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr olda = m68k_areg(regs, 7) - 4;\n\tm68k_areg (regs, 7) = olda;\n{\tuae_s32 src = m68k_areg(regs, srcreg);\n\tput_long(olda,src);\n\tm68k_areg(regs, srcreg) = (m68k_areg(regs, 7));\n{\tuae_s32 offs = get_ilong(2);\n\tm68k_areg(regs, 7) += offs;\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_4810_0)(uae_u32 opcode) /* NBCD.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u16 newv_lo = - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = - (src & 0xF0);\n\tuae_u16 newv;\n\tint cflg;\n\tif (newv_lo > 9) { newv_lo -= 6; }\n\tnewv = newv_hi + newv_lo;\n\tcflg = (newv & 0x1F0) > 0x90;\n\tif (cflg) newv -= 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tput_byte(srca,newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4818_0)(uae_u32 opcode) /* NBCD.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tuae_u16 newv_lo = - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = - (src & 0xF0);\n\tuae_u16 newv;\n\tint cflg;\n\tif (newv_lo > 9) { newv_lo -= 6; }\n\tnewv = newv_hi + newv_lo;\n\tcflg = (newv & 0x1F0) > 0x90;\n\tif (cflg) newv -= 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tput_byte(srca,newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4820_0)(uae_u32 opcode) /* NBCD.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_u16 newv_lo = - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = - (src & 0xF0);\n\tuae_u16 newv;\n\tint cflg;\n\tif (newv_lo > 9) { newv_lo -= 6; }\n\tnewv = newv_hi + newv_lo;\n\tcflg = (newv & 0x1F0) > 0x90;\n\tif (cflg) newv -= 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tput_byte(srca,newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4828_0)(uae_u32 opcode) /* NBCD.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u16 newv_lo = - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = - (src & 0xF0);\n\tuae_u16 newv;\n\tint cflg;\n\tif (newv_lo > 9) { newv_lo -= 6; }\n\tnewv = newv_hi + newv_lo;\n\tcflg = (newv & 0x1F0) > 0x90;\n\tif (cflg) newv -= 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tput_byte(srca,newv);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4830_0)(uae_u32 opcode) /* NBCD.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u16 newv_lo = - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = - (src & 0xF0);\n\tuae_u16 newv;\n\tint cflg;\n\tif (newv_lo > 9) { newv_lo -= 6; }\n\tnewv = newv_hi + newv_lo;\n\tcflg = (newv & 0x1F0) > 0x90;\n\tif (cflg) newv -= 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tput_byte(srca,newv);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4838_0)(uae_u32 opcode) /* NBCD.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u16 newv_lo = - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = - (src & 0xF0);\n\tuae_u16 newv;\n\tint cflg;\n\tif (newv_lo > 9) { newv_lo -= 6; }\n\tnewv = newv_hi + newv_lo;\n\tcflg = (newv & 0x1F0) > 0x90;\n\tif (cflg) newv -= 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tput_byte(srca,newv);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4839_0)(uae_u32 opcode) /* NBCD.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u16 newv_lo = - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = - (src & 0xF0);\n\tuae_u16 newv;\n\tint cflg;\n\tif (newv_lo > 9) { newv_lo -= 6; }\n\tnewv = newv_hi + newv_lo;\n\tcflg = (newv & 0x1F0) > 0x90;\n\tif (cflg) newv -= 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tput_byte(srca,newv);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4840_0)(uae_u32 opcode) /* SWAP.W Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_u32 dst = ((src >> 16)&0xFFFF) | ((src&0xFFFF)<<16);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_NFLG (((uae_s32)(dst)) < 0);\n\tm68k_dreg(regs, srcreg) = (dst);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4848_0)(uae_u32 opcode) /* BKPT.L #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{m68k_incpc(2);\n\top_illg(opcode);\n}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4850_0)(uae_u32 opcode) /* PEA.L (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, 7) - 4;\n\tm68k_areg (regs, 7) = dsta;\n\tput_long(dsta,srca);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4868_0)(uae_u32 opcode) /* PEA.L (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, 7) - 4;\n\tm68k_areg (regs, 7) = dsta;\n\tput_long(dsta,srca);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4870_0)(uae_u32 opcode) /* PEA.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuaecptr dsta = m68k_areg(regs, 7) - 4;\n\tm68k_areg (regs, 7) = dsta;\n\tput_long(dsta,srca);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4878_0)(uae_u32 opcode) /* PEA.L (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, 7) - 4;\n\tm68k_areg (regs, 7) = dsta;\n\tput_long(dsta,srca);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4879_0)(uae_u32 opcode) /* PEA.L (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuaecptr dsta = m68k_areg(regs, 7) - 4;\n\tm68k_areg (regs, 7) = dsta;\n\tput_long(dsta,srca);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_487a_0)(uae_u32 opcode) /* PEA.L (d16,PC) */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, 7) - 4;\n\tm68k_areg (regs, 7) = dsta;\n\tput_long(dsta,srca);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_487b_0)(uae_u32 opcode) /* PEA.L (d8,PC,Xn) */\n{\n\tcpuop_begin();\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuaecptr dsta = m68k_areg(regs, 7) - 4;\n\tm68k_areg (regs, 7) = dsta;\n\tput_long(dsta,srca);\n}}}}\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_4880_0)(uae_u32 opcode) /* EXT.W Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_u16 dst = (uae_s16)(uae_s8)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_NFLG (((uae_s16)(dst)) < 0);\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | ((dst) & 0xffff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4890_0)(uae_u32 opcode) /* MVMLE.W #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n{\tuaecptr srca = m68k_areg(regs, dstreg);\n{\tuae_u16 dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n\twhile (dmask) { put_word(srca, m68k_dreg(regs, movem_index1[dmask])); srca += 2; dmask = movem_next[dmask]; }\n\twhile (amask) { put_word(srca, m68k_areg(regs, movem_index1[amask])); srca += 2; amask = movem_next[amask]; }\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_48a0_0)(uae_u32 opcode) /* MVMLE.W #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n{\tuaecptr srca = m68k_areg(regs, dstreg) - 0;\n{\tuae_u16 amask = mask & 0xff, dmask = (mask >> 8) & 0xff;\n\twhile (amask) { srca -= 2; put_word(srca, m68k_areg(regs, movem_index2[amask])); amask = movem_next[amask]; }\n\twhile (dmask) { srca -= 2; put_word(srca, m68k_dreg(regs, movem_index2[dmask])); dmask = movem_next[dmask]; }\n\tm68k_areg(regs, dstreg) = srca;\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_48a8_0)(uae_u32 opcode) /* MVMLE.W #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n{\tuaecptr srca = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_u16 dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n\twhile (dmask) { put_word(srca, m68k_dreg(regs, movem_index1[dmask])); srca += 2; dmask = movem_next[dmask]; }\n\twhile (amask) { put_word(srca, m68k_areg(regs, movem_index1[amask])); srca += 2; amask = movem_next[amask]; }\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_48b0_0)(uae_u32 opcode) /* MVMLE.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_u16 dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n\twhile (dmask) { put_word(srca, m68k_dreg(regs, movem_index1[dmask])); srca += 2; dmask = movem_next[dmask]; }\n\twhile (amask) { put_word(srca, m68k_areg(regs, movem_index1[amask])); srca += 2; amask = movem_next[amask]; }\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_48b8_0)(uae_u32 opcode) /* MVMLE.W #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{\tuae_u16 mask = get_iword(2);\n{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_u16 dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n\twhile (dmask) { put_word(srca, m68k_dreg(regs, movem_index1[dmask])); srca += 2; dmask = movem_next[dmask]; }\n\twhile (amask) { put_word(srca, m68k_areg(regs, movem_index1[amask])); srca += 2; amask = movem_next[amask]; }\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_48b9_0)(uae_u32 opcode) /* MVMLE.W #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{\tuae_u16 mask = get_iword(2);\n{\tuaecptr srca = get_ilong(4);\n{\tuae_u16 dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n\twhile (dmask) { put_word(srca, m68k_dreg(regs, movem_index1[dmask])); srca += 2; dmask = movem_next[dmask]; }\n\twhile (amask) { put_word(srca, m68k_areg(regs, movem_index1[amask])); srca += 2; amask = movem_next[amask]; }\n}}}m68k_incpc(8);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_48c0_0)(uae_u32 opcode) /* EXT.L Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_u32 dst = (uae_s32)(uae_s16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_NFLG (((uae_s32)(dst)) < 0);\n\tm68k_dreg(regs, srcreg) = (dst);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_48d0_0)(uae_u32 opcode) /* MVMLE.L #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n{\tuaecptr srca = m68k_areg(regs, dstreg);\n{\tuae_u16 dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n\twhile (dmask) { put_long(srca, m68k_dreg(regs, movem_index1[dmask])); srca += 4; dmask = movem_next[dmask]; }\n\twhile (amask) { put_long(srca, m68k_areg(regs, movem_index1[amask])); srca += 4; amask = movem_next[amask]; }\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_48e0_0)(uae_u32 opcode) /* MVMLE.L #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n{\tuaecptr srca = m68k_areg(regs, dstreg) - 0;\n{\tuae_u16 amask = mask & 0xff, dmask = (mask >> 8) & 0xff;\n\twhile (amask) { srca -= 4; put_long(srca, m68k_areg(regs, movem_index2[amask])); amask = movem_next[amask]; }\n\twhile (dmask) { srca -= 4; put_long(srca, m68k_dreg(regs, movem_index2[dmask])); dmask = movem_next[dmask]; }\n\tm68k_areg(regs, dstreg) = srca;\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_48e8_0)(uae_u32 opcode) /* MVMLE.L #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n{\tuaecptr srca = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_u16 dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n\twhile (dmask) { put_long(srca, m68k_dreg(regs, movem_index1[dmask])); srca += 4; dmask = movem_next[dmask]; }\n\twhile (amask) { put_long(srca, m68k_areg(regs, movem_index1[amask])); srca += 4; amask = movem_next[amask]; }\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_48f0_0)(uae_u32 opcode) /* MVMLE.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_u16 dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n\twhile (dmask) { put_long(srca, m68k_dreg(regs, movem_index1[dmask])); srca += 4; dmask = movem_next[dmask]; }\n\twhile (amask) { put_long(srca, m68k_areg(regs, movem_index1[amask])); srca += 4; amask = movem_next[amask]; }\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_48f8_0)(uae_u32 opcode) /* MVMLE.L #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{\tuae_u16 mask = get_iword(2);\n{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_u16 dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n\twhile (dmask) { put_long(srca, m68k_dreg(regs, movem_index1[dmask])); srca += 4; dmask = movem_next[dmask]; }\n\twhile (amask) { put_long(srca, m68k_areg(regs, movem_index1[amask])); srca += 4; amask = movem_next[amask]; }\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_48f9_0)(uae_u32 opcode) /* MVMLE.L #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{\tuae_u16 mask = get_iword(2);\n{\tuaecptr srca = get_ilong(4);\n{\tuae_u16 dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n\twhile (dmask) { put_long(srca, m68k_dreg(regs, movem_index1[dmask])); srca += 4; dmask = movem_next[dmask]; }\n\twhile (amask) { put_long(srca, m68k_areg(regs, movem_index1[amask])); srca += 4; amask = movem_next[amask]; }\n}}}m68k_incpc(8);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_49c0_0)(uae_u32 opcode) /* EXT.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_u32 dst = (uae_s32)(uae_s8)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_NFLG (((uae_s32)(dst)) < 0);\n\tm68k_dreg(regs, srcreg) = (dst);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a00_0)(uae_u32 opcode) /* TST.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a10_0)(uae_u32 opcode) /* TST.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a18_0)(uae_u32 opcode) /* TST.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a20_0)(uae_u32 opcode) /* TST.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a28_0)(uae_u32 opcode) /* TST.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a30_0)(uae_u32 opcode) /* TST.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a38_0)(uae_u32 opcode) /* TST.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a39_0)(uae_u32 opcode) /* TST.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a3a_0)(uae_u32 opcode) /* TST.B (d16,PC) */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a3b_0)(uae_u32 opcode) /* TST.B (d8,PC,Xn) */\n{\n\tcpuop_begin();\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 src = get_byte(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a3c_0)(uae_u32 opcode) /* TST.B #<data>.B */\n{\n\tcpuop_begin();\n{{\tuae_s8 src = get_ibyte(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a40_0)(uae_u32 opcode) /* TST.W Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a48_0)(uae_u32 opcode) /* TST.W An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_areg(regs, srcreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a50_0)(uae_u32 opcode) /* TST.W (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a58_0)(uae_u32 opcode) /* TST.W (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a60_0)(uae_u32 opcode) /* TST.W -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a68_0)(uae_u32 opcode) /* TST.W (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a70_0)(uae_u32 opcode) /* TST.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a78_0)(uae_u32 opcode) /* TST.W (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a79_0)(uae_u32 opcode) /* TST.W (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a7a_0)(uae_u32 opcode) /* TST.W (d16,PC) */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a7b_0)(uae_u32 opcode) /* TST.W (d8,PC,Xn) */\n{\n\tcpuop_begin();\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a7c_0)(uae_u32 opcode) /* TST.W #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a80_0)(uae_u32 opcode) /* TST.L Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a88_0)(uae_u32 opcode) /* TST.L An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a90_0)(uae_u32 opcode) /* TST.L (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a98_0)(uae_u32 opcode) /* TST.L (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4aa0_0)(uae_u32 opcode) /* TST.L -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4aa8_0)(uae_u32 opcode) /* TST.L (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4ab0_0)(uae_u32 opcode) /* TST.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4ab8_0)(uae_u32 opcode) /* TST.L (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4ab9_0)(uae_u32 opcode) /* TST.L (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4aba_0)(uae_u32 opcode) /* TST.L (d16,PC) */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4abb_0)(uae_u32 opcode) /* TST.L (d8,PC,Xn) */\n{\n\tcpuop_begin();\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4abc_0)(uae_u32 opcode) /* TST.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4ac0_0)(uae_u32 opcode) /* TAS.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tsrc |= 0x80;\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((src) & 0xff);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4ad0_0)(uae_u32 opcode) /* TAS.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tsrc |= 0x80;\n\tput_byte(srca,src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4ad8_0)(uae_u32 opcode) /* TAS.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tsrc |= 0x80;\n\tput_byte(srca,src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4ae0_0)(uae_u32 opcode) /* TAS.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tsrc |= 0x80;\n\tput_byte(srca,src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4ae8_0)(uae_u32 opcode) /* TAS.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tsrc |= 0x80;\n\tput_byte(srca,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4af0_0)(uae_u32 opcode) /* TAS.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tsrc |= 0x80;\n\tput_byte(srca,src);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4af8_0)(uae_u32 opcode) /* TAS.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tsrc |= 0x80;\n\tput_byte(srca,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4af9_0)(uae_u32 opcode) /* TAS.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tsrc |= 0x80;\n\tput_byte(srca,src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c00_0)(uae_u32 opcode) /* MULL.L #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(4);\n\tm68k_mull(opcode, dst, extra);\n}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c10_0)(uae_u32 opcode) /* MULL.L #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\nm68k_incpc(4);\n\tm68k_mull(opcode, dst, extra);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c18_0)(uae_u32 opcode) /* MULL.L #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg(regs, dstreg) += 4;\nm68k_incpc(4);\n\tm68k_mull(opcode, dst, extra);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c20_0)(uae_u32 opcode) /* MULL.L #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\nm68k_incpc(4);\n\tm68k_mull(opcode, dst, extra);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c28_0)(uae_u32 opcode) /* MULL.L #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 dst = get_long(dsta);\nm68k_incpc(6);\n\tm68k_mull(opcode, dst, extra);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c30_0)(uae_u32 opcode) /* MULL.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_mull(opcode, dst, extra);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c38_0)(uae_u32 opcode) /* MULL.L #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 dst = get_long(dsta);\nm68k_incpc(6);\n\tm68k_mull(opcode, dst, extra);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c39_0)(uae_u32 opcode) /* MULL.L #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s32 dst = get_long(dsta);\nm68k_incpc(8);\n\tm68k_mull(opcode, dst, extra);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c3a_0)(uae_u32 opcode) /* MULL.L #<data>.W,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_getpc () + 4;\n\tdsta += (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 dst = get_long(dsta);\nm68k_incpc(6);\n\tm68k_mull(opcode, dst, extra);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c3b_0)(uae_u32 opcode) /* MULL.L #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_mull(opcode, dst, extra);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c3c_0)(uae_u32 opcode) /* MULL.L #<data>.W,#<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuae_s32 dst = get_ilong(4);\nm68k_incpc(8);\n\tm68k_mull(opcode, dst, extra);\n}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c40_0)(uae_u32 opcode) /* DIVL.L #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{m68k_incpc(2);\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(0);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(2);\n\tm68k_divl(opcode, dst, extra, oldpc);\n}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c50_0)(uae_u32 opcode) /* DIVL.L #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{m68k_incpc(2);\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(0);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\nm68k_incpc(2);\n\tm68k_divl(opcode, dst, extra, oldpc);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c58_0)(uae_u32 opcode) /* DIVL.L #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{m68k_incpc(2);\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(0);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg(regs, dstreg) += 4;\nm68k_incpc(2);\n\tm68k_divl(opcode, dst, extra, oldpc);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c60_0)(uae_u32 opcode) /* DIVL.L #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{m68k_incpc(2);\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(0);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\nm68k_incpc(2);\n\tm68k_divl(opcode, dst, extra, oldpc);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c68_0)(uae_u32 opcode) /* DIVL.L #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{m68k_incpc(2);\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(0);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 dst = get_long(dsta);\nm68k_incpc(4);\n\tm68k_divl(opcode, dst, extra, oldpc);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c70_0)(uae_u32 opcode) /* DIVL.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{m68k_incpc(2);\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(0);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_divl(opcode, dst, extra, oldpc);\n}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c78_0)(uae_u32 opcode) /* DIVL.L #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{m68k_incpc(2);\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(0);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 dst = get_long(dsta);\nm68k_incpc(4);\n\tm68k_divl(opcode, dst, extra, oldpc);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c79_0)(uae_u32 opcode) /* DIVL.L #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{m68k_incpc(2);\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(0);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s32 dst = get_long(dsta);\nm68k_incpc(6);\n\tm68k_divl(opcode, dst, extra, oldpc);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c7a_0)(uae_u32 opcode) /* DIVL.L #<data>.W,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{m68k_incpc(2);\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(0);\n{\tuaecptr dsta = m68k_getpc () + 2;\n\tdsta += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 dst = get_long(dsta);\nm68k_incpc(4);\n\tm68k_divl(opcode, dst, extra, oldpc);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c7b_0)(uae_u32 opcode) /* DIVL.L #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{m68k_incpc(2);\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(0);\n{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_divl(opcode, dst, extra, oldpc);\n}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4c7c_0)(uae_u32 opcode) /* DIVL.L #<data>.W,#<data>.L */\n{\n\tcpuop_begin();\n{m68k_incpc(2);\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 extra = get_iword(0);\n{\tuae_s32 dst = get_ilong(2);\nm68k_incpc(6);\n\tm68k_divl(opcode, dst, extra, oldpc);\n}}}}\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4c90_0)(uae_u32 opcode) /* MVMEL.W #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{\tuaecptr srca = m68k_areg(regs, dstreg);\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; amask = movem_next[amask]; }\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4c98_0)(uae_u32 opcode) /* MVMEL.W #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{\tuaecptr srca = m68k_areg(regs, dstreg);\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; amask = movem_next[amask]; }\n\tm68k_areg(regs, dstreg) = srca;\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4ca8_0)(uae_u32 opcode) /* MVMEL.W #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{\tuaecptr srca = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; amask = movem_next[amask]; }\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4cb0_0)(uae_u32 opcode) /* MVMEL.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{m68k_incpc(4);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; amask = movem_next[amask]; }\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4cb8_0)(uae_u32 opcode) /* MVMEL.W #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(4);\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; amask = movem_next[amask]; }\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4cb9_0)(uae_u32 opcode) /* MVMEL.W #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{\tuaecptr srca = get_ilong(4);\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; amask = movem_next[amask]; }\n}}}m68k_incpc(8);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4cba_0)(uae_u32 opcode) /* MVMEL.W #<data>.W,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{\tuaecptr srca = m68k_getpc () + 4;\n\tsrca += (uae_s32)(uae_s16)get_iword(4);\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; amask = movem_next[amask]; }\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4cbb_0)(uae_u32 opcode) /* MVMEL.W #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{m68k_incpc(4);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; amask = movem_next[amask]; }\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4cd0_0)(uae_u32 opcode) /* MVMEL.L #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{\tuaecptr srca = m68k_areg(regs, dstreg);\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = get_long(srca); srca += 4; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = get_long(srca); srca += 4; amask = movem_next[amask]; }\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4cd8_0)(uae_u32 opcode) /* MVMEL.L #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{\tuaecptr srca = m68k_areg(regs, dstreg);\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = get_long(srca); srca += 4; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = get_long(srca); srca += 4; amask = movem_next[amask]; }\n\tm68k_areg(regs, dstreg) = srca;\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4ce8_0)(uae_u32 opcode) /* MVMEL.L #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{\tuaecptr srca = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = get_long(srca); srca += 4; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = get_long(srca); srca += 4; amask = movem_next[amask]; }\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4cf0_0)(uae_u32 opcode) /* MVMEL.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{m68k_incpc(4);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = get_long(srca); srca += 4; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = get_long(srca); srca += 4; amask = movem_next[amask]; }\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4cf8_0)(uae_u32 opcode) /* MVMEL.L #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(4);\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = get_long(srca); srca += 4; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = get_long(srca); srca += 4; amask = movem_next[amask]; }\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4cf9_0)(uae_u32 opcode) /* MVMEL.L #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{\tuaecptr srca = get_ilong(4);\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = get_long(srca); srca += 4; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = get_long(srca); srca += 4; amask = movem_next[amask]; }\n}}}m68k_incpc(8);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4cfa_0)(uae_u32 opcode) /* MVMEL.L #<data>.W,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{\tuaecptr srca = m68k_getpc () + 4;\n\tsrca += (uae_s32)(uae_s16)get_iword(4);\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = get_long(srca); srca += 4; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = get_long(srca); srca += 4; amask = movem_next[amask]; }\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4cfb_0)(uae_u32 opcode) /* MVMEL.L #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{m68k_incpc(4);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = get_long(srca); srca += 4; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = get_long(srca); srca += 4; amask = movem_next[amask]; }\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4e40_0)(uae_u32 opcode) /* TRAP.L #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 15);\n#else\n\tuae_u32 srcreg = (opcode & 15);\n#endif\n{{\tuae_u32 src = srcreg;\nm68k_incpc(2);\n\tException(src+32,0);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4e50_0)(uae_u32 opcode) /* LINK.W An,#<data>.W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr olda = m68k_areg(regs, 7) - 4;\n\tm68k_areg (regs, 7) = olda;\n{\tuae_s32 src = m68k_areg(regs, srcreg);\n\tput_long(olda,src);\n\tm68k_areg(regs, srcreg) = (m68k_areg(regs, 7));\n{\tuae_s16 offs = get_iword(2);\n\tm68k_areg(regs, 7) += offs;\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4e58_0)(uae_u32 opcode) /* UNLK.L An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, 7) = src;\n{\tuaecptr olda = m68k_areg(regs, 7);\n{\tuae_s32 old = get_long(olda);\n\tm68k_areg(regs, 7) += 4;\n\tm68k_areg(regs, srcreg) = (old);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4e60_0)(uae_u32 opcode) /* MVR2USP.L An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel901; }\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n\tregs.usp = src;\n}}}m68k_incpc(2);\nendlabel901: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4e68_0)(uae_u32 opcode) /* MVUSP2R.L An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel902; }\n{{\tm68k_areg(regs, srcreg) = (regs.usp);\n}}}m68k_incpc(2);\nendlabel902: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4e70_0)(uae_u32 opcode) /* RESET.L  */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel903; }\n{}}m68k_incpc(2);\nendlabel903: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4e71_0)(uae_u32 opcode) /* NOP.L  */\n{\n\tcpuop_begin();\n{}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_4e72_0)(uae_u32 opcode) /* STOP.L #<data>.W */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel905; }\n{{\tuae_s16 src = get_iword(2);\n\tregs.sr = src;\n\tMakeFromSR();\n\tm68k_setstopped(1);\n}}}m68k_incpc(4);\nendlabel905: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4e73_0)(uae_u32 opcode) /* RTE.L  */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel906; }\n{\tuae_u16 newsr; uae_u32 newpc; for (;;) {\n{\tuaecptr sra = m68k_areg(regs, 7);\n{\tuae_s16 sr = get_word(sra);\n\tm68k_areg(regs, 7) += 2;\n{\tuaecptr pca = m68k_areg(regs, 7);\n{\tuae_s32 pc = get_long(pca);\n\tm68k_areg(regs, 7) += 4;\n{\tuaecptr formata = m68k_areg(regs, 7);\n{\tuae_s16 format = get_word(formata);\n\tm68k_areg(regs, 7) += 2;\n\tnewsr = sr; newpc = pc;\n\tif ((format & 0xF000) == 0x0000) { break; }\n\telse if ((format & 0xF000) == 0x1000) { ; }\n\telse if ((format & 0xF000) == 0x2000) { m68k_areg(regs, 7) += 4; break; }\n\telse if ((format & 0xF000) == 0x3000) { m68k_areg(regs, 7) += 4; break; }\n\telse if ((format & 0xF000) == 0x7000) { m68k_areg(regs, 7) += 52; break; }\n\telse if ((format & 0xF000) == 0x8000) { m68k_areg(regs, 7) += 50; break; }\n\telse if ((format & 0xF000) == 0x9000) { m68k_areg(regs, 7) += 12; break; }\n\telse if ((format & 0xF000) == 0xa000) { m68k_areg(regs, 7) += 24; break; }\n\telse if ((format & 0xF000) == 0xb000) { m68k_areg(regs, 7) += 84; break; }\n\telse { Exception(14,0); goto endlabel906; }\n\tregs.sr = newsr; MakeFromSR();\n}\n}}}}}}\tregs.sr = newsr; MakeFromSR();\n\tm68k_setpc_rte(newpc);\n}}endlabel906: ;\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4e74_0)(uae_u32 opcode) /* RTD.L #<data>.W */\n{\n\tcpuop_begin();\n{{\tuaecptr pca = m68k_areg(regs, 7);\n{\tuae_s32 pc = get_long(pca);\n\tm68k_areg(regs, 7) += 4;\n{\tuae_s16 offs = get_iword(2);\n\tm68k_areg(regs, 7) += offs;\n\tm68k_setpc_rte(pc);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4e75_0)(uae_u32 opcode) /* RTS.L  */\n{\n\tcpuop_begin();\n{\tm68k_do_rts();\n}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4e76_0)(uae_u32 opcode) /* TRAPV.L  */\n{\n\tcpuop_begin();\n{m68k_incpc(2);\n\tif (GET_VFLG) { Exception(7,m68k_getpc()); goto endlabel909; }\n}endlabel909: ;\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_4e77_0)(uae_u32 opcode) /* RTR.L  */\n{\n\tcpuop_begin();\n{\tMakeSR();\n{\tuaecptr sra = m68k_areg(regs, 7);\n{\tuae_s16 sr = get_word(sra);\n\tm68k_areg(regs, 7) += 2;\n{\tuaecptr pca = m68k_areg(regs, 7);\n{\tuae_s32 pc = get_long(pca);\n\tm68k_areg(regs, 7) += 4;\n\tregs.sr &= 0xFF00; sr &= 0xFF;\n\tregs.sr |= sr; m68k_setpc(pc);\n\tMakeFromSR();\n}}}}}\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4e7a_0)(uae_u32 opcode) /* MOVEC2.L #<data>.W */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel911; }\n{{\tuae_s16 src = get_iword(2);\n{\tint regno = (src >> 12) & 15;\n\tuae_u32 *regp = regs.regs + regno;\n\tif (! m68k_movec2(src & 0xFFF, regp)) goto endlabel911;\n}}}}m68k_incpc(4);\nendlabel911: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4e7b_0)(uae_u32 opcode) /* MOVE2C.L #<data>.W */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel912; }\n{{\tuae_s16 src = get_iword(2);\n{\tint regno = (src >> 12) & 15;\n\tuae_u32 *regp = regs.regs + regno;\n\tif (! m68k_move2c(src & 0xFFF, regp)) goto endlabel912;\n}}}}m68k_incpc(4);\nendlabel912: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4e90_0)(uae_u32 opcode) /* JSR.L (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_do_jsr(m68k_getpc() + 2, srca);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4ea8_0)(uae_u32 opcode) /* JSR.L (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n\tm68k_do_jsr(m68k_getpc() + 4, srca);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4eb0_0)(uae_u32 opcode) /* JSR.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n\tm68k_do_jsr(m68k_getpc() + 0, srca);\n}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4eb8_0)(uae_u32 opcode) /* JSR.L (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n\tm68k_do_jsr(m68k_getpc() + 4, srca);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4eb9_0)(uae_u32 opcode) /* JSR.L (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n\tm68k_do_jsr(m68k_getpc() + 6, srca);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4eba_0)(uae_u32 opcode) /* JSR.L (d16,PC) */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n\tm68k_do_jsr(m68k_getpc() + 4, srca);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4ebb_0)(uae_u32 opcode) /* JSR.L (d8,PC,Xn) */\n{\n\tcpuop_begin();\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n\tm68k_do_jsr(m68k_getpc() + 0, srca);\n}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4ed0_0)(uae_u32 opcode) /* JMP.L (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_setpc(srca);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4ee8_0)(uae_u32 opcode) /* JMP.L (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n\tm68k_setpc(srca);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4ef0_0)(uae_u32 opcode) /* JMP.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n\tm68k_setpc(srca);\n}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4ef8_0)(uae_u32 opcode) /* JMP.L (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n\tm68k_setpc(srca);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4ef9_0)(uae_u32 opcode) /* JMP.L (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n\tm68k_setpc(srca);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4efa_0)(uae_u32 opcode) /* JMP.L (d16,PC) */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n\tm68k_setpc(srca);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4efb_0)(uae_u32 opcode) /* JMP.L (d8,PC,Xn) */\n{\n\tcpuop_begin();\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n\tm68k_setpc(srca);\n}}}\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_5000_0)(uae_u32 opcode) /* ADD.B #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5010_0)(uae_u32 opcode) /* ADD.B #<data>,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5018_0)(uae_u32 opcode) /* ADD.B #<data>,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5020_0)(uae_u32 opcode) /* ADD.B #<data>,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5028_0)(uae_u32 opcode) /* ADD.B #<data>,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5030_0)(uae_u32 opcode) /* ADD.B #<data>,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5038_0)(uae_u32 opcode) /* ADD.B #<data>,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5039_0)(uae_u32 opcode) /* ADD.B #<data>,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n#endif\n\n#ifdef PART_5\nvoid REGPARAM2 CPUFUNC(op_5040_0)(uae_u32 opcode) /* ADD.W #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5048_0)(uae_u32 opcode) /* ADDA.W #<data>,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_5050_0)(uae_u32 opcode) /* ADD.W #<data>,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5058_0)(uae_u32 opcode) /* ADD.W #<data>,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg(regs, dstreg) += 2;\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5060_0)(uae_u32 opcode) /* ADD.W #<data>,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5068_0)(uae_u32 opcode) /* ADD.W #<data>,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5070_0)(uae_u32 opcode) /* ADD.W #<data>,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5078_0)(uae_u32 opcode) /* ADD.W #<data>,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5079_0)(uae_u32 opcode) /* ADD.W #<data>,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5080_0)(uae_u32 opcode) /* ADD.L #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5088_0)(uae_u32 opcode) /* ADDA.L #<data>,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_5090_0)(uae_u32 opcode) /* ADD.L #<data>,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5098_0)(uae_u32 opcode) /* ADD.L #<data>,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg(regs, dstreg) += 4;\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_50a0_0)(uae_u32 opcode) /* ADD.L #<data>,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_50a8_0)(uae_u32 opcode) /* ADD.L #<data>,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_50b0_0)(uae_u32 opcode) /* ADD.L #<data>,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_50b8_0)(uae_u32 opcode) /* ADD.L #<data>,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_50b9_0)(uae_u32 opcode) /* ADD.L #<data>,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_50c0_0)(uae_u32 opcode) /* Scc.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{{\tint val = cctrue(0) ? 0xff : 0;\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((val) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_50c8_0)(uae_u32 opcode) /* DBcc.W Dn,#<data>.W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 offs = get_iword(2);\n\tif (!cctrue(0)) {\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | (((src-1)) & 0xffff);\n\t\tif (src) {\n\t\t\tm68k_incpc((uae_s32)offs + 2);\nreturn;\n\t\t}\n\t}\n}}}m68k_incpc(4);\nendlabel954: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_50d0_0)(uae_u32 opcode) /* Scc.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tint val = cctrue(0) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_50d8_0)(uae_u32 opcode) /* Scc.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tint val = cctrue(0) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_50e0_0)(uae_u32 opcode) /* Scc.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n\tm68k_areg (regs, srcreg) = srca;\n{\tint val = cctrue(0) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_50e8_0)(uae_u32 opcode) /* Scc.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(0) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_50f0_0)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tint val = cctrue(0) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_50f8_0)(uae_u32 opcode) /* Scc.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(0) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_50f9_0)(uae_u32 opcode) /* Scc.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tint val = cctrue(0) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_50fa_0)(uae_u32 opcode) /* TRAPcc.L #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 dummy = get_iword(2);\n\tif (cctrue(0)) { Exception(7,m68k_getpc()); goto endlabel962; }\n}}m68k_incpc(4);\nendlabel962: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_50fb_0)(uae_u32 opcode) /* TRAPcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 dummy = get_ilong(2);\n\tif (cctrue(0)) { Exception(7,m68k_getpc()); goto endlabel963; }\n}}m68k_incpc(6);\nendlabel963: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_50fc_0)(uae_u32 opcode) /* TRAPcc.L  */\n{\n\tcpuop_begin();\n{\tif (cctrue(0)) { Exception(7,m68k_getpc()); goto endlabel964; }\n}m68k_incpc(2);\nendlabel964: ;\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_5100_0)(uae_u32 opcode) /* SUB.B #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5110_0)(uae_u32 opcode) /* SUB.B #<data>,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5118_0)(uae_u32 opcode) /* SUB.B #<data>,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5120_0)(uae_u32 opcode) /* SUB.B #<data>,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5128_0)(uae_u32 opcode) /* SUB.B #<data>,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5130_0)(uae_u32 opcode) /* SUB.B #<data>,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5138_0)(uae_u32 opcode) /* SUB.B #<data>,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5139_0)(uae_u32 opcode) /* SUB.B #<data>,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5140_0)(uae_u32 opcode) /* SUB.W #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5148_0)(uae_u32 opcode) /* SUBA.W #<data>,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_5150_0)(uae_u32 opcode) /* SUB.W #<data>,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5158_0)(uae_u32 opcode) /* SUB.W #<data>,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg(regs, dstreg) += 2;\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5160_0)(uae_u32 opcode) /* SUB.W #<data>,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5168_0)(uae_u32 opcode) /* SUB.W #<data>,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5170_0)(uae_u32 opcode) /* SUB.W #<data>,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5178_0)(uae_u32 opcode) /* SUB.W #<data>,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5179_0)(uae_u32 opcode) /* SUB.W #<data>,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5180_0)(uae_u32 opcode) /* SUB.L #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5188_0)(uae_u32 opcode) /* SUBA.L #<data>,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_5190_0)(uae_u32 opcode) /* SUB.L #<data>,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5198_0)(uae_u32 opcode) /* SUB.L #<data>,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg(regs, dstreg) += 4;\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_51a0_0)(uae_u32 opcode) /* SUB.L #<data>,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_51a8_0)(uae_u32 opcode) /* SUB.L #<data>,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_51b0_0)(uae_u32 opcode) /* SUB.L #<data>,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_51b8_0)(uae_u32 opcode) /* SUB.L #<data>,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_51b9_0)(uae_u32 opcode) /* SUB.L #<data>,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_51c0_0)(uae_u32 opcode) /* Scc.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{{\tint val = cctrue(1) ? 0xff : 0;\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((val) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_51c8_0)(uae_u32 opcode) /* DBcc.W Dn,#<data>.W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 offs = get_iword(2);\n\tif (!cctrue(1)) {\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | (((src-1)) & 0xffff);\n\t\tif (src) {\n\t\t\tm68k_incpc((uae_s32)offs + 2);\nreturn;\n\t\t}\n\t}\n}}}m68k_incpc(4);\nendlabel992: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_51d0_0)(uae_u32 opcode) /* Scc.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tint val = cctrue(1) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_51d8_0)(uae_u32 opcode) /* Scc.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tint val = cctrue(1) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_51e0_0)(uae_u32 opcode) /* Scc.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n\tm68k_areg (regs, srcreg) = srca;\n{\tint val = cctrue(1) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_51e8_0)(uae_u32 opcode) /* Scc.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(1) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_51f0_0)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tint val = cctrue(1) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_51f8_0)(uae_u32 opcode) /* Scc.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(1) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_51f9_0)(uae_u32 opcode) /* Scc.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tint val = cctrue(1) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_51fa_0)(uae_u32 opcode) /* TRAPcc.L #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 dummy = get_iword(2);\n\tif (cctrue(1)) { Exception(7,m68k_getpc()); goto endlabel1000; }\n}}m68k_incpc(4);\nendlabel1000: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_51fb_0)(uae_u32 opcode) /* TRAPcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 dummy = get_ilong(2);\n\tif (cctrue(1)) { Exception(7,m68k_getpc()); goto endlabel1001; }\n}}m68k_incpc(6);\nendlabel1001: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_51fc_0)(uae_u32 opcode) /* TRAPcc.L  */\n{\n\tcpuop_begin();\n{\tif (cctrue(1)) { Exception(7,m68k_getpc()); goto endlabel1002; }\n}m68k_incpc(2);\nendlabel1002: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_52c0_0)(uae_u32 opcode) /* Scc.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{{\tint val = cctrue(2) ? 0xff : 0;\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((val) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_52c8_0)(uae_u32 opcode) /* DBcc.W Dn,#<data>.W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 offs = get_iword(2);\n\tif (!cctrue(2)) {\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | (((src-1)) & 0xffff);\n\t\tif (src) {\n\t\t\tm68k_incpc((uae_s32)offs + 2);\nreturn;\n\t\t}\n\t}\n}}}m68k_incpc(4);\nendlabel1004: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_52d0_0)(uae_u32 opcode) /* Scc.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tint val = cctrue(2) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_52d8_0)(uae_u32 opcode) /* Scc.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tint val = cctrue(2) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_52e0_0)(uae_u32 opcode) /* Scc.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n\tm68k_areg (regs, srcreg) = srca;\n{\tint val = cctrue(2) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_52e8_0)(uae_u32 opcode) /* Scc.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(2) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_52f0_0)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tint val = cctrue(2) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_52f8_0)(uae_u32 opcode) /* Scc.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(2) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_52f9_0)(uae_u32 opcode) /* Scc.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tint val = cctrue(2) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_52fa_0)(uae_u32 opcode) /* TRAPcc.L #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 dummy = get_iword(2);\n\tif (cctrue(2)) { Exception(7,m68k_getpc()); goto endlabel1012; }\n}}m68k_incpc(4);\nendlabel1012: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_52fb_0)(uae_u32 opcode) /* TRAPcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 dummy = get_ilong(2);\n\tif (cctrue(2)) { Exception(7,m68k_getpc()); goto endlabel1013; }\n}}m68k_incpc(6);\nendlabel1013: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_52fc_0)(uae_u32 opcode) /* TRAPcc.L  */\n{\n\tcpuop_begin();\n{\tif (cctrue(2)) { Exception(7,m68k_getpc()); goto endlabel1014; }\n}m68k_incpc(2);\nendlabel1014: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_53c0_0)(uae_u32 opcode) /* Scc.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{{\tint val = cctrue(3) ? 0xff : 0;\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((val) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_53c8_0)(uae_u32 opcode) /* DBcc.W Dn,#<data>.W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 offs = get_iword(2);\n\tif (!cctrue(3)) {\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | (((src-1)) & 0xffff);\n\t\tif (src) {\n\t\t\tm68k_incpc((uae_s32)offs + 2);\nreturn;\n\t\t}\n\t}\n}}}m68k_incpc(4);\nendlabel1016: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_53d0_0)(uae_u32 opcode) /* Scc.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tint val = cctrue(3) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_53d8_0)(uae_u32 opcode) /* Scc.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tint val = cctrue(3) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_53e0_0)(uae_u32 opcode) /* Scc.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n\tm68k_areg (regs, srcreg) = srca;\n{\tint val = cctrue(3) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_53e8_0)(uae_u32 opcode) /* Scc.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(3) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_53f0_0)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tint val = cctrue(3) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_53f8_0)(uae_u32 opcode) /* Scc.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(3) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_53f9_0)(uae_u32 opcode) /* Scc.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tint val = cctrue(3) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_53fa_0)(uae_u32 opcode) /* TRAPcc.L #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 dummy = get_iword(2);\n\tif (cctrue(3)) { Exception(7,m68k_getpc()); goto endlabel1024; }\n}}m68k_incpc(4);\nendlabel1024: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_53fb_0)(uae_u32 opcode) /* TRAPcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 dummy = get_ilong(2);\n\tif (cctrue(3)) { Exception(7,m68k_getpc()); goto endlabel1025; }\n}}m68k_incpc(6);\nendlabel1025: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_53fc_0)(uae_u32 opcode) /* TRAPcc.L  */\n{\n\tcpuop_begin();\n{\tif (cctrue(3)) { Exception(7,m68k_getpc()); goto endlabel1026; }\n}m68k_incpc(2);\nendlabel1026: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_54c0_0)(uae_u32 opcode) /* Scc.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{{\tint val = cctrue(4) ? 0xff : 0;\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((val) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_54c8_0)(uae_u32 opcode) /* DBcc.W Dn,#<data>.W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 offs = get_iword(2);\n\tif (!cctrue(4)) {\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | (((src-1)) & 0xffff);\n\t\tif (src) {\n\t\t\tm68k_incpc((uae_s32)offs + 2);\nreturn;\n\t\t}\n\t}\n}}}m68k_incpc(4);\nendlabel1028: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_54d0_0)(uae_u32 opcode) /* Scc.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tint val = cctrue(4) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_54d8_0)(uae_u32 opcode) /* Scc.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tint val = cctrue(4) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_54e0_0)(uae_u32 opcode) /* Scc.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n\tm68k_areg (regs, srcreg) = srca;\n{\tint val = cctrue(4) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_54e8_0)(uae_u32 opcode) /* Scc.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(4) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_54f0_0)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tint val = cctrue(4) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_54f8_0)(uae_u32 opcode) /* Scc.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(4) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_54f9_0)(uae_u32 opcode) /* Scc.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tint val = cctrue(4) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_54fa_0)(uae_u32 opcode) /* TRAPcc.L #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 dummy = get_iword(2);\n\tif (cctrue(4)) { Exception(7,m68k_getpc()); goto endlabel1036; }\n}}m68k_incpc(4);\nendlabel1036: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_54fb_0)(uae_u32 opcode) /* TRAPcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 dummy = get_ilong(2);\n\tif (cctrue(4)) { Exception(7,m68k_getpc()); goto endlabel1037; }\n}}m68k_incpc(6);\nendlabel1037: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_54fc_0)(uae_u32 opcode) /* TRAPcc.L  */\n{\n\tcpuop_begin();\n{\tif (cctrue(4)) { Exception(7,m68k_getpc()); goto endlabel1038; }\n}m68k_incpc(2);\nendlabel1038: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_55c0_0)(uae_u32 opcode) /* Scc.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{{\tint val = cctrue(5) ? 0xff : 0;\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((val) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_55c8_0)(uae_u32 opcode) /* DBcc.W Dn,#<data>.W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 offs = get_iword(2);\n\tif (!cctrue(5)) {\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | (((src-1)) & 0xffff);\n\t\tif (src) {\n\t\t\tm68k_incpc((uae_s32)offs + 2);\nreturn;\n\t\t}\n\t}\n}}}m68k_incpc(4);\nendlabel1040: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_55d0_0)(uae_u32 opcode) /* Scc.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tint val = cctrue(5) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_55d8_0)(uae_u32 opcode) /* Scc.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tint val = cctrue(5) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_55e0_0)(uae_u32 opcode) /* Scc.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n\tm68k_areg (regs, srcreg) = srca;\n{\tint val = cctrue(5) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_55e8_0)(uae_u32 opcode) /* Scc.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(5) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_55f0_0)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tint val = cctrue(5) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_55f8_0)(uae_u32 opcode) /* Scc.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(5) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_55f9_0)(uae_u32 opcode) /* Scc.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tint val = cctrue(5) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_55fa_0)(uae_u32 opcode) /* TRAPcc.L #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 dummy = get_iword(2);\n\tif (cctrue(5)) { Exception(7,m68k_getpc()); goto endlabel1048; }\n}}m68k_incpc(4);\nendlabel1048: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_55fb_0)(uae_u32 opcode) /* TRAPcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 dummy = get_ilong(2);\n\tif (cctrue(5)) { Exception(7,m68k_getpc()); goto endlabel1049; }\n}}m68k_incpc(6);\nendlabel1049: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_55fc_0)(uae_u32 opcode) /* TRAPcc.L  */\n{\n\tcpuop_begin();\n{\tif (cctrue(5)) { Exception(7,m68k_getpc()); goto endlabel1050; }\n}m68k_incpc(2);\nendlabel1050: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_56c0_0)(uae_u32 opcode) /* Scc.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{{\tint val = cctrue(6) ? 0xff : 0;\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((val) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_56c8_0)(uae_u32 opcode) /* DBcc.W Dn,#<data>.W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 offs = get_iword(2);\n\tif (!cctrue(6)) {\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | (((src-1)) & 0xffff);\n\t\tif (src) {\n\t\t\tm68k_incpc((uae_s32)offs + 2);\nreturn;\n\t\t}\n\t}\n}}}m68k_incpc(4);\nendlabel1052: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_56d0_0)(uae_u32 opcode) /* Scc.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tint val = cctrue(6) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_56d8_0)(uae_u32 opcode) /* Scc.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tint val = cctrue(6) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_56e0_0)(uae_u32 opcode) /* Scc.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n\tm68k_areg (regs, srcreg) = srca;\n{\tint val = cctrue(6) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_56e8_0)(uae_u32 opcode) /* Scc.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(6) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_56f0_0)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tint val = cctrue(6) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_56f8_0)(uae_u32 opcode) /* Scc.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(6) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_56f9_0)(uae_u32 opcode) /* Scc.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tint val = cctrue(6) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_56fa_0)(uae_u32 opcode) /* TRAPcc.L #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 dummy = get_iword(2);\n\tif (cctrue(6)) { Exception(7,m68k_getpc()); goto endlabel1060; }\n}}m68k_incpc(4);\nendlabel1060: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_56fb_0)(uae_u32 opcode) /* TRAPcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 dummy = get_ilong(2);\n\tif (cctrue(6)) { Exception(7,m68k_getpc()); goto endlabel1061; }\n}}m68k_incpc(6);\nendlabel1061: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_56fc_0)(uae_u32 opcode) /* TRAPcc.L  */\n{\n\tcpuop_begin();\n{\tif (cctrue(6)) { Exception(7,m68k_getpc()); goto endlabel1062; }\n}m68k_incpc(2);\nendlabel1062: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_57c0_0)(uae_u32 opcode) /* Scc.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{{\tint val = cctrue(7) ? 0xff : 0;\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((val) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_57c8_0)(uae_u32 opcode) /* DBcc.W Dn,#<data>.W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 offs = get_iword(2);\n\tif (!cctrue(7)) {\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | (((src-1)) & 0xffff);\n\t\tif (src) {\n\t\t\tm68k_incpc((uae_s32)offs + 2);\nreturn;\n\t\t}\n\t}\n}}}m68k_incpc(4);\nendlabel1064: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_57d0_0)(uae_u32 opcode) /* Scc.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tint val = cctrue(7) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_57d8_0)(uae_u32 opcode) /* Scc.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tint val = cctrue(7) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_57e0_0)(uae_u32 opcode) /* Scc.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n\tm68k_areg (regs, srcreg) = srca;\n{\tint val = cctrue(7) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_57e8_0)(uae_u32 opcode) /* Scc.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(7) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_57f0_0)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tint val = cctrue(7) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_57f8_0)(uae_u32 opcode) /* Scc.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(7) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_57f9_0)(uae_u32 opcode) /* Scc.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tint val = cctrue(7) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_57fa_0)(uae_u32 opcode) /* TRAPcc.L #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 dummy = get_iword(2);\n\tif (cctrue(7)) { Exception(7,m68k_getpc()); goto endlabel1072; }\n}}m68k_incpc(4);\nendlabel1072: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_57fb_0)(uae_u32 opcode) /* TRAPcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 dummy = get_ilong(2);\n\tif (cctrue(7)) { Exception(7,m68k_getpc()); goto endlabel1073; }\n}}m68k_incpc(6);\nendlabel1073: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_57fc_0)(uae_u32 opcode) /* TRAPcc.L  */\n{\n\tcpuop_begin();\n{\tif (cctrue(7)) { Exception(7,m68k_getpc()); goto endlabel1074; }\n}m68k_incpc(2);\nendlabel1074: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_58c0_0)(uae_u32 opcode) /* Scc.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{{\tint val = cctrue(8) ? 0xff : 0;\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((val) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_58c8_0)(uae_u32 opcode) /* DBcc.W Dn,#<data>.W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 offs = get_iword(2);\n\tif (!cctrue(8)) {\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | (((src-1)) & 0xffff);\n\t\tif (src) {\n\t\t\tm68k_incpc((uae_s32)offs + 2);\nreturn;\n\t\t}\n\t}\n}}}m68k_incpc(4);\nendlabel1076: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_58d0_0)(uae_u32 opcode) /* Scc.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tint val = cctrue(8) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_58d8_0)(uae_u32 opcode) /* Scc.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tint val = cctrue(8) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_58e0_0)(uae_u32 opcode) /* Scc.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n\tm68k_areg (regs, srcreg) = srca;\n{\tint val = cctrue(8) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_58e8_0)(uae_u32 opcode) /* Scc.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(8) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_58f0_0)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tint val = cctrue(8) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_58f8_0)(uae_u32 opcode) /* Scc.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(8) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_58f9_0)(uae_u32 opcode) /* Scc.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tint val = cctrue(8) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_58fa_0)(uae_u32 opcode) /* TRAPcc.L #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 dummy = get_iword(2);\n\tif (cctrue(8)) { Exception(7,m68k_getpc()); goto endlabel1084; }\n}}m68k_incpc(4);\nendlabel1084: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_58fb_0)(uae_u32 opcode) /* TRAPcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 dummy = get_ilong(2);\n\tif (cctrue(8)) { Exception(7,m68k_getpc()); goto endlabel1085; }\n}}m68k_incpc(6);\nendlabel1085: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_58fc_0)(uae_u32 opcode) /* TRAPcc.L  */\n{\n\tcpuop_begin();\n{\tif (cctrue(8)) { Exception(7,m68k_getpc()); goto endlabel1086; }\n}m68k_incpc(2);\nendlabel1086: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_59c0_0)(uae_u32 opcode) /* Scc.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{{\tint val = cctrue(9) ? 0xff : 0;\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((val) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_59c8_0)(uae_u32 opcode) /* DBcc.W Dn,#<data>.W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 offs = get_iword(2);\n\tif (!cctrue(9)) {\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | (((src-1)) & 0xffff);\n\t\tif (src) {\n\t\t\tm68k_incpc((uae_s32)offs + 2);\nreturn;\n\t\t}\n\t}\n}}}m68k_incpc(4);\nendlabel1088: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_59d0_0)(uae_u32 opcode) /* Scc.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tint val = cctrue(9) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_59d8_0)(uae_u32 opcode) /* Scc.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tint val = cctrue(9) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_59e0_0)(uae_u32 opcode) /* Scc.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n\tm68k_areg (regs, srcreg) = srca;\n{\tint val = cctrue(9) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_59e8_0)(uae_u32 opcode) /* Scc.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(9) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_59f0_0)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tint val = cctrue(9) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_59f8_0)(uae_u32 opcode) /* Scc.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(9) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_59f9_0)(uae_u32 opcode) /* Scc.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tint val = cctrue(9) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_59fa_0)(uae_u32 opcode) /* TRAPcc.L #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 dummy = get_iword(2);\n\tif (cctrue(9)) { Exception(7,m68k_getpc()); goto endlabel1096; }\n}}m68k_incpc(4);\nendlabel1096: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_59fb_0)(uae_u32 opcode) /* TRAPcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 dummy = get_ilong(2);\n\tif (cctrue(9)) { Exception(7,m68k_getpc()); goto endlabel1097; }\n}}m68k_incpc(6);\nendlabel1097: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_59fc_0)(uae_u32 opcode) /* TRAPcc.L  */\n{\n\tcpuop_begin();\n{\tif (cctrue(9)) { Exception(7,m68k_getpc()); goto endlabel1098; }\n}m68k_incpc(2);\nendlabel1098: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ac0_0)(uae_u32 opcode) /* Scc.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{{\tint val = cctrue(10) ? 0xff : 0;\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((val) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ac8_0)(uae_u32 opcode) /* DBcc.W Dn,#<data>.W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 offs = get_iword(2);\n\tif (!cctrue(10)) {\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | (((src-1)) & 0xffff);\n\t\tif (src) {\n\t\t\tm68k_incpc((uae_s32)offs + 2);\nreturn;\n\t\t}\n\t}\n}}}m68k_incpc(4);\nendlabel1100: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ad0_0)(uae_u32 opcode) /* Scc.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tint val = cctrue(10) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ad8_0)(uae_u32 opcode) /* Scc.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tint val = cctrue(10) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ae0_0)(uae_u32 opcode) /* Scc.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n\tm68k_areg (regs, srcreg) = srca;\n{\tint val = cctrue(10) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ae8_0)(uae_u32 opcode) /* Scc.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(10) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5af0_0)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tint val = cctrue(10) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5af8_0)(uae_u32 opcode) /* Scc.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(10) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5af9_0)(uae_u32 opcode) /* Scc.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tint val = cctrue(10) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5afa_0)(uae_u32 opcode) /* TRAPcc.L #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 dummy = get_iword(2);\n\tif (cctrue(10)) { Exception(7,m68k_getpc()); goto endlabel1108; }\n}}m68k_incpc(4);\nendlabel1108: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5afb_0)(uae_u32 opcode) /* TRAPcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 dummy = get_ilong(2);\n\tif (cctrue(10)) { Exception(7,m68k_getpc()); goto endlabel1109; }\n}}m68k_incpc(6);\nendlabel1109: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5afc_0)(uae_u32 opcode) /* TRAPcc.L  */\n{\n\tcpuop_begin();\n{\tif (cctrue(10)) { Exception(7,m68k_getpc()); goto endlabel1110; }\n}m68k_incpc(2);\nendlabel1110: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5bc0_0)(uae_u32 opcode) /* Scc.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{{\tint val = cctrue(11) ? 0xff : 0;\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((val) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5bc8_0)(uae_u32 opcode) /* DBcc.W Dn,#<data>.W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 offs = get_iword(2);\n\tif (!cctrue(11)) {\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | (((src-1)) & 0xffff);\n\t\tif (src) {\n\t\t\tm68k_incpc((uae_s32)offs + 2);\nreturn;\n\t\t}\n\t}\n}}}m68k_incpc(4);\nendlabel1112: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5bd0_0)(uae_u32 opcode) /* Scc.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tint val = cctrue(11) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5bd8_0)(uae_u32 opcode) /* Scc.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tint val = cctrue(11) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5be0_0)(uae_u32 opcode) /* Scc.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n\tm68k_areg (regs, srcreg) = srca;\n{\tint val = cctrue(11) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5be8_0)(uae_u32 opcode) /* Scc.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(11) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5bf0_0)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tint val = cctrue(11) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5bf8_0)(uae_u32 opcode) /* Scc.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(11) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5bf9_0)(uae_u32 opcode) /* Scc.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tint val = cctrue(11) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5bfa_0)(uae_u32 opcode) /* TRAPcc.L #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 dummy = get_iword(2);\n\tif (cctrue(11)) { Exception(7,m68k_getpc()); goto endlabel1120; }\n}}m68k_incpc(4);\nendlabel1120: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5bfb_0)(uae_u32 opcode) /* TRAPcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 dummy = get_ilong(2);\n\tif (cctrue(11)) { Exception(7,m68k_getpc()); goto endlabel1121; }\n}}m68k_incpc(6);\nendlabel1121: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5bfc_0)(uae_u32 opcode) /* TRAPcc.L  */\n{\n\tcpuop_begin();\n{\tif (cctrue(11)) { Exception(7,m68k_getpc()); goto endlabel1122; }\n}m68k_incpc(2);\nendlabel1122: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5cc0_0)(uae_u32 opcode) /* Scc.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{{\tint val = cctrue(12) ? 0xff : 0;\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((val) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5cc8_0)(uae_u32 opcode) /* DBcc.W Dn,#<data>.W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 offs = get_iword(2);\n\tif (!cctrue(12)) {\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | (((src-1)) & 0xffff);\n\t\tif (src) {\n\t\t\tm68k_incpc((uae_s32)offs + 2);\nreturn;\n\t\t}\n\t}\n}}}m68k_incpc(4);\nendlabel1124: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5cd0_0)(uae_u32 opcode) /* Scc.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tint val = cctrue(12) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5cd8_0)(uae_u32 opcode) /* Scc.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tint val = cctrue(12) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ce0_0)(uae_u32 opcode) /* Scc.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n\tm68k_areg (regs, srcreg) = srca;\n{\tint val = cctrue(12) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ce8_0)(uae_u32 opcode) /* Scc.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(12) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5cf0_0)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tint val = cctrue(12) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5cf8_0)(uae_u32 opcode) /* Scc.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(12) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5cf9_0)(uae_u32 opcode) /* Scc.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tint val = cctrue(12) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5cfa_0)(uae_u32 opcode) /* TRAPcc.L #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 dummy = get_iword(2);\n\tif (cctrue(12)) { Exception(7,m68k_getpc()); goto endlabel1132; }\n}}m68k_incpc(4);\nendlabel1132: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5cfb_0)(uae_u32 opcode) /* TRAPcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 dummy = get_ilong(2);\n\tif (cctrue(12)) { Exception(7,m68k_getpc()); goto endlabel1133; }\n}}m68k_incpc(6);\nendlabel1133: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5cfc_0)(uae_u32 opcode) /* TRAPcc.L  */\n{\n\tcpuop_begin();\n{\tif (cctrue(12)) { Exception(7,m68k_getpc()); goto endlabel1134; }\n}m68k_incpc(2);\nendlabel1134: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5dc0_0)(uae_u32 opcode) /* Scc.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{{\tint val = cctrue(13) ? 0xff : 0;\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((val) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5dc8_0)(uae_u32 opcode) /* DBcc.W Dn,#<data>.W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 offs = get_iword(2);\n\tif (!cctrue(13)) {\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | (((src-1)) & 0xffff);\n\t\tif (src) {\n\t\t\tm68k_incpc((uae_s32)offs + 2);\nreturn;\n\t\t}\n\t}\n}}}m68k_incpc(4);\nendlabel1136: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5dd0_0)(uae_u32 opcode) /* Scc.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tint val = cctrue(13) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5dd8_0)(uae_u32 opcode) /* Scc.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tint val = cctrue(13) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5de0_0)(uae_u32 opcode) /* Scc.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n\tm68k_areg (regs, srcreg) = srca;\n{\tint val = cctrue(13) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5de8_0)(uae_u32 opcode) /* Scc.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(13) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5df0_0)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tint val = cctrue(13) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5df8_0)(uae_u32 opcode) /* Scc.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(13) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5df9_0)(uae_u32 opcode) /* Scc.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tint val = cctrue(13) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5dfa_0)(uae_u32 opcode) /* TRAPcc.L #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 dummy = get_iword(2);\n\tif (cctrue(13)) { Exception(7,m68k_getpc()); goto endlabel1144; }\n}}m68k_incpc(4);\nendlabel1144: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5dfb_0)(uae_u32 opcode) /* TRAPcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 dummy = get_ilong(2);\n\tif (cctrue(13)) { Exception(7,m68k_getpc()); goto endlabel1145; }\n}}m68k_incpc(6);\nendlabel1145: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5dfc_0)(uae_u32 opcode) /* TRAPcc.L  */\n{\n\tcpuop_begin();\n{\tif (cctrue(13)) { Exception(7,m68k_getpc()); goto endlabel1146; }\n}m68k_incpc(2);\nendlabel1146: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ec0_0)(uae_u32 opcode) /* Scc.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{{\tint val = cctrue(14) ? 0xff : 0;\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((val) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ec8_0)(uae_u32 opcode) /* DBcc.W Dn,#<data>.W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 offs = get_iword(2);\n\tif (!cctrue(14)) {\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | (((src-1)) & 0xffff);\n\t\tif (src) {\n\t\t\tm68k_incpc((uae_s32)offs + 2);\nreturn;\n\t\t}\n\t}\n}}}m68k_incpc(4);\nendlabel1148: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ed0_0)(uae_u32 opcode) /* Scc.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tint val = cctrue(14) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ed8_0)(uae_u32 opcode) /* Scc.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tint val = cctrue(14) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ee0_0)(uae_u32 opcode) /* Scc.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n\tm68k_areg (regs, srcreg) = srca;\n{\tint val = cctrue(14) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ee8_0)(uae_u32 opcode) /* Scc.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(14) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ef0_0)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tint val = cctrue(14) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ef8_0)(uae_u32 opcode) /* Scc.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(14) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ef9_0)(uae_u32 opcode) /* Scc.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tint val = cctrue(14) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5efa_0)(uae_u32 opcode) /* TRAPcc.L #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 dummy = get_iword(2);\n\tif (cctrue(14)) { Exception(7,m68k_getpc()); goto endlabel1156; }\n}}m68k_incpc(4);\nendlabel1156: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5efb_0)(uae_u32 opcode) /* TRAPcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 dummy = get_ilong(2);\n\tif (cctrue(14)) { Exception(7,m68k_getpc()); goto endlabel1157; }\n}}m68k_incpc(6);\nendlabel1157: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5efc_0)(uae_u32 opcode) /* TRAPcc.L  */\n{\n\tcpuop_begin();\n{\tif (cctrue(14)) { Exception(7,m68k_getpc()); goto endlabel1158; }\n}m68k_incpc(2);\nendlabel1158: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5fc0_0)(uae_u32 opcode) /* Scc.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{{\tint val = cctrue(15) ? 0xff : 0;\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((val) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5fc8_0)(uae_u32 opcode) /* DBcc.W Dn,#<data>.W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 offs = get_iword(2);\n\tif (!cctrue(15)) {\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | (((src-1)) & 0xffff);\n\t\tif (src) {\n\t\t\tm68k_incpc((uae_s32)offs + 2);\nreturn;\n\t\t}\n\t}\n}}}m68k_incpc(4);\nendlabel1160: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5fd0_0)(uae_u32 opcode) /* Scc.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tint val = cctrue(15) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5fd8_0)(uae_u32 opcode) /* Scc.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tint val = cctrue(15) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5fe0_0)(uae_u32 opcode) /* Scc.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n\tm68k_areg (regs, srcreg) = srca;\n{\tint val = cctrue(15) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5fe8_0)(uae_u32 opcode) /* Scc.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(15) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ff0_0)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tint val = cctrue(15) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ff8_0)(uae_u32 opcode) /* Scc.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tint val = cctrue(15) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ff9_0)(uae_u32 opcode) /* Scc.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tint val = cctrue(15) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#endif\n\n#ifdef PART_6\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ffa_0)(uae_u32 opcode) /* TRAPcc.L #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 dummy = get_iword(2);\n\tif (cctrue(15)) { Exception(7,m68k_getpc()); goto endlabel1168; }\n}}m68k_incpc(4);\nendlabel1168: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ffb_0)(uae_u32 opcode) /* TRAPcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 dummy = get_ilong(2);\n\tif (cctrue(15)) { Exception(7,m68k_getpc()); goto endlabel1169; }\n}}m68k_incpc(6);\nendlabel1169: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ffc_0)(uae_u32 opcode) /* TRAPcc.L  */\n{\n\tcpuop_begin();\n{\tif (cctrue(15)) { Exception(7,m68k_getpc()); goto endlabel1170; }\n}m68k_incpc(2);\nendlabel1170: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6000_0)(uae_u32 opcode) /* Bcc.W #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n\tif (!cctrue(0)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(4);\nendlabel1171: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6001_0)(uae_u32 opcode) /* Bcc.B #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = (uae_s32)(uae_s8)((opcode >> 8) & 255);\n#else\n\tuae_u32 srcreg = (uae_s32)(uae_s8)(opcode & 255);\n#endif\n{{\tuae_u32 src = srcreg;\n\tif (!cctrue(0)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(2);\nendlabel1172: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_60ff_0)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(0)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel1173: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6100_0)(uae_u32 opcode) /* BSR.W #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n\tuae_s32 s = (uae_s32)src + 2;\n\tm68k_do_bsr(m68k_getpc() + 4, s);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6101_0)(uae_u32 opcode) /* BSR.B #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = (uae_s32)(uae_s8)((opcode >> 8) & 255);\n#else\n\tuae_u32 srcreg = (uae_s32)(uae_s8)(opcode & 255);\n#endif\n{{\tuae_u32 src = srcreg;\n\tuae_s32 s = (uae_s32)src + 2;\n\tm68k_do_bsr(m68k_getpc() + 2, s);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_61ff_0)(uae_u32 opcode) /* BSR.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n\tuae_s32 s = (uae_s32)src + 2;\n\tm68k_do_bsr(m68k_getpc() + 6, s);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6200_0)(uae_u32 opcode) /* Bcc.W #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n\tif (!cctrue(2)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(4);\nendlabel1177: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6201_0)(uae_u32 opcode) /* Bcc.B #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = (uae_s32)(uae_s8)((opcode >> 8) & 255);\n#else\n\tuae_u32 srcreg = (uae_s32)(uae_s8)(opcode & 255);\n#endif\n{{\tuae_u32 src = srcreg;\n\tif (!cctrue(2)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(2);\nendlabel1178: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_62ff_0)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(2)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel1179: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6300_0)(uae_u32 opcode) /* Bcc.W #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n\tif (!cctrue(3)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(4);\nendlabel1180: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6301_0)(uae_u32 opcode) /* Bcc.B #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = (uae_s32)(uae_s8)((opcode >> 8) & 255);\n#else\n\tuae_u32 srcreg = (uae_s32)(uae_s8)(opcode & 255);\n#endif\n{{\tuae_u32 src = srcreg;\n\tif (!cctrue(3)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(2);\nendlabel1181: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_63ff_0)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(3)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel1182: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6400_0)(uae_u32 opcode) /* Bcc.W #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n\tif (!cctrue(4)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(4);\nendlabel1183: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6401_0)(uae_u32 opcode) /* Bcc.B #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = (uae_s32)(uae_s8)((opcode >> 8) & 255);\n#else\n\tuae_u32 srcreg = (uae_s32)(uae_s8)(opcode & 255);\n#endif\n{{\tuae_u32 src = srcreg;\n\tif (!cctrue(4)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(2);\nendlabel1184: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_64ff_0)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(4)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel1185: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6500_0)(uae_u32 opcode) /* Bcc.W #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n\tif (!cctrue(5)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(4);\nendlabel1186: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6501_0)(uae_u32 opcode) /* Bcc.B #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = (uae_s32)(uae_s8)((opcode >> 8) & 255);\n#else\n\tuae_u32 srcreg = (uae_s32)(uae_s8)(opcode & 255);\n#endif\n{{\tuae_u32 src = srcreg;\n\tif (!cctrue(5)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(2);\nendlabel1187: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_65ff_0)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(5)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel1188: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6600_0)(uae_u32 opcode) /* Bcc.W #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n\tif (!cctrue(6)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(4);\nendlabel1189: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6601_0)(uae_u32 opcode) /* Bcc.B #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = (uae_s32)(uae_s8)((opcode >> 8) & 255);\n#else\n\tuae_u32 srcreg = (uae_s32)(uae_s8)(opcode & 255);\n#endif\n{{\tuae_u32 src = srcreg;\n\tif (!cctrue(6)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(2);\nendlabel1190: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_66ff_0)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(6)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel1191: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6700_0)(uae_u32 opcode) /* Bcc.W #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n\tif (!cctrue(7)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(4);\nendlabel1192: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6701_0)(uae_u32 opcode) /* Bcc.B #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = (uae_s32)(uae_s8)((opcode >> 8) & 255);\n#else\n\tuae_u32 srcreg = (uae_s32)(uae_s8)(opcode & 255);\n#endif\n{{\tuae_u32 src = srcreg;\n\tif (!cctrue(7)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(2);\nendlabel1193: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_67ff_0)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(7)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel1194: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6800_0)(uae_u32 opcode) /* Bcc.W #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n\tif (!cctrue(8)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(4);\nendlabel1195: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6801_0)(uae_u32 opcode) /* Bcc.B #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = (uae_s32)(uae_s8)((opcode >> 8) & 255);\n#else\n\tuae_u32 srcreg = (uae_s32)(uae_s8)(opcode & 255);\n#endif\n{{\tuae_u32 src = srcreg;\n\tif (!cctrue(8)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(2);\nendlabel1196: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_68ff_0)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(8)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel1197: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6900_0)(uae_u32 opcode) /* Bcc.W #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n\tif (!cctrue(9)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(4);\nendlabel1198: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6901_0)(uae_u32 opcode) /* Bcc.B #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = (uae_s32)(uae_s8)((opcode >> 8) & 255);\n#else\n\tuae_u32 srcreg = (uae_s32)(uae_s8)(opcode & 255);\n#endif\n{{\tuae_u32 src = srcreg;\n\tif (!cctrue(9)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(2);\nendlabel1199: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_69ff_0)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(9)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel1200: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6a00_0)(uae_u32 opcode) /* Bcc.W #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n\tif (!cctrue(10)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(4);\nendlabel1201: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6a01_0)(uae_u32 opcode) /* Bcc.B #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = (uae_s32)(uae_s8)((opcode >> 8) & 255);\n#else\n\tuae_u32 srcreg = (uae_s32)(uae_s8)(opcode & 255);\n#endif\n{{\tuae_u32 src = srcreg;\n\tif (!cctrue(10)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(2);\nendlabel1202: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6aff_0)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(10)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel1203: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6b00_0)(uae_u32 opcode) /* Bcc.W #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n\tif (!cctrue(11)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(4);\nendlabel1204: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6b01_0)(uae_u32 opcode) /* Bcc.B #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = (uae_s32)(uae_s8)((opcode >> 8) & 255);\n#else\n\tuae_u32 srcreg = (uae_s32)(uae_s8)(opcode & 255);\n#endif\n{{\tuae_u32 src = srcreg;\n\tif (!cctrue(11)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(2);\nendlabel1205: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6bff_0)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(11)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel1206: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6c00_0)(uae_u32 opcode) /* Bcc.W #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n\tif (!cctrue(12)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(4);\nendlabel1207: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6c01_0)(uae_u32 opcode) /* Bcc.B #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = (uae_s32)(uae_s8)((opcode >> 8) & 255);\n#else\n\tuae_u32 srcreg = (uae_s32)(uae_s8)(opcode & 255);\n#endif\n{{\tuae_u32 src = srcreg;\n\tif (!cctrue(12)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(2);\nendlabel1208: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6cff_0)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(12)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel1209: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6d00_0)(uae_u32 opcode) /* Bcc.W #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n\tif (!cctrue(13)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(4);\nendlabel1210: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6d01_0)(uae_u32 opcode) /* Bcc.B #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = (uae_s32)(uae_s8)((opcode >> 8) & 255);\n#else\n\tuae_u32 srcreg = (uae_s32)(uae_s8)(opcode & 255);\n#endif\n{{\tuae_u32 src = srcreg;\n\tif (!cctrue(13)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(2);\nendlabel1211: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6dff_0)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(13)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel1212: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6e00_0)(uae_u32 opcode) /* Bcc.W #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n\tif (!cctrue(14)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(4);\nendlabel1213: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6e01_0)(uae_u32 opcode) /* Bcc.B #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = (uae_s32)(uae_s8)((opcode >> 8) & 255);\n#else\n\tuae_u32 srcreg = (uae_s32)(uae_s8)(opcode & 255);\n#endif\n{{\tuae_u32 src = srcreg;\n\tif (!cctrue(14)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(2);\nendlabel1214: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6eff_0)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(14)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel1215: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6f00_0)(uae_u32 opcode) /* Bcc.W #<data>.W */\n{\n\tcpuop_begin();\n{{\tuae_s16 src = get_iword(2);\n\tif (!cctrue(15)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(4);\nendlabel1216: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6f01_0)(uae_u32 opcode) /* Bcc.B #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = (uae_s32)(uae_s8)((opcode >> 8) & 255);\n#else\n\tuae_u32 srcreg = (uae_s32)(uae_s8)(opcode & 255);\n#endif\n{{\tuae_u32 src = srcreg;\n\tif (!cctrue(15)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(2);\nendlabel1217: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6fff_0)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(15)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel1218: ;\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_7000_0)(uae_u32 opcode) /* MOVE.L #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = (uae_s32)(uae_s8)((opcode >> 8) & 255);\n#else\n\tuae_u32 srcreg = (uae_s32)(uae_s8)(opcode & 255);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_7100_0)(uae_u32 opcode) /* EMULOP_RETURN.L  */\n{\n\tcpuop_begin();\n{\tm68k_emulop_return();\n}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_7101_0)(uae_u32 opcode) /* EMULOP.L #<data> */\n{\n\tcpuop_begin();\n{\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tm68k_emulop(opcode);\n}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_8000_0)(uae_u32 opcode) /* OR.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8010_0)(uae_u32 opcode) /* OR.B (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8018_0)(uae_u32 opcode) /* OR.B (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8020_0)(uae_u32 opcode) /* OR.B -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8028_0)(uae_u32 opcode) /* OR.B (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8030_0)(uae_u32 opcode) /* OR.B (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8038_0)(uae_u32 opcode) /* OR.B (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8039_0)(uae_u32 opcode) /* OR.B (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_803a_0)(uae_u32 opcode) /* OR.B (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_803b_0)(uae_u32 opcode) /* OR.B (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_803c_0)(uae_u32 opcode) /* OR.B #<data>.B,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8040_0)(uae_u32 opcode) /* OR.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8050_0)(uae_u32 opcode) /* OR.W (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8058_0)(uae_u32 opcode) /* OR.W (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8060_0)(uae_u32 opcode) /* OR.W -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8068_0)(uae_u32 opcode) /* OR.W (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8070_0)(uae_u32 opcode) /* OR.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8078_0)(uae_u32 opcode) /* OR.W (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8079_0)(uae_u32 opcode) /* OR.W (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_807a_0)(uae_u32 opcode) /* OR.W (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_807b_0)(uae_u32 opcode) /* OR.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_807c_0)(uae_u32 opcode) /* OR.W #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8080_0)(uae_u32 opcode) /* OR.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8090_0)(uae_u32 opcode) /* OR.L (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8098_0)(uae_u32 opcode) /* OR.L (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80a0_0)(uae_u32 opcode) /* OR.L -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80a8_0)(uae_u32 opcode) /* OR.L (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80b0_0)(uae_u32 opcode) /* OR.L (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80b8_0)(uae_u32 opcode) /* OR.L (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80b9_0)(uae_u32 opcode) /* OR.L (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80ba_0)(uae_u32 opcode) /* OR.L (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80bb_0)(uae_u32 opcode) /* OR.L (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80bc_0)(uae_u32 opcode) /* OR.L #<data>.L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80c0_0)(uae_u32 opcode) /* DIVU.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(2);\n\tif (src == 0) { SET_VFLG (0); Exception (5, oldpc); goto endlabel1255; } else {\n\tuae_u32 newv = (uae_u32)dst / (uae_u32)(uae_u16)src;\n\tuae_u32 rem = (uae_u32)dst % (uae_u32)(uae_u16)src;\n\tif (newv > 0xffff) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}endlabel1255: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80d0_0)(uae_u32 opcode) /* DIVU.W (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(2);\n\tif (src == 0) { SET_VFLG (0); Exception (5, oldpc); goto endlabel1256; } else {\n\tuae_u32 newv = (uae_u32)dst / (uae_u32)(uae_u16)src;\n\tuae_u32 rem = (uae_u32)dst % (uae_u32)(uae_u16)src;\n\tif (newv > 0xffff) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}endlabel1256: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80d8_0)(uae_u32 opcode) /* DIVU.W (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(2);\n\tif (src == 0) { SET_VFLG (0); Exception (5, oldpc); goto endlabel1257; } else {\n\tuae_u32 newv = (uae_u32)dst / (uae_u32)(uae_u16)src;\n\tuae_u32 rem = (uae_u32)dst % (uae_u32)(uae_u16)src;\n\tif (newv > 0xffff) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}endlabel1257: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80e0_0)(uae_u32 opcode) /* DIVU.W -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(2);\n\tif (src == 0) { SET_VFLG (0); Exception (5, oldpc); goto endlabel1258; } else {\n\tuae_u32 newv = (uae_u32)dst / (uae_u32)(uae_u16)src;\n\tuae_u32 rem = (uae_u32)dst % (uae_u32)(uae_u16)src;\n\tif (newv > 0xffff) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}endlabel1258: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80e8_0)(uae_u32 opcode) /* DIVU.W (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(4);\n\tif (src == 0) { SET_VFLG (0); Exception (5, oldpc); goto endlabel1259; } else {\n\tuae_u32 newv = (uae_u32)dst / (uae_u32)(uae_u16)src;\n\tuae_u32 rem = (uae_u32)dst % (uae_u32)(uae_u16)src;\n\tif (newv > 0xffff) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}endlabel1259: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80f0_0)(uae_u32 opcode) /* DIVU.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tif (src == 0) { SET_VFLG (0); Exception (5, oldpc); goto endlabel1260; } else {\n\tuae_u32 newv = (uae_u32)dst / (uae_u32)(uae_u16)src;\n\tuae_u32 rem = (uae_u32)dst % (uae_u32)(uae_u16)src;\n\tif (newv > 0xffff) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}}endlabel1260: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80f8_0)(uae_u32 opcode) /* DIVU.W (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(4);\n\tif (src == 0) { SET_VFLG (0); Exception (5, oldpc); goto endlabel1261; } else {\n\tuae_u32 newv = (uae_u32)dst / (uae_u32)(uae_u16)src;\n\tuae_u32 rem = (uae_u32)dst % (uae_u32)(uae_u16)src;\n\tif (newv > 0xffff) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}endlabel1261: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80f9_0)(uae_u32 opcode) /* DIVU.W (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(6);\n\tif (src == 0) { SET_VFLG (0); Exception (5, oldpc); goto endlabel1262; } else {\n\tuae_u32 newv = (uae_u32)dst / (uae_u32)(uae_u16)src;\n\tuae_u32 rem = (uae_u32)dst % (uae_u32)(uae_u16)src;\n\tif (newv > 0xffff) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}endlabel1262: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80fa_0)(uae_u32 opcode) /* DIVU.W (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(4);\n\tif (src == 0) { SET_VFLG (0); Exception (5, oldpc); goto endlabel1263; } else {\n\tuae_u32 newv = (uae_u32)dst / (uae_u32)(uae_u16)src;\n\tuae_u32 rem = (uae_u32)dst % (uae_u32)(uae_u16)src;\n\tif (newv > 0xffff) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}endlabel1263: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80fb_0)(uae_u32 opcode) /* DIVU.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tif (src == 0) { SET_VFLG (0); Exception (5, oldpc); goto endlabel1264; } else {\n\tuae_u32 newv = (uae_u32)dst / (uae_u32)(uae_u16)src;\n\tuae_u32 rem = (uae_u32)dst % (uae_u32)(uae_u16)src;\n\tif (newv > 0xffff) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}}endlabel1264: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80fc_0)(uae_u32 opcode) /* DIVU.W #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 src = get_iword(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(4);\n\tif (src == 0) { SET_VFLG (0); Exception (5, oldpc); goto endlabel1265; } else {\n\tuae_u32 newv = (uae_u32)dst / (uae_u32)(uae_u16)src;\n\tuae_u32 rem = (uae_u32)dst % (uae_u32)(uae_u16)src;\n\tif (newv > 0xffff) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}endlabel1265: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8100_0)(uae_u32 opcode) /* SBCD.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{\tuae_u16 newv_lo = (dst & 0xF) - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = (dst & 0xF0) - (src & 0xF0);\n\tuae_u16 newv, tmp_newv;\n\tint bcd = 0;\n\tnewv = tmp_newv = newv_hi + newv_lo;\n\tif (newv_lo & 0xF0) { newv -= 6; bcd = 6; };\n\tif ((((dst & 0xFF) - (src & 0xFF) - (GET_XFLG ? 1 : 0)) & 0x100) > 0xFF) { newv -= 0x60; }\n\tSET_CFLG ((((dst & 0xFF) - (src & 0xFF) - bcd - (GET_XFLG ? 1 : 0)) & 0x300) > 0xFF);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8108_0)(uae_u32 opcode) /* SBCD.B -(An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{\tuae_u16 newv_lo = (dst & 0xF) - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = (dst & 0xF0) - (src & 0xF0);\n\tuae_u16 newv, tmp_newv;\n\tint bcd = 0;\n\tnewv = tmp_newv = newv_hi + newv_lo;\n\tif (newv_lo & 0xF0) { newv -= 6; bcd = 6; };\n\tif ((((dst & 0xFF) - (src & 0xFF) - (GET_XFLG ? 1 : 0)) & 0x100) > 0xFF) { newv -= 0x60; }\n\tSET_CFLG ((((dst & 0xFF) - (src & 0xFF) - bcd - (GET_XFLG ? 1 : 0)) & 0x300) > 0xFF);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tput_byte(dsta,newv);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8110_0)(uae_u32 opcode) /* OR.B Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8118_0)(uae_u32 opcode) /* OR.B Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8120_0)(uae_u32 opcode) /* OR.B Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8128_0)(uae_u32 opcode) /* OR.B Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8130_0)(uae_u32 opcode) /* OR.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8138_0)(uae_u32 opcode) /* OR.B Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8139_0)(uae_u32 opcode) /* OR.B Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_8140_0)(uae_u32 opcode) /* PACK.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuae_u16 val = m68k_dreg(regs, srcreg) + get_iword(2);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & 0xffffff00) | ((val >> 4) & 0xf0) | (val & 0xf);\n}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_8148_0)(uae_u32 opcode) /* PACK.L -(An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuae_u16 val;\n\tm68k_areg(regs, srcreg) -= areg_byteinc[srcreg];\n\tval = (uae_u16)get_byte(m68k_areg(regs, srcreg));\n\tm68k_areg(regs, srcreg) -= areg_byteinc[srcreg];\n\tval = (val | ((uae_u16)get_byte(m68k_areg(regs, srcreg)) << 8)) + get_iword(2);\n\tm68k_areg(regs, dstreg) -= areg_byteinc[dstreg];\n\tput_byte(m68k_areg(regs, dstreg),((val >> 4) & 0xf0) | (val & 0xf));\n}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_8150_0)(uae_u32 opcode) /* OR.W Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8158_0)(uae_u32 opcode) /* OR.W Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg(regs, dstreg) += 2;\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8160_0)(uae_u32 opcode) /* OR.W Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8168_0)(uae_u32 opcode) /* OR.W Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8170_0)(uae_u32 opcode) /* OR.W Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s16 dst = get_word(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8178_0)(uae_u32 opcode) /* OR.W Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8179_0)(uae_u32 opcode) /* OR.W Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_8180_0)(uae_u32 opcode) /* UNPK.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuae_u16 val = m68k_dreg(regs, srcreg);\n\tval = (((val << 4) & 0xf00) | (val & 0xf)) + get_iword(2);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & 0xffff0000) | (val & 0xffff);\n}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_8188_0)(uae_u32 opcode) /* UNPK.L -(An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuae_u16 val;\n\tm68k_areg(regs, srcreg) -= areg_byteinc[srcreg];\n\tval = (uae_u16)get_byte(m68k_areg(regs, srcreg));\n\tval = (((val << 4) & 0xf00) | (val & 0xf)) + get_iword(2);\n\tm68k_areg(regs, dstreg) -= areg_byteinc[dstreg];\n\tput_byte(m68k_areg(regs, dstreg),val);\n\tm68k_areg(regs, dstreg) -= areg_byteinc[dstreg];\n\tput_byte(m68k_areg(regs, dstreg),val >> 8);\n}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_8190_0)(uae_u32 opcode) /* OR.L Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8198_0)(uae_u32 opcode) /* OR.L Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg(regs, dstreg) += 4;\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81a0_0)(uae_u32 opcode) /* OR.L Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81a8_0)(uae_u32 opcode) /* OR.L Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81b0_0)(uae_u32 opcode) /* OR.L Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 dst = get_long(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81b8_0)(uae_u32 opcode) /* OR.L Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81b9_0)(uae_u32 opcode) /* OR.L Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81c0_0)(uae_u32 opcode) /* DIVS.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(2);\n\tif (src == 0) { SET_VFLG (0); Exception(5,oldpc); goto endlabel1293; } else {\n\tuae_s32 newv = (uae_s32)dst / (uae_s32)(uae_s16)src;\n\tuae_u16 rem = (uae_s32)dst % (uae_s32)(uae_s16)src;\n\tif ((newv & 0xffff8000) != 0 && (newv & 0xffff8000) != 0xffff8000) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tif (((uae_s16)rem < 0) != ((uae_s32)dst < 0)) rem = -rem;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}endlabel1293: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81d0_0)(uae_u32 opcode) /* DIVS.W (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(2);\n\tif (src == 0) { SET_VFLG (0); Exception(5,oldpc); goto endlabel1294; } else {\n\tuae_s32 newv = (uae_s32)dst / (uae_s32)(uae_s16)src;\n\tuae_u16 rem = (uae_s32)dst % (uae_s32)(uae_s16)src;\n\tif ((newv & 0xffff8000) != 0 && (newv & 0xffff8000) != 0xffff8000) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tif (((uae_s16)rem < 0) != ((uae_s32)dst < 0)) rem = -rem;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}endlabel1294: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81d8_0)(uae_u32 opcode) /* DIVS.W (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(2);\n\tif (src == 0) { SET_VFLG (0); Exception(5,oldpc); goto endlabel1295; } else {\n\tuae_s32 newv = (uae_s32)dst / (uae_s32)(uae_s16)src;\n\tuae_u16 rem = (uae_s32)dst % (uae_s32)(uae_s16)src;\n\tif ((newv & 0xffff8000) != 0 && (newv & 0xffff8000) != 0xffff8000) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tif (((uae_s16)rem < 0) != ((uae_s32)dst < 0)) rem = -rem;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}endlabel1295: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81e0_0)(uae_u32 opcode) /* DIVS.W -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(2);\n\tif (src == 0) { SET_VFLG (0); Exception(5,oldpc); goto endlabel1296; } else {\n\tuae_s32 newv = (uae_s32)dst / (uae_s32)(uae_s16)src;\n\tuae_u16 rem = (uae_s32)dst % (uae_s32)(uae_s16)src;\n\tif ((newv & 0xffff8000) != 0 && (newv & 0xffff8000) != 0xffff8000) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tif (((uae_s16)rem < 0) != ((uae_s32)dst < 0)) rem = -rem;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}endlabel1296: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81e8_0)(uae_u32 opcode) /* DIVS.W (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(4);\n\tif (src == 0) { SET_VFLG (0); Exception(5,oldpc); goto endlabel1297; } else {\n\tuae_s32 newv = (uae_s32)dst / (uae_s32)(uae_s16)src;\n\tuae_u16 rem = (uae_s32)dst % (uae_s32)(uae_s16)src;\n\tif ((newv & 0xffff8000) != 0 && (newv & 0xffff8000) != 0xffff8000) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tif (((uae_s16)rem < 0) != ((uae_s32)dst < 0)) rem = -rem;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}endlabel1297: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81f0_0)(uae_u32 opcode) /* DIVS.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tif (src == 0) { SET_VFLG (0); Exception(5,oldpc); goto endlabel1298; } else {\n\tuae_s32 newv = (uae_s32)dst / (uae_s32)(uae_s16)src;\n\tuae_u16 rem = (uae_s32)dst % (uae_s32)(uae_s16)src;\n\tif ((newv & 0xffff8000) != 0 && (newv & 0xffff8000) != 0xffff8000) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tif (((uae_s16)rem < 0) != ((uae_s32)dst < 0)) rem = -rem;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}}endlabel1298: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81f8_0)(uae_u32 opcode) /* DIVS.W (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(4);\n\tif (src == 0) { SET_VFLG (0); Exception(5,oldpc); goto endlabel1299; } else {\n\tuae_s32 newv = (uae_s32)dst / (uae_s32)(uae_s16)src;\n\tuae_u16 rem = (uae_s32)dst % (uae_s32)(uae_s16)src;\n\tif ((newv & 0xffff8000) != 0 && (newv & 0xffff8000) != 0xffff8000) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tif (((uae_s16)rem < 0) != ((uae_s32)dst < 0)) rem = -rem;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}endlabel1299: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81f9_0)(uae_u32 opcode) /* DIVS.W (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(6);\n\tif (src == 0) { SET_VFLG (0); Exception(5,oldpc); goto endlabel1300; } else {\n\tuae_s32 newv = (uae_s32)dst / (uae_s32)(uae_s16)src;\n\tuae_u16 rem = (uae_s32)dst % (uae_s32)(uae_s16)src;\n\tif ((newv & 0xffff8000) != 0 && (newv & 0xffff8000) != 0xffff8000) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tif (((uae_s16)rem < 0) != ((uae_s32)dst < 0)) rem = -rem;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}endlabel1300: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81fa_0)(uae_u32 opcode) /* DIVS.W (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(4);\n\tif (src == 0) { SET_VFLG (0); Exception(5,oldpc); goto endlabel1301; } else {\n\tuae_s32 newv = (uae_s32)dst / (uae_s32)(uae_s16)src;\n\tuae_u16 rem = (uae_s32)dst % (uae_s32)(uae_s16)src;\n\tif ((newv & 0xffff8000) != 0 && (newv & 0xffff8000) != 0xffff8000) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tif (((uae_s16)rem < 0) != ((uae_s32)dst < 0)) rem = -rem;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}endlabel1301: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81fb_0)(uae_u32 opcode) /* DIVS.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tif (src == 0) { SET_VFLG (0); Exception(5,oldpc); goto endlabel1302; } else {\n\tuae_s32 newv = (uae_s32)dst / (uae_s32)(uae_s16)src;\n\tuae_u16 rem = (uae_s32)dst % (uae_s32)(uae_s16)src;\n\tif ((newv & 0xffff8000) != 0 && (newv & 0xffff8000) != 0xffff8000) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tif (((uae_s16)rem < 0) != ((uae_s32)dst < 0)) rem = -rem;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}}endlabel1302: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81fc_0)(uae_u32 opcode) /* DIVS.W #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 src = get_iword(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(4);\n\tif (src == 0) { SET_VFLG (0); Exception(5,oldpc); goto endlabel1303; } else {\n\tuae_s32 newv = (uae_s32)dst / (uae_s32)(uae_s16)src;\n\tuae_u16 rem = (uae_s32)dst % (uae_s32)(uae_s16)src;\n\tif ((newv & 0xffff8000) != 0 && (newv & 0xffff8000) != 0xffff8000) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tif (((uae_s16)rem < 0) != ((uae_s32)dst < 0)) rem = -rem;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}endlabel1303: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9000_0)(uae_u32 opcode) /* SUB.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9010_0)(uae_u32 opcode) /* SUB.B (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9018_0)(uae_u32 opcode) /* SUB.B (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9020_0)(uae_u32 opcode) /* SUB.B -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9028_0)(uae_u32 opcode) /* SUB.B (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9030_0)(uae_u32 opcode) /* SUB.B (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9038_0)(uae_u32 opcode) /* SUB.B (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9039_0)(uae_u32 opcode) /* SUB.B (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_903a_0)(uae_u32 opcode) /* SUB.B (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_903b_0)(uae_u32 opcode) /* SUB.B (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_903c_0)(uae_u32 opcode) /* SUB.B #<data>.B,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9040_0)(uae_u32 opcode) /* SUB.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9048_0)(uae_u32 opcode) /* SUB.W An,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_areg(regs, srcreg);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9050_0)(uae_u32 opcode) /* SUB.W (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9058_0)(uae_u32 opcode) /* SUB.W (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9060_0)(uae_u32 opcode) /* SUB.W -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9068_0)(uae_u32 opcode) /* SUB.W (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9070_0)(uae_u32 opcode) /* SUB.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9078_0)(uae_u32 opcode) /* SUB.W (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9079_0)(uae_u32 opcode) /* SUB.W (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_907a_0)(uae_u32 opcode) /* SUB.W (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_907b_0)(uae_u32 opcode) /* SUB.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_907c_0)(uae_u32 opcode) /* SUB.W #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9080_0)(uae_u32 opcode) /* SUB.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9088_0)(uae_u32 opcode) /* SUB.L An,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9090_0)(uae_u32 opcode) /* SUB.L (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9098_0)(uae_u32 opcode) /* SUB.L (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_90a0_0)(uae_u32 opcode) /* SUB.L -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_90a8_0)(uae_u32 opcode) /* SUB.L (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_90b0_0)(uae_u32 opcode) /* SUB.L (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_90b8_0)(uae_u32 opcode) /* SUB.L (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_90b9_0)(uae_u32 opcode) /* SUB.L (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_90ba_0)(uae_u32 opcode) /* SUB.L (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_90bb_0)(uae_u32 opcode) /* SUB.L (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_90bc_0)(uae_u32 opcode) /* SUB.L #<data>.L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_90c0_0)(uae_u32 opcode) /* SUBA.W Dn,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_90c8_0)(uae_u32 opcode) /* SUBA.W An,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_areg(regs, srcreg);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_90d0_0)(uae_u32 opcode) /* SUBA.W (An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_90d8_0)(uae_u32 opcode) /* SUBA.W (An)+,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_90e0_0)(uae_u32 opcode) /* SUBA.W -(An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_90e8_0)(uae_u32 opcode) /* SUBA.W (d16,An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_90f0_0)(uae_u32 opcode) /* SUBA.W (d8,An,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_90f8_0)(uae_u32 opcode) /* SUBA.W (xxx).W,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_90f9_0)(uae_u32 opcode) /* SUBA.W (xxx).L,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_90fa_0)(uae_u32 opcode) /* SUBA.W (d16,PC),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_90fb_0)(uae_u32 opcode) /* SUBA.W (d8,PC,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_90fc_0)(uae_u32 opcode) /* SUBA.W #<data>.W,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_9100_0)(uae_u32 opcode) /* SUBX.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = dst - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9108_0)(uae_u32 opcode) /* SUBX.B -(An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{\tuae_u32 newv = dst - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9110_0)(uae_u32 opcode) /* SUB.B Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9118_0)(uae_u32 opcode) /* SUB.B Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9120_0)(uae_u32 opcode) /* SUB.B Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9128_0)(uae_u32 opcode) /* SUB.B Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9130_0)(uae_u32 opcode) /* SUB.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9138_0)(uae_u32 opcode) /* SUB.B Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9139_0)(uae_u32 opcode) /* SUB.B Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9140_0)(uae_u32 opcode) /* SUBX.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = dst - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s16)(newv)) == 0));\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9148_0)(uae_u32 opcode) /* SUBX.W -(An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{\tuae_u32 newv = dst - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s16)(newv)) == 0));\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9150_0)(uae_u32 opcode) /* SUB.W Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9158_0)(uae_u32 opcode) /* SUB.W Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg(regs, dstreg) += 2;\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9160_0)(uae_u32 opcode) /* SUB.W Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9168_0)(uae_u32 opcode) /* SUB.W Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9170_0)(uae_u32 opcode) /* SUB.W Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9178_0)(uae_u32 opcode) /* SUB.W Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9179_0)(uae_u32 opcode) /* SUB.W Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9180_0)(uae_u32 opcode) /* SUBX.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = dst - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s32)(newv)) == 0));\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9188_0)(uae_u32 opcode) /* SUBX.L -(An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{\tuae_u32 newv = dst - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s32)(newv)) == 0));\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9190_0)(uae_u32 opcode) /* SUB.L Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9198_0)(uae_u32 opcode) /* SUB.L Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg(regs, dstreg) += 4;\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_91a0_0)(uae_u32 opcode) /* SUB.L Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_91a8_0)(uae_u32 opcode) /* SUB.L Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_91b0_0)(uae_u32 opcode) /* SUB.L Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_91b8_0)(uae_u32 opcode) /* SUB.L Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_91b9_0)(uae_u32 opcode) /* SUB.L Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_91c0_0)(uae_u32 opcode) /* SUBA.L Dn,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_91c8_0)(uae_u32 opcode) /* SUBA.L An,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_91d0_0)(uae_u32 opcode) /* SUBA.L (An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_91d8_0)(uae_u32 opcode) /* SUBA.L (An)+,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_91e0_0)(uae_u32 opcode) /* SUBA.L -(An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_91e8_0)(uae_u32 opcode) /* SUBA.L (d16,An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_91f0_0)(uae_u32 opcode) /* SUBA.L (d8,An,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_91f8_0)(uae_u32 opcode) /* SUBA.L (xxx).W,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_91f9_0)(uae_u32 opcode) /* SUBA.L (xxx).L,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_91fa_0)(uae_u32 opcode) /* SUBA.L (d16,PC),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_91fb_0)(uae_u32 opcode) /* SUBA.L (d8,PC,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_91fc_0)(uae_u32 opcode) /* SUBA.L #<data>.L,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_b000_0)(uae_u32 opcode) /* CMP.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b010_0)(uae_u32 opcode) /* CMP.B (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b018_0)(uae_u32 opcode) /* CMP.B (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b020_0)(uae_u32 opcode) /* CMP.B -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b028_0)(uae_u32 opcode) /* CMP.B (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b030_0)(uae_u32 opcode) /* CMP.B (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b038_0)(uae_u32 opcode) /* CMP.B (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b039_0)(uae_u32 opcode) /* CMP.B (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b03a_0)(uae_u32 opcode) /* CMP.B (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b03b_0)(uae_u32 opcode) /* CMP.B (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b03c_0)(uae_u32 opcode) /* CMP.B #<data>.B,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b040_0)(uae_u32 opcode) /* CMP.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n#endif\n\n#ifdef PART_7\nvoid REGPARAM2 CPUFUNC(op_b048_0)(uae_u32 opcode) /* CMP.W An,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_areg(regs, srcreg);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b050_0)(uae_u32 opcode) /* CMP.W (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b058_0)(uae_u32 opcode) /* CMP.W (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b060_0)(uae_u32 opcode) /* CMP.W -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b068_0)(uae_u32 opcode) /* CMP.W (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b070_0)(uae_u32 opcode) /* CMP.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b078_0)(uae_u32 opcode) /* CMP.W (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b079_0)(uae_u32 opcode) /* CMP.W (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b07a_0)(uae_u32 opcode) /* CMP.W (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b07b_0)(uae_u32 opcode) /* CMP.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b07c_0)(uae_u32 opcode) /* CMP.W #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b080_0)(uae_u32 opcode) /* CMP.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b088_0)(uae_u32 opcode) /* CMP.L An,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b090_0)(uae_u32 opcode) /* CMP.L (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b098_0)(uae_u32 opcode) /* CMP.L (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0a0_0)(uae_u32 opcode) /* CMP.L -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0a8_0)(uae_u32 opcode) /* CMP.L (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0b0_0)(uae_u32 opcode) /* CMP.L (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0b8_0)(uae_u32 opcode) /* CMP.L (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0b9_0)(uae_u32 opcode) /* CMP.L (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0ba_0)(uae_u32 opcode) /* CMP.L (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0bb_0)(uae_u32 opcode) /* CMP.L (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0bc_0)(uae_u32 opcode) /* CMP.L #<data>.L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0c0_0)(uae_u32 opcode) /* CMPA.W Dn,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0c8_0)(uae_u32 opcode) /* CMPA.W An,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_areg(regs, srcreg);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0d0_0)(uae_u32 opcode) /* CMPA.W (An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0d8_0)(uae_u32 opcode) /* CMPA.W (An)+,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0e0_0)(uae_u32 opcode) /* CMPA.W -(An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0e8_0)(uae_u32 opcode) /* CMPA.W (d16,An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0f0_0)(uae_u32 opcode) /* CMPA.W (d8,An,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0f8_0)(uae_u32 opcode) /* CMPA.W (xxx).W,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0f9_0)(uae_u32 opcode) /* CMPA.W (xxx).L,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0fa_0)(uae_u32 opcode) /* CMPA.W (d16,PC),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0fb_0)(uae_u32 opcode) /* CMPA.W (d8,PC,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0fc_0)(uae_u32 opcode) /* CMPA.W #<data>.W,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b100_0)(uae_u32 opcode) /* EOR.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b108_0)(uae_u32 opcode) /* CMPM.B (An)+,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b110_0)(uae_u32 opcode) /* EOR.B Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b118_0)(uae_u32 opcode) /* EOR.B Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b120_0)(uae_u32 opcode) /* EOR.B Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b128_0)(uae_u32 opcode) /* EOR.B Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b130_0)(uae_u32 opcode) /* EOR.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b138_0)(uae_u32 opcode) /* EOR.B Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b139_0)(uae_u32 opcode) /* EOR.B Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b140_0)(uae_u32 opcode) /* EOR.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b148_0)(uae_u32 opcode) /* CMPM.W (An)+,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg(regs, dstreg) += 2;\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b150_0)(uae_u32 opcode) /* EOR.W Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b158_0)(uae_u32 opcode) /* EOR.W Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg(regs, dstreg) += 2;\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b160_0)(uae_u32 opcode) /* EOR.W Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b168_0)(uae_u32 opcode) /* EOR.W Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b170_0)(uae_u32 opcode) /* EOR.W Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s16 dst = get_word(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b178_0)(uae_u32 opcode) /* EOR.W Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b179_0)(uae_u32 opcode) /* EOR.W Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b180_0)(uae_u32 opcode) /* EOR.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b188_0)(uae_u32 opcode) /* CMPM.L (An)+,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg(regs, dstreg) += 4;\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b190_0)(uae_u32 opcode) /* EOR.L Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b198_0)(uae_u32 opcode) /* EOR.L Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg(regs, dstreg) += 4;\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1a0_0)(uae_u32 opcode) /* EOR.L Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1a8_0)(uae_u32 opcode) /* EOR.L Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1b0_0)(uae_u32 opcode) /* EOR.L Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 dst = get_long(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1b8_0)(uae_u32 opcode) /* EOR.L Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1b9_0)(uae_u32 opcode) /* EOR.L Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1c0_0)(uae_u32 opcode) /* CMPA.L Dn,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1c8_0)(uae_u32 opcode) /* CMPA.L An,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1d0_0)(uae_u32 opcode) /* CMPA.L (An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1d8_0)(uae_u32 opcode) /* CMPA.L (An)+,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1e0_0)(uae_u32 opcode) /* CMPA.L -(An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1e8_0)(uae_u32 opcode) /* CMPA.L (d16,An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1f0_0)(uae_u32 opcode) /* CMPA.L (d8,An,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1f8_0)(uae_u32 opcode) /* CMPA.L (xxx).W,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1f9_0)(uae_u32 opcode) /* CMPA.L (xxx).L,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1fa_0)(uae_u32 opcode) /* CMPA.L (d16,PC),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1fb_0)(uae_u32 opcode) /* CMPA.L (d8,PC,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1fc_0)(uae_u32 opcode) /* CMPA.L #<data>.L,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c000_0)(uae_u32 opcode) /* AND.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c010_0)(uae_u32 opcode) /* AND.B (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c018_0)(uae_u32 opcode) /* AND.B (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c020_0)(uae_u32 opcode) /* AND.B -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c028_0)(uae_u32 opcode) /* AND.B (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c030_0)(uae_u32 opcode) /* AND.B (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c038_0)(uae_u32 opcode) /* AND.B (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c039_0)(uae_u32 opcode) /* AND.B (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c03a_0)(uae_u32 opcode) /* AND.B (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c03b_0)(uae_u32 opcode) /* AND.B (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c03c_0)(uae_u32 opcode) /* AND.B #<data>.B,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c040_0)(uae_u32 opcode) /* AND.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c050_0)(uae_u32 opcode) /* AND.W (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c058_0)(uae_u32 opcode) /* AND.W (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c060_0)(uae_u32 opcode) /* AND.W -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c068_0)(uae_u32 opcode) /* AND.W (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c070_0)(uae_u32 opcode) /* AND.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c078_0)(uae_u32 opcode) /* AND.W (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c079_0)(uae_u32 opcode) /* AND.W (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c07a_0)(uae_u32 opcode) /* AND.W (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c07b_0)(uae_u32 opcode) /* AND.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c07c_0)(uae_u32 opcode) /* AND.W #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c080_0)(uae_u32 opcode) /* AND.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c090_0)(uae_u32 opcode) /* AND.L (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c098_0)(uae_u32 opcode) /* AND.L (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0a0_0)(uae_u32 opcode) /* AND.L -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0a8_0)(uae_u32 opcode) /* AND.L (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0b0_0)(uae_u32 opcode) /* AND.L (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0b8_0)(uae_u32 opcode) /* AND.L (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0b9_0)(uae_u32 opcode) /* AND.L (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0ba_0)(uae_u32 opcode) /* AND.L (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0bb_0)(uae_u32 opcode) /* AND.L (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0bc_0)(uae_u32 opcode) /* AND.L #<data>.L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0c0_0)(uae_u32 opcode) /* MULU.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_u32)(uae_u16)dst * (uae_u32)(uae_u16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0d0_0)(uae_u32 opcode) /* MULU.W (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_u32)(uae_u16)dst * (uae_u32)(uae_u16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0d8_0)(uae_u32 opcode) /* MULU.W (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_u32)(uae_u16)dst * (uae_u32)(uae_u16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0e0_0)(uae_u32 opcode) /* MULU.W -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_u32)(uae_u16)dst * (uae_u32)(uae_u16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0e8_0)(uae_u32 opcode) /* MULU.W (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_u32)(uae_u16)dst * (uae_u32)(uae_u16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0f0_0)(uae_u32 opcode) /* MULU.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_u32)(uae_u16)dst * (uae_u32)(uae_u16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0f8_0)(uae_u32 opcode) /* MULU.W (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_u32)(uae_u16)dst * (uae_u32)(uae_u16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0f9_0)(uae_u32 opcode) /* MULU.W (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_u32)(uae_u16)dst * (uae_u32)(uae_u16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0fa_0)(uae_u32 opcode) /* MULU.W (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_u32)(uae_u16)dst * (uae_u32)(uae_u16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0fb_0)(uae_u32 opcode) /* MULU.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_u32)(uae_u16)dst * (uae_u32)(uae_u16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0fc_0)(uae_u32 opcode) /* MULU.W #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_u32)(uae_u16)dst * (uae_u32)(uae_u16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c100_0)(uae_u32 opcode) /* ABCD.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{\tuae_u16 newv_lo = (src & 0xF) + (dst & 0xF) + (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = (src & 0xF0) + (dst & 0xF0);\n\tuae_u16 newv, tmp_newv;\n\tint cflg;\n\tnewv = tmp_newv = newv_hi + newv_lo;\n\tif (newv_lo > 9) { newv += 6; }\n\tcflg = (newv & 0x3F0) > 0x90;\n\tif (cflg) newv += 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c108_0)(uae_u32 opcode) /* ABCD.B -(An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{\tuae_u16 newv_lo = (src & 0xF) + (dst & 0xF) + (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = (src & 0xF0) + (dst & 0xF0);\n\tuae_u16 newv, tmp_newv;\n\tint cflg;\n\tnewv = tmp_newv = newv_hi + newv_lo;\n\tif (newv_lo > 9) { newv += 6; }\n\tcflg = (newv & 0x3F0) > 0x90;\n\tif (cflg) newv += 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tput_byte(dsta,newv);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c110_0)(uae_u32 opcode) /* AND.B Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c118_0)(uae_u32 opcode) /* AND.B Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c120_0)(uae_u32 opcode) /* AND.B Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c128_0)(uae_u32 opcode) /* AND.B Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c130_0)(uae_u32 opcode) /* AND.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c138_0)(uae_u32 opcode) /* AND.B Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c139_0)(uae_u32 opcode) /* AND.B Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_c140_0)(uae_u32 opcode) /* EXG.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tm68k_dreg(regs, srcreg) = (dst);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_c148_0)(uae_u32 opcode) /* EXG.L An,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, srcreg) = (dst);\n\tm68k_areg(regs, dstreg) = (src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_c150_0)(uae_u32 opcode) /* AND.W Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c158_0)(uae_u32 opcode) /* AND.W Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg(regs, dstreg) += 2;\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c160_0)(uae_u32 opcode) /* AND.W Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c168_0)(uae_u32 opcode) /* AND.W Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c170_0)(uae_u32 opcode) /* AND.W Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s16 dst = get_word(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c178_0)(uae_u32 opcode) /* AND.W Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c179_0)(uae_u32 opcode) /* AND.W Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s16 dst = get_word(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_c188_0)(uae_u32 opcode) /* EXG.L Dn,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n\tm68k_dreg(regs, srcreg) = (dst);\n\tm68k_areg(regs, dstreg) = (src);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_c190_0)(uae_u32 opcode) /* AND.L Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c198_0)(uae_u32 opcode) /* AND.L Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg(regs, dstreg) += 4;\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1a0_0)(uae_u32 opcode) /* AND.L Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1a8_0)(uae_u32 opcode) /* AND.L Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1b0_0)(uae_u32 opcode) /* AND.L Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 dst = get_long(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1b8_0)(uae_u32 opcode) /* AND.L Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1b9_0)(uae_u32 opcode) /* AND.L Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s32 dst = get_long(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1c0_0)(uae_u32 opcode) /* MULS.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_s32)(uae_s16)dst * (uae_s32)(uae_s16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1d0_0)(uae_u32 opcode) /* MULS.W (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_s32)(uae_s16)dst * (uae_s32)(uae_s16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1d8_0)(uae_u32 opcode) /* MULS.W (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_s32)(uae_s16)dst * (uae_s32)(uae_s16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1e0_0)(uae_u32 opcode) /* MULS.W -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_s32)(uae_s16)dst * (uae_s32)(uae_s16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1e8_0)(uae_u32 opcode) /* MULS.W (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_s32)(uae_s16)dst * (uae_s32)(uae_s16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1f0_0)(uae_u32 opcode) /* MULS.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_s32)(uae_s16)dst * (uae_s32)(uae_s16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1f8_0)(uae_u32 opcode) /* MULS.W (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_s32)(uae_s16)dst * (uae_s32)(uae_s16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1f9_0)(uae_u32 opcode) /* MULS.W (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_s32)(uae_s16)dst * (uae_s32)(uae_s16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1fa_0)(uae_u32 opcode) /* MULS.W (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_s32)(uae_s16)dst * (uae_s32)(uae_s16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1fb_0)(uae_u32 opcode) /* MULS.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_s32)(uae_s16)dst * (uae_s32)(uae_s16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1fc_0)(uae_u32 opcode) /* MULS.W #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_s32)(uae_s16)dst * (uae_s32)(uae_s16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d000_0)(uae_u32 opcode) /* ADD.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d010_0)(uae_u32 opcode) /* ADD.B (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d018_0)(uae_u32 opcode) /* ADD.B (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d020_0)(uae_u32 opcode) /* ADD.B -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d028_0)(uae_u32 opcode) /* ADD.B (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d030_0)(uae_u32 opcode) /* ADD.B (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d038_0)(uae_u32 opcode) /* ADD.B (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d039_0)(uae_u32 opcode) /* ADD.B (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d03a_0)(uae_u32 opcode) /* ADD.B (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d03b_0)(uae_u32 opcode) /* ADD.B (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d03c_0)(uae_u32 opcode) /* ADD.B #<data>.B,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d040_0)(uae_u32 opcode) /* ADD.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d048_0)(uae_u32 opcode) /* ADD.W An,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_areg(regs, srcreg);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d050_0)(uae_u32 opcode) /* ADD.W (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d058_0)(uae_u32 opcode) /* ADD.W (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d060_0)(uae_u32 opcode) /* ADD.W -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d068_0)(uae_u32 opcode) /* ADD.W (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d070_0)(uae_u32 opcode) /* ADD.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d078_0)(uae_u32 opcode) /* ADD.W (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d079_0)(uae_u32 opcode) /* ADD.W (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d07a_0)(uae_u32 opcode) /* ADD.W (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d07b_0)(uae_u32 opcode) /* ADD.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d07c_0)(uae_u32 opcode) /* ADD.W #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d080_0)(uae_u32 opcode) /* ADD.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d088_0)(uae_u32 opcode) /* ADD.L An,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d090_0)(uae_u32 opcode) /* ADD.L (An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d098_0)(uae_u32 opcode) /* ADD.L (An)+,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d0a0_0)(uae_u32 opcode) /* ADD.L -(An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d0a8_0)(uae_u32 opcode) /* ADD.L (d16,An),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d0b0_0)(uae_u32 opcode) /* ADD.L (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d0b8_0)(uae_u32 opcode) /* ADD.L (xxx).W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d0b9_0)(uae_u32 opcode) /* ADD.L (xxx).L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d0ba_0)(uae_u32 opcode) /* ADD.L (d16,PC),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d0bb_0)(uae_u32 opcode) /* ADD.L (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d0bc_0)(uae_u32 opcode) /* ADD.L #<data>.L,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d0c0_0)(uae_u32 opcode) /* ADDA.W Dn,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d0c8_0)(uae_u32 opcode) /* ADDA.W An,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_areg(regs, srcreg);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d0d0_0)(uae_u32 opcode) /* ADDA.W (An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d0d8_0)(uae_u32 opcode) /* ADDA.W (An)+,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d0e0_0)(uae_u32 opcode) /* ADDA.W -(An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d0e8_0)(uae_u32 opcode) /* ADDA.W (d16,An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d0f0_0)(uae_u32 opcode) /* ADDA.W (d8,An,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d0f8_0)(uae_u32 opcode) /* ADDA.W (xxx).W,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d0f9_0)(uae_u32 opcode) /* ADDA.W (xxx).L,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d0fa_0)(uae_u32 opcode) /* ADDA.W (d16,PC),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d0fb_0)(uae_u32 opcode) /* ADDA.W (d8,PC,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d0fc_0)(uae_u32 opcode) /* ADDA.W #<data>.W,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_d100_0)(uae_u32 opcode) /* ADDX.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = dst + src + (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgo) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d108_0)(uae_u32 opcode) /* ADDX.B -(An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{\tuae_u32 newv = dst + src + (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgo) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d110_0)(uae_u32 opcode) /* ADD.B Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d118_0)(uae_u32 opcode) /* ADD.B Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d120_0)(uae_u32 opcode) /* ADD.B Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d128_0)(uae_u32 opcode) /* ADD.B Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d130_0)(uae_u32 opcode) /* ADD.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d138_0)(uae_u32 opcode) /* ADD.B Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d139_0)(uae_u32 opcode) /* ADD.B Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d140_0)(uae_u32 opcode) /* ADDX.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = dst + src + (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgo) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s16)(newv)) == 0));\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d148_0)(uae_u32 opcode) /* ADDX.W -(An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{\tuae_u32 newv = dst + src + (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgo) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s16)(newv)) == 0));\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d150_0)(uae_u32 opcode) /* ADD.W Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d158_0)(uae_u32 opcode) /* ADD.W Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg(regs, dstreg) += 2;\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d160_0)(uae_u32 opcode) /* ADD.W Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n{\tuae_s16 dst = get_word(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d168_0)(uae_u32 opcode) /* ADD.W Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d170_0)(uae_u32 opcode) /* ADD.W Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d178_0)(uae_u32 opcode) /* ADD.W Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d179_0)(uae_u32 opcode) /* ADD.W Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d180_0)(uae_u32 opcode) /* ADDX.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = dst + src + (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgo) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s32)(newv)) == 0));\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d188_0)(uae_u32 opcode) /* ADDX.L -(An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{\tuae_u32 newv = dst + src + (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgo) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s32)(newv)) == 0));\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d190_0)(uae_u32 opcode) /* ADD.L Dn,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d198_0)(uae_u32 opcode) /* ADD.L Dn,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg(regs, dstreg) += 4;\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d1a0_0)(uae_u32 opcode) /* ADD.L Dn,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n{\tuae_s32 dst = get_long(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d1a8_0)(uae_u32 opcode) /* ADD.L Dn,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d1b0_0)(uae_u32 opcode) /* ADD.L Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{m68k_incpc(2);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d1b8_0)(uae_u32 opcode) /* ADD.L Dn,(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d1b9_0)(uae_u32 opcode) /* ADD.L Dn,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_ilong(2);\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d1c0_0)(uae_u32 opcode) /* ADDA.L Dn,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d1c8_0)(uae_u32 opcode) /* ADDA.L An,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d1d0_0)(uae_u32 opcode) /* ADDA.L (An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d1d8_0)(uae_u32 opcode) /* ADDA.L (An)+,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#endif\n\n#ifdef PART_8\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d1e0_0)(uae_u32 opcode) /* ADDA.L -(An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d1e8_0)(uae_u32 opcode) /* ADDA.L (d16,An),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d1f0_0)(uae_u32 opcode) /* ADDA.L (d8,An,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d1f8_0)(uae_u32 opcode) /* ADDA.L (xxx).W,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d1f9_0)(uae_u32 opcode) /* ADDA.L (xxx).L,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d1fa_0)(uae_u32 opcode) /* ADDA.L (d16,PC),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d1fb_0)(uae_u32 opcode) /* ADDA.L (d8,PC,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{m68k_incpc(2);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr srca = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d1fc_0)(uae_u32 opcode) /* ADDA.L #<data>.L,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_e000_0)(uae_u32 opcode) /* ASR.B #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s8 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u8)data;\n\tuae_u32 sign = (0x80 & val) >> 7;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 8) {\n\t\tval = 0xff & (uae_u32)-sign;\n\t\tSET_CFLG (sign);\n\tCOPY_CARRY;\n\t} else {\n\t\tval >>= cnt - 1;\n\t\tSET_CFLG (val & 1);\n\tCOPY_CARRY;\n\t\tval >>= 1;\n\t\tval |= (0xff << (8 - cnt)) & (uae_u32)-sign;\n\t\tval &= 0xff;\n\t}\n\tSET_ZFLG (((uae_s8)(val)) == 0);\n\tSET_NFLG (((uae_s8)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((val) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e008_0)(uae_u32 opcode) /* LSR.B #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s8 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u8)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 8) {\n\t\tSET_CFLG ((cnt == 8) & (val >> 7));\n\tCOPY_CARRY;\n\t\tval = 0;\n\t} else {\n\t\tval >>= cnt - 1;\n\t\tSET_CFLG (val & 1);\n\tCOPY_CARRY;\n\t\tval >>= 1;\n\t}\n\tSET_ZFLG (((uae_s8)(val)) == 0);\n\tSET_NFLG (((uae_s8)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((val) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e010_0)(uae_u32 opcode) /* ROXR.B #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s8 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u8)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n{\tcnt--;\n\t{\n\tuae_u32 carry;\n\tuae_u32 hival = (val << 1) | GET_XFLG;\n\thival <<= (7 - cnt);\n\tval >>= cnt;\n\tcarry = val & 1;\n\tval >>= 1;\n\tval |= hival;\n\tSET_XFLG (carry);\n\tval &= 0xff;\n\t} }\n\tSET_CFLG (GET_XFLG);\n\tSET_ZFLG (((uae_s8)(val)) == 0);\n\tSET_NFLG (((uae_s8)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((val) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e018_0)(uae_u32 opcode) /* ROR.B #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s8 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u8)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n{\tuae_u32 hival;\n\tcnt &= 7;\n\thival = val << (8 - cnt);\n\tval >>= cnt;\n\tval |= hival;\n\tval &= 0xff;\n\tSET_CFLG ((val & 0x80) >> 7);\n\t}\n\tSET_ZFLG (((uae_s8)(val)) == 0);\n\tSET_NFLG (((uae_s8)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((val) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e020_0)(uae_u32 opcode) /* ASR.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s8 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u8)data;\n\tuae_u32 sign = (0x80 & val) >> 7;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 8) {\n\t\tval = 0xff & (uae_u32)-sign;\n\t\tSET_CFLG (sign);\n\tCOPY_CARRY;\n\t} else if (cnt > 0) {\n\t\tval >>= cnt - 1;\n\t\tSET_CFLG (val & 1);\n\tCOPY_CARRY;\n\t\tval >>= 1;\n\t\tval |= (0xff << (8 - cnt)) & (uae_u32)-sign;\n\t\tval &= 0xff;\n\t}\n\tSET_ZFLG (((uae_s8)(val)) == 0);\n\tSET_NFLG (((uae_s8)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((val) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e028_0)(uae_u32 opcode) /* LSR.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s8 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u8)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 8) {\n\t\tSET_CFLG ((cnt == 8) & (val >> 7));\n\tCOPY_CARRY;\n\t\tval = 0;\n\t} else if (cnt > 0) {\n\t\tval >>= cnt - 1;\n\t\tSET_CFLG (val & 1);\n\tCOPY_CARRY;\n\t\tval >>= 1;\n\t}\n\tSET_ZFLG (((uae_s8)(val)) == 0);\n\tSET_NFLG (((uae_s8)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((val) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e030_0)(uae_u32 opcode) /* ROXR.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s8 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u8)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 36) cnt -= 36;\n\tif (cnt >= 18) cnt -= 18;\n\tif (cnt >= 9) cnt -= 9;\n\tif (cnt > 0) {\n\tcnt--;\n\t{\n\tuae_u32 carry;\n\tuae_u32 hival = (val << 1) | GET_XFLG;\n\thival <<= (7 - cnt);\n\tval >>= cnt;\n\tcarry = val & 1;\n\tval >>= 1;\n\tval |= hival;\n\tSET_XFLG (carry);\n\tval &= 0xff;\n\t} }\n\tSET_CFLG (GET_XFLG);\n\tSET_ZFLG (((uae_s8)(val)) == 0);\n\tSET_NFLG (((uae_s8)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((val) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e038_0)(uae_u32 opcode) /* ROR.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s8 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u8)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt > 0) {\tuae_u32 hival;\n\tcnt &= 7;\n\thival = val << (8 - cnt);\n\tval >>= cnt;\n\tval |= hival;\n\tval &= 0xff;\n\tSET_CFLG ((val & 0x80) >> 7);\n\t}\n\tSET_ZFLG (((uae_s8)(val)) == 0);\n\tSET_NFLG (((uae_s8)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((val) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e040_0)(uae_u32 opcode) /* ASR.W #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s16 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 sign = (0x8000 & val) >> 15;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 16) {\n\t\tval = 0xffff & (uae_u32)-sign;\n\t\tSET_CFLG (sign);\n\tCOPY_CARRY;\n\t} else {\n\t\tval >>= cnt - 1;\n\t\tSET_CFLG (val & 1);\n\tCOPY_CARRY;\n\t\tval >>= 1;\n\t\tval |= (0xffff << (16 - cnt)) & (uae_u32)-sign;\n\t\tval &= 0xffff;\n\t}\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((val) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e048_0)(uae_u32 opcode) /* LSR.W #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s16 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u16)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 16) {\n\t\tSET_CFLG ((cnt == 16) & (val >> 15));\n\tCOPY_CARRY;\n\t\tval = 0;\n\t} else {\n\t\tval >>= cnt - 1;\n\t\tSET_CFLG (val & 1);\n\tCOPY_CARRY;\n\t\tval >>= 1;\n\t}\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((val) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e050_0)(uae_u32 opcode) /* ROXR.W #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s16 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u16)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n{\tcnt--;\n\t{\n\tuae_u32 carry;\n\tuae_u32 hival = (val << 1) | GET_XFLG;\n\thival <<= (15 - cnt);\n\tval >>= cnt;\n\tcarry = val & 1;\n\tval >>= 1;\n\tval |= hival;\n\tSET_XFLG (carry);\n\tval &= 0xffff;\n\t} }\n\tSET_CFLG (GET_XFLG);\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((val) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e058_0)(uae_u32 opcode) /* ROR.W #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s16 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u16)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n{\tuae_u32 hival;\n\tcnt &= 15;\n\thival = val << (16 - cnt);\n\tval >>= cnt;\n\tval |= hival;\n\tval &= 0xffff;\n\tSET_CFLG ((val & 0x8000) >> 15);\n\t}\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((val) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e060_0)(uae_u32 opcode) /* ASR.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s16 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 sign = (0x8000 & val) >> 15;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 16) {\n\t\tval = 0xffff & (uae_u32)-sign;\n\t\tSET_CFLG (sign);\n\tCOPY_CARRY;\n\t} else if (cnt > 0) {\n\t\tval >>= cnt - 1;\n\t\tSET_CFLG (val & 1);\n\tCOPY_CARRY;\n\t\tval >>= 1;\n\t\tval |= (0xffff << (16 - cnt)) & (uae_u32)-sign;\n\t\tval &= 0xffff;\n\t}\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((val) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e068_0)(uae_u32 opcode) /* LSR.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s16 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u16)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 16) {\n\t\tSET_CFLG ((cnt == 16) & (val >> 15));\n\tCOPY_CARRY;\n\t\tval = 0;\n\t} else if (cnt > 0) {\n\t\tval >>= cnt - 1;\n\t\tSET_CFLG (val & 1);\n\tCOPY_CARRY;\n\t\tval >>= 1;\n\t}\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((val) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e070_0)(uae_u32 opcode) /* ROXR.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s16 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u16)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 34) cnt -= 34;\n\tif (cnt >= 17) cnt -= 17;\n\tif (cnt > 0) {\n\tcnt--;\n\t{\n\tuae_u32 carry;\n\tuae_u32 hival = (val << 1) | GET_XFLG;\n\thival <<= (15 - cnt);\n\tval >>= cnt;\n\tcarry = val & 1;\n\tval >>= 1;\n\tval |= hival;\n\tSET_XFLG (carry);\n\tval &= 0xffff;\n\t} }\n\tSET_CFLG (GET_XFLG);\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((val) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e078_0)(uae_u32 opcode) /* ROR.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s16 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u16)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt > 0) {\tuae_u32 hival;\n\tcnt &= 15;\n\thival = val << (16 - cnt);\n\tval >>= cnt;\n\tval |= hival;\n\tval &= 0xffff;\n\tSET_CFLG ((val & 0x8000) >> 15);\n\t}\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((val) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e080_0)(uae_u32 opcode) /* ASR.L #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s32 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = data;\n\tuae_u32 sign = (0x80000000 & val) >> 31;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 32) {\n\t\tval = 0xffffffff & (uae_u32)-sign;\n\t\tSET_CFLG (sign);\n\tCOPY_CARRY;\n\t} else {\n\t\tval >>= cnt - 1;\n\t\tSET_CFLG (val & 1);\n\tCOPY_CARRY;\n\t\tval >>= 1;\n\t\tval |= (0xffffffff << (32 - cnt)) & (uae_u32)-sign;\n\t\tval &= 0xffffffff;\n\t}\n\tSET_ZFLG (((uae_s32)(val)) == 0);\n\tSET_NFLG (((uae_s32)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e088_0)(uae_u32 opcode) /* LSR.L #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s32 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 32) {\n\t\tSET_CFLG ((cnt == 32) & (val >> 31));\n\tCOPY_CARRY;\n\t\tval = 0;\n\t} else {\n\t\tval >>= cnt - 1;\n\t\tSET_CFLG (val & 1);\n\tCOPY_CARRY;\n\t\tval >>= 1;\n\t}\n\tSET_ZFLG (((uae_s32)(val)) == 0);\n\tSET_NFLG (((uae_s32)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e090_0)(uae_u32 opcode) /* ROXR.L #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s32 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n{\tcnt--;\n\t{\n\tuae_u32 carry;\n\tuae_u32 hival = (val << 1) | GET_XFLG;\n\thival <<= (31 - cnt);\n\tval >>= cnt;\n\tcarry = val & 1;\n\tval >>= 1;\n\tval |= hival;\n\tSET_XFLG (carry);\n\tval &= 0xffffffff;\n\t} }\n\tSET_CFLG (GET_XFLG);\n\tSET_ZFLG (((uae_s32)(val)) == 0);\n\tSET_NFLG (((uae_s32)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e098_0)(uae_u32 opcode) /* ROR.L #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s32 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n{\tuae_u32 hival;\n\tcnt &= 31;\n\thival = val << (32 - cnt);\n\tval >>= cnt;\n\tval |= hival;\n\tval &= 0xffffffff;\n\tSET_CFLG ((val & 0x80000000) >> 31);\n\t}\n\tSET_ZFLG (((uae_s32)(val)) == 0);\n\tSET_NFLG (((uae_s32)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e0a0_0)(uae_u32 opcode) /* ASR.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s32 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = data;\n\tuae_u32 sign = (0x80000000 & val) >> 31;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 32) {\n\t\tval = 0xffffffff & (uae_u32)-sign;\n\t\tSET_CFLG (sign);\n\tCOPY_CARRY;\n\t} else if (cnt > 0) {\n\t\tval >>= cnt - 1;\n\t\tSET_CFLG (val & 1);\n\tCOPY_CARRY;\n\t\tval >>= 1;\n\t\tval |= (0xffffffff << (32 - cnt)) & (uae_u32)-sign;\n\t\tval &= 0xffffffff;\n\t}\n\tSET_ZFLG (((uae_s32)(val)) == 0);\n\tSET_NFLG (((uae_s32)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e0a8_0)(uae_u32 opcode) /* LSR.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s32 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 32) {\n\t\tSET_CFLG ((cnt == 32) & (val >> 31));\n\tCOPY_CARRY;\n\t\tval = 0;\n\t} else if (cnt > 0) {\n\t\tval >>= cnt - 1;\n\t\tSET_CFLG (val & 1);\n\tCOPY_CARRY;\n\t\tval >>= 1;\n\t}\n\tSET_ZFLG (((uae_s32)(val)) == 0);\n\tSET_NFLG (((uae_s32)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e0b0_0)(uae_u32 opcode) /* ROXR.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s32 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 33) cnt -= 33;\n\tif (cnt > 0) {\n\tcnt--;\n\t{\n\tuae_u32 carry;\n\tuae_u32 hival = (val << 1) | GET_XFLG;\n\thival <<= (31 - cnt);\n\tval >>= cnt;\n\tcarry = val & 1;\n\tval >>= 1;\n\tval |= hival;\n\tSET_XFLG (carry);\n\tval &= 0xffffffff;\n\t} }\n\tSET_CFLG (GET_XFLG);\n\tSET_ZFLG (((uae_s32)(val)) == 0);\n\tSET_NFLG (((uae_s32)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e0b8_0)(uae_u32 opcode) /* ROR.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s32 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt > 0) {\tuae_u32 hival;\n\tcnt &= 31;\n\thival = val << (32 - cnt);\n\tval >>= cnt;\n\tval |= hival;\n\tval &= 0xffffffff;\n\tSET_CFLG ((val & 0x80000000) >> 31);\n\t}\n\tSET_ZFLG (((uae_s32)(val)) == 0);\n\tSET_NFLG (((uae_s32)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e0d0_0)(uae_u32 opcode) /* ASRW.W (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 sign = 0x8000 & val;\n\tuae_u32 cflg = val & 1;\n\tval = (val >> 1) | sign;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e0d8_0)(uae_u32 opcode) /* ASRW.W (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg);\n{\tuae_s16 data = get_word(dataa);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 sign = 0x8000 & val;\n\tuae_u32 cflg = val & 1;\n\tval = (val >> 1) | sign;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e0e0_0)(uae_u32 opcode) /* ASRW.W -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 data = get_word(dataa);\n\tm68k_areg (regs, srcreg) = dataa;\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 sign = 0x8000 & val;\n\tuae_u32 cflg = val & 1;\n\tval = (val >> 1) | sign;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e0e8_0)(uae_u32 opcode) /* ASRW.W (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 sign = 0x8000 & val;\n\tuae_u32 cflg = val & 1;\n\tval = (val >> 1) | sign;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e0f0_0)(uae_u32 opcode) /* ASRW.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr dataa = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 sign = 0x8000 & val;\n\tuae_u32 cflg = val & 1;\n\tval = (val >> 1) | sign;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e0f8_0)(uae_u32 opcode) /* ASRW.W (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr dataa = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 sign = 0x8000 & val;\n\tuae_u32 cflg = val & 1;\n\tval = (val >> 1) | sign;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e0f9_0)(uae_u32 opcode) /* ASRW.W (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr dataa = get_ilong(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 sign = 0x8000 & val;\n\tuae_u32 cflg = val & 1;\n\tval = (val >> 1) | sign;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e100_0)(uae_u32 opcode) /* ASL.B #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s8 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u8)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 8) {\n\t\tSET_VFLG (val != 0);\n\t\tSET_CFLG (cnt == 8 ? val & 1 : 0);\n\tCOPY_CARRY;\n\t\tval = 0;\n\t} else {\n\t\tuae_u32 mask = (0xff << (7 - cnt)) & 0xff;\n\t\tSET_VFLG ((val & mask) != mask && (val & mask) != 0);\n\t\tval <<= cnt - 1;\n\t\tSET_CFLG ((val & 0x80) >> 7);\n\tCOPY_CARRY;\n\t\tval <<= 1;\n\t\tval &= 0xff;\n\t}\n\tSET_ZFLG (((uae_s8)(val)) == 0);\n\tSET_NFLG (((uae_s8)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((val) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e108_0)(uae_u32 opcode) /* LSL.B #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s8 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u8)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 8) {\n\t\tSET_CFLG (cnt == 8 ? val & 1 : 0);\n\tCOPY_CARRY;\n\t\tval = 0;\n\t} else {\n\t\tval <<= (cnt - 1);\n\t\tSET_CFLG ((val & 0x80) >> 7);\n\tCOPY_CARRY;\n\t\tval <<= 1;\n\tval &= 0xff;\n\t}\n\tSET_ZFLG (((uae_s8)(val)) == 0);\n\tSET_NFLG (((uae_s8)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((val) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e110_0)(uae_u32 opcode) /* ROXL.B #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s8 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u8)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n{\tcnt--;\n\t{\n\tuae_u32 carry;\n\tuae_u32 loval = val >> (7 - cnt);\n\tcarry = loval & 1;\n\tval = (((val << 1) | GET_XFLG) << cnt) | (loval >> 1);\n\tSET_XFLG (carry);\n\tval &= 0xff;\n\t} }\n\tSET_CFLG (GET_XFLG);\n\tSET_ZFLG (((uae_s8)(val)) == 0);\n\tSET_NFLG (((uae_s8)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((val) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e118_0)(uae_u32 opcode) /* ROL.B #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s8 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u8)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n{\tuae_u32 loval;\n\tcnt &= 7;\n\tloval = val >> (8 - cnt);\n\tval <<= cnt;\n\tval |= loval;\n\tval &= 0xff;\n\tSET_CFLG (val & 1);\n}\n\tSET_ZFLG (((uae_s8)(val)) == 0);\n\tSET_NFLG (((uae_s8)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((val) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e120_0)(uae_u32 opcode) /* ASL.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s8 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u8)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 8) {\n\t\tSET_VFLG (val != 0);\n\t\tSET_CFLG (cnt == 8 ? val & 1 : 0);\n\tCOPY_CARRY;\n\t\tval = 0;\n\t} else if (cnt > 0) {\n\t\tuae_u32 mask = (0xff << (7 - cnt)) & 0xff;\n\t\tSET_VFLG ((val & mask) != mask && (val & mask) != 0);\n\t\tval <<= cnt - 1;\n\t\tSET_CFLG ((val & 0x80) >> 7);\n\tCOPY_CARRY;\n\t\tval <<= 1;\n\t\tval &= 0xff;\n\t}\n\tSET_ZFLG (((uae_s8)(val)) == 0);\n\tSET_NFLG (((uae_s8)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((val) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e128_0)(uae_u32 opcode) /* LSL.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s8 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u8)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 8) {\n\t\tSET_CFLG (cnt == 8 ? val & 1 : 0);\n\tCOPY_CARRY;\n\t\tval = 0;\n\t} else if (cnt > 0) {\n\t\tval <<= (cnt - 1);\n\t\tSET_CFLG ((val & 0x80) >> 7);\n\tCOPY_CARRY;\n\t\tval <<= 1;\n\tval &= 0xff;\n\t}\n\tSET_ZFLG (((uae_s8)(val)) == 0);\n\tSET_NFLG (((uae_s8)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((val) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e130_0)(uae_u32 opcode) /* ROXL.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s8 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u8)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 36) cnt -= 36;\n\tif (cnt >= 18) cnt -= 18;\n\tif (cnt >= 9) cnt -= 9;\n\tif (cnt > 0) {\n\tcnt--;\n\t{\n\tuae_u32 carry;\n\tuae_u32 loval = val >> (7 - cnt);\n\tcarry = loval & 1;\n\tval = (((val << 1) | GET_XFLG) << cnt) | (loval >> 1);\n\tSET_XFLG (carry);\n\tval &= 0xff;\n\t} }\n\tSET_CFLG (GET_XFLG);\n\tSET_ZFLG (((uae_s8)(val)) == 0);\n\tSET_NFLG (((uae_s8)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((val) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e138_0)(uae_u32 opcode) /* ROL.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s8 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u8)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt > 0) {\n\tuae_u32 loval;\n\tcnt &= 7;\n\tloval = val >> (8 - cnt);\n\tval <<= cnt;\n\tval |= loval;\n\tval &= 0xff;\n\tSET_CFLG (val & 1);\n}\n\tSET_ZFLG (((uae_s8)(val)) == 0);\n\tSET_NFLG (((uae_s8)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((val) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e140_0)(uae_u32 opcode) /* ASL.W #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s16 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u16)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 16) {\n\t\tSET_VFLG (val != 0);\n\t\tSET_CFLG (cnt == 16 ? val & 1 : 0);\n\tCOPY_CARRY;\n\t\tval = 0;\n\t} else {\n\t\tuae_u32 mask = (0xffff << (15 - cnt)) & 0xffff;\n\t\tSET_VFLG ((val & mask) != mask && (val & mask) != 0);\n\t\tval <<= cnt - 1;\n\t\tSET_CFLG ((val & 0x8000) >> 15);\n\tCOPY_CARRY;\n\t\tval <<= 1;\n\t\tval &= 0xffff;\n\t}\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((val) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e148_0)(uae_u32 opcode) /* LSL.W #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s16 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u16)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 16) {\n\t\tSET_CFLG (cnt == 16 ? val & 1 : 0);\n\tCOPY_CARRY;\n\t\tval = 0;\n\t} else {\n\t\tval <<= (cnt - 1);\n\t\tSET_CFLG ((val & 0x8000) >> 15);\n\tCOPY_CARRY;\n\t\tval <<= 1;\n\tval &= 0xffff;\n\t}\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((val) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e150_0)(uae_u32 opcode) /* ROXL.W #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s16 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u16)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n{\tcnt--;\n\t{\n\tuae_u32 carry;\n\tuae_u32 loval = val >> (15 - cnt);\n\tcarry = loval & 1;\n\tval = (((val << 1) | GET_XFLG) << cnt) | (loval >> 1);\n\tSET_XFLG (carry);\n\tval &= 0xffff;\n\t} }\n\tSET_CFLG (GET_XFLG);\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((val) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e158_0)(uae_u32 opcode) /* ROL.W #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s16 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u16)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n{\tuae_u32 loval;\n\tcnt &= 15;\n\tloval = val >> (16 - cnt);\n\tval <<= cnt;\n\tval |= loval;\n\tval &= 0xffff;\n\tSET_CFLG (val & 1);\n}\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((val) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e160_0)(uae_u32 opcode) /* ASL.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s16 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u16)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 16) {\n\t\tSET_VFLG (val != 0);\n\t\tSET_CFLG (cnt == 16 ? val & 1 : 0);\n\tCOPY_CARRY;\n\t\tval = 0;\n\t} else if (cnt > 0) {\n\t\tuae_u32 mask = (0xffff << (15 - cnt)) & 0xffff;\n\t\tSET_VFLG ((val & mask) != mask && (val & mask) != 0);\n\t\tval <<= cnt - 1;\n\t\tSET_CFLG ((val & 0x8000) >> 15);\n\tCOPY_CARRY;\n\t\tval <<= 1;\n\t\tval &= 0xffff;\n\t}\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((val) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e168_0)(uae_u32 opcode) /* LSL.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s16 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u16)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 16) {\n\t\tSET_CFLG (cnt == 16 ? val & 1 : 0);\n\tCOPY_CARRY;\n\t\tval = 0;\n\t} else if (cnt > 0) {\n\t\tval <<= (cnt - 1);\n\t\tSET_CFLG ((val & 0x8000) >> 15);\n\tCOPY_CARRY;\n\t\tval <<= 1;\n\tval &= 0xffff;\n\t}\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((val) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e170_0)(uae_u32 opcode) /* ROXL.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s16 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u16)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 34) cnt -= 34;\n\tif (cnt >= 17) cnt -= 17;\n\tif (cnt > 0) {\n\tcnt--;\n\t{\n\tuae_u32 carry;\n\tuae_u32 loval = val >> (15 - cnt);\n\tcarry = loval & 1;\n\tval = (((val << 1) | GET_XFLG) << cnt) | (loval >> 1);\n\tSET_XFLG (carry);\n\tval &= 0xffff;\n\t} }\n\tSET_CFLG (GET_XFLG);\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((val) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e178_0)(uae_u32 opcode) /* ROL.W Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s16 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = (uae_u16)data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt > 0) {\n\tuae_u32 loval;\n\tcnt &= 15;\n\tloval = val >> (16 - cnt);\n\tval <<= cnt;\n\tval |= loval;\n\tval &= 0xffff;\n\tSET_CFLG (val & 1);\n}\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((val) & 0xffff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e180_0)(uae_u32 opcode) /* ASL.L #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s32 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 32) {\n\t\tSET_VFLG (val != 0);\n\t\tSET_CFLG (cnt == 32 ? val & 1 : 0);\n\tCOPY_CARRY;\n\t\tval = 0;\n\t} else {\n\t\tuae_u32 mask = (0xffffffff << (31 - cnt)) & 0xffffffff;\n\t\tSET_VFLG ((val & mask) != mask && (val & mask) != 0);\n\t\tval <<= cnt - 1;\n\t\tSET_CFLG ((val & 0x80000000) >> 31);\n\tCOPY_CARRY;\n\t\tval <<= 1;\n\t\tval &= 0xffffffff;\n\t}\n\tSET_ZFLG (((uae_s32)(val)) == 0);\n\tSET_NFLG (((uae_s32)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e188_0)(uae_u32 opcode) /* LSL.L #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s32 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 32) {\n\t\tSET_CFLG (cnt == 32 ? val & 1 : 0);\n\tCOPY_CARRY;\n\t\tval = 0;\n\t} else {\n\t\tval <<= (cnt - 1);\n\t\tSET_CFLG ((val & 0x80000000) >> 31);\n\tCOPY_CARRY;\n\t\tval <<= 1;\n\tval &= 0xffffffff;\n\t}\n\tSET_ZFLG (((uae_s32)(val)) == 0);\n\tSET_NFLG (((uae_s32)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e190_0)(uae_u32 opcode) /* ROXL.L #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s32 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n{\tcnt--;\n\t{\n\tuae_u32 carry;\n\tuae_u32 loval = val >> (31 - cnt);\n\tcarry = loval & 1;\n\tval = (((val << 1) | GET_XFLG) << cnt) | (loval >> 1);\n\tSET_XFLG (carry);\n\tval &= 0xffffffff;\n\t} }\n\tSET_CFLG (GET_XFLG);\n\tSET_ZFLG (((uae_s32)(val)) == 0);\n\tSET_NFLG (((uae_s32)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e198_0)(uae_u32 opcode) /* ROL.L #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 cnt = srcreg;\n{\tuae_s32 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n{\tuae_u32 loval;\n\tcnt &= 31;\n\tloval = val >> (32 - cnt);\n\tval <<= cnt;\n\tval |= loval;\n\tval &= 0xffffffff;\n\tSET_CFLG (val & 1);\n}\n\tSET_ZFLG (((uae_s32)(val)) == 0);\n\tSET_NFLG (((uae_s32)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e1a0_0)(uae_u32 opcode) /* ASL.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s32 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 32) {\n\t\tSET_VFLG (val != 0);\n\t\tSET_CFLG (cnt == 32 ? val & 1 : 0);\n\tCOPY_CARRY;\n\t\tval = 0;\n\t} else if (cnt > 0) {\n\t\tuae_u32 mask = (0xffffffff << (31 - cnt)) & 0xffffffff;\n\t\tSET_VFLG ((val & mask) != mask && (val & mask) != 0);\n\t\tval <<= cnt - 1;\n\t\tSET_CFLG ((val & 0x80000000) >> 31);\n\tCOPY_CARRY;\n\t\tval <<= 1;\n\t\tval &= 0xffffffff;\n\t}\n\tSET_ZFLG (((uae_s32)(val)) == 0);\n\tSET_NFLG (((uae_s32)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e1a8_0)(uae_u32 opcode) /* LSL.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s32 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 32) {\n\t\tSET_CFLG (cnt == 32 ? val & 1 : 0);\n\tCOPY_CARRY;\n\t\tval = 0;\n\t} else if (cnt > 0) {\n\t\tval <<= (cnt - 1);\n\t\tSET_CFLG ((val & 0x80000000) >> 31);\n\tCOPY_CARRY;\n\t\tval <<= 1;\n\tval &= 0xffffffff;\n\t}\n\tSET_ZFLG (((uae_s32)(val)) == 0);\n\tSET_NFLG (((uae_s32)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e1b0_0)(uae_u32 opcode) /* ROXL.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s32 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt >= 33) cnt -= 33;\n\tif (cnt > 0) {\n\tcnt--;\n\t{\n\tuae_u32 carry;\n\tuae_u32 loval = val >> (31 - cnt);\n\tcarry = loval & 1;\n\tval = (((val << 1) | GET_XFLG) << cnt) | (loval >> 1);\n\tSET_XFLG (carry);\n\tval &= 0xffffffff;\n\t} }\n\tSET_CFLG (GET_XFLG);\n\tSET_ZFLG (((uae_s32)(val)) == 0);\n\tSET_NFLG (((uae_s32)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e1b8_0)(uae_u32 opcode) /* ROL.L Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 cnt = m68k_dreg(regs, srcreg);\n{\tuae_s32 data = m68k_dreg(regs, dstreg);\n{\tuae_u32 val = data;\n\tcnt &= 63;\n\tCLEAR_CZNV;\n\tif (cnt > 0) {\n\tuae_u32 loval;\n\tcnt &= 31;\n\tloval = val >> (32 - cnt);\n\tval <<= cnt;\n\tval |= loval;\n\tval &= 0xffffffff;\n\tSET_CFLG (val & 1);\n}\n\tSET_ZFLG (((uae_s32)(val)) == 0);\n\tSET_NFLG (((uae_s32)(val)) < 0);\n\tm68k_dreg(regs, dstreg) = (val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e1d0_0)(uae_u32 opcode) /* ASLW.W (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 sign = 0x8000 & val;\n\tuae_u32 sign2;\n\tval <<= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tsign2 = 0x8000 & val;\n\tSET_CFLG (sign != 0);\n\tCOPY_CARRY;\n\tSET_VFLG (GET_VFLG | (sign2 != sign));\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e1d8_0)(uae_u32 opcode) /* ASLW.W (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg);\n{\tuae_s16 data = get_word(dataa);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 sign = 0x8000 & val;\n\tuae_u32 sign2;\n\tval <<= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tsign2 = 0x8000 & val;\n\tSET_CFLG (sign != 0);\n\tCOPY_CARRY;\n\tSET_VFLG (GET_VFLG | (sign2 != sign));\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e1e0_0)(uae_u32 opcode) /* ASLW.W -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 data = get_word(dataa);\n\tm68k_areg (regs, srcreg) = dataa;\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 sign = 0x8000 & val;\n\tuae_u32 sign2;\n\tval <<= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tsign2 = 0x8000 & val;\n\tSET_CFLG (sign != 0);\n\tCOPY_CARRY;\n\tSET_VFLG (GET_VFLG | (sign2 != sign));\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e1e8_0)(uae_u32 opcode) /* ASLW.W (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 sign = 0x8000 & val;\n\tuae_u32 sign2;\n\tval <<= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tsign2 = 0x8000 & val;\n\tSET_CFLG (sign != 0);\n\tCOPY_CARRY;\n\tSET_VFLG (GET_VFLG | (sign2 != sign));\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e1f0_0)(uae_u32 opcode) /* ASLW.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr dataa = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 sign = 0x8000 & val;\n\tuae_u32 sign2;\n\tval <<= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tsign2 = 0x8000 & val;\n\tSET_CFLG (sign != 0);\n\tCOPY_CARRY;\n\tSET_VFLG (GET_VFLG | (sign2 != sign));\n\tput_word(dataa,val);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e1f8_0)(uae_u32 opcode) /* ASLW.W (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr dataa = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 sign = 0x8000 & val;\n\tuae_u32 sign2;\n\tval <<= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tsign2 = 0x8000 & val;\n\tSET_CFLG (sign != 0);\n\tCOPY_CARRY;\n\tSET_VFLG (GET_VFLG | (sign2 != sign));\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e1f9_0)(uae_u32 opcode) /* ASLW.W (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr dataa = get_ilong(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 sign = 0x8000 & val;\n\tuae_u32 sign2;\n\tval <<= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tsign2 = 0x8000 & val;\n\tSET_CFLG (sign != 0);\n\tCOPY_CARRY;\n\tSET_VFLG (GET_VFLG | (sign2 != sign));\n\tput_word(dataa,val);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e2d0_0)(uae_u32 opcode) /* LSRW.W (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e2d8_0)(uae_u32 opcode) /* LSRW.W (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg);\n{\tuae_s16 data = get_word(dataa);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e2e0_0)(uae_u32 opcode) /* LSRW.W -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 data = get_word(dataa);\n\tm68k_areg (regs, srcreg) = dataa;\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e2e8_0)(uae_u32 opcode) /* LSRW.W (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e2f0_0)(uae_u32 opcode) /* LSRW.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr dataa = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e2f8_0)(uae_u32 opcode) /* LSRW.W (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr dataa = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e2f9_0)(uae_u32 opcode) /* LSRW.W (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr dataa = get_ilong(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e3d0_0)(uae_u32 opcode) /* LSLW.W (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e3d8_0)(uae_u32 opcode) /* LSLW.W (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg);\n{\tuae_s16 data = get_word(dataa);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e3e0_0)(uae_u32 opcode) /* LSLW.W -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 data = get_word(dataa);\n\tm68k_areg (regs, srcreg) = dataa;\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e3e8_0)(uae_u32 opcode) /* LSLW.W (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e3f0_0)(uae_u32 opcode) /* LSLW.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr dataa = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e3f8_0)(uae_u32 opcode) /* LSLW.W (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr dataa = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e3f9_0)(uae_u32 opcode) /* LSLW.W (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr dataa = get_ilong(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e4d0_0)(uae_u32 opcode) /* ROXRW.W (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tif (GET_XFLG) val |= 0x8000;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e4d8_0)(uae_u32 opcode) /* ROXRW.W (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg);\n{\tuae_s16 data = get_word(dataa);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tif (GET_XFLG) val |= 0x8000;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e4e0_0)(uae_u32 opcode) /* ROXRW.W -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 data = get_word(dataa);\n\tm68k_areg (regs, srcreg) = dataa;\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tif (GET_XFLG) val |= 0x8000;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e4e8_0)(uae_u32 opcode) /* ROXRW.W (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tif (GET_XFLG) val |= 0x8000;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e4f0_0)(uae_u32 opcode) /* ROXRW.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr dataa = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tif (GET_XFLG) val |= 0x8000;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e4f8_0)(uae_u32 opcode) /* ROXRW.W (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr dataa = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tif (GET_XFLG) val |= 0x8000;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e4f9_0)(uae_u32 opcode) /* ROXRW.W (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr dataa = get_ilong(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tif (GET_XFLG) val |= 0x8000;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e5d0_0)(uae_u32 opcode) /* ROXLW.W (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tif (GET_XFLG) val |= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e5d8_0)(uae_u32 opcode) /* ROXLW.W (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg);\n{\tuae_s16 data = get_word(dataa);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tif (GET_XFLG) val |= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e5e0_0)(uae_u32 opcode) /* ROXLW.W -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 data = get_word(dataa);\n\tm68k_areg (regs, srcreg) = dataa;\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tif (GET_XFLG) val |= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e5e8_0)(uae_u32 opcode) /* ROXLW.W (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tif (GET_XFLG) val |= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e5f0_0)(uae_u32 opcode) /* ROXLW.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr dataa = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tif (GET_XFLG) val |= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e5f8_0)(uae_u32 opcode) /* ROXLW.W (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr dataa = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tif (GET_XFLG) val |= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e5f9_0)(uae_u32 opcode) /* ROXLW.W (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr dataa = get_ilong(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tif (GET_XFLG) val |= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e6d0_0)(uae_u32 opcode) /* RORW.W (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tif (carry) val |= 0x8000;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e6d8_0)(uae_u32 opcode) /* RORW.W (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg);\n{\tuae_s16 data = get_word(dataa);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tif (carry) val |= 0x8000;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e6e0_0)(uae_u32 opcode) /* RORW.W -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 data = get_word(dataa);\n\tm68k_areg (regs, srcreg) = dataa;\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tif (carry) val |= 0x8000;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e6e8_0)(uae_u32 opcode) /* RORW.W (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tif (carry) val |= 0x8000;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e6f0_0)(uae_u32 opcode) /* RORW.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr dataa = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tif (carry) val |= 0x8000;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tput_word(dataa,val);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e6f8_0)(uae_u32 opcode) /* RORW.W (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr dataa = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tif (carry) val |= 0x8000;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e6f9_0)(uae_u32 opcode) /* RORW.W (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr dataa = get_ilong(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tif (carry) val |= 0x8000;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tput_word(dataa,val);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e7d0_0)(uae_u32 opcode) /* ROLW.W (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tif (carry)  val |= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e7d8_0)(uae_u32 opcode) /* ROLW.W (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg);\n{\tuae_s16 data = get_word(dataa);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tif (carry)  val |= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e7e0_0)(uae_u32 opcode) /* ROLW.W -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 data = get_word(dataa);\n\tm68k_areg (regs, srcreg) = dataa;\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tif (carry)  val |= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tput_word(dataa,val);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e7e8_0)(uae_u32 opcode) /* ROLW.W (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tif (carry)  val |= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e7f0_0)(uae_u32 opcode) /* ROLW.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr dataa = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tif (carry)  val |= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tput_word(dataa,val);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e7f8_0)(uae_u32 opcode) /* ROLW.W (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr dataa = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tif (carry)  val |= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e7f9_0)(uae_u32 opcode) /* ROLW.W (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr dataa = get_ilong(2);\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tif (carry)  val |= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tput_word(dataa,val);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e8c0_0)(uae_u32 opcode) /* BFTST.L #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp = m68k_dreg(regs, dstreg) << (offset & 0x1f);\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e8d0_0)(uae_u32 opcode) /* BFTST.L #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e8e8_0)(uae_u32 opcode) /* BFTST.L #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e8f0_0)(uae_u32 opcode) /* BFTST.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e8f8_0)(uae_u32 opcode) /* BFTST.L #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e8f9_0)(uae_u32 opcode) /* BFTST.L #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e8fa_0)(uae_u32 opcode) /* BFTST.L #<data>.W,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_getpc () + 4;\n\tdsta += (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e8fb_0)(uae_u32 opcode) /* BFTST.L #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e9c0_0)(uae_u32 opcode) /* BFEXTU.L #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp = m68k_dreg(regs, dstreg) << (offset & 0x1f);\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\tm68k_dreg(regs, (extra >> 12) & 7) = tmp;\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e9d0_0)(uae_u32 opcode) /* BFEXTU.L #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\tm68k_dreg(regs, (extra >> 12) & 7) = tmp;\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e9e8_0)(uae_u32 opcode) /* BFEXTU.L #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\tm68k_dreg(regs, (extra >> 12) & 7) = tmp;\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e9f0_0)(uae_u32 opcode) /* BFEXTU.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\tm68k_dreg(regs, (extra >> 12) & 7) = tmp;\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e9f8_0)(uae_u32 opcode) /* BFEXTU.L #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\tm68k_dreg(regs, (extra >> 12) & 7) = tmp;\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e9f9_0)(uae_u32 opcode) /* BFEXTU.L #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\tm68k_dreg(regs, (extra >> 12) & 7) = tmp;\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e9fa_0)(uae_u32 opcode) /* BFEXTU.L #<data>.W,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_getpc () + 4;\n\tdsta += (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\tm68k_dreg(regs, (extra >> 12) & 7) = tmp;\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e9fb_0)(uae_u32 opcode) /* BFEXTU.L #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\tm68k_dreg(regs, (extra >> 12) & 7) = tmp;\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_eac0_0)(uae_u32 opcode) /* BFCHG.L #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp = m68k_dreg(regs, dstreg) << (offset & 0x1f);\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = ~tmp;\n\ttmp <<= (32 - width);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ((offset & 0x1f) == 0 ? 0 :\n\t\t(0xffffffff << (32 - (offset & 0x1f))))) |\n\t\t(tmp >> (offset & 0x1f)) |\n\t\t(((offset & 0x1f) + width) >= 32 ? 0 :\n (m68k_dreg(regs, dstreg) & ((uae_u32)0xffffffff >> ((offset & 0x1f) + width))));\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ead0_0)(uae_u32 opcode) /* BFCHG.L #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = ~tmp;\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_eae8_0)(uae_u32 opcode) /* BFCHG.L #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = ~tmp;\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_eaf0_0)(uae_u32 opcode) /* BFCHG.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = ~tmp;\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_eaf8_0)(uae_u32 opcode) /* BFCHG.L #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = ~tmp;\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_eaf9_0)(uae_u32 opcode) /* BFCHG.L #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = ~tmp;\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ebc0_0)(uae_u32 opcode) /* BFEXTS.L #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp = m68k_dreg(regs, dstreg) << (offset & 0x1f);\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\tif (GET_NFLG) tmp |= width == 32 ? 0 : (-1 << width);\n\tm68k_dreg(regs, (extra >> 12) & 7) = tmp;\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ebd0_0)(uae_u32 opcode) /* BFEXTS.L #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\tif (GET_NFLG) tmp |= width == 32 ? 0 : (-1 << width);\n\tm68k_dreg(regs, (extra >> 12) & 7) = tmp;\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ebe8_0)(uae_u32 opcode) /* BFEXTS.L #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\tif (GET_NFLG) tmp |= width == 32 ? 0 : (-1 << width);\n\tm68k_dreg(regs, (extra >> 12) & 7) = tmp;\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ebf0_0)(uae_u32 opcode) /* BFEXTS.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\tif (GET_NFLG) tmp |= width == 32 ? 0 : (-1 << width);\n\tm68k_dreg(regs, (extra >> 12) & 7) = tmp;\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ebf8_0)(uae_u32 opcode) /* BFEXTS.L #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\tif (GET_NFLG) tmp |= width == 32 ? 0 : (-1 << width);\n\tm68k_dreg(regs, (extra >> 12) & 7) = tmp;\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ebf9_0)(uae_u32 opcode) /* BFEXTS.L #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\tif (GET_NFLG) tmp |= width == 32 ? 0 : (-1 << width);\n\tm68k_dreg(regs, (extra >> 12) & 7) = tmp;\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ebfa_0)(uae_u32 opcode) /* BFEXTS.L #<data>.W,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_getpc () + 4;\n\tdsta += (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\tif (GET_NFLG) tmp |= width == 32 ? 0 : (-1 << width);\n\tm68k_dreg(regs, (extra >> 12) & 7) = tmp;\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ebfb_0)(uae_u32 opcode) /* BFEXTS.L #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\tif (GET_NFLG) tmp |= width == 32 ? 0 : (-1 << width);\n\tm68k_dreg(regs, (extra >> 12) & 7) = tmp;\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ecc0_0)(uae_u32 opcode) /* BFCLR.L #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp = m68k_dreg(regs, dstreg) << (offset & 0x1f);\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = 0;\n\ttmp <<= (32 - width);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ((offset & 0x1f) == 0 ? 0 :\n\t\t(0xffffffff << (32 - (offset & 0x1f))))) |\n\t\t(tmp >> (offset & 0x1f)) |\n\t\t(((offset & 0x1f) + width) >= 32 ? 0 :\n (m68k_dreg(regs, dstreg) & ((uae_u32)0xffffffff >> ((offset & 0x1f) + width))));\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ecd0_0)(uae_u32 opcode) /* BFCLR.L #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = 0;\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ece8_0)(uae_u32 opcode) /* BFCLR.L #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = 0;\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ecf0_0)(uae_u32 opcode) /* BFCLR.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = 0;\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ecf8_0)(uae_u32 opcode) /* BFCLR.L #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = 0;\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ecf9_0)(uae_u32 opcode) /* BFCLR.L #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = 0;\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_edc0_0)(uae_u32 opcode) /* BFFFO.L #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp = m68k_dreg(regs, dstreg) << (offset & 0x1f);\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\t{ uae_u32 mask = 1 << (width-1);\n\twhile (mask) { if (tmp & mask) break; mask >>= 1; offset++; }}\n\tm68k_dreg(regs, (extra >> 12) & 7) = offset;\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_edd0_0)(uae_u32 opcode) /* BFFFO.L #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\t{ uae_u32 mask = 1 << (width-1);\n\twhile (mask) { if (tmp & mask) break; mask >>= 1; offset++; }}\n\tm68k_dreg(regs, (extra >> 12) & 7) = offset;\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_ede8_0)(uae_u32 opcode) /* BFFFO.L #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\t{ uae_u32 mask = 1 << (width-1);\n\twhile (mask) { if (tmp & mask) break; mask >>= 1; offset++; }}\n\tm68k_dreg(regs, (extra >> 12) & 7) = offset;\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_edf0_0)(uae_u32 opcode) /* BFFFO.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\t{ uae_u32 mask = 1 << (width-1);\n\twhile (mask) { if (tmp & mask) break; mask >>= 1; offset++; }}\n\tm68k_dreg(regs, (extra >> 12) & 7) = offset;\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_edf8_0)(uae_u32 opcode) /* BFFFO.L #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\t{ uae_u32 mask = 1 << (width-1);\n\twhile (mask) { if (tmp & mask) break; mask >>= 1; offset++; }}\n\tm68k_dreg(regs, (extra >> 12) & 7) = offset;\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_edf9_0)(uae_u32 opcode) /* BFFFO.L #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\t{ uae_u32 mask = 1 << (width-1);\n\twhile (mask) { if (tmp & mask) break; mask >>= 1; offset++; }}\n\tm68k_dreg(regs, (extra >> 12) & 7) = offset;\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_edfa_0)(uae_u32 opcode) /* BFFFO.L #<data>.W,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_getpc () + 4;\n\tdsta += (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\t{ uae_u32 mask = 1 << (width-1);\n\twhile (mask) { if (tmp & mask) break; mask >>= 1; offset++; }}\n\tm68k_dreg(regs, (extra >> 12) & 7) = offset;\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_edfb_0)(uae_u32 opcode) /* BFFFO.L #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr tmppc = m68k_getpc();\n\tuaecptr dsta = get_disp_ea_020(tmppc, next_iword());\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\t{ uae_u32 mask = 1 << (width-1);\n\twhile (mask) { if (tmp & mask) break; mask >>= 1; offset++; }}\n\tm68k_dreg(regs, (extra >> 12) & 7) = offset;\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_eec0_0)(uae_u32 opcode) /* BFSET.L #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp = m68k_dreg(regs, dstreg) << (offset & 0x1f);\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = 0xffffffff;\n\ttmp <<= (32 - width);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ((offset & 0x1f) == 0 ? 0 :\n\t\t(0xffffffff << (32 - (offset & 0x1f))))) |\n\t\t(tmp >> (offset & 0x1f)) |\n\t\t(((offset & 0x1f) + width) >= 32 ? 0 :\n (m68k_dreg(regs, dstreg) & ((uae_u32)0xffffffff >> ((offset & 0x1f) + width))));\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_eed0_0)(uae_u32 opcode) /* BFSET.L #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = 0xffffffff;\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_eee8_0)(uae_u32 opcode) /* BFSET.L #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = 0xffffffff;\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_eef0_0)(uae_u32 opcode) /* BFSET.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = 0xffffffff;\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_eef8_0)(uae_u32 opcode) /* BFSET.L #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = 0xffffffff;\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_eef9_0)(uae_u32 opcode) /* BFSET.L #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = 0xffffffff;\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_efc0_0)(uae_u32 opcode) /* BFINS.L #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp = m68k_dreg(regs, dstreg) << (offset & 0x1f);\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = m68k_dreg(regs, (extra >> 12) & 7);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width - 1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0);\n\ttmp <<= (32 - width);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ((offset & 0x1f) == 0 ? 0 :\n\t\t(0xffffffff << (32 - (offset & 0x1f))))) |\n\t\t(tmp >> (offset & 0x1f)) |\n\t\t(((offset & 0x1f) + width) >= 32 ? 0 :\n (m68k_dreg(regs, dstreg) & ((uae_u32)0xffffffff >> ((offset & 0x1f) + width))));\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_efd0_0)(uae_u32 opcode) /* BFINS.L #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = m68k_dreg(regs, (extra >> 12) & 7);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width - 1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0);\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_efe8_0)(uae_u32 opcode) /* BFINS.L #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = m68k_dreg(regs, (extra >> 12) & 7);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width - 1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0);\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_eff0_0)(uae_u32 opcode) /* BFINS.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\n{m68k_incpc(4);\n{\tuaecptr dsta = get_disp_ea_020(m68k_areg(regs, dstreg), next_iword());\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = m68k_dreg(regs, (extra >> 12) & 7);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width - 1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0);\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_eff8_0)(uae_u32 opcode) /* BFINS.L #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = m68k_dreg(regs, (extra >> 12) & 7);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width - 1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0);\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_eff9_0)(uae_u32 opcode) /* BFINS.L #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\n{\tuaecptr dsta = get_ilong(4);\n{\tuae_s32 offset = extra & 0x800 ? m68k_dreg(regs, (extra >> 6) & 7) : (extra >> 6) & 0x1f;\n\tint width = (((extra & 0x20 ? m68k_dreg(regs, extra & 7) : extra) -1) & 0x1f) +1;\n\tuae_u32 tmp,bf0,bf1;\n\tdsta += (offset >> 3) | (offset & 0x80000000 ? ~0x1fffffff : 0);\n\tbf0 = get_long(dsta);bf1 = get_byte(dsta+4) & 0xff;\n\ttmp = (bf0 << (offset & 7)) | (bf1 >> (8 - (offset & 7)));\n\ttmp >>= (32 - width);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width-1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0); SET_VFLG (0); SET_CFLG (0);\n\ttmp = m68k_dreg(regs, (extra >> 12) & 7);\n\tSET_NFLG_ALWAYS (tmp & (1 << (width - 1)) ? 1 : 0);\n\tSET_ZFLG (tmp == 0);\n\ttmp <<= (32 - width);\n\tbf0 = (bf0 & (0xff000000 << (8 - (offset & 7)))) |\n\t\t(tmp >> (offset & 7)) |\n\t\t(((offset & 7) + width) >= 32 ? 0 :\n\t\t (bf0 & ((uae_u32)0xffffffff >> ((offset & 7) + width))));\n\tput_long(dsta,bf0 );\n\tif (((offset & 7) + width) > 32) {\n\t\tbf1 = (bf1 & (0xff >> (width - 32 + (offset & 7)))) |\n\t\t\t(tmp << (8 - (offset & 7)));\n\t\tput_byte(dsta+4,bf1);\n\t}\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f200_0)(uae_u32 opcode) /* FPP.L #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_arithmetic(opcode, extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f208_0)(uae_u32 opcode) /* FPP.L #<data>.W,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_arithmetic(opcode, extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f210_0)(uae_u32 opcode) /* FPP.L #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_arithmetic(opcode, extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f218_0)(uae_u32 opcode) /* FPP.L #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_arithmetic(opcode, extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f220_0)(uae_u32 opcode) /* FPP.L #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_arithmetic(opcode, extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f228_0)(uae_u32 opcode) /* FPP.L #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_arithmetic(opcode, extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f230_0)(uae_u32 opcode) /* FPP.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_arithmetic(opcode, extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f238_0)(uae_u32 opcode) /* FPP.L #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_arithmetic(opcode, extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f239_0)(uae_u32 opcode) /* FPP.L #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_arithmetic(opcode, extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f23a_0)(uae_u32 opcode) /* FPP.L #<data>.W,(d16,PC) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 2;\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_arithmetic(opcode, extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f23b_0)(uae_u32 opcode) /* FPP.L #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_arithmetic(opcode, extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f23c_0)(uae_u32 opcode) /* FPP.L #<data>.W,#<data>.L */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_arithmetic(opcode, extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f240_0)(uae_u32 opcode) /* FScc.L #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_scc(opcode,extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f248_0)(uae_u32 opcode) /* FDBcc.L #<data>.W,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_dbcc(opcode, extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f250_0)(uae_u32 opcode) /* FScc.L #<data>.W,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_scc(opcode,extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f258_0)(uae_u32 opcode) /* FScc.L #<data>.W,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_scc(opcode,extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f260_0)(uae_u32 opcode) /* FScc.L #<data>.W,-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_scc(opcode,extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f268_0)(uae_u32 opcode) /* FScc.L #<data>.W,(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_scc(opcode,extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f270_0)(uae_u32 opcode) /* FScc.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_scc(opcode,extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f278_0)(uae_u32 opcode) /* FScc.L #<data>.W,(xxx).W */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_scc(opcode,extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f279_0)(uae_u32 opcode) /* FScc.L #<data>.W,(xxx).L */\n{\n\tcpuop_begin();\n{{\tuae_s16 extra = get_iword(2);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_scc(opcode,extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f27a_0)(uae_u32 opcode) /* FTRAPcc.L #<data>.W */\n{\n\tcpuop_begin();\n{m68k_incpc(2);\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s16 dummy = get_iword(0);\nm68k_incpc(2);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_trapcc(opcode,oldpc);\n}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f27b_0)(uae_u32 opcode) /* FTRAPcc.L #<data>.L */\n{\n\tcpuop_begin();\n{m68k_incpc(2);\n{\tuaecptr oldpc = m68k_getpc();\n{\tuae_s32 dummy = get_ilong(0);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_trapcc(opcode,oldpc);\n}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f27c_0)(uae_u32 opcode) /* FTRAPcc.L  */\n{\n\tcpuop_begin();\n{m68k_incpc(2);\n{\tuaecptr oldpc = m68k_getpc();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_trapcc(opcode,oldpc);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f280_0)(uae_u32 opcode) /* FBcc.L #<data>,#<data>.W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 63);\n#else\n\tuae_u32 srcreg = (opcode & 63);\n#endif\n{m68k_incpc(2);\n{\tuaecptr pc = m68k_getpc();\n{\tuae_s16 extra = get_iword(0);\nm68k_incpc(2);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_bcc(opcode,pc,extra);\n}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f2c0_0)(uae_u32 opcode) /* FBcc.L #<data>,#<data>.L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 63);\n#else\n\tuae_u32 srcreg = (opcode & 63);\n#endif\n{m68k_incpc(2);\n{\tuaecptr pc = m68k_getpc();\n{\tuae_s32 extra = get_ilong(0);\nm68k_incpc(4);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_bcc(opcode,pc,extra);\n}}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f310_0)(uae_u32 opcode) /* FSAVE.L (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1829; }\n{m68k_incpc(2);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_save(opcode);\n}}endlabel1829: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f320_0)(uae_u32 opcode) /* FSAVE.L -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1830; }\n{m68k_incpc(2);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_save(opcode);\n}}endlabel1830: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f328_0)(uae_u32 opcode) /* FSAVE.L (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1831; }\n{m68k_incpc(2);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_save(opcode);\n}}endlabel1831: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f330_0)(uae_u32 opcode) /* FSAVE.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1832; }\n{m68k_incpc(2);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_save(opcode);\n}}endlabel1832: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f338_0)(uae_u32 opcode) /* FSAVE.L (xxx).W */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel1833; }\n{m68k_incpc(2);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_save(opcode);\n}}endlabel1833: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f339_0)(uae_u32 opcode) /* FSAVE.L (xxx).L */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel1834; }\n{m68k_incpc(2);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_save(opcode);\n}}endlabel1834: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f350_0)(uae_u32 opcode) /* FRESTORE.L (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1835; }\n{m68k_incpc(2);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_restore(opcode);\n}}endlabel1835: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f358_0)(uae_u32 opcode) /* FRESTORE.L (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1836; }\n{m68k_incpc(2);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_restore(opcode);\n}}endlabel1836: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f368_0)(uae_u32 opcode) /* FRESTORE.L (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1837; }\n{m68k_incpc(2);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_restore(opcode);\n}}endlabel1837: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f370_0)(uae_u32 opcode) /* FRESTORE.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1838; }\n{m68k_incpc(2);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_restore(opcode);\n}}endlabel1838: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f378_0)(uae_u32 opcode) /* FRESTORE.L (xxx).W */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel1839; }\n{m68k_incpc(2);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_restore(opcode);\n}}endlabel1839: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f379_0)(uae_u32 opcode) /* FRESTORE.L (xxx).L */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel1840; }\n{m68k_incpc(2);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_restore(opcode);\n}}endlabel1840: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f37a_0)(uae_u32 opcode) /* FRESTORE.L (d16,PC) */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel1841; }\n{m68k_incpc(2);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_restore(opcode);\n}}endlabel1841: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f37b_0)(uae_u32 opcode) /* FRESTORE.L (d8,PC,Xn) */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel1842; }\n{m68k_incpc(2);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tfpuop_restore(opcode);\n}}endlabel1842: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f408_0)(uae_u32 opcode) /* CINVL.L #<data>,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1843; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(31);\n}}m68k_incpc(2);\nendlabel1843: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f410_0)(uae_u32 opcode) /* CINVP.L #<data>,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1844; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(32);\n}}m68k_incpc(2);\nendlabel1844: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f418_0)(uae_u32 opcode) /* CINVA.L #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1845; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(33);\n}}m68k_incpc(2);\nendlabel1845: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f419_0)(uae_u32 opcode) /* CINVA.L #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1846; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(33);\n}}m68k_incpc(2);\nendlabel1846: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f41a_0)(uae_u32 opcode) /* CINVA.L #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1847; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(33);\n}}m68k_incpc(2);\nendlabel1847: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f41b_0)(uae_u32 opcode) /* CINVA.L #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1848; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(33);\n}}m68k_incpc(2);\nendlabel1848: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f41c_0)(uae_u32 opcode) /* CINVA.L #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1849; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(33);\n}}m68k_incpc(2);\nendlabel1849: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f41d_0)(uae_u32 opcode) /* CINVA.L #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1850; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(33);\n}}m68k_incpc(2);\nendlabel1850: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f41e_0)(uae_u32 opcode) /* CINVA.L #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1851; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(33);\n}}m68k_incpc(2);\nendlabel1851: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f41f_0)(uae_u32 opcode) /* CINVA.L #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1852; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(33);\n}}m68k_incpc(2);\nendlabel1852: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f428_0)(uae_u32 opcode) /* CPUSHL.L #<data>,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1853; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(41);\n}}m68k_incpc(2);\nendlabel1853: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f430_0)(uae_u32 opcode) /* CPUSHP.L #<data>,An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1854; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(42);\n}}m68k_incpc(2);\nendlabel1854: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f438_0)(uae_u32 opcode) /* CPUSHA.L #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1855; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(43);\n}}m68k_incpc(2);\nendlabel1855: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f439_0)(uae_u32 opcode) /* CPUSHA.L #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1856; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(43);\n}}m68k_incpc(2);\nendlabel1856: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f43a_0)(uae_u32 opcode) /* CPUSHA.L #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1857; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(43);\n}}m68k_incpc(2);\nendlabel1857: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f43b_0)(uae_u32 opcode) /* CPUSHA.L #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1858; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(43);\n}}m68k_incpc(2);\nendlabel1858: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f43c_0)(uae_u32 opcode) /* CPUSHA.L #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1859; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(43);\n}}m68k_incpc(2);\nendlabel1859: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f43d_0)(uae_u32 opcode) /* CPUSHA.L #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1860; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(43);\n}}m68k_incpc(2);\nendlabel1860: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f43e_0)(uae_u32 opcode) /* CPUSHA.L #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1861; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(43);\n}}m68k_incpc(2);\nendlabel1861: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f43f_0)(uae_u32 opcode) /* CPUSHA.L #<data> */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 14) & 3);\n#else\n\tuae_u32 srcreg = ((opcode >> 6) & 3);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel1862; }\n{\tif (srcreg&0x2)\n\t\tflush_icache(43);\n}}m68k_incpc(2);\nendlabel1862: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f500_0)(uae_u32 opcode) /* MMUOP.L #<data>,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = (uae_s32)(uae_s8)(((opcode >> 11) | (opcode << 5)) & 7);\n#else\n\tuae_u32 srcreg = (uae_s32)(uae_s8)((opcode >> 3) & 255);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 extra = srcreg;\nm68k_incpc(2);\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\topcode = ((opcode << 8) & 0xFF00) | ((opcode >> 8) & 0xFF);\n#endif\n\tmmu_op(opcode,extra);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f600_0)(uae_u32 opcode) /* MOVE16.L (An)+,(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr memsa = m68k_areg(regs, srcreg);\n{\tuaecptr memda = get_ilong(2);\n\tmemsa &= ~15;\n\tmemda &= ~15;\n\tput_long(memda, get_long(memsa));\n\tput_long(memda+4, get_long(memsa+4));\n\tput_long(memda+8, get_long(memsa+8));\n\tput_long(memda+12, get_long(memsa+12));\n\tm68k_areg(regs, srcreg) += 16;\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f608_0)(uae_u32 opcode) /* MOVE16.L (xxx).L,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuaecptr memsa = get_ilong(2);\n{\tuaecptr memda = m68k_areg(regs, dstreg);\n\tmemsa &= ~15;\n\tmemda &= ~15;\n\tput_long(memda, get_long(memsa));\n\tput_long(memda+4, get_long(memsa+4));\n\tput_long(memda+8, get_long(memsa+8));\n\tput_long(memda+12, get_long(memsa+12));\n\tm68k_areg(regs, dstreg) += 16;\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f610_0)(uae_u32 opcode) /* MOVE16.L (An),(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr memsa = m68k_areg(regs, srcreg);\n{\tuaecptr memda = get_ilong(2);\n\tmemsa &= ~15;\n\tmemda &= ~15;\n\tput_long(memda, get_long(memsa));\n\tput_long(memda+4, get_long(memsa+4));\n\tput_long(memda+8, get_long(memsa+8));\n\tput_long(memda+12, get_long(memsa+12));\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f618_0)(uae_u32 opcode) /* MOVE16.L (xxx).L,(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuaecptr memsa = get_ilong(2);\n{\tuaecptr memda = m68k_areg(regs, dstreg);\n\tmemsa &= ~15;\n\tmemda &= ~15;\n\tput_long(memda, get_long(memsa));\n\tput_long(memda+4, get_long(memsa+4));\n\tput_long(memda+8, get_long(memsa+8));\n\tput_long(memda+12, get_long(memsa+12));\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_f620_0)(uae_u32 opcode) /* MOVE16.L (An)+,(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n\tuae_u32 dstreg = 0;\n{\tuaecptr mems = m68k_areg(regs, srcreg) & ~15, memd;\n\tdstreg = (get_iword(2) >> 12) & 7;\n\tmemd = m68k_areg(regs, dstreg) & ~15;\n\tput_long(memd, get_long(mems));\n\tput_long(memd+4, get_long(mems+4));\n\tput_long(memd+8, get_long(mems+8));\n\tput_long(memd+12, get_long(mems+12));\n\tif (srcreg != dstreg)\n\tm68k_areg(regs, srcreg) += 16;\n\tm68k_areg(regs, dstreg) += 16;\n}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#endif\n\n\n#if !defined(PART_1) && !defined(PART_2) && !defined(PART_3) && !defined(PART_4) && !defined(PART_5) && !defined(PART_6) && !defined(PART_7) && !defined(PART_8)\n#define PART_1 1\n#define PART_2 1\n#define PART_3 1\n#define PART_4 1\n#define PART_5 1\n#define PART_6 1\n#define PART_7 1\n#define PART_8 1\n#endif\n\n#ifdef PART_1\n#endif\n\n#ifdef PART_2\n#endif\n\n#ifdef PART_3\n#endif\n\n#ifdef PART_4\nvoid REGPARAM2 CPUFUNC(op_4800_1)(uae_u32 opcode) /* NBCD.B Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuae_u16 newv_lo = - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = - (src & 0xF0);\n\tuae_u16 newv;\n\tint cflg;\n\tif (newv_lo > 9) { newv_lo -= 6; }\n\tnewv = newv_hi + newv_lo;\n\tcflg = (newv & 0x1F0) > 0x90;\n\tif (cflg) newv -= 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xff) | ((newv) & 0xff);\n}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4810_1)(uae_u32 opcode) /* NBCD.B (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u16 newv_lo = - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = - (src & 0xF0);\n\tuae_u16 newv;\n\tint cflg;\n\tif (newv_lo > 9) { newv_lo -= 6; }\n\tnewv = newv_hi + newv_lo;\n\tcflg = (newv & 0x1F0) > 0x90;\n\tif (cflg) newv -= 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tput_byte(srca,newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4818_1)(uae_u32 opcode) /* NBCD.B (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tuae_u16 newv_lo = - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = - (src & 0xF0);\n\tuae_u16 newv;\n\tint cflg;\n\tif (newv_lo > 9) { newv_lo -= 6; }\n\tnewv = newv_hi + newv_lo;\n\tcflg = (newv & 0x1F0) > 0x90;\n\tif (cflg) newv -= 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tput_byte(srca,newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4820_1)(uae_u32 opcode) /* NBCD.B -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuae_u16 newv_lo = - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = - (src & 0xF0);\n\tuae_u16 newv;\n\tint cflg;\n\tif (newv_lo > 9) { newv_lo -= 6; }\n\tnewv = newv_hi + newv_lo;\n\tcflg = (newv & 0x1F0) > 0x90;\n\tif (cflg) newv -= 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tput_byte(srca,newv);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4828_1)(uae_u32 opcode) /* NBCD.B (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u16 newv_lo = - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = - (src & 0xF0);\n\tuae_u16 newv;\n\tint cflg;\n\tif (newv_lo > 9) { newv_lo -= 6; }\n\tnewv = newv_hi + newv_lo;\n\tcflg = (newv & 0x1F0) > 0x90;\n\tif (cflg) newv -= 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tput_byte(srca,newv);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4830_1)(uae_u32 opcode) /* NBCD.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{m68k_incpc(2);\n{\tuaecptr srca = get_disp_ea_020(m68k_areg(regs, srcreg), next_iword());\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u16 newv_lo = - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = - (src & 0xF0);\n\tuae_u16 newv;\n\tint cflg;\n\tif (newv_lo > 9) { newv_lo -= 6; }\n\tnewv = newv_hi + newv_lo;\n\tcflg = (newv & 0x1F0) > 0x90;\n\tif (cflg) newv -= 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tput_byte(srca,newv);\n}}}}}\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4838_1)(uae_u32 opcode) /* NBCD.B (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u16 newv_lo = - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = - (src & 0xF0);\n\tuae_u16 newv;\n\tint cflg;\n\tif (newv_lo > 9) { newv_lo -= 6; }\n\tnewv = newv_hi + newv_lo;\n\tcflg = (newv & 0x1F0) > 0x90;\n\tif (cflg) newv -= 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tput_byte(srca,newv);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4839_1)(uae_u32 opcode) /* NBCD.B (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u16 newv_lo = - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = - (src & 0xF0);\n\tuae_u16 newv;\n\tint cflg;\n\tif (newv_lo > 9) { newv_lo -= 6; }\n\tnewv = newv_hi + newv_lo;\n\tcflg = (newv & 0x1F0) > 0x90;\n\tif (cflg) newv -= 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tput_byte(srca,newv);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n#endif\n\n#ifdef PART_5\n#endif\n\n#ifdef PART_6\nvoid REGPARAM2 CPUFUNC(op_8100_1)(uae_u32 opcode) /* SBCD.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{\tuae_u16 newv_lo = (dst & 0xF) - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = (dst & 0xF0) - (src & 0xF0);\n\tuae_u16 newv, tmp_newv;\n\tint bcd = 0;\n\tnewv = tmp_newv = newv_hi + newv_lo;\n\tif (newv_lo & 0xF0) { newv -= 6; bcd = 6; };\n\tif ((((dst & 0xFF) - (src & 0xFF) - (GET_XFLG ? 1 : 0)) & 0x100) > 0xFF) { newv -= 0x60; }\n\tSET_CFLG ((((dst & 0xFF) - (src & 0xFF) - bcd - (GET_XFLG ? 1 : 0)) & 0x300) > 0xFF);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tSET_VFLG ((tmp_newv & 0x80) != 0 && (newv & 0x80) == 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8108_1)(uae_u32 opcode) /* SBCD.B -(An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{\tuae_u16 newv_lo = (dst & 0xF) - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = (dst & 0xF0) - (src & 0xF0);\n\tuae_u16 newv, tmp_newv;\n\tint bcd = 0;\n\tnewv = tmp_newv = newv_hi + newv_lo;\n\tif (newv_lo & 0xF0) { newv -= 6; bcd = 6; };\n\tif ((((dst & 0xFF) - (src & 0xFF) - (GET_XFLG ? 1 : 0)) & 0x100) > 0xFF) { newv -= 0x60; }\n\tSET_CFLG ((((dst & 0xFF) - (src & 0xFF) - bcd - (GET_XFLG ? 1 : 0)) & 0x300) > 0xFF);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tSET_VFLG ((tmp_newv & 0x80) != 0 && (newv & 0x80) == 0);\n\tput_byte(dsta,newv);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n#endif\n\n#ifdef PART_7\nvoid REGPARAM2 CPUFUNC(op_c100_1)(uae_u32 opcode) /* ABCD.B Dn,Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{\tuae_u16 newv_lo = (src & 0xF) + (dst & 0xF) + (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = (src & 0xF0) + (dst & 0xF0);\n\tuae_u16 newv, tmp_newv;\n\tint cflg;\n\tnewv = tmp_newv = newv_hi + newv_lo;\n\tif (newv_lo > 9) { newv += 6; }\n\tcflg = (newv & 0x3F0) > 0x90;\n\tif (cflg) newv += 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tSET_VFLG ((tmp_newv & 0x80) == 0 && (newv & 0x80) != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}m68k_incpc(2);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c108_1)(uae_u32 opcode) /* ABCD.B -(An),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n{\tuae_s8 dst = get_byte(dsta);\n\tm68k_areg (regs, dstreg) = dsta;\n{\tuae_u16 newv_lo = (src & 0xF) + (dst & 0xF) + (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = (src & 0xF0) + (dst & 0xF0);\n\tuae_u16 newv, tmp_newv;\n\tint cflg;\n\tnewv = tmp_newv = newv_hi + newv_lo;\n\tif (newv_lo > 9) { newv += 6; }\n\tcflg = (newv & 0x3F0) > 0x90;\n\tif (cflg) newv += 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tSET_VFLG ((tmp_newv & 0x80) == 0 && (newv & 0x80) != 0);\n\tput_byte(dsta,newv);\n}}}}}}m68k_incpc(2);\n\tcpuop_end();\n}\n#endif\n\n#ifdef PART_8\n#endif\n\n\n#if !defined(PART_1) && !defined(PART_2) && !defined(PART_3) && !defined(PART_4) && !defined(PART_5) && !defined(PART_6) && !defined(PART_7) && !defined(PART_8)\n#define PART_1 1\n#define PART_2 1\n#define PART_3 1\n#define PART_4 1\n#define PART_5 1\n#define PART_6 1\n#define PART_7 1\n#define PART_8 1\n#endif\n\n#ifdef PART_1\n#endif\n\n#ifdef PART_2\n#endif\n\n#ifdef PART_3\n#endif\n\n#ifdef PART_4\n#endif\n\n#ifdef PART_5\n#endif\n\n#ifdef PART_6\n#endif\n\n#ifdef PART_7\n#endif\n\n#ifdef PART_8\n#endif\n\n\n#if !defined(PART_1) && !defined(PART_2) && !defined(PART_3) && !defined(PART_4) && !defined(PART_5) && !defined(PART_6) && !defined(PART_7) && !defined(PART_8)\n#define PART_1 1\n#define PART_2 1\n#define PART_3 1\n#define PART_4 1\n#define PART_5 1\n#define PART_6 1\n#define PART_7 1\n#define PART_8 1\n#endif\n\n#ifdef PART_1\nvoid REGPARAM2 CPUFUNC(op_30_3)(uae_u32 opcode) /* OR.B #<data>.B,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_70_3)(uae_u32 opcode) /* OR.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\tuae_s16 dst = get_word(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0_3)(uae_u32 opcode) /* OR.L #<data>.L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(6));\n{\tuae_s32 dst = get_long(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_130_3)(uae_u32 opcode) /* BTST.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_13b_3)(uae_u32 opcode) /* BTST.B Dn,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n\tuae_u32 dstreg = 3;\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr dsta = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_170_3)(uae_u32 opcode) /* BCHG.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_17b_3)(uae_u32 opcode) /* BCHG.B Dn,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n\tuae_u32 dstreg = 3;\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr dsta = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1b0_3)(uae_u32 opcode) /* BCLR.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1bb_3)(uae_u32 opcode) /* BCLR.B Dn,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n\tuae_u32 dstreg = 3;\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr dsta = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1f0_3)(uae_u32 opcode) /* BSET.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1fb_3)(uae_u32 opcode) /* BSET.B Dn,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n\tuae_u32 dstreg = 3;\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr dsta = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_230_3)(uae_u32 opcode) /* AND.B #<data>.B,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_270_3)(uae_u32 opcode) /* AND.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\tuae_s16 dst = get_word(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2b0_3)(uae_u32 opcode) /* AND.L #<data>.L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(6));\n{\tuae_s32 dst = get_long(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_430_3)(uae_u32 opcode) /* SUB.B #<data>.B,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_470_3)(uae_u32 opcode) /* SUB.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4b0_3)(uae_u32 opcode) /* SUB.L #<data>.L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(6));\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_630_3)(uae_u32 opcode) /* ADD.B #<data>.B,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_670_3)(uae_u32 opcode) /* ADD.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_6b0_3)(uae_u32 opcode) /* ADD.L #<data>.L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(6));\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_830_3)(uae_u32 opcode) /* BTST.B #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_83b_3)(uae_u32 opcode) /* BTST.B #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr tmppc = m68k_getpc() + 4;\n\tuaecptr dsta = get_disp_ea_000(tmppc, get_iword(4));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_870_3)(uae_u32 opcode) /* BCHG.B #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_87b_3)(uae_u32 opcode) /* BCHG.B #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr tmppc = m68k_getpc() + 4;\n\tuaecptr dsta = get_disp_ea_000(tmppc, get_iword(4));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tdst ^= (1 << src);\n\tSET_ZFLG (((uae_u32)dst & (1 << src)) >> src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8b0_3)(uae_u32 opcode) /* BCLR.B #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8bb_3)(uae_u32 opcode) /* BCLR.B #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr tmppc = m68k_getpc() + 4;\n\tuaecptr dsta = get_disp_ea_000(tmppc, get_iword(4));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst &= ~(1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8f0_3)(uae_u32 opcode) /* BSET.B #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8fb_3)(uae_u32 opcode) /* BSET.B #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr tmppc = m68k_getpc() + 4;\n\tuaecptr dsta = get_disp_ea_000(tmppc, get_iword(4));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= 7;\n\tSET_ZFLG (1 ^ ((dst >> src) & 1));\n\tdst |= (1 << src);\n\tput_byte(dsta,dst);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a30_3)(uae_u32 opcode) /* EOR.B #<data>.B,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_a70_3)(uae_u32 opcode) /* EOR.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\tuae_s16 dst = get_word(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\n#endif\n\n#ifdef PART_2\nvoid REGPARAM2 CPUFUNC(op_ab0_3)(uae_u32 opcode) /* EOR.L #<data>.L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(6));\n{\tuae_s32 dst = get_long(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c30_3)(uae_u32 opcode) /* CMP.B #<data>.B,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c3b_3)(uae_u32 opcode) /* CMP.B #<data>.B,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr tmppc = m68k_getpc() + 4;\n\tuaecptr dsta = get_disp_ea_000(tmppc, get_iword(4));\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c70_3)(uae_u32 opcode) /* CMP.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c7b_3)(uae_u32 opcode) /* CMP.W #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr tmppc = m68k_getpc() + 4;\n\tuaecptr dsta = get_disp_ea_000(tmppc, get_iword(4));\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_cb0_3)(uae_u32 opcode) /* CMP.L #<data>.L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(6));\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_cbb_3)(uae_u32 opcode) /* CMP.L #<data>.L,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr tmppc = m68k_getpc() + 6;\n\tuaecptr dsta = get_disp_ea_000(tmppc, get_iword(6));\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1030_3)(uae_u32 opcode) /* MOVE.B (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_103b_3)(uae_u32 opcode) /* MOVE.B (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10b0_3)(uae_u32 opcode) /* MOVE.B (d8,An,Xn),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10bb_3)(uae_u32 opcode) /* MOVE.B (d8,PC,Xn),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10f0_3)(uae_u32 opcode) /* MOVE.B (d8,An,Xn),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_10fb_3)(uae_u32 opcode) /* MOVE.B (d8,PC,Xn),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += areg_byteinc[dstreg];\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1130_3)(uae_u32 opcode) /* MOVE.B (d8,An,Xn),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_113b_3)(uae_u32 opcode) /* MOVE.B (d8,PC,Xn),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - areg_byteinc[dstreg];\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1170_3)(uae_u32 opcode) /* MOVE.B (d8,An,Xn),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_117b_3)(uae_u32 opcode) /* MOVE.B (d8,PC,Xn),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1180_3)(uae_u32 opcode) /* MOVE.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1190_3)(uae_u32 opcode) /* MOVE.B (An),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_1198_3)(uae_u32 opcode) /* MOVE.B (An)+,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg(regs, srcreg) += areg_byteinc[srcreg];\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11a0_3)(uae_u32 opcode) /* MOVE.B -(An),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - areg_byteinc[srcreg];\n{\tuae_s8 src = get_byte(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11a8_3)(uae_u32 opcode) /* MOVE.B (d16,An),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11b0_3)(uae_u32 opcode) /* MOVE.B (d8,An,Xn),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11b8_3)(uae_u32 opcode) /* MOVE.B (xxx).W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11b9_3)(uae_u32 opcode) /* MOVE.B (xxx).L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(6));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11ba_3)(uae_u32 opcode) /* MOVE.B (d16,PC),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11bb_3)(uae_u32 opcode) /* MOVE.B (d8,PC,Xn),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11bc_3)(uae_u32 opcode) /* MOVE.B #<data>.B,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s8 src = get_ibyte(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11f0_3)(uae_u32 opcode) /* MOVE.B (d8,An,Xn),(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_11fb_3)(uae_u32 opcode) /* MOVE.B (d8,PC,Xn),(xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_13f0_3)(uae_u32 opcode) /* MOVE.B (d8,An,Xn),(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = get_ilong(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_13fb_3)(uae_u32 opcode) /* MOVE.B (d8,PC,Xn),(xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuaecptr dsta = get_ilong(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2030_3)(uae_u32 opcode) /* MOVE.L (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_203b_3)(uae_u32 opcode) /* MOVE.L (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_2070_3)(uae_u32 opcode) /* MOVEA.L (d8,An,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 val = src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_207b_3)(uae_u32 opcode) /* MOVEA.L (d8,PC,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 val = src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_20b0_3)(uae_u32 opcode) /* MOVE.L (d8,An,Xn),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20bb_3)(uae_u32 opcode) /* MOVE.L (d8,PC,Xn),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20f0_3)(uae_u32 opcode) /* MOVE.L (d8,An,Xn),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 4;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_20fb_3)(uae_u32 opcode) /* MOVE.L (d8,PC,Xn),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 4;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2130_3)(uae_u32 opcode) /* MOVE.L (d8,An,Xn),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_213b_3)(uae_u32 opcode) /* MOVE.L (d8,PC,Xn),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 4;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n#endif\n\n#ifdef PART_3\nvoid REGPARAM2 CPUFUNC(op_2170_3)(uae_u32 opcode) /* MOVE.L (d8,An,Xn),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_217b_3)(uae_u32 opcode) /* MOVE.L (d8,PC,Xn),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2180_3)(uae_u32 opcode) /* MOVE.L Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2188_3)(uae_u32 opcode) /* MOVE.L An,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = m68k_areg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2190_3)(uae_u32 opcode) /* MOVE.L (An),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_2198_3)(uae_u32 opcode) /* MOVE.L (An)+,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg(regs, srcreg) += 4;\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21a0_3)(uae_u32 opcode) /* MOVE.L -(An),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 4;\n{\tuae_s32 src = get_long(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21a8_3)(uae_u32 opcode) /* MOVE.L (d16,An),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21b0_3)(uae_u32 opcode) /* MOVE.L (d8,An,Xn),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21b8_3)(uae_u32 opcode) /* MOVE.L (xxx).W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21b9_3)(uae_u32 opcode) /* MOVE.L (xxx).L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(6));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21ba_3)(uae_u32 opcode) /* MOVE.L (d16,PC),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21bb_3)(uae_u32 opcode) /* MOVE.L (d8,PC,Xn),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21bc_3)(uae_u32 opcode) /* MOVE.L #<data>.L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s32 src = get_ilong(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(6));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21f0_3)(uae_u32 opcode) /* MOVE.L (d8,An,Xn),(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_21fb_3)(uae_u32 opcode) /* MOVE.L (d8,PC,Xn),(xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_23f0_3)(uae_u32 opcode) /* MOVE.L (d8,An,Xn),(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = get_ilong(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_23fb_3)(uae_u32 opcode) /* MOVE.L (d8,PC,Xn),(xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuaecptr dsta = get_ilong(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3030_3)(uae_u32 opcode) /* MOVE.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_303b_3)(uae_u32 opcode) /* MOVE.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_3070_3)(uae_u32 opcode) /* MOVEA.W (d8,An,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 val = (uae_s32)(uae_s16)src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_307b_3)(uae_u32 opcode) /* MOVEA.W (d8,PC,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 val = (uae_s32)(uae_s16)src;\n\tm68k_areg(regs, dstreg) = (val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_30b0_3)(uae_u32 opcode) /* MOVE.W (d8,An,Xn),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30bb_3)(uae_u32 opcode) /* MOVE.W (d8,PC,Xn),(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30f0_3)(uae_u32 opcode) /* MOVE.W (d8,An,Xn),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 2;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_30fb_3)(uae_u32 opcode) /* MOVE.W (d8,PC,Xn),(An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg);\n\tm68k_areg(regs, dstreg) += 2;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3130_3)(uae_u32 opcode) /* MOVE.W (d8,An,Xn),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_313b_3)(uae_u32 opcode) /* MOVE.W (d8,PC,Xn),-(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) - 2;\n\tm68k_areg (regs, dstreg) = dsta;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3170_3)(uae_u32 opcode) /* MOVE.W (d8,An,Xn),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_317b_3)(uae_u32 opcode) /* MOVE.W (d8,PC,Xn),(d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = m68k_areg(regs, dstreg) + (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3180_3)(uae_u32 opcode) /* MOVE.W Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3188_3)(uae_u32 opcode) /* MOVE.W An,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = m68k_areg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3190_3)(uae_u32 opcode) /* MOVE.W (An),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_3198_3)(uae_u32 opcode) /* MOVE.W (An)+,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg(regs, srcreg) += 2;\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31a0_3)(uae_u32 opcode) /* MOVE.W -(An),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n{\tuae_s16 src = get_word(srca);\n\tm68k_areg (regs, srcreg) = srca;\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31a8_3)(uae_u32 opcode) /* MOVE.W (d16,An),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31b0_3)(uae_u32 opcode) /* MOVE.W (d8,An,Xn),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31b8_3)(uae_u32 opcode) /* MOVE.W (xxx).W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31b9_3)(uae_u32 opcode) /* MOVE.W (xxx).L,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_ilong(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(6));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31ba_3)(uae_u32 opcode) /* MOVE.W (d16,PC),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = m68k_getpc () + 2;\n\tsrca += (uae_s32)(uae_s16)get_iword(2);\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31bb_3)(uae_u32 opcode) /* MOVE.W (d8,PC,Xn),(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31bc_3)(uae_u32 opcode) /* MOVE.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuae_s16 src = get_iword(2);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31f0_3)(uae_u32 opcode) /* MOVE.W (d8,An,Xn),(xxx).W */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_31fb_3)(uae_u32 opcode) /* MOVE.W (d8,PC,Xn),(xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = (uae_s32)(uae_s16)get_iword(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(6);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_33f0_3)(uae_u32 opcode) /* MOVE.W (d8,An,Xn),(xxx).L */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = get_ilong(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_33fb_3)(uae_u32 opcode) /* MOVE.W (d8,PC,Xn),(xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuaecptr dsta = get_ilong(4);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(8);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4030_3)(uae_u32 opcode) /* NEGX.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(0)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tput_byte(srca,newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4070_3)(uae_u32 opcode) /* NEGX.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(0)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s16)(newv)) == 0));\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tput_word(srca,newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_40b0_3)(uae_u32 opcode) /* NEGX.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 newv = 0 - src - (GET_XFLG ? 1 : 0);\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(0)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_VFLG ((flgs ^ flgo) & (flgo ^ flgn));\n\tSET_CFLG (flgs ^ ((flgs ^ flgn) & (flgo ^ flgn)));\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s32)(newv)) == 0));\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tput_long(srca,newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_40f0_3)(uae_u32 opcode) /* MVSR2.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel2002; }\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n\tMakeSR();\n\tput_word(srca,regs.sr);\n}}}m68k_incpc(4);\nendlabel2002: ;\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_4130_3)(uae_u32 opcode) /* CHK.L (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel2003; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel2003; }\n}}}}m68k_incpc(4);\nendlabel2003: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_413b_3)(uae_u32 opcode) /* CHK.L (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel2004; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel2004; }\n}}}}m68k_incpc(4);\nendlabel2004: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_41b0_3)(uae_u32 opcode) /* CHK.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel2005; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel2005; }\n}}}}m68k_incpc(4);\nendlabel2005: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_41bb_3)(uae_u32 opcode) /* CHK.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tif ((uae_s32)dst < 0) { SET_NFLG (1); Exception(6,oldpc); goto endlabel2006; }\n\telse if (dst > src) { SET_NFLG (0); Exception(6,oldpc); goto endlabel2006; }\n}}}}m68k_incpc(4);\nendlabel2006: ;\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_41f0_3)(uae_u32 opcode) /* LEA.L (d8,An,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tm68k_areg(regs, dstreg) = (srca);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_41fb_3)(uae_u32 opcode) /* LEA.L (d8,PC,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tm68k_areg(regs, dstreg) = (srca);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_4230_3)(uae_u32 opcode) /* CLR.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(0)) == 0);\n\tSET_NFLG (((uae_s8)(0)) < 0);\n\tput_byte(srca,0);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4270_3)(uae_u32 opcode) /* CLR.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(0)) == 0);\n\tSET_NFLG (((uae_s16)(0)) < 0);\n\tput_word(srca,0);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\n#endif\n\n#ifdef PART_4\nvoid REGPARAM2 CPUFUNC(op_42b0_3)(uae_u32 opcode) /* CLR.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(0)) == 0);\n\tSET_NFLG (((uae_s32)(0)) < 0);\n\tput_long(srca,0);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_42f0_3)(uae_u32 opcode) /* MVSR2.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n\tMakeSR();\n\tput_word(srca,regs.sr & 0xff);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_4430_3)(uae_u32 opcode) /* NEG.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{{uae_u32 dst = ((uae_s8)(0)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(0)) < 0;\n\tint flgn = ((uae_s8)(dst)) < 0;\n\tSET_ZFLG (((uae_s8)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(srca,dst);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4470_3)(uae_u32 opcode) /* NEG.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{{uae_u32 dst = ((uae_s16)(0)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(0)) < 0;\n\tint flgn = ((uae_s16)(dst)) < 0;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(srca,dst);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44b0_3)(uae_u32 opcode) /* NEG.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{{uae_u32 dst = ((uae_s32)(0)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(0)) < 0;\n\tint flgn = ((uae_s32)(dst)) < 0;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(0)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(srca,dst);\n}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44f0_3)(uae_u32 opcode) /* MV2SR.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n\tMakeSR();\n\tregs.sr &= 0xFF00;\n\tregs.sr |= src & 0xFF;\n\tMakeFromSR();\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_44fb_3)(uae_u32 opcode) /* MV2SR.B (d8,PC,Xn) */\n{\n\tcpuop_begin();\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n\tMakeSR();\n\tregs.sr &= 0xFF00;\n\tregs.sr |= src & 0xFF;\n\tMakeFromSR();\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4630_3)(uae_u32 opcode) /* NOT.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(dst)) == 0);\n\tSET_NFLG (((uae_s8)(dst)) < 0);\n\tput_byte(srca,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4670_3)(uae_u32 opcode) /* NOT.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(dst)) == 0);\n\tSET_NFLG (((uae_s16)(dst)) < 0);\n\tput_word(srca,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46b0_3)(uae_u32 opcode) /* NOT.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_u32 dst = ~src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(dst)) == 0);\n\tSET_NFLG (((uae_s32)(dst)) < 0);\n\tput_long(srca,dst);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46f0_3)(uae_u32 opcode) /* MV2SR.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{if (!regs.s) { Exception(8,0); goto endlabel2021; }\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n\tregs.sr = src;\n\tMakeFromSR();\n}}}}m68k_incpc(4);\nendlabel2021: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_46fb_3)(uae_u32 opcode) /* MV2SR.W (d8,PC,Xn) */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel2022; }\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n\tregs.sr = src;\n\tMakeFromSR();\n}}}}m68k_incpc(4);\nendlabel2022: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4830_3)(uae_u32 opcode) /* NBCD.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuae_u16 newv_lo = - (src & 0xF) - (GET_XFLG ? 1 : 0);\n\tuae_u16 newv_hi = - (src & 0xF0);\n\tuae_u16 newv;\n\tint cflg;\n\tif (newv_lo > 9) { newv_lo -= 6; }\n\tnewv = newv_hi + newv_lo;\n\tcflg = (newv & 0x1F0) > 0x90;\n\tif (cflg) newv -= 0x60;\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tSET_ZFLG (GET_ZFLG & (((uae_s8)(newv)) == 0));\n\tSET_NFLG (((uae_s8)(newv)) < 0);\n\tput_byte(srca,newv);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4870_3)(uae_u32 opcode) /* PEA.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuaecptr dsta = m68k_areg(regs, 7) - 4;\n\tm68k_areg (regs, 7) = dsta;\n\tput_long(dsta,srca);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_487b_3)(uae_u32 opcode) /* PEA.L (d8,PC,Xn) */\n{\n\tcpuop_begin();\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuaecptr dsta = m68k_areg(regs, 7) - 4;\n\tm68k_areg (regs, 7) = dsta;\n\tput_long(dsta,srca);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_48b0_3)(uae_u32 opcode) /* MVMLE.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\tuae_u16 dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n\twhile (dmask) { put_word(srca, m68k_dreg(regs, movem_index1[dmask])); srca += 2; dmask = movem_next[dmask]; }\n\twhile (amask) { put_word(srca, m68k_areg(regs, movem_index1[amask])); srca += 2; amask = movem_next[amask]; }\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_48f0_3)(uae_u32 opcode) /* MVMLE.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\tuae_u16 dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n\twhile (dmask) { put_long(srca, m68k_dreg(regs, movem_index1[dmask])); srca += 4; dmask = movem_next[dmask]; }\n\twhile (amask) { put_long(srca, m68k_areg(regs, movem_index1[amask])); srca += 4; amask = movem_next[amask]; }\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_4a30_3)(uae_u32 opcode) /* TST.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a3b_3)(uae_u32 opcode) /* TST.B (d8,PC,Xn) */\n{\n\tcpuop_begin();\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a70_3)(uae_u32 opcode) /* TST.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4a7b_3)(uae_u32 opcode) /* TST.W (d8,PC,Xn) */\n{\n\tcpuop_begin();\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4ab0_3)(uae_u32 opcode) /* TST.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4abb_3)(uae_u32 opcode) /* TST.L (d8,PC,Xn) */\n{\n\tcpuop_begin();\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_4af0_3)(uae_u32 opcode) /* TAS.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tsrc |= 0x80;\n\tput_byte(srca,src);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4cb0_3)(uae_u32 opcode) /* MVMEL.W #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; amask = movem_next[amask]; }\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4cbb_3)(uae_u32 opcode) /* MVMEL.W #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{\tuaecptr tmppc = m68k_getpc() + 4;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(4));\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = (uae_s32)(uae_s16)get_word(srca); srca += 2; amask = movem_next[amask]; }\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4cf0_3)(uae_u32 opcode) /* MVMEL.L #<data>.W,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(4));\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = get_long(srca); srca += 4; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = get_long(srca); srca += 4; amask = movem_next[amask]; }\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4cfb_3)(uae_u32 opcode) /* MVMEL.L #<data>.W,(d8,PC,Xn) */\n{\n\tcpuop_begin();\n\tuae_u32 dstreg = 3;\n{\tuae_u16 mask = get_iword(2);\n\tunsigned int dmask = mask & 0xff, amask = (mask >> 8) & 0xff;\n{\tuaecptr tmppc = m68k_getpc() + 4;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(4));\n{\twhile (dmask) { m68k_dreg(regs, movem_index1[dmask]) = get_long(srca); srca += 4; dmask = movem_next[dmask]; }\n\twhile (amask) { m68k_areg(regs, movem_index1[amask]) = get_long(srca); srca += 4; amask = movem_next[amask]; }\n}}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4eb0_3)(uae_u32 opcode) /* JSR.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n\tm68k_do_jsr(m68k_getpc() + 4, srca);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4ebb_3)(uae_u32 opcode) /* JSR.L (d8,PC,Xn) */\n{\n\tcpuop_begin();\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n\tm68k_do_jsr(m68k_getpc() + 4, srca);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4ef0_3)(uae_u32 opcode) /* JMP.L (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n\tm68k_setpc(srca);\n}}\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_4efb_3)(uae_u32 opcode) /* JMP.L (d8,PC,Xn) */\n{\n\tcpuop_begin();\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n\tm68k_setpc(srca);\n}}\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_5030_3)(uae_u32 opcode) /* ADD.B #<data>,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n#endif\n\n#ifdef PART_5\nvoid REGPARAM2 CPUFUNC(op_5070_3)(uae_u32 opcode) /* ADD.W #<data>,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_50b0_3)(uae_u32 opcode) /* ADD.L #<data>,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_50f0_3)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tint val = cctrue(0) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_5130_3)(uae_u32 opcode) /* SUB.B #<data>,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_5170_3)(uae_u32 opcode) /* SUB.W #<data>,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_51b0_3)(uae_u32 opcode) /* SUB.L #<data>,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = imm8_table[((opcode >> 1) & 7)];\n#else\n\tuae_u32 srcreg = imm8_table[((opcode >> 9) & 7)];\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_u32 src = srcreg;\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_51f0_3)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tint val = cctrue(1) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_52f0_3)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tint val = cctrue(2) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_53f0_3)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tint val = cctrue(3) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_54f0_3)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tint val = cctrue(4) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_55f0_3)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tint val = cctrue(5) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_56f0_3)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tint val = cctrue(6) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_57f0_3)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tint val = cctrue(7) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_58f0_3)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tint val = cctrue(8) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_59f0_3)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tint val = cctrue(9) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5af0_3)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tint val = cctrue(10) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5bf0_3)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tint val = cctrue(11) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5cf0_3)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tint val = cctrue(12) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5df0_3)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tint val = cctrue(13) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ef0_3)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tint val = cctrue(14) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_5ff0_3)(uae_u32 opcode) /* Scc.B (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tint val = cctrue(15) ? 0xff : 0;\n\tput_byte(srca,val);\n}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#endif\n\n#ifdef PART_6\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_60ff_3)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{\tm68k_incpc(2);\n\tif (!cctrue(0)) goto endlabel2065;\n\t\tlast_addr_for_exception_3 = m68k_getpc() + 2;\n\t\tlast_fault_for_exception_3 = m68k_getpc() + 1;\n\t\tlast_op_for_exception_3 = opcode; Exception(3,0); goto endlabel2065;\n{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(0)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel2065: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_62ff_3)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{\tm68k_incpc(2);\n\tif (!cctrue(2)) goto endlabel2066;\n\t\tlast_addr_for_exception_3 = m68k_getpc() + 2;\n\t\tlast_fault_for_exception_3 = m68k_getpc() + 1;\n\t\tlast_op_for_exception_3 = opcode; Exception(3,0); goto endlabel2066;\n{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(2)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel2066: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_63ff_3)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{\tm68k_incpc(2);\n\tif (!cctrue(3)) goto endlabel2067;\n\t\tlast_addr_for_exception_3 = m68k_getpc() + 2;\n\t\tlast_fault_for_exception_3 = m68k_getpc() + 1;\n\t\tlast_op_for_exception_3 = opcode; Exception(3,0); goto endlabel2067;\n{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(3)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel2067: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_64ff_3)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{\tm68k_incpc(2);\n\tif (!cctrue(4)) goto endlabel2068;\n\t\tlast_addr_for_exception_3 = m68k_getpc() + 2;\n\t\tlast_fault_for_exception_3 = m68k_getpc() + 1;\n\t\tlast_op_for_exception_3 = opcode; Exception(3,0); goto endlabel2068;\n{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(4)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel2068: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_65ff_3)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{\tm68k_incpc(2);\n\tif (!cctrue(5)) goto endlabel2069;\n\t\tlast_addr_for_exception_3 = m68k_getpc() + 2;\n\t\tlast_fault_for_exception_3 = m68k_getpc() + 1;\n\t\tlast_op_for_exception_3 = opcode; Exception(3,0); goto endlabel2069;\n{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(5)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel2069: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_66ff_3)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{\tm68k_incpc(2);\n\tif (!cctrue(6)) goto endlabel2070;\n\t\tlast_addr_for_exception_3 = m68k_getpc() + 2;\n\t\tlast_fault_for_exception_3 = m68k_getpc() + 1;\n\t\tlast_op_for_exception_3 = opcode; Exception(3,0); goto endlabel2070;\n{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(6)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel2070: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_67ff_3)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{\tm68k_incpc(2);\n\tif (!cctrue(7)) goto endlabel2071;\n\t\tlast_addr_for_exception_3 = m68k_getpc() + 2;\n\t\tlast_fault_for_exception_3 = m68k_getpc() + 1;\n\t\tlast_op_for_exception_3 = opcode; Exception(3,0); goto endlabel2071;\n{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(7)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel2071: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_68ff_3)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{\tm68k_incpc(2);\n\tif (!cctrue(8)) goto endlabel2072;\n\t\tlast_addr_for_exception_3 = m68k_getpc() + 2;\n\t\tlast_fault_for_exception_3 = m68k_getpc() + 1;\n\t\tlast_op_for_exception_3 = opcode; Exception(3,0); goto endlabel2072;\n{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(8)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel2072: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_69ff_3)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{\tm68k_incpc(2);\n\tif (!cctrue(9)) goto endlabel2073;\n\t\tlast_addr_for_exception_3 = m68k_getpc() + 2;\n\t\tlast_fault_for_exception_3 = m68k_getpc() + 1;\n\t\tlast_op_for_exception_3 = opcode; Exception(3,0); goto endlabel2073;\n{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(9)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel2073: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6aff_3)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{\tm68k_incpc(2);\n\tif (!cctrue(10)) goto endlabel2074;\n\t\tlast_addr_for_exception_3 = m68k_getpc() + 2;\n\t\tlast_fault_for_exception_3 = m68k_getpc() + 1;\n\t\tlast_op_for_exception_3 = opcode; Exception(3,0); goto endlabel2074;\n{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(10)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel2074: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6bff_3)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{\tm68k_incpc(2);\n\tif (!cctrue(11)) goto endlabel2075;\n\t\tlast_addr_for_exception_3 = m68k_getpc() + 2;\n\t\tlast_fault_for_exception_3 = m68k_getpc() + 1;\n\t\tlast_op_for_exception_3 = opcode; Exception(3,0); goto endlabel2075;\n{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(11)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel2075: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6cff_3)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{\tm68k_incpc(2);\n\tif (!cctrue(12)) goto endlabel2076;\n\t\tlast_addr_for_exception_3 = m68k_getpc() + 2;\n\t\tlast_fault_for_exception_3 = m68k_getpc() + 1;\n\t\tlast_op_for_exception_3 = opcode; Exception(3,0); goto endlabel2076;\n{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(12)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel2076: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6dff_3)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{\tm68k_incpc(2);\n\tif (!cctrue(13)) goto endlabel2077;\n\t\tlast_addr_for_exception_3 = m68k_getpc() + 2;\n\t\tlast_fault_for_exception_3 = m68k_getpc() + 1;\n\t\tlast_op_for_exception_3 = opcode; Exception(3,0); goto endlabel2077;\n{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(13)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel2077: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6eff_3)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{\tm68k_incpc(2);\n\tif (!cctrue(14)) goto endlabel2078;\n\t\tlast_addr_for_exception_3 = m68k_getpc() + 2;\n\t\tlast_fault_for_exception_3 = m68k_getpc() + 1;\n\t\tlast_op_for_exception_3 = opcode; Exception(3,0); goto endlabel2078;\n{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(14)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel2078: ;\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_6fff_3)(uae_u32 opcode) /* Bcc.L #<data>.L */\n{\n\tcpuop_begin();\n{\tm68k_incpc(2);\n\tif (!cctrue(15)) goto endlabel2079;\n\t\tlast_addr_for_exception_3 = m68k_getpc() + 2;\n\t\tlast_fault_for_exception_3 = m68k_getpc() + 1;\n\t\tlast_op_for_exception_3 = opcode; Exception(3,0); goto endlabel2079;\n{\tuae_s32 src = get_ilong(2);\n\tif (!cctrue(15)) goto didnt_jump;\n\tm68k_incpc ((uae_s32)src + 2);\nreturn;\ndidnt_jump:;\n}}m68k_incpc(6);\nendlabel2079: ;\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_8030_3)(uae_u32 opcode) /* OR.B (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_803b_3)(uae_u32 opcode) /* OR.B (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8070_3)(uae_u32 opcode) /* OR.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_807b_3)(uae_u32 opcode) /* OR.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80b0_3)(uae_u32 opcode) /* OR.L (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80bb_3)(uae_u32 opcode) /* OR.L (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80f0_3)(uae_u32 opcode) /* DIVU.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(4);\n\tif (src == 0) { SET_VFLG (0); Exception (5, oldpc); goto endlabel2086; } else {\n\tuae_u32 newv = (uae_u32)dst / (uae_u32)(uae_u16)src;\n\tuae_u32 rem = (uae_u32)dst % (uae_u32)(uae_u16)src;\n\tif (newv > 0xffff) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}endlabel2086: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_80fb_3)(uae_u32 opcode) /* DIVU.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(4);\n\tif (src == 0) { SET_VFLG (0); Exception (5, oldpc); goto endlabel2087; } else {\n\tuae_u32 newv = (uae_u32)dst / (uae_u32)(uae_u16)src;\n\tuae_u32 rem = (uae_u32)dst % (uae_u32)(uae_u16)src;\n\tif (newv > 0xffff) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}endlabel2087: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8130_3)(uae_u32 opcode) /* OR.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_8170_3)(uae_u32 opcode) /* OR.W Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s16 dst = get_word(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81b0_3)(uae_u32 opcode) /* OR.L Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s32 dst = get_long(dsta);\n\tsrc |= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81f0_3)(uae_u32 opcode) /* DIVS.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(4);\n\tif (src == 0) { SET_VFLG (0); Exception(5,oldpc); goto endlabel2091; } else {\n\tuae_s32 newv = (uae_s32)dst / (uae_s32)(uae_s16)src;\n\tuae_u16 rem = (uae_s32)dst % (uae_s32)(uae_s16)src;\n\tif ((newv & 0xffff8000) != 0 && (newv & 0xffff8000) != 0xffff8000) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tif (((uae_s16)rem < 0) != ((uae_s32)dst < 0)) rem = -rem;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}endlabel2091: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_81fb_3)(uae_u32 opcode) /* DIVS.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{\tuaecptr oldpc = m68k_getpc();\n{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\nm68k_incpc(4);\n\tif (src == 0) { SET_VFLG (0); Exception(5,oldpc); goto endlabel2092; } else {\n\tuae_s32 newv = (uae_s32)dst / (uae_s32)(uae_s16)src;\n\tuae_u16 rem = (uae_s32)dst % (uae_s32)(uae_s16)src;\n\tif ((newv & 0xffff8000) != 0 && (newv & 0xffff8000) != 0xffff8000) { SET_VFLG (1); SET_NFLG (1); SET_CFLG (0); } else\n\t{\n\tif (((uae_s16)rem < 0) != ((uae_s32)dst < 0)) rem = -rem;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_NFLG (((uae_s16)(newv)) < 0);\n\tnewv = (newv & 0xffff) | ((uae_u32)rem << 16);\n\tm68k_dreg(regs, dstreg) = (newv);\n\t}\n\t}\n}}}}endlabel2092: ;\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9030_3)(uae_u32 opcode) /* SUB.B (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_903b_3)(uae_u32 opcode) /* SUB.B (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9070_3)(uae_u32 opcode) /* SUB.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_907b_3)(uae_u32 opcode) /* SUB.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_90b0_3)(uae_u32 opcode) /* SUB.L (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_90bb_3)(uae_u32 opcode) /* SUB.L (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_90f0_3)(uae_u32 opcode) /* SUBA.W (d8,An,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_90fb_3)(uae_u32 opcode) /* SUBA.W (d8,PC,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_9130_3)(uae_u32 opcode) /* SUB.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_9170_3)(uae_u32 opcode) /* SUB.W Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_91b0_3)(uae_u32 opcode) /* SUB.L Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgo) & (flgn ^ flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_91f0_3)(uae_u32 opcode) /* SUBA.L (d8,An,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_91fb_3)(uae_u32 opcode) /* SUBA.L (d8,PC,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst - src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_b030_3)(uae_u32 opcode) /* CMP.B (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b03b_3)(uae_u32 opcode) /* CMP.B (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) - ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u8)(src)) > ((uae_u8)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n#endif\n\n#ifdef PART_7\nvoid REGPARAM2 CPUFUNC(op_b070_3)(uae_u32 opcode) /* CMP.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b07b_3)(uae_u32 opcode) /* CMP.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) - ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u16)(src)) > ((uae_u16)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0b0_3)(uae_u32 opcode) /* CMP.L (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0bb_3)(uae_u32 opcode) /* CMP.L (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0f0_3)(uae_u32 opcode) /* CMPA.W (d8,An,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b0fb_3)(uae_u32 opcode) /* CMPA.W (d8,PC,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b130_3)(uae_u32 opcode) /* EOR.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b170_3)(uae_u32 opcode) /* EOR.W Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s16 dst = get_word(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1b0_3)(uae_u32 opcode) /* EOR.L Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s32 dst = get_long(dsta);\n\tsrc ^= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1f0_3)(uae_u32 opcode) /* CMPA.L (d8,An,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_b1fb_3)(uae_u32 opcode) /* CMPA.L (d8,PC,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) - ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs != flgo) && (flgn != flgo));\n\tSET_CFLG (((uae_u32)(src)) > ((uae_u32)(dst)));\n\tSET_NFLG (flgn != 0);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c030_3)(uae_u32 opcode) /* AND.B (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c03b_3)(uae_u32 opcode) /* AND.B (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((src) & 0xff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c070_3)(uae_u32 opcode) /* AND.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c07b_3)(uae_u32 opcode) /* AND.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((src) & 0xffff);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0b0_3)(uae_u32 opcode) /* AND.L (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0bb_3)(uae_u32 opcode) /* AND.L (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tm68k_dreg(regs, dstreg) = (src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0f0_3)(uae_u32 opcode) /* MULU.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_u32)(uae_u16)dst * (uae_u32)(uae_u16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c0fb_3)(uae_u32 opcode) /* MULU.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_u32)(uae_u16)dst * (uae_u32)(uae_u16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c130_3)(uae_u32 opcode) /* AND.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s8 dst = get_byte(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s8)(src)) == 0);\n\tSET_NFLG (((uae_s8)(src)) < 0);\n\tput_byte(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c170_3)(uae_u32 opcode) /* AND.W Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s16 dst = get_word(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(src)) == 0);\n\tSET_NFLG (((uae_s16)(src)) < 0);\n\tput_word(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1b0_3)(uae_u32 opcode) /* AND.L Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s32 dst = get_long(dsta);\n\tsrc &= dst;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(src)) == 0);\n\tSET_NFLG (((uae_s32)(src)) < 0);\n\tput_long(dsta,src);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1f0_3)(uae_u32 opcode) /* MULS.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_s32)(uae_s16)dst * (uae_s32)(uae_s16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_c1fb_3)(uae_u32 opcode) /* MULS.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{\tuae_u32 newv = (uae_s32)(uae_s16)dst * (uae_s32)(uae_s16)src;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_NFLG (((uae_s32)(newv)) < 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d030_3)(uae_u32 opcode) /* ADD.B (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d03b_3)(uae_u32 opcode) /* ADD.B (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s8 src = get_byte(srca);\n{\tuae_s8 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xff) | ((newv) & 0xff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d070_3)(uae_u32 opcode) /* ADD.W (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d07b_3)(uae_u32 opcode) /* ADD.W (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s16 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (m68k_dreg(regs, dstreg) & ~0xffff) | ((newv) & 0xffff);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d0b0_3)(uae_u32 opcode) /* ADD.L (d8,An,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d0bb_3)(uae_u32 opcode) /* ADD.L (d8,PC,Xn),Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_dreg(regs, dstreg);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tm68k_dreg(regs, dstreg) = (newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d0f0_3)(uae_u32 opcode) /* ADDA.W (d8,An,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d0fb_3)(uae_u32 opcode) /* ADDA.W (d8,PC,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s16 src = get_word(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_d130_3)(uae_u32 opcode) /* ADD.B Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s8 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s8 dst = get_byte(dsta);\n{{uae_u32 newv = ((uae_s8)(dst)) + ((uae_s8)(src));\n{\tint flgs = ((uae_s8)(src)) < 0;\n\tint flgo = ((uae_s8)(dst)) < 0;\n\tint flgn = ((uae_s8)(newv)) < 0;\n\tSET_ZFLG (((uae_s8)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u8)(~dst)) < ((uae_u8)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_byte(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d170_3)(uae_u32 opcode) /* ADD.W Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s16 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s16 dst = get_word(dsta);\n{{uae_u32 newv = ((uae_s16)(dst)) + ((uae_s16)(src));\n{\tint flgs = ((uae_s16)(src)) < 0;\n\tint flgo = ((uae_s16)(dst)) < 0;\n\tint flgn = ((uae_s16)(newv)) < 0;\n\tSET_ZFLG (((uae_s16)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u16)(~dst)) < ((uae_u16)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_word(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_d1b0_3)(uae_u32 opcode) /* ADD.L Dn,(d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 1) & 7);\n#else\n\tuae_u32 srcreg = ((opcode >> 9) & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 8) & 7;\n#else\n\tuae_u32 dstreg = opcode & 7;\n#endif\n{{\tuae_s32 src = m68k_dreg(regs, srcreg);\n{\tuaecptr dsta = get_disp_ea_000(m68k_areg(regs, dstreg), get_iword(2));\n{\tuae_s32 dst = get_long(dsta);\n{{uae_u32 newv = ((uae_s32)(dst)) + ((uae_s32)(src));\n{\tint flgs = ((uae_s32)(src)) < 0;\n\tint flgo = ((uae_s32)(dst)) < 0;\n\tint flgn = ((uae_s32)(newv)) < 0;\n\tSET_ZFLG (((uae_s32)(newv)) == 0);\n\tSET_VFLG ((flgs ^ flgn) & (flgo ^ flgn));\n\tSET_CFLG (((uae_u32)(~dst)) < ((uae_u32)(src)));\n\tCOPY_CARRY;\n\tSET_NFLG (flgn != 0);\n\tput_long(dsta,newv);\n}}}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n#endif\n\n#ifdef PART_8\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d1f0_3)(uae_u32 opcode) /* ADDA.L (d8,An,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_d1fb_3)(uae_u32 opcode) /* ADDA.L (d8,PC,Xn),An */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 dstreg = (opcode >> 1) & 7;\n#else\n\tuae_u32 dstreg = (opcode >> 9) & 7;\n#endif\n{{\tuaecptr tmppc = m68k_getpc() + 2;\n\tuaecptr srca = get_disp_ea_000(tmppc, get_iword(2));\n{\tuae_s32 src = get_long(srca);\n{\tuae_s32 dst = m68k_areg(regs, dstreg);\n{\tuae_u32 newv = dst + src;\n\tm68k_areg(regs, dstreg) = (newv);\n}}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\nvoid REGPARAM2 CPUFUNC(op_e0f0_3)(uae_u32 opcode) /* ASRW.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 sign = 0x8000 & val;\n\tuae_u32 cflg = val & 1;\n\tval = (val >> 1) | sign;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tSET_CFLG (cflg);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e1f0_3)(uae_u32 opcode) /* ASLW.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 sign = 0x8000 & val;\n\tuae_u32 sign2;\n\tval <<= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\n\tsign2 = 0x8000 & val;\n\tSET_CFLG (sign != 0);\n\tCOPY_CARRY;\n\tSET_VFLG (GET_VFLG | (sign2 != sign));\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e2f0_3)(uae_u32 opcode) /* LSRW.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u32 val = (uae_u16)data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e3f0_3)(uae_u32 opcode) /* LSLW.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e4f0_3)(uae_u32 opcode) /* ROXRW.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tif (GET_XFLG) val |= 0x8000;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e5f0_3)(uae_u32 opcode) /* ROXLW.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tif (GET_XFLG) val |= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tCOPY_CARRY;\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e6f0_3)(uae_u32 opcode) /* RORW.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 1;\n\tval >>= 1;\n\tif (carry) val |= 0x8000;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry);\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\nvoid REGPARAM2 CPUFUNC(op_e7f0_3)(uae_u32 opcode) /* ROLW.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr dataa = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n{\tuae_s16 data = get_word(dataa);\n{\tuae_u16 val = data;\n\tuae_u32 carry = val & 0x8000;\n\tval <<= 1;\n\tif (carry)  val |= 1;\n\tCLEAR_CZNV;\n\tSET_ZFLG (((uae_s16)(val)) == 0);\n\tSET_NFLG (((uae_s16)(val)) < 0);\nSET_CFLG (carry >> 15);\n\tput_word(dataa,val);\n}}}}m68k_incpc(4);\n\tcpuop_end();\n}\n#endif\n\n\n#if !defined(PART_1) && !defined(PART_2) && !defined(PART_3) && !defined(PART_4) && !defined(PART_5) && !defined(PART_6) && !defined(PART_7) && !defined(PART_8)\n#define PART_1 1\n#define PART_2 1\n#define PART_3 1\n#define PART_4 1\n#define PART_5 1\n#define PART_6 1\n#define PART_7 1\n#define PART_8 1\n#endif\n\n#ifdef PART_1\n#endif\n\n#ifdef PART_2\n#endif\n\n#ifdef PART_3\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_40c0_4)(uae_u32 opcode) /* MVSR2.W Dn */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tMakeSR();\n\tm68k_dreg(regs, srcreg) = (m68k_dreg(regs, srcreg) & ~0xffff) | ((regs.sr) & 0xffff);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_40d0_4)(uae_u32 opcode) /* MVSR2.W (An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tMakeSR();\n\tput_word(srca,regs.sr);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_40d8_4)(uae_u32 opcode) /* MVSR2.W (An)+ */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg);\n\tm68k_areg(regs, srcreg) += 2;\n\tMakeSR();\n\tput_word(srca,regs.sr);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_40e0_4)(uae_u32 opcode) /* MVSR2.W -(An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) - 2;\n\tm68k_areg (regs, srcreg) = srca;\n\tMakeSR();\n\tput_word(srca,regs.sr);\n}}m68k_incpc(2);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_40e8_4)(uae_u32 opcode) /* MVSR2.W (d16,An) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = m68k_areg(regs, srcreg) + (uae_s32)(uae_s16)get_iword(2);\n\tMakeSR();\n\tput_word(srca,regs.sr);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_40f0_4)(uae_u32 opcode) /* MVSR2.W (d8,An,Xn) */\n{\n\tcpuop_begin();\n#ifdef HAVE_GET_WORD_UNSWAPPED\n\tuae_u32 srcreg = ((opcode >> 8) & 7);\n#else\n\tuae_u32 srcreg = (opcode & 7);\n#endif\n{{\tuaecptr srca = get_disp_ea_000(m68k_areg(regs, srcreg), get_iword(2));\n\tMakeSR();\n\tput_word(srca,regs.sr);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_40f8_4)(uae_u32 opcode) /* MVSR2.W (xxx).W */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = (uae_s32)(uae_s16)get_iword(2);\n\tMakeSR();\n\tput_word(srca,regs.sr);\n}}m68k_incpc(4);\n\tcpuop_end();\n}\n\n#endif\n#ifndef NOFLAGS\nvoid REGPARAM2 CPUFUNC(op_40f9_4)(uae_u32 opcode) /* MVSR2.W (xxx).L */\n{\n\tcpuop_begin();\n{{\tuaecptr srca = get_ilong(2);\n\tMakeSR();\n\tput_word(srca,regs.sr);\n}}m68k_incpc(6);\n\tcpuop_end();\n}\n\n#endif\n#endif\n\n#ifdef PART_4\nvoid REGPARAM2 CPUFUNC(op_4e73_4)(uae_u32 opcode) /* RTE.L  */\n{\n\tcpuop_begin();\n{if (!regs.s) { Exception(8,0); goto endlabel2161; }\n{{\tuaecptr sra = m68k_areg(regs, 7);\n{\tuae_s16 sr = get_word(sra);\n\tm68k_areg(regs, 7) += 2;\n{\tuaecptr pca = m68k_areg(regs, 7);\n{\tuae_s32 pc = get_long(pca);\n\tm68k_areg(regs, 7) += 4;\n\tregs.sr = sr; m68k_setpc_rte(pc);\n\tMakeFromSR();\n}}}}}}endlabel2161: ;\n\tcpuop_end();\n}\n#endif\n\n#ifdef PART_5\n#endif\n\n#ifdef PART_6\n#endif\n\n#ifdef PART_7\n#endif\n\n#ifdef PART_8\n#endif\n\n","/*\n *  video.cpp - Video/graphics emulation\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *  Portions written by Marc Hellwig\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/*\n *  SEE ALSO\n *    Inside Macintosh: Devices, chapter 1 \"Device Manager\"\n *    Designing Cards and Drivers for the Macintosh Family, Second Edition\n *    Designing PCI Cards and Drivers for Power Macintosh Computers\n *    Display Device Driver Guide\n */\n\n#include <stdio.h>\n\n#include \"sysdeps.h\"\n#include \"cpu_emulation.h\"\n#include \"main.h\"\n#include \"macos_util.h\"\n#include \"slot_rom.h\"\n#include \"video.h\"\n#include \"video_defs.h\"\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n// Next available NuBus slot ID\nuint8 monitor_desc::next_slot_id = 0x80;\n\n// Vector of pointers to available monitor descriptions, filled by VideoInit()\nvector<monitor_desc *> VideoMonitors;\n\n\n/*\n *  Find palette size for given color depth\n */\n\nstatic int palette_size(video_depth depth)\n{\n\tswitch (depth) {\n\t\tcase VDEPTH_1BIT: return 2;\n\t\tcase VDEPTH_2BIT: return 4;\n\t\tcase VDEPTH_4BIT: return 16;\n\t\tcase VDEPTH_8BIT: return 256;\n\t\tcase VDEPTH_16BIT: return 32;\n\t\tcase VDEPTH_32BIT: return 256;\n\t\tdefault: return 0;\n\t}\n}\n\n\n/*\n *  Find pointer to monitor_desc for given slot ID (or NULL if not found)\n */\n\nstatic monitor_desc *find_monitor(uint8 id)\n{\n\tvector<monitor_desc *>::const_iterator i, end = VideoMonitors.end();\n\tfor (i = VideoMonitors.begin(); i != end; ++i) {\n\t\tif ((*i)->get_slot_id() == id)\n\t\t\treturn *i;\n\t}\n\treturn NULL;\n}\n\n\n/*\n *  monitor_desc constructor\n */\n\nmonitor_desc::monitor_desc(const vector<video_mode> &available_modes, video_depth default_depth, uint32 default_id) : modes(available_modes)\n{\n\t// Assign the next slot ID on construction\n\tslot_id = next_slot_id++;\n\n\t// Initialize Apple mode list\n\tuint16 mode = 0x80;\n\tfor (int depth = VDEPTH_1BIT; depth <= VDEPTH_32BIT; depth++) {\n\t\tif (has_depth(video_depth(depth)))\n\t\t\tapple_mode_for_depth[depth] = mode++;\n\t\telse\n\t\t\tapple_mode_for_depth[depth] = 0;\n\t}\n\n\t// Set default mode\n\tcurrent_mode = find_mode(depth_to_apple_mode(default_depth), default_id);\n}\n\n\n/*\n *  Get bytes-per-row value for specified resolution/depth\n *  (if the mode isn't supported, make a good guess)\n */\n\nuint32 monitor_desc::get_bytes_per_row(video_depth depth, uint32 id) const\n{\n\tvector<video_mode>::const_iterator i, end = modes.end();\n\tfor (i = modes.begin(); i != end; ++i) {\n\t\tif (i->depth == depth && i->resolution_id == id)\n\t\t\treturn i->bytes_per_row;\n\t}\n\tuint32 x, y;\n\tget_size_of_resolution(id, x, y);\n\treturn TrivialBytesPerRow(x, depth);\n}\n\n\n/*\n *  Check whether a mode with the specified depth exists on this display\n */\n\nbool monitor_desc::has_depth(video_depth depth) const\n{\n\tvector<video_mode>::const_iterator i = modes.begin(), end = modes.end();\n\twhile (i != end) {\n\t\tif (i->depth == depth)\n\t\t\treturn true;\n\t\t++i;\n\t}\n\treturn false;\n}\n\n\n/*\n *  Check whether the specified resolution ID is one of the supported resolutions\n */\n\nbool monitor_desc::has_resolution(uint32 id) const\n{\n\tvector<video_mode>::const_iterator i, end = modes.end();\n\tfor (i = modes.begin(); i != end; ++i) {\n\t\tif (i->resolution_id == id)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n/*\n *  Find specified mode (depth/resolution) (or invalid_mode() if not found)\n */\n\nvector<video_mode>::const_iterator monitor_desc::find_mode(uint16 apple_mode, uint32 id) const\n{\n\tvector<video_mode>::const_iterator i, end = modes.end();\n\tfor (i = modes.begin(); i != end; ++i) {\n\t\tif (i->resolution_id == id && depth_to_apple_mode(i->depth) == apple_mode)\n\t\t\treturn i;\n\t}\n\treturn i;\n}\n\n\n/*\n *  Find maximum supported depth for given resolution ID\n */\n\nvideo_depth monitor_desc::max_depth_of_resolution(uint32 id) const\n{\n\tvideo_depth m = VDEPTH_1BIT;\n\tvector<video_mode>::const_iterator i, end = modes.end();\n\tfor (i = modes.begin(); i != end; ++i) {\n\t\tif (i->depth > m)\n\t\t\tm = i->depth;\n\t}\n\treturn m;\n}\n\n\n/*\n *  Get X/Y size of specified resolution\n */\n\nvoid monitor_desc::get_size_of_resolution(uint32 id, uint32 &x, uint32 &y) const\n{\n\tvector<video_mode>::const_iterator i, end = modes.end();\n\tfor (i = modes.begin(); i != end; ++i) {\n\t\tif (i->resolution_id == id) {\n\t\t\tx = i->x;\n\t\t\ty = i->y;\n\t\t\treturn;\n\t\t}\n\t}\n\tx = y = 0;\n}\n\n\n/*\n *  Set palette to 50% gray\n */\n\nvoid monitor_desc::set_gray_palette(void)\n{\n\tfor (int i=0; i<256; i++) {\n\t\tpalette[i * 3 + 0] = 127;\n\t\tpalette[i * 3 + 1] = 127;\n\t\tpalette[i * 3 + 2] = 127;\n\t}\n\tset_palette(palette, 256);\n}\n\n\n/*\n *  Load gamma-corrected black-to-white ramp to palette for direct-color mode\n */\n\nvoid monitor_desc::load_ramp_palette(void)\n{\n\t// Find tables for gamma correction\n\tuint8 *red_gamma = NULL, *green_gamma = NULL, *blue_gamma = NULL;\n\tbool have_gamma = false;\n\tint data_width = 0;\n\tif (gamma_table) {\n\t\tuint32 table = gamma_table;\n\t\tred_gamma = Mac2HostAddr(table + gFormulaData + ReadMacInt16(table + gFormulaSize));\n\t\tint chan_cnt = ReadMacInt16(table + gChanCnt);\n\t\tif (chan_cnt == 1)\n\t\t\tgreen_gamma = blue_gamma = red_gamma;\n\t\telse {\n\t\t\tint ofs = ReadMacInt16(table + gDataCnt);\n\t\t\tgreen_gamma = red_gamma + ofs;\n\t\t\tblue_gamma = green_gamma + ofs;\n\t\t}\n\t\tdata_width = ReadMacInt16(table + gDataWidth);\n\t\thave_gamma = true;\n\t}\n\n\tint num = (current_mode->depth == VDEPTH_16BIT ? 32 : 256);\n\tuint8 *p = palette;\n\tfor (int i=0; i<num; i++) {\n\t\tuint8 red = (i * 256 / num), green = red, blue = red;\n\t\tif (have_gamma) {\n\t\t\tred = red_gamma[red >> (8 - data_width)];\n\t\t\tgreen = green_gamma[green >> (8 - data_width)];\n\t\t\tblue = blue_gamma[blue >> (8 - data_width)];\n\t\t}\n\t\t*p++ = red;\n\t\t*p++ = green;\n\t\t*p++ = blue;\n\t}\n\n\tset_palette(palette, num);\n}\n\n\n/*\n *  Allocate gamma table of specified size\n */\n\nbool monitor_desc::allocate_gamma_table(int size)\n{\n\tM68kRegisters r;\n\n\tif (size > alloc_gamma_table_size) {\n\t\tif (gamma_table) {\n\t\t\tr.a[0] = gamma_table;\n\t\t\tExecute68kTrap(0xa01f, &r);\t// DisposePtr()\n\t\t\tgamma_table = 0;\n\t\t\talloc_gamma_table_size = 0;\n\t\t}\n\t\tr.d[0] = size;\n\t\tExecute68kTrap(0xa71e, &r);\t// NewPtrSysClear()\n\t\tif (r.a[0] == 0)\n\t\t\treturn false;\n\t\tgamma_table = r.a[0];\n\t\talloc_gamma_table_size = size;\n\t}\n\treturn true;\n}\n\n\n/*\n *  Set gamma table (0 = build linear ramp)\n */\n\nbool monitor_desc::set_gamma_table(uint32 user_table)\n{\n\tif (user_table == 0) { // Build linear ramp, 256 entries\n\n\t\t// Allocate new table, if necessary\n\t\tif (!allocate_gamma_table(SIZEOF_GammaTbl + 256))\n\t\t\treturn memFullErr;\n\n\t\t// Initialize header\n\t\tWriteMacInt16(gamma_table + gVersion, 0);\n\t\tWriteMacInt16(gamma_table + gType, 0);\n\t\tWriteMacInt16(gamma_table + gFormulaSize, 0);\n\t\tWriteMacInt16(gamma_table + gChanCnt, 1);\n\t\tWriteMacInt16(gamma_table + gDataCnt, 256);\n\t\tWriteMacInt16(gamma_table + gDataWidth, 8);\n\n\t\t// Build ramp\n\t\tuint32 p = gamma_table + gFormulaData;\n\t\tfor (int i=0; i<256; i++)\n\t\t\tWriteMacInt8(p + i, i);\n\n\t} else { // User-supplied gamma table\n\n\t\t// Validate header\n\t\tif (ReadMacInt16(user_table + gVersion))\n\t\t\treturn paramErr;\n\t\tif (ReadMacInt16(user_table + gType))\n\t\t\treturn paramErr;\n\t\tint chan_cnt = ReadMacInt16(user_table + gChanCnt);\n\t\tif (chan_cnt != 1 && chan_cnt != 3)\n\t\t\treturn paramErr;\n\t\tint data_width = ReadMacInt16(user_table + gDataWidth);\n\t\tif (data_width > 8)\n\t\t\treturn paramErr;\n\t\tint data_cnt = ReadMacInt16(user_table + gDataCnt);\n\t\tif (data_cnt != (1 << data_width))\n\t\t\treturn paramErr;\n\n\t\t// Allocate new table, if necessary\n\t\tint size = SIZEOF_GammaTbl + ReadMacInt16(user_table + gFormulaSize) + chan_cnt * data_cnt;\n\t\tif (!allocate_gamma_table(size))\n\t\t\treturn memFullErr;\n\n\t\t// Copy table\n\t\tMac2Mac_memcpy(gamma_table, user_table, size);\n\t}\n\n\tif (IsDirectMode(*current_mode))\n\t\tload_ramp_palette();\n\n\treturn true;\n}\n\n\n/*\n *  Switch video mode\n */\n\nvoid monitor_desc::switch_mode(vector<video_mode>::const_iterator it, uint32 param, uint32 dce)\n{\n\tconst video_mode &mode = *it;\n\n\t// Switch mode\n\tset_gray_palette();\n\tcurrent_mode = it;\n\tswitch_to_current_mode();\n\n\t// Update variables\n\tcurrent_apple_mode = depth_to_apple_mode(mode.depth);\n\tcurrent_id = mode.resolution_id;\n\n\tM68kRegisters r;\n\tr.a[0] = slot_param;\n\n\t// Find functional sResource for this display\n\tWriteMacInt8(slot_param + spSlot, ReadMacInt8(dce + dCtlSlot));\n\tWriteMacInt8(slot_param + spID, ReadMacInt8(dce + dCtlSlotId));\n\tWriteMacInt8(slot_param + spExtDev, 0);\n\tr.d[0] = 0x0016;\n\tExecute68kTrap(0xa06e, &r);\t// SRsrcInfo()\n\tuint32 rsrc = ReadMacInt32(slot_param + spPointer);\n\n\t// Patch minorBase (otherwise rebooting won't work)\n\tWriteMacInt8(slot_param + spID, 0x0a); // minorBase\n\tr.d[0] = 0x0006;\n\tExecute68kTrap(0xa06e, &r); // SFindStruct()\n\tuint32 minor_base = ReadMacInt32(slot_param + spPointer) - ROMBaseMac;\n\tROMBaseHost[minor_base + 0] = mac_frame_base >> 24;\n\tROMBaseHost[minor_base + 1] = mac_frame_base >> 16;\n\tROMBaseHost[minor_base + 2] = mac_frame_base >> 8;\n\tROMBaseHost[minor_base + 3] = mac_frame_base;\n\n\t// Patch video mode parameter table\n\tWriteMacInt32(slot_param + spPointer, rsrc);\n\tWriteMacInt8(slot_param + spID, depth_to_apple_mode(mode.depth));\n\tr.d[0] = 0x0006;\n\tExecute68kTrap(0xa06e, &r); // SFindStruct()\n\tWriteMacInt8(slot_param + spID, 0x01);\n\tr.d[0] = 0x0006;\n\tExecute68kTrap(0xa06e, &r); // SFindStruct()\n\tuint32 p = ReadMacInt32(slot_param + spPointer) - ROMBaseMac;\n\tROMBaseHost[p +  8] = mode.bytes_per_row >> 8;\n\tROMBaseHost[p +  9] = mode.bytes_per_row;\n\tROMBaseHost[p + 14] = mode.y >> 8;\n\tROMBaseHost[p + 15] = mode.y;\n\tROMBaseHost[p + 16] = mode.x >> 8;\n\tROMBaseHost[p + 17] = mode.x;\n\n\t// Recalculate slot ROM checksum\n\tChecksumSlotROM();\n\n\t// Update sResource\n\tWriteMacInt8(slot_param + spID, ReadMacInt8(dce + dCtlSlotId));\n\tr.d[0] = 0x002b;\n\tExecute68kTrap(0xa06e, &r); // SUpdateSRT()\n\n\t// Update frame buffer base in DCE and param block\n\tWriteMacInt32(dce + dCtlDevBase, mac_frame_base);\n\tWriteMacInt32(param + csBaseAddr, mac_frame_base);\n\n\t// Patch frame buffer base address for MacOS versions <7.6\n\tif (!dm_present) { // Only do this when no Display Manager seems to be present; otherwise, the screen will not get redrawn\n\t\tD(bug(\"No Display Manager, patching frame buffer base\\n\"));\n\t\tWriteMacInt32(0x824, mac_frame_base);\t\t// ScrnBase\n\t\tWriteMacInt32(0x898, mac_frame_base);\t\t// CrsrBase\n\t\tuint32 gdev = ReadMacInt32(0x8a4);\t\t\t// MainDevice\n\t\tD(bug(\"MainDevice handle at %08lx\\n\", gdev));\n\t\tif (gdev != 0 && gdev != 0xffffffff) {\n\t\t\tgdev = ReadMacInt32(gdev);\n\t\t\tD(bug(\"          pointer at %08lx\\n\", gdev));\n\t\t\tuint32 pmap = ReadMacInt32(gdev + 0x16);\t// gdPMap\n\t\t\tD(bug(\"    PixMap handle at %08lx\\n\", pmap));\n\t\t\tpmap = ReadMacInt32(pmap);\n\t\t\tD(bug(\"          pointer at %08lx\\n\", pmap));\n\t\t\tWriteMacInt32(pmap, mac_frame_base);\t\t// baseAddr\n\t\t}\n\t\tgdev = ReadMacInt32(0xcc8);\t\t\t// TheGDevice\n\t\tD(bug(\"TheGDevice handle at %08lx\\n\", gdev));\n\t}\n}\n\n\n/*\n *  Driver Open() routine\n */\n\nint16 monitor_desc::driver_open(void)\n{\n\t// This shouldn't happen unless the platform-specific video code is broken\n\tif (modes.empty())\n\t\tfprintf(stderr, \"No valid video modes found (broken video driver?)\\n\");\n\n\t// Init local variables\n\tluminance_mapping = false;\n\tinterrupts_enabled = false;\n\tcurrent_apple_mode = preferred_apple_mode = depth_to_apple_mode(current_mode->depth);\n\tcurrent_id = preferred_id = current_mode->resolution_id;\n\tdm_present = false;\n\n\t// Allocate Slot Manager parameter block in Mac RAM\n\tM68kRegisters r;\n\tr.d[0] = SIZEOF_SPBlock;\n\tExecute68kTrap(0xa71e, &r);\t// NewPtrSysClear()\n\tif (r.a[0] == 0)\n\t\treturn memFullErr;\n\tslot_param = r.a[0];\n\tD(bug(\"SPBlock at %08x\\n\", slot_param));\n\n\t// Find and set default gamma table\n\tgamma_table = 0;\n\talloc_gamma_table_size = 0;\n\tset_gamma_table(0);\n\n\t// Init color palette (solid gray)\n\tset_gray_palette();\n\treturn noErr;\n}\n\nint16 VideoDriverOpen(uint32 pb, uint32 dce)\n{\n\tuint8 slot_id = ReadMacInt8(dce + dCtlSlotId);\n\tD(bug(\"VideoDriverOpen slot %02x\\n\", slot_id));\n\n\tmonitor_desc *m = find_monitor(slot_id);\n\tif (m)\n\t\treturn m->driver_open();\n\telse\n\t\treturn nsDrvErr;\n}\n\n\n/*\n *  Driver Control() routine\n */\n\nint16 monitor_desc::driver_control(uint16 code, uint32 param, uint32 dce)\n{\n\tswitch (code) {\n\n\t\tcase cscSetMode: {\t\t// Set color depth\n\t\t\tuint16 mode = ReadMacInt16(param + csMode);\n\t\t\tD(bug(\" SetMode %04x\\n\", mode));\n\n\t\t\t// Set old base address in case the switch fails\n\t\t\tWriteMacInt32(param + csBaseAddr, mac_frame_base);\n\n\t\t\tif (ReadMacInt16(param + csPage))\n\t\t\t\treturn paramErr;\n\n\t\t\tif (mode != current_apple_mode) {\n\t\t\t\tvector<video_mode>::const_iterator i = find_mode(mode, current_id);\n\t\t\t\tif (i == invalid_mode())\n\t\t\t\t\treturn paramErr;\n\t\t\t\tswitch_mode(i, param, dce);\n\t\t\t}\n\t\t\tD(bug(\"  base %08x\\n\", mac_frame_base));\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase cscSetEntries:\t\t// Set palette\n\t\tcase cscDirectSetEntries: {\n\t\t\tD(bug(\" (Direct)SetEntries table %08x, count %d, start %d\\n\", ReadMacInt32(param + csTable), ReadMacInt16(param + csCount), ReadMacInt16(param + csStart)));\n\t\t\tbool is_direct = IsDirectMode(*current_mode);\n\t\t\tif (code == cscSetEntries && is_direct)\n\t\t\t\treturn controlErr;\n\t\t\tif (code == cscDirectSetEntries && !is_direct)\n\t\t\t\treturn controlErr;\n\n\t\t\tuint32 s_pal = ReadMacInt32(param + csTable);\t// Source palette\n\t\t\tuint8 *d_pal;\t\t\t\t\t\t\t\t\t// Destination palette\n\t\t\tuint16 start = ReadMacInt16(param + csStart);\n\t\t\tuint16 count = ReadMacInt16(param + csCount);\n\t\t\tif (s_pal == 0 || count > 255)\n\t\t\t\treturn paramErr;\n\n\t\t\t// Find tables for gamma correction\n\t\t\tuint8 *red_gamma = NULL, *green_gamma = NULL, *blue_gamma = NULL;\n\t\t\tbool have_gamma = false;\n\t\t\tint data_width = 0;\n\t\t\tif (gamma_table) {\n\t\t\t\tred_gamma = Mac2HostAddr(gamma_table + gFormulaData + ReadMacInt16(gamma_table + gFormulaSize));\n\t\t\t\tint chan_cnt = ReadMacInt16(gamma_table + gChanCnt);\n\t\t\t\tif (chan_cnt == 1)\n\t\t\t\t\tgreen_gamma = blue_gamma = red_gamma;\n\t\t\t\telse {\n\t\t\t\t\tint ofs = ReadMacInt16(gamma_table + gDataCnt);\n\t\t\t\t\tgreen_gamma = red_gamma + ofs;\n\t\t\t\t\tblue_gamma = green_gamma + ofs;\n\t\t\t\t}\n\t\t\t\tdata_width = ReadMacInt16(gamma_table + gDataWidth);\n\t\t\t\thave_gamma = true;\n\t\t\t}\n\n\t\t\t// Convert palette\n\t\t\tif (start == 0xffff) {\t// Indexed\n\t\t\t\tfor (uint32 i=0; i<=count; i++) {\n\t\t\t\t\td_pal = palette + (ReadMacInt16(s_pal) & 0xff) * 3;\n\t\t\t\t\tuint8 red = (uint16)ReadMacInt16(s_pal + 2) >> 8;\n\t\t\t\t\tuint8 green = (uint16)ReadMacInt16(s_pal + 4) >> 8;\n\t\t\t\t\tuint8 blue = (uint16)ReadMacInt16(s_pal + 6) >> 8;\n\t\t\t\t\tif (luminance_mapping && !is_direct)\n\t\t\t\t\t\tred = green = blue = (red * 0x4ccc + green * 0x970a + blue * 0x1c29) >> 16;\n\t\t\t\t\tif (have_gamma) {\n\t\t\t\t\t\tred = red_gamma[red >> (8 - data_width)];\n\t\t\t\t\t\tgreen = green_gamma[green >> (8 - data_width)];\n\t\t\t\t\t\tblue = blue_gamma[blue >> (8 - data_width)];\n\t\t\t\t\t}\n\t\t\t\t\t*d_pal++ = red;\n\t\t\t\t\t*d_pal++ = green;\n\t\t\t\t\t*d_pal++ = blue;\n\t\t\t\t\ts_pal += 8;\n\t\t\t\t}\n\t\t\t} else {\t\t\t\t// Sequential\n\t\t\t\tif (start + count > 255)\n\t\t\t\t\treturn paramErr;\n\t\t\t\td_pal = palette + start * 3;\n\t\t\t\tfor (uint32 i=0; i<=count; i++) {\n\t\t\t\t\tuint8 red = (uint16)ReadMacInt16(s_pal + 2) >> 8;\n\t\t\t\t\tuint8 green = (uint16)ReadMacInt16(s_pal + 4) >> 8;\n\t\t\t\t\tuint8 blue = (uint16)ReadMacInt16(s_pal + 6) >> 8;\n\t\t\t\t\tif (luminance_mapping && !is_direct)\n\t\t\t\t\t\tred = green = blue = (red * 0x4ccc + green * 0x970a + blue * 0x1c29) >> 16;\n\t\t\t\t\tif (have_gamma) {\n\t\t\t\t\t\tred = red_gamma[red >> (8 - data_width)];\n\t\t\t\t\t\tgreen = green_gamma[green >> (8 - data_width)];\n\t\t\t\t\t\tblue = blue_gamma[blue >> (8 - data_width)];\n\t\t\t\t\t}\n\t\t\t\t\t*d_pal++ = red;\n\t\t\t\t\t*d_pal++ = green;\n\t\t\t\t\t*d_pal++ = blue;\n\t\t\t\t\ts_pal += 8;\n\t\t\t\t}\n\t\t\t}\n\t\t\tset_palette(palette, palette_size(current_mode->depth));\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase cscSetGamma: {\t\t// Set gamma table\n\t\t\tuint32 user_table = ReadMacInt32(param + csGTable);\n\t\t\tD(bug(\" SetGamma %08x\\n\", user_table));\n\t\t\treturn set_gamma_table(user_table) ? noErr : memFullErr;\n\t\t}\n\n\t\tcase cscGrayPage: {\t\t// Fill page with dithered gray pattern\n\t\t\tD(bug(\" GrayPage %d\\n\", ReadMacInt16(param + csPage)));\n\t\t\tif (ReadMacInt16(param + csPage))\n\t\t\t\treturn paramErr;\n\n\t\t\tuint32 pattern[6] = {\n\t\t\t\t0xaaaaaaaa,\t\t// 1 bpp\n\t\t\t\t0xcccccccc,\t\t// 2 bpp\n\t\t\t\t0xf0f0f0f0,\t\t// 4 bpp\n\t\t\t\t0xff00ff00,\t\t// 8 bpp\n\t\t\t\t0xffff0000,\t\t// 16 bpp\n\t\t\t\t0xffffffff\t\t// 32 bpp\n\t\t\t};\n\t\t\tuint32 p = mac_frame_base;\n\t\t\tuint32 pat = pattern[current_mode->depth];\n\t\t\tbool invert = (current_mode->depth == VDEPTH_32BIT);\n\t\t\tfor (uint32 y=0; y<current_mode->y; y++) {\n\t\t\t\tfor (uint32 x=0; x<current_mode->bytes_per_row; x+=4) {\n\t\t\t\t\tWriteMacInt32(p + x, pat);\n\t\t\t\t\tif (invert)\n\t\t\t\t\t\tpat = ~pat;\n\t\t\t\t}\n\t\t\t\tp += current_mode->bytes_per_row;\n\t\t\t\tpat = ~pat;\n\t\t\t}\n\n\t\t\tif (IsDirectMode(*current_mode))\n\t\t\t\tload_ramp_palette();\n\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase cscSetGray:\t\t// Enable/disable luminance mapping\n\t\t\tD(bug(\" SetGray %02x\\n\", ReadMacInt8(param + csMode)));\n\t\t\tluminance_mapping = ReadMacInt8(param + csMode);\n\t\t\treturn noErr;\n\n\t\tcase cscSetInterrupt:\t// Enable/disable VBL\n\t\t\tD(bug(\" SetInterrupt %02x\\n\", ReadMacInt8(param + csMode)));\n\t\t\tinterrupts_enabled = (ReadMacInt8(param + csMode) == 0);\n\t\t\treturn noErr;\n\n\t\tcase cscSetDefaultMode: { // Set default color depth\n\t\t\tuint16 mode = ReadMacInt8(param + csMode);\n\t\t\tD(bug(\" SetDefaultMode %02x\\n\", mode));\n\t\t\tpreferred_apple_mode = mode;\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase cscSwitchMode: {\t// Switch video mode (depth and resolution)\n\t\t\tuint16 mode = ReadMacInt16(param + csMode);\n\t\t\tuint32 id = ReadMacInt32(param + csData);\n\t\t\tD(bug(\" SwitchMode %04x, %08x\\n\", mode, id));\n\n\t\t\t// Set old base address in case the switch fails\n\t\t\tWriteMacInt32(param + csBaseAddr, mac_frame_base);\n\n\t\t\tif (ReadMacInt16(param + csPage))\n\t\t\t\treturn paramErr;\n\n\t\t\tif (mode != current_apple_mode || id != current_id) {\n\t\t\t\tvector<video_mode>::const_iterator i = find_mode(mode, id);\n\t\t\t\tif (i == invalid_mode())\n\t\t\t\t\treturn paramErr;\n\t\t\t\tswitch_mode(i, param, dce);\n\t\t\t}\n\t\t\tD(bug(\"  base %08x\\n\", mac_frame_base));\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase cscSavePreferredConfiguration: {\n\t\t\tuint16 mode = ReadMacInt16(param + csMode);\n\t\t\tuint32 id = ReadMacInt32(param + csData);\n\t\t\tD(bug(\" SavePreferredConfiguration %04x, %08x\\n\", mode, id));\n\t\t\tpreferred_apple_mode = mode;\n\t\t\tpreferred_id = id;\n\t\t\treturn noErr;\n\t\t}\n\n\t\tdefault:\n\t\t\tprintf(\"WARNING: Unknown VideoDriverControl(%d)\\n\", code);\n\t\t\treturn controlErr;\n\t}\n}\n\nint16 VideoDriverControl(uint32 pb, uint32 dce)\n{\n\tuint8 slot_id = ReadMacInt8(dce + dCtlSlotId);\n\tuint16 code = ReadMacInt16(pb + csCode);\n\tuint32 param = ReadMacInt32(pb + csParam);\n\tD(bug(\"VideoDriverControl slot %02x, code %d\\n\", slot_id, code));\n\n\tmonitor_desc *m = find_monitor(slot_id);\n\tif (m)\n\t\treturn m->driver_control(code, param, dce);\n\telse\n\t\treturn nsDrvErr;\n}\n\n\n/*\n *  Driver Status() routine\n */\n\nint16 monitor_desc::driver_status(uint16 code, uint32 param)\n{\n\tswitch (code) {\n\n\t\tcase cscGetMode:\t\t\t// Get current color depth\n\t\t\tD(bug(\" GetMode -> %04x, base %08x\\n\", current_apple_mode, mac_frame_base));\n\t\t\tWriteMacInt16(param + csMode, current_apple_mode);\n\t\t\tWriteMacInt16(param + csPage, 0);\n\t\t\tWriteMacInt32(param + csBaseAddr, mac_frame_base);\n\t\t\treturn noErr;\n\n\t\tcase cscGetEntries: {\t\t// Read palette\n\t\t\tD(bug(\" GetEntries table %08x, count %d, start %d\\n\", ReadMacInt32(param + csTable), ReadMacInt16(param + csCount), ReadMacInt16(param + csStart)));\n\n\t\t\tuint8 *s_pal;\t\t\t\t\t\t\t\t\t// Source palette\n\t\t\tuint32 d_pal = ReadMacInt32(param + csTable);\t// Destination palette\n\t\t\tuint16 start = ReadMacInt16(param + csStart);\n\t\t\tuint16 count = ReadMacInt16(param + csCount);\n\t\t\tif (d_pal == 0 || count > 255)\n\t\t\t\treturn paramErr;\n\n\t\t\tif (start == 0xffff) {\t// Indexed\n\t\t\t\tfor (uint32 i=0; i<=count; i++) {\n\t\t\t\t\ts_pal = palette + (ReadMacInt16(d_pal) & 0xff) * 3;\n\t\t\t\t\tuint8 red = *s_pal++;\n\t\t\t\t\tuint8 green = *s_pal++;\n\t\t\t\t\tuint8 blue = *s_pal++;\n\t\t\t\t\tWriteMacInt16(d_pal + 2, red * 0x0101);\n\t\t\t\t\tWriteMacInt16(d_pal + 4, green * 0x0101);\n\t\t\t\t\tWriteMacInt16(d_pal + 6, blue * 0x0101);\n\t\t\t\t\td_pal += 8;\n\t\t\t\t}\n\t\t\t} else {\t\t\t\t// Sequential\n\t\t\t\tif (start + count > 255)\n\t\t\t\t\treturn paramErr;\n\t\t\t\ts_pal = palette + start * 3;\n\t\t\t\tfor (uint32 i=0; i<=count; i++) {\n\t\t\t\t\tuint8 red = *s_pal++;\n\t\t\t\t\tuint8 green = *s_pal++;\n\t\t\t\t\tuint8 blue = *s_pal++;\n\t\t\t\t\tWriteMacInt16(d_pal + 2, red * 0x0101);\n\t\t\t\t\tWriteMacInt16(d_pal + 4, green * 0x0101);\n\t\t\t\t\tWriteMacInt16(d_pal + 6, blue * 0x0101);\n\t\t\t\t\td_pal += 8;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase cscGetPages:\t\t\t// Get number of pages\n\t\t\tD(bug(\" GetPages -> 1\\n\"));\n\t\t\tWriteMacInt16(param + csPage, 1);\n\t\t\treturn noErr;\n\n\t\tcase cscGetBaseAddress:\t\t// Get page base address\n\t\t\tD(bug(\" GetBaseAddress -> %08x\\n\", mac_frame_base));\n\t\t\tWriteMacInt32(param + csBaseAddr, mac_frame_base);\n\t\t\tif (ReadMacInt16(param + csPage))\n\t\t\t\treturn paramErr;\n\t\t\telse\n\t\t\t\treturn noErr;\n\n\t\tcase cscGetGray:\t\t\t// Get luminance mapping flag\n\t\t\tD(bug(\" GetGray -> %d\\n\", luminance_mapping));\n\t\t\tWriteMacInt8(param, luminance_mapping ? 1 : 0);\n\t\t\treturn noErr;\n\n\t\tcase cscGetInterrupt:\t\t// Get interrupt disable flag\n\t\t\tD(bug(\" GetInterrupt -> %d\\n\", interrupts_enabled));\n\t\t\tWriteMacInt8(param, interrupts_enabled ? 0 : 1);\n\t\t\treturn noErr;\n\n\t\tcase cscGetGamma:\n\t\t\tD(bug(\" GetGamma -> %08x\\n\", gamma_table));\n\t\t\tWriteMacInt32(param + csGTable, gamma_table);\n\t\t\treturn noErr;\n\n\t\tcase cscGetDefaultMode:\t\t// Get default color depth\n\t\t\tD(bug(\" GetDefaultMode -> %02x\\n\", preferred_apple_mode));\n\t\t\tWriteMacInt8(param + csMode, preferred_apple_mode);\n\t\t\treturn noErr;\n\n\t\tcase cscGetCurrentMode:\t\t// Get current video mode (depth and resolution)\n\t\t\tD(bug(\" GetCurMode -> %04x/%08x, base %08x\\n\", current_apple_mode, current_id, mac_frame_base));\n\t\t\tWriteMacInt16(param + csMode, current_apple_mode);\n\t\t\tWriteMacInt32(param + csData, current_id);\n\t\t\tWriteMacInt16(param + csPage, 0);\n\t\t\tWriteMacInt32(param + csBaseAddr, mac_frame_base);\n\t\t\treturn noErr;\n\n\t\tcase cscGetConnection:\t\t// Get monitor information\n\t\t\tD(bug(\" GetConnection\\n\"));\n\t\t\tWriteMacInt16(param + csDisplayType, 8);\t\t// Modeless connection\n\t\t\tWriteMacInt8(param + csConnectTaggedType, 0);\n\t\t\tWriteMacInt8(param + csConnectTaggedData, 0);\n\t\t\tWriteMacInt32(param + csConnectFlags, 0x43);\t// All modes valid and safe, non-standard tagging\n\t\t\tWriteMacInt32(param + csDisplayComponent, 0);\n\t\t\treturn noErr;\n\n\t\tcase cscGetModeTiming: {\t// Get video timing for specified resolution\n\t\t\tuint32 id = ReadMacInt32(param + csTimingMode);\n\t\t\tD(bug(\" GetModeTiming %08x\\n\", id));\n\t\t\tif (!has_resolution(id))\n\t\t\t\treturn paramErr;\n\n\t\t\tWriteMacInt32(param + csTimingFormat, FOURCC('d', 'e', 'c', 'l'));\n\t\t\tWriteMacInt32(param + csTimingData, 0);\t// unknown\n\t\t\tuint32 flags = 0xb; // mode valid, safe and shown in Monitors panel\n\t\t\tif (id == preferred_id)\n\t\t\t\tflags |= 4; // default mode\n\t\t\tWriteMacInt32(param + csTimingFlags, flags);\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase cscGetModeBaseAddress:\t// Get frame buffer base address\n\t\t\tD(bug(\" GetModeBaseAddress -> base %08x\\n\", mac_frame_base));\n\t\t\tWriteMacInt32(param + csBaseAddr, mac_frame_base);\n\t\t\treturn noErr;\n\n\t\tcase cscGetPreferredConfiguration: // Get default video mode (depth and resolution)\n\t\t\tD(bug(\" GetPreferredConfiguration -> %04x/%08x\\n\", preferred_apple_mode, preferred_id));\n\t\t\tWriteMacInt16(param + csMode, preferred_apple_mode);\n\t\t\tWriteMacInt32(param + csData, preferred_id);\n\t\t\treturn noErr;\n\n\t\tcase cscGetNextResolution: {\t// Called iteratively to obtain a list of all supported resolutions\n\t\t\tuint32 id = ReadMacInt32(param + csPreviousDisplayModeID);\n\t\t\tD(bug(\" GetNextResolution %08x\\n\", id));\n\n\t\t\tswitch (id) {\n\t\t\t\tcase 0:\n\t\t\t\t\t// Return current resolution\n\t\t\t\t\tid = current_id;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xfffffffe:\n\t\t\t\t\t// Return first supported resolution\n\t\t\t\t\tid = 0x80;\n\t\t\t\t\twhile (!has_resolution(id))\n\t\t\t\t\t\tid++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// Get next resolution\n\t\t\t\t\tif (!has_resolution(id))\n\t\t\t\t\t\treturn paramErr;\n\t\t\t\t\tid++;\n\t\t\t\t\twhile (!has_resolution(id) && id < 0x100)\n\t\t\t\t\t\tid++;\n\t\t\t\t\tif (id == 0x100) { // No more resolutions\n\t\t\t\t\t\tWriteMacInt32(param + csRIDisplayModeID, 0xfffffffd);\n\t\t\t\t\t\treturn noErr;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tWriteMacInt32(param + csRIDisplayModeID, id);\n\t\t\tuint32 x, y;\n\t\t\tget_size_of_resolution(id, x, y);\n\t\t\tWriteMacInt32(param + csHorizontalPixels, x);\n\t\t\tWriteMacInt32(param + csVerticalLines, y);\n\t\t\tWriteMacInt32(param + csRefreshRate, 75 << 16);\n\t\t\tWriteMacInt16(param + csMaxDepthMode, depth_to_apple_mode(max_depth_of_resolution(id)));\n\t\t\tWriteMacInt32(param + csResolutionFlags, 0);\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase cscGetVideoParameters: {\t// Get information about specified resolution/depth\n\t\t\tuint32 id = ReadMacInt32(param + csDisplayModeID);\n\t\t\tuint16 mode = ReadMacInt16(param + csDepthMode);\n\t\t\tD(bug(\" GetVideoParameters %04x/%08x\\n\", mode, id));\n\t\t\tdm_present = true;\t// Display Manager seems to be present\n\t\t\tD(bug(\"  Display Manager detected\\n\"));\n\n\t\t\tvector<video_mode>::const_iterator i, end = modes.end();\n\t\t\tfor (i = modes.begin(); i != end; ++i) {\n\t\t\t\tif (depth_to_apple_mode(i->depth) == mode && i->resolution_id == id) {\n\t\t\t\t\tuint32 vp = ReadMacInt32(param + csVPBlockPtr);\n\t\t\t\t\tWriteMacInt32(vp + vpBaseOffset, 0);\n\t\t\t\t\tWriteMacInt16(vp + vpRowBytes, i->bytes_per_row);\n\t\t\t\t\tWriteMacInt16(vp + vpBounds, 0);\n\t\t\t\t\tWriteMacInt16(vp + vpBounds + 2, 0);\n\t\t\t\t\tWriteMacInt16(vp + vpBounds + 4, i->y);\n\t\t\t\t\tWriteMacInt16(vp + vpBounds + 6, i->x);\n\t\t\t\t\tWriteMacInt16(vp + vpVersion, 0);\n\t\t\t\t\tWriteMacInt16(vp + vpPackType, 0);\n\t\t\t\t\tWriteMacInt32(vp + vpPackSize, 0);\n\t\t\t\t\tWriteMacInt32(vp + vpHRes, 0x00480000);\t// 72 dpi\n\t\t\t\t\tWriteMacInt32(vp + vpVRes, 0x00480000);\n\t\t\t\t\tuint32 pix_type, pix_size, cmp_count, cmp_size, dev_type;\n\t\t\t\t\tswitch (i->depth) {\n\t\t\t\t\t\tcase VDEPTH_16BIT:\n\t\t\t\t\t\t\tpix_type = 0x10; pix_size = 16;\n\t\t\t\t\t\t\tcmp_count = 3; cmp_size = 5;\n\t\t\t\t\t\t\tdev_type = 2; // direct\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase VDEPTH_32BIT:\n\t\t\t\t\t\t\tpix_type = 0x10; pix_size = 32;\n\t\t\t\t\t\t\tcmp_count = 3; cmp_size = 8;\n\t\t\t\t\t\t\tdev_type = 2; // direct\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tpix_type = 0; pix_size = 1 << i->depth;\n\t\t\t\t\t\t\tcmp_count = 1; cmp_size = 1 << i->depth;\n\t\t\t\t\t\t\tdev_type = 0; // CLUT\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tWriteMacInt16(vp + vpPixelType, pix_type);\n\t\t\t\t\tWriteMacInt16(vp + vpPixelSize, pix_size);\n\t\t\t\t\tWriteMacInt16(vp + vpCmpCount, cmp_count);\n\t\t\t\t\tWriteMacInt16(vp + vpCmpSize, cmp_size);\n\t\t\t\t\tWriteMacInt32(param + csPageCount, 1);\n\t\t\t\t\tWriteMacInt32(param + csDeviceType, dev_type);\n\t\t\t\t\treturn noErr;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn paramErr; // specified resolution/depth not supported\n\t\t}\n\n\t\tcase cscGetMultiConnect: {\n\t\t\tuint32 conn = ReadMacInt32(param + csDisplayCountOrNumber);\n\t\t\tD(bug(\" GetMultiConnect %08x\\n\", conn));\n\t\t\tif (conn == 0xffffffff) {\t// Get number of connections\n\t\t\t\tWriteMacInt32(param + csDisplayCountOrNumber, 1); // Single-headed\n\t\t\t\treturn noErr;\n\t\t\t} else if (conn == 1) {\t\t// Get information about first connection\n\t\t\t\tWriteMacInt16(param + csConnectInfo + csDisplayType, 8);\t\t// Modeless connection\n\t\t\t\tWriteMacInt8(param + csConnectInfo + csConnectTaggedType, 0);\n\t\t\t\tWriteMacInt8(param + csConnectInfo + csConnectTaggedData, 0);\n\t\t\t\tWriteMacInt32(param + csConnectInfo + csConnectFlags, 0x43);\t// All modes valid and safe, non-standard tagging\n\t\t\t\tWriteMacInt32(param + csConnectInfo + csDisplayComponent, 0);\n\t\t\t\treturn noErr;\n\t\t\t} else\n\t\t\t\treturn paramErr;\n\t\t}\n\n\t\tdefault:\n\t\t\tprintf(\"WARNING: Unknown VideoDriverStatus(%d)\\n\", code);\n\t\t\treturn statusErr;\n\t}\n}\n\nint16 VideoDriverStatus(uint32 pb, uint32 dce)\n{\n\tuint8 slot_id = ReadMacInt8(dce + dCtlSlotId);\n\tuint16 code = ReadMacInt16(pb + csCode);\n\tuint32 param = ReadMacInt32(pb + csParam);\n\tD(bug(\"VideoDriverStatus slot %02x, code %d\\n\", slot_id, code));\n\n\tmonitor_desc *m = find_monitor(slot_id);\n\tif (m)\n\t\treturn m->driver_status(code, param);\n\telse\n\t\treturn nsDrvErr;\n}\n","/*\n *  fpu/rounding.h - system-dependant FPU rounding mode and precision\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  MC68881/68040 fpu emulation\n *  \n *  Original UAE FPU, copyright 1996 Herman ten Brugge\n *  Rewrite for x86, copyright 1999-2000 Lauri Pesonen\n *  New framework, copyright 2000 Gwenole Beauchesne\n *  Adapted for JIT compilation (c) Bernd Meyer, 2000\n *  \n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef FPU_ROUNDING_H\n#define FPU_ROUNDING_H\n\n/* NOTE: this file shall be included from fpu/fpu_*.cpp */\n#undef\tPUBLIC\n#define PUBLIC\textern\n\n#undef\tPRIVATE\n#define PRIVATE\tstatic\n\n#undef\tFFPU\n#define FFPU\t/**/\n\n#undef\tFPU\n#define\tFPU\tfpu.\n\n/* Defaults to generic rounding mode and precision handling */\n#define FPU_USE_GENERIC_ROUNDING_MODE\n#define FPU_USE_GENERIC_ROUNDING_PRECISION\n\n/* -------------------------------------------------------------------------- */\n/* --- Selection of floating-point rounding mode and precision            --- */\n/* -------------------------------------------------------------------------- */\n\n/* Optimized i386 fpu core must use native rounding mode */\n#if defined(FPU_X86) && defined(USE_X87_ASSEMBLY)\n# undef FPU_USE_GENERIC_ROUNDING_MODE\n# define FPU_USE_X86_ROUNDING_MODE\n#endif\n\n/* Optimized i386 fpu core must use native rounding precision */\n#if defined(FPU_X86) && defined(USE_X87_ASSEMBLY)\n# undef FPU_USE_GENERIC_ROUNDING_PRECISION\n# define FPU_USE_X86_ROUNDING_PRECISION\n#endif\n\n#if 0 // gb-- FIXME: that doesn't work\n/* IEEE-based fpu core can have native rounding mode on i386 */\n#if defined(FPU_IEEE) && defined(USE_X87_ASSEMBLY)\n# undef FPU_USE_GENERIC_ROUNDING_MODE\n# define FPU_USE_X86_ROUNDING_MODE\n#endif\n\n/* IEEE-based fpu core can have native rounding precision on i386 */\n#if defined(FPU_IEEE) && defined(USE_X87_ASSEMBLY)\n# undef FPU_USE_GENERIC_ROUNDING_PRECISION\n# define FPU_USE_X86_ROUNDING_PRECISION\n#endif\n#endif\n\n/* -------------------------------------------------------------------------- */\n/* --- Sanity checks                                                      --- */\n/* -------------------------------------------------------------------------- */\n\n/* X86 rounding mode and precision work together */\n#if defined(FPU_USE_X86_ROUNDING_MODE) && defined(FPU_USE_X86_ROUNDING_PRECISION)\n# define FPU_USE_X86_ROUNDING\n# define CW_INITIAL (CW_RESET|CW_X|CW_PC_EXTENDED|CW_RC_NEAR|CW_PM|CW_UM|CW_OM|CW_ZM|CW_DM|CW_IM)\n  PRIVATE uae_u32 x86_control_word;\n#endif\n\n/* Control word -- rounding mode */\n#ifdef FPU_USE_X86_ROUNDING_MODE\nPUBLIC const uae_u32 x86_control_word_rm_mac2host[];\n#endif\n\n/* Control word -- rounding precision */\n#ifdef FPU_USE_X86_ROUNDING_PRECISION\nPUBLIC const uae_u32 x86_control_word_rp_mac2host[];\n#endif\n\n#if defined(FPU_USE_X86_ROUNDING_MODE) && defined(FPU_USE_X86_ROUNDING_PRECISION)\n/* Set host control word for rounding mode and rounding precision */\nPRIVATE inline void set_host_control_word(void)\n{\n\t/*\n\t\tException enable byte is ignored, but the same value is returned\n\t\tthat was previously set.\n\t*/\n\tx86_control_word\n\t\t= (x86_control_word & ~(X86_ROUNDING_MODE|X86_ROUNDING_PRECISION))\n\t\t| x86_control_word_rm_mac2host[(FPU fpcr.rounding_mode & FPCR_ROUNDING_MODE) >> 4]\n\t\t| x86_control_word_rp_mac2host[(FPU fpcr.rounding_precision & FPCR_ROUNDING_PRECISION) >> 6]\n\t\t;\n\t__asm__ __volatile__(\"fldcw %0\" : : \"m\" (x86_control_word));\n}\n#endif\n\n/* -------------------------------------------------------------------------- */\n/* --- Generic rounding mode and precision                                --- */\n/* -------------------------------------------------------------------------- */\n\n#if defined(FPU_USE_GENERIC_ROUNDING_MODE) && defined(FPU_USE_GENERIC_ROUNDING_PRECISION)\n/* Set host control word for rounding mode and rounding precision */\nPRIVATE inline void set_host_control_word(void)\n\t{ }\n#endif\n\n/* -------------------------------------------------------------------------- */\n/* --- Common rounding mode and precision                                 --- */\n/* -------------------------------------------------------------------------- */\n\n#if defined(FPU_USE_GENERIC_ROUNDING_MODE) || defined(FPU_USE_X86_ROUNDING_MODE)\n\n/* Return the current rounding mode in m68k format */\nstatic inline uae_u32 FFPU get_rounding_mode(void)\n\t{ return FPU fpcr.rounding_mode; }\n\n/* Convert and set to native rounding mode */\nstatic inline void FFPU set_rounding_mode(uae_u32 new_rounding_mode)\n\t{ FPU fpcr.rounding_mode = new_rounding_mode; }\n\n#endif\n\n#if defined(FPU_USE_GENERIC_ROUNDING_PRECISION) || defined(FPU_USE_X86_ROUNDING_PRECISION)\n\n/* Return the current rounding precision in m68k format */\nstatic inline uae_u32 FFPU get_rounding_precision(void)\n\t{ return FPU fpcr.rounding_precision; }\n\n/* Convert and set to native rounding precision */\nstatic inline void FFPU set_rounding_precision(uae_u32 new_rounding_precision)\n\t{ FPU fpcr.rounding_precision = new_rounding_precision; }\n\n#endif\n\n#endif /* FPU_ROUNDING_H */\n","/*\n *  fpu/impl.h - extra functions and inline implementations\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  MC68881/68040 fpu emulation\n *  \n *  Original UAE FPU, copyright 1996 Herman ten Brugge\n *  Rewrite for x86, copyright 1999-2000 Lauri Pesonen\n *  New framework, copyright 2000 Gwenole Beauchesne\n *  Adapted for JIT compilation (c) Bernd Meyer, 2000\n *  \n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef FPU_IMPL_H\n#define FPU_IMPL_H\n\n/* NOTE: this file shall be included from fpu/core.h */\n#undef\tPUBLIC\n#define PUBLIC\t/**/\n\n#undef\tPRIVATE\n#define PRIVATE\t/**/\n\n#undef\tFFPU\n#define FFPU\t/**/\n\n#undef\tFPU\n#define\tFPU\t\tfpu.\n\n/* -------------------------------------------------------------------------- */\n/* --- X86 assembly fpu specific methods                                  --- */\n/* -------------------------------------------------------------------------- */\n\n#ifdef FPU_X86\n\n/* Return the floating-point status register in m68k format */\nstatic inline uae_u32 FFPU get_fpsr(void)\n{\n\treturn\tto_m68k_fpcond[(x86_status_word & 0x4700) >> 8]\n\t\t|\tFPU fpsr.quotient\n\t\t|\texception_host2mac[x86_status_word & (SW_FAKE_BSUN|SW_PE|SW_UE|SW_OE|SW_ZE|SW_DE|SW_IE)]\n\t\t|\taccrued_exception_host2mac[x86_status_word_accrued & (SW_PE|SW_UE|SW_OE|SW_ZE|SW_DE|SW_IE)]\n\t\t;\n}\n\n/* Set the floating-point status register from an m68k format */\nstatic inline void FFPU set_fpsr(uae_u32 new_fpsr)\n{\n\tx86_status_word = to_host_fpcond[(new_fpsr & FPSR_CCB) >> 24 ]\n\t\t| exception_mac2host[(new_fpsr & FPSR_EXCEPTION_STATUS) >> 8];\n\tx86_status_word_accrued\t= accrued_exception_mac2host[(new_fpsr & FPSR_ACCRUED_EXCEPTION) >> 3];\n}\n\n#endif\n\n/* -------------------------------------------------------------------------- */\n/* --- Original UAE and IEEE FPU core methods                             --- */\n/* -------------------------------------------------------------------------- */\n\n#ifndef FPU_X86\n\n/* Return the floating-point status register in m68k format */\nstatic inline uae_u32 FFPU get_fpsr(void)\n{\n\tuae_u32 condition_codes\t\t= get_fpccr();\n\tuae_u32 exception_status\t= get_exception_status();\n\tuae_u32 accrued_exception\t= get_accrued_exception();\n\tuae_u32 quotient\t\t\t= FPU fpsr.quotient;\n\treturn (condition_codes | quotient | exception_status | accrued_exception);\n}\n\n/* Set the floating-point status register from an m68k format */\nstatic inline void FFPU set_fpsr(uae_u32 new_fpsr)\n{\n\tset_fpccr\t\t\t\t\t( new_fpsr & FPSR_CCB\t\t\t\t);\n\tset_exception_status\t\t( new_fpsr & FPSR_EXCEPTION_STATUS\t);\n\tset_accrued_exception\t\t( new_fpsr & FPSR_ACCRUED_EXCEPTION\t);\n\tFPU fpsr.quotient\t\t\t= new_fpsr & FPSR_QUOTIENT;\n}\n\n#endif\n\n/* -------------------------------------------------------------------------- */\n/* --- Common routines for control word                                   --- */\n/* -------------------------------------------------------------------------- */\n\n/* Return the floating-point control register in m68k format */\nstatic inline uae_u32 FFPU get_fpcr(void)\n{\n\tuae_u32 rounding_precision\t= get_rounding_precision();\n\tuae_u32 rounding_mode\t\t= get_rounding_mode();\n\treturn (rounding_precision | rounding_mode);\n}\n\n/* Set the floating-point control register from an m68k format */\nstatic inline void FFPU set_fpcr(uae_u32 new_fpcr)\n{\n\tset_rounding_precision\t\t( new_fpcr & FPCR_ROUNDING_PRECISION);\n\tset_rounding_mode\t\t\t( new_fpcr & FPCR_ROUNDING_MODE\t\t);\n\tset_host_control_word();\n}\n\n/* -------------------------------------------------------------------------- */\n/* --- Specific part to X86 assembly FPU                                  --- */\n/* -------------------------------------------------------------------------- */\n\n#ifdef FPU_X86\n\n/* Retrieve a floating-point register value and convert it to double precision */\nstatic inline double FFPU fpu_get_register(int r)\n{\n\tdouble f;\n\t__asm__ __volatile__(\"fldt %1\\n\\tfstpl %0\" : \"=m\" (f) : \"m\" (FPU registers[r]));\n\treturn f;\n}\n\n#endif\n\n/* -------------------------------------------------------------------------- */\n/* --- Specific to original UAE or new IEEE-based FPU core                --- */\n/* -------------------------------------------------------------------------- */\n\n#if defined(FPU_UAE) || defined(FPU_IEEE)\n\n/* Retrieve a floating-point register value and convert it to double precision */\nstatic inline double FFPU fpu_get_register(int r)\n{\n\treturn FPU registers[r];\n}\n\n#endif\n\n#endif /* FPU_IMPL_H */\n","/*\n *  video_sdl.cpp - Video/graphics emulation, SDL specific stuff\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/*\n *  NOTES:\n *    The Ctrl key works like a qualifier for special actions:\n *      Ctrl-Tab = suspend DGA mode (TODO)\n *      Ctrl-Esc = emergency quit\n *      Ctrl-F1 = mount floppy\n *      Ctrl-F5 = grab mouse (in windowed mode)\n *\n *  FIXMEs and TODOs:\n *  - Windows requires an extra mouse event to update the actual cursor image?\n *  - Ctr-Tab for suspend/resume but how? SDL does not support that for non-Linux\n *  - Ctrl-Fn doesn't generate SDL_KEYDOWN events (SDL bug?)\n *  - Mouse acceleration, there is no API in SDL yet for that\n *  - Force relative mode in Grab mode even if SDL provides absolute coordinates?\n *  - Gamma tables support is likely to be broken here\n *  - Events processing is bound to the general emulation thread as SDL requires\n *    to PumpEvents() within the same thread as the one that called SetVideoMode().\n *    Besides, there can't seem to be a way to call SetVideoMode() from a child thread.\n *  - Backport hw cursor acceleration to Basilisk II?\n *  - Factor out code\n */\n\n#include \"sysdeps.h\"\n\n#include <SDL.h>\n#include <SDL_mutex.h>\n#include <SDL_thread.h>\n#include <errno.h>\n#include <vector>\n\n#ifdef WIN32\n#include <malloc.h> /* alloca() */\n#endif\n\n#include \"cpu_emulation.h\"\n#include \"main.h\"\n#include \"adb.h\"\n#include \"macos_util.h\"\n#include \"prefs.h\"\n#include \"user_strings.h\"\n#include \"video.h\"\n#include \"video_defs.h\"\n#include \"video_blit.h\"\n#include \"vm_alloc.h\"\n\n#define DEBUG 1\n#include \"debug.h\"\n\n#define REUSE_VIDEO_BUFFER 1\n#define BROWSER_VIDEO 1\n\n#ifdef EMSCRIPTEN\n#include <emscripten.h>\n#endif\n// Supported video modes\nusing std::vector;\nstatic vector<VIDEO_MODE> VideoModes;\n\n// Display types\n#ifdef SHEEPSHAVER\nenum {\n\tDISPLAY_WINDOW = DIS_WINDOW,\t\t\t\t\t// windowed display\n\tDISPLAY_SCREEN = DIS_SCREEN\t\t\t\t\t\t// fullscreen display\n};\nextern int display_type;\t\t\t\t\t\t\t// See enum above\n#else\nenum {\n\tDISPLAY_WINDOW,\t\t\t\t\t\t\t\t\t// windowed display\n\tDISPLAY_SCREEN\t\t\t\t\t\t\t\t\t// fullscreen display\n};\nstatic int display_type = DISPLAY_WINDOW;\t\t\t// See enum above\n#endif\n\n// Constants\n#ifdef WIN32\nconst char KEYCODE_FILE_NAME[] = \"BasiliskII_keycodes\";\n#else\nconst char KEYCODE_FILE_NAME[] = DATADIR \"/keycodes\";\n#endif\n\n\n// Global variables\nstatic int32 frame_skip;\t\t\t\t\t\t\t// Prefs items\nstatic int16 mouse_wheel_mode;\nstatic int16 mouse_wheel_lines;\n\nstatic uint8 *the_buffer = NULL;\t\t\t\t\t// Mac frame buffer (where MacOS draws into)\nstatic uint8 *the_buffer_copy = NULL;\t\t\t\t// Copy of Mac frame buffer (for refreshed modes)\nstatic uint32 the_buffer_size;\t\t\t\t\t\t// Size of allocated the_buffer\n\nstatic bool redraw_thread_active = false;\t\t\t// Flag: Redraw thread installed\n#ifndef USE_CPU_EMUL_SERVICES\nstatic volatile bool redraw_thread_cancel;\t\t\t// Flag: Cancel Redraw thread\nstatic SDL_Thread *redraw_thread = NULL;\t\t\t// Redraw thread\n#ifdef SHEEPSHAVER\nstatic volatile bool thread_stop_req = false;\nstatic volatile bool thread_stop_ack = false;\t\t// Acknowledge for thread_stop_req\n#endif\n#endif\n\n#ifdef ENABLE_VOSF\nstatic bool use_vosf = false;\t\t\t\t\t\t// Flag: VOSF enabled\n#else\nstatic const bool use_vosf = false;\t\t\t\t\t// VOSF not possible\n#endif\n\nstatic bool ctrl_down = false;\t\t\t\t\t\t// Flag: Ctrl key pressed\nstatic bool caps_on = false;\t\t\t\t\t\t// Flag: Caps Lock on\nstatic bool quit_full_screen = false;\t\t\t\t// Flag: DGA close requested from redraw thread\nstatic bool emerg_quit = false;\t\t\t\t\t\t// Flag: Ctrl-Esc pressed, emergency quit requested from MacOS thread\nstatic bool emul_suspended = false;\t\t\t\t\t// Flag: Emulator suspended\n\nstatic bool classic_mode = false;\t\t\t\t\t// Flag: Classic Mac video mode\n\nstatic bool use_keycodes = false;\t\t\t\t\t// Flag: Use keycodes rather than keysyms\nstatic int keycode_table[256];\t\t\t\t\t\t// X keycode -> Mac keycode translation table\n\n// SDL variables\nstatic int screen_depth;\t\t\t\t\t\t\t// Depth of current screen\nstatic SDL_Cursor *sdl_cursor;\t\t\t\t\t\t// Copy of Mac cursor\nstatic SDL_Color sdl_palette[256];\t\t\t\t\t// Color palette to be used as CLUT and gamma table\nstatic bool sdl_palette_changed = false;\t\t\t// Flag: Palette changed, redraw thread must set new colors\nstatic const int sdl_eventmask = SDL_MOUSEEVENTMASK | SDL_KEYEVENTMASK | SDL_VIDEOEXPOSEMASK | SDL_QUITMASK | SDL_ACTIVEEVENTMASK;\n\n// Mutex to protect SDL events\nstatic SDL_mutex *sdl_events_lock = NULL;\n#define LOCK_EVENTS SDL_LockMutex(sdl_events_lock)\n#define UNLOCK_EVENTS SDL_UnlockMutex(sdl_events_lock)\n\n// Mutex to protect palette\nstatic SDL_mutex *sdl_palette_lock = NULL;\n#define LOCK_PALETTE SDL_LockMutex(sdl_palette_lock)\n#define UNLOCK_PALETTE SDL_UnlockMutex(sdl_palette_lock)\n\n// Mutex to protect frame buffer\nstatic SDL_mutex *frame_buffer_lock = NULL;\n#define LOCK_FRAME_BUFFER SDL_LockMutex(frame_buffer_lock)\n#define UNLOCK_FRAME_BUFFER SDL_UnlockMutex(frame_buffer_lock)\n\n// Video refresh function\nstatic void VideoRefreshInit(void);\nstatic void (*video_refresh)(void);\n\n\n// Prototypes\nstatic int redraw_func(void *arg);\n\n// From sys_unix.cpp\nextern void SysMountFirstFloppy(void);\n\n\n/*\n *  SDL surface locking glue\n */\n\n#ifdef ENABLE_VOSF\n#define SDL_VIDEO_LOCK_VOSF_SURFACE(SURFACE) do {\t\t\t\t\\\n\tif ((SURFACE)->flags & (SDL_HWSURFACE | SDL_FULLSCREEN))\t\\\n\t\tthe_host_buffer = (uint8 *)(SURFACE)->pixels;\t\t\t\\\n} while (0)\n#else\n#define SDL_VIDEO_LOCK_VOSF_SURFACE(SURFACE)\n#endif\n\n#define SDL_VIDEO_LOCK_SURFACE(SURFACE) do {\t\\\n\tif (SDL_MUSTLOCK(SURFACE)) {\t\t\t\t\\\n\t\tSDL_LockSurface(SURFACE);\t\t\t\t\\\n\t\tSDL_VIDEO_LOCK_VOSF_SURFACE(SURFACE);\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define SDL_VIDEO_UNLOCK_SURFACE(SURFACE) do {\t\\\n\tif (SDL_MUSTLOCK(SURFACE))\t\t\t\t\t\\\n\t\tSDL_UnlockSurface(SURFACE);\t\t\t\t\\\n} while (0)\n\n\n/*\n *  Framebuffer allocation routines\n */\n\nstatic void *vm_acquire_framebuffer(uint32 size)\n{\n\t// always try to reallocate framebuffer at the same address\n\tstatic void *fb = VM_MAP_FAILED;\n\tif (fb != VM_MAP_FAILED) {\n\t\tif (vm_acquire_fixed(fb, size) < 0) {\n#ifndef SHEEPSHAVER\n\t\t\tprintf(\"FATAL: Could not reallocate framebuffer at previous address\\n\");\n#endif\n\t\t\tfb = VM_MAP_FAILED;\n\t\t}\n\t}\n\tif (fb == VM_MAP_FAILED)\n\t\tfb = vm_acquire(size, VM_MAP_DEFAULT | VM_MAP_32BIT);\n\treturn fb;\n}\n\nstatic inline void vm_release_framebuffer(void *fb, uint32 size)\n{\n\tvm_release(fb, size);\n}\n\n\n/*\n *  Windows message handler\n */\n\n#ifdef WIN32\n#include <dbt.h>\nstatic WNDPROC sdl_window_proc = NULL;\t\t\t\t// Window proc used by SDL\n\nextern void SysMediaArrived(void);\nextern void SysMediaRemoved(void);\nextern HWND GetMainWindowHandle(void);\n\nstatic LRESULT CALLBACK windows_message_handler(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\n{\n\tswitch (msg) {\n\tcase WM_DEVICECHANGE:\n\t\tif (wParam == DBT_DEVICEREMOVECOMPLETE) {\n\t\t\tDEV_BROADCAST_HDR *p = (DEV_BROADCAST_HDR *)lParam;\n\t\t\tif (p->dbch_devicetype == DBT_DEVTYP_VOLUME)\n\t\t\t\tSysMediaRemoved();\n\t\t}\n\t\telse if (wParam == DBT_DEVICEARRIVAL) {\n\t\t\tDEV_BROADCAST_HDR *p = (DEV_BROADCAST_HDR *)lParam;\n\t\t\tif (p->dbch_devicetype == DBT_DEVTYP_VOLUME)\n\t\t\t\tSysMediaArrived();\n\t\t}\n\t\treturn 0;\n\n\tdefault:\n\t\tif (sdl_window_proc)\n\t\t\treturn CallWindowProc(sdl_window_proc, hwnd, msg, wParam, lParam);\n\t}\n\n\treturn DefWindowProc(hwnd, msg, wParam, lParam);\n}\n#endif\n\n\n/*\n *  SheepShaver glue\n */\n\n#ifdef SHEEPSHAVER\n// Color depth modes type\ntypedef int video_depth;\n\n// 1, 2, 4 and 8 bit depths use a color palette\nstatic inline bool IsDirectMode(VIDEO_MODE const & mode)\n{\n\treturn IsDirectMode(mode.viAppleMode);\n}\n\n// Abstract base class representing one (possibly virtual) monitor\n// (\"monitor\" = rectangular display with a contiguous frame buffer)\nclass monitor_desc {\npublic:\n\tmonitor_desc(const vector<VIDEO_MODE> &available_modes, video_depth default_depth, uint32 default_id) {}\n\tvirtual ~monitor_desc() {}\n\n\t// Get current Mac frame buffer base address\n\tuint32 get_mac_frame_base(void) const {return screen_base;}\n\n\t// Set Mac frame buffer base address (called from switch_to_mode())\n\tvoid set_mac_frame_base(uint32 base) {screen_base = base;}\n\n\t// Get current video mode\n\tconst VIDEO_MODE &get_current_mode(void) const {return VModes[cur_mode];}\n\n\t// Called by the video driver to switch the video mode on this display\n\t// (must call set_mac_frame_base())\n\tvirtual void switch_to_current_mode(void) = 0;\n\n\t// Called by the video driver to set the color palette (in indexed modes)\n\t// or the gamma table (in direct modes)\n\tvirtual void set_palette(uint8 *pal, int num) = 0;\n};\n\n// Vector of pointers to available monitor descriptions, filled by VideoInit()\nstatic vector<monitor_desc *> VideoMonitors;\n\n// Find Apple mode matching best specified dimensions\nstatic int find_apple_resolution(int xsize, int ysize)\n{\n\tif (xsize == 640 && ysize == 480)\n\t\treturn APPLE_640x480;\n\tif (xsize == 800 && ysize == 600)\n\t\treturn APPLE_800x600;\n\tif (xsize == 1024 && ysize == 768)\n\t\treturn APPLE_1024x768;\n\tif (xsize == 1152 && ysize == 768)\n\t\treturn APPLE_1152x768;\n\tif (xsize == 1152 && ysize == 900)\n\t\treturn APPLE_1152x900;\n\tif (xsize == 1280 && ysize == 1024)\n\t\treturn APPLE_1280x1024;\n\tif (xsize == 1600 && ysize == 1200)\n\t\treturn APPLE_1600x1200;\n\treturn APPLE_CUSTOM;\n}\n\n// Display error alert\nstatic void ErrorAlert(int error)\n{\n\tErrorAlert(GetString(error));\n}\n\n// Display warning alert\nstatic void WarningAlert(int warning)\n{\n\tWarningAlert(GetString(warning));\n}\n#endif\n\n\n/*\n *  monitor_desc subclass for SDL display\n */\n\nclass SDL_monitor_desc : public monitor_desc {\npublic:\n\tSDL_monitor_desc(const vector<VIDEO_MODE> &available_modes, video_depth default_depth, uint32 default_id) : monitor_desc(available_modes, default_depth, default_id) {}\n\t~SDL_monitor_desc() {}\n\n\tvirtual void switch_to_current_mode(void);\n\tvirtual void set_palette(uint8 *pal, int num);\n\n\tbool video_open(void);\n\tvoid video_close(void);\n};\n\n\n/*\n *  Utility functions\n */\n\n// Find palette size for given color depth\nstatic int palette_size(int mode)\n{\n\tswitch (mode) {\n\tcase VIDEO_DEPTH_1BIT: return 2;\n\tcase VIDEO_DEPTH_2BIT: return 4;\n\tcase VIDEO_DEPTH_4BIT: return 16;\n\tcase VIDEO_DEPTH_8BIT: return 256;\n\tcase VIDEO_DEPTH_16BIT: return 32;\n\tcase VIDEO_DEPTH_32BIT: return 256;\n\tdefault: return 0;\n\t}\n}\n\n// Return bytes per pixel for requested depth\nstatic inline int bytes_per_pixel(int depth)\n{\n\tint bpp;\n\tswitch (depth) {\n\tcase 8:\n\t\tbpp = 1;\n\t\tbreak;\n\tcase 15: case 16:\n\t\tbpp = 2;\n\t\tbreak;\n\tcase 24: case 32:\n\t\tbpp = 4;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\treturn bpp;\n}\n\n// Map video_mode depth ID to numerical depth value\nstatic int mac_depth_of_video_depth(int video_depth)\n{\n\tint depth = -1;\n\tswitch (video_depth) {\n\tcase VIDEO_DEPTH_1BIT:\n\t\tdepth = 1;\n\t\tbreak;\n\tcase VIDEO_DEPTH_2BIT:\n\t\tdepth = 2;\n\t\tbreak;\n\tcase VIDEO_DEPTH_4BIT:\n\t\tdepth = 4;\n\t\tbreak;\n\tcase VIDEO_DEPTH_8BIT:\n\t\tdepth = 8;\n\t\tbreak;\n\tcase VIDEO_DEPTH_16BIT:\n\t\tdepth = 16;\n\t\tbreak;\n\tcase VIDEO_DEPTH_32BIT:\n\t\tdepth = 32;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\treturn depth;\n}\n\n// Map video_mode depth ID to SDL screen depth\nstatic int sdl_depth_of_video_depth(int video_depth)\n{\n\treturn (video_depth <= VIDEO_DEPTH_8BIT) ? 8 : mac_depth_of_video_depth(video_depth);\n}\n\n// Get screen dimensions\nstatic void sdl_display_dimensions(int &width, int &height)\n{\n\tstatic int max_width, max_height;\n\tif (max_width == 0 && max_height == 0) {\n\t\tmax_width = 640 ; max_height = 480;\n\t\tSDL_Rect **modes = SDL_ListModes(NULL, SDL_FULLSCREEN | SDL_HWSURFACE);\n\t\tif (modes && modes != (SDL_Rect **)-1) {\n\t\t\t// It turns out that on some implementations, and contrary to the documentation,\n\t\t\t// the returned list is not sorted from largest to smallest (e.g. Windows)\n\t\t\tfor (int i = 0; modes[i] != NULL; i++) {\n\t\t\t\tconst int w = modes[i]->w;\n\t\t\t\tconst int h = modes[i]->h;\n\t\t\t\tif (w > max_width && h > max_height) {\n\t\t\t\t\tmax_width = w;\n\t\t\t\t\tmax_height = h;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twidth = max_width;\n\theight = max_height;\n}\n\nstatic inline int sdl_display_width(void)\n{\n\t#ifdef EMSCRIPTEN\n\t\treturn 800;\n\t#endif\n\tint width, height;\n\tsdl_display_dimensions(width, height);\n\treturn width;\n}\n\nstatic inline int sdl_display_height(void)\n{\n\t#ifdef EMSCRIPTEN\n\t\treturn 600;\n\t#endif\n\tint width, height;\n\tsdl_display_dimensions(width, height);\n\treturn height;\n}\n\n// Check wether specified mode is available\nstatic bool has_mode(int type, int width, int height, int depth)\n{\n#ifdef SHEEPSHAVER\n\t// Filter out Classic resolutions\n\tif (width == 512 && height == 384)\n\t\treturn false;\n#endif\n\n\t// Filter out out-of-bounds resolutions\n\tif (width > sdl_display_width() || height > sdl_display_height())\n\t\treturn false;\n\n\t// Rely on SDL capabilities\n\treturn SDL_VideoModeOK(width, height,\n\t\t\t\t\t\t   sdl_depth_of_video_depth(depth),\n\t\t\t\t\t\t   SDL_HWSURFACE | (type == DISPLAY_SCREEN ? SDL_FULLSCREEN : 0));\n}\n\n// Add mode to list of supported modes\nstatic void add_mode(int type, int width, int height, int resolution_id, int bytes_per_row, int depth)\n{\n\t// Filter out unsupported modes\n\tif (!has_mode(type, width, height, depth))\n\t\treturn;\n\n\t// Fill in VideoMode entry\n\tVIDEO_MODE mode;\n#ifdef SHEEPSHAVER\n\tresolution_id = find_apple_resolution(width, height);\n\tmode.viType = type;\n#endif\n\tVIDEO_MODE_X = width;\n\tVIDEO_MODE_Y = height;\n\tVIDEO_MODE_RESOLUTION = resolution_id;\n\tVIDEO_MODE_ROW_BYTES = bytes_per_row;\n\tVIDEO_MODE_DEPTH = (video_depth)depth;\n\tVideoModes.push_back(mode);\n}\n\n// Set Mac frame layout and base address (uses the_buffer/MacFrameBaseMac)\nstatic void set_mac_frame_buffer(SDL_monitor_desc &monitor, int depth, bool native_byte_order)\n{\n#if !REAL_ADDRESSING && !DIRECT_ADDRESSING\n\tint layout = FLAYOUT_DIRECT;\n\tif (depth == VIDEO_DEPTH_16BIT)\n\t\tlayout = (screen_depth == 15) ? FLAYOUT_HOST_555 : FLAYOUT_HOST_565;\n\telse if (depth == VIDEO_DEPTH_32BIT)\n\t\tlayout = (screen_depth == 24) ? FLAYOUT_HOST_888 : FLAYOUT_DIRECT;\n\tif (native_byte_order)\n\t\tMacFrameLayout = layout;\n\telse\n\t\tMacFrameLayout = FLAYOUT_DIRECT;\n\tmonitor.set_mac_frame_base(MacFrameBaseMac);\n\n\t// Set variables used by UAE memory banking\n\tconst VIDEO_MODE &mode = monitor.get_current_mode();\n\tMacFrameBaseHost = the_buffer;\n\tMacFrameSize = VIDEO_MODE_ROW_BYTES * VIDEO_MODE_Y;\n\tInitFrameBufferMapping();\n#else\n\tmonitor.set_mac_frame_base(Host2MacAddr(the_buffer));\n#endif\n\tD(bug(\"monitor.mac_frame_base = %08x\\n\", monitor.get_mac_frame_base()));\n}\n\n// Set window name and class\nstatic void set_window_name(int name)\n{\n\tconst SDL_VideoInfo *vi = SDL_GetVideoInfo();\n\tif (vi && vi->wm_available) {\n\t\tconst char *str = GetString(name);\n\t\tSDL_WM_SetCaption(str, str);\n\t}\n}\n\n// Set mouse grab mode\nstatic SDL_GrabMode set_grab_mode(SDL_GrabMode mode)\n{\n\tconst SDL_VideoInfo *vi = SDL_GetVideoInfo();\n\treturn (vi && vi->wm_available ? SDL_WM_GrabInput(mode) : SDL_GRAB_OFF);\n}\n\n// Migrate preferences items (XXX to be handled in MigratePrefs())\nstatic void migrate_screen_prefs(void)\n{\n#ifdef SHEEPSHAVER\n\t// Look-up priorities are: \"screen\", \"screenmodes\", \"windowmodes\".\n\tif (PrefsFindString(\"screen\"))\n\t\treturn;\n\n\tuint32 window_modes = PrefsFindInt32(\"windowmodes\");\n\tuint32 screen_modes = PrefsFindInt32(\"screenmodes\");\n\tint width = 0, height = 0;\n\tif (screen_modes) {\n\t\tstatic const struct {\n\t\t\tint id;\n\t\t\tint width;\n\t\t\tint height;\n\t\t}\n\t\tmodes[] = {\n\t\t\t{  1,\t 640,\t 480 },\n\t\t\t{  2,\t 800,\t 600 },\n\t\t\t{  4,\t1024,\t 768 },\n\t\t\t{ 64,\t1152,\t 768 },\n\t\t\t{  8,\t1152,\t 900 },\n\t\t\t{ 16,\t1280,\t1024 },\n\t\t\t{ 32,\t1600,\t1200 },\n\t\t\t{ 0, }\n\t\t};\n\t\tfor (int i = 0; modes[i].id != 0; i++) {\n\t\t\tif (screen_modes & modes[i].id) {\n\t\t\t\tif (width < modes[i].width && height < modes[i].height) {\n\t\t\t\t\twidth = modes[i].width;\n\t\t\t\t\theight = modes[i].height;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (window_modes & 1)\n\t\t\twidth = 640, height = 480;\n\t\tif (window_modes & 2)\n\t\t\twidth = 800, height = 600;\n\t}\n\tif (width && height) {\n\t\tchar str[32];\n\t\tsprintf(str, \"%s/%d/%d\", screen_modes ? \"dga\" : \"win\", width, height);\n\t\tPrefsReplaceString(\"screen\", str);\n\t}\n#endif\n}\n\n// Map RGB color to pixel value (this only works in TrueColor/DirectColor visuals)\nstatic inline uint32 map_rgb(uint8 red, uint8 green, uint8 blue, bool fix_byte_order = false)\n{\n  uint32 val = (red&0xff)|(green&0xff)<<8|(blue&0xff)<<16|0xff000000;\n  return val;\n\n\t// uint32 val = ((red >> 8) << 0) | ((green >> 8) << 0) | ((blue >> 8) << 0);\n\n\tif (fix_byte_order) {\n\t\t// We have to fix byte order in the ExpandMap[]\n\t\t// NOTE: this is only an optimization since Screen_blitter_init()\n\t\t// could be arranged to choose an NBO or OBO (with\n\t\t// byteswapping) Blit_Expand_X_To_Y() function\n\t\tswitch (32) {\n\t\tcase 15: case 16:\n\t\t\tval = do_byteswap_16(val);\n\t\t\tbreak;\n\t\tcase 24: case 32:\n\t\t\tval = do_byteswap_32(val);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn val;\n}\n\n__attribute__((noinline))\nvoid free_browser_pixels(uint8 *browser_pixels) {\n\tfree(browser_pixels);\n}\n\n/*\n *  Display \"driver\" classes\n */\n\nclass driver_base {\npublic:\n\tdriver_base(SDL_monitor_desc &m);\n\tvirtual ~driver_base();\n\n\tvirtual void update_palette(void);\n\tvirtual void suspend(void) {}\n\tvirtual void resume(void) {}\n\tvirtual void toggle_mouse_grab(void) {}\n\tvirtual void mouse_moved(int x, int y) { ADBMouseMoved(x, y); }\n\n\tvoid disable_mouse_accel(void);\n\tvoid restore_mouse_accel(void);\n\n\tvirtual void grab_mouse(void) {}\n\tvirtual void ungrab_mouse(void) {}\n\npublic:\n\tSDL_monitor_desc &monitor; // Associated video monitor\n\tconst VIDEO_MODE &mode;    // Video mode handled by the driver\n\n\tbool init_ok;\t// Initialization succeeded (we can't use exceptions because of -fomit-frame-pointer)\n\tSDL_Surface *s;\t// The surface we draw into\n\n\t// uint8 *browser_pixels;\n};\n\nclass driver_window;\n#ifdef ENABLE_VOSF\nstatic void update_display_window_vosf(driver_window *drv);\n#endif\nstatic void update_display_static(driver_base *drv);\n\nclass driver_window : public driver_base {\n#ifdef ENABLE_VOSF\n\tfriend void update_display_window_vosf(driver_window *drv);\n#endif\n\tfriend void update_display_static(driver_base *drv);\n\npublic:\n\tdriver_window(SDL_monitor_desc &monitor);\n\t~driver_window();\n\n\tvoid toggle_mouse_grab(void);\n\tvoid mouse_moved(int x, int y);\n\n\tvoid grab_mouse(void);\n\tvoid ungrab_mouse(void);\n\nprivate:\n\tbool mouse_grabbed;\t\t\t\t// Flag: mouse pointer grabbed, using relative mouse mode\n\tint mouse_last_x, mouse_last_y;\t// Last mouse position (for relative mode)\n};\n\nclass driver_fullscreen : public driver_base {\npublic:\n\tdriver_fullscreen(SDL_monitor_desc &monitor);\n\t~driver_fullscreen();\n};\n\nstatic driver_base *drv = NULL;\t// Pointer to currently used driver object\n\n#ifdef ENABLE_VOSF\n# include \"video_vosf.h\"\n#endif\n\ndriver_base::driver_base(SDL_monitor_desc &m)\n\t: monitor(m), mode(m.get_current_mode()), init_ok(false), s(NULL)\n{\n\tthe_buffer = NULL;\n\tthe_buffer_copy = NULL;\n\t// browser_pixels = NULL;\n}\n\ndriver_base::~driver_base()\n{\n\tungrab_mouse();\n\trestore_mouse_accel();\n\n\tif (s)\n\t\tSDL_FreeSurface(s);\n\n\tif (REUSE_VIDEO_BUFFER) {\n\t\t// printf(\"~driver_base checking browser_pixels %p != %p \\n\", (void *)browser_pixels, (void *)NULL);\n\t\t// assert(browser_pixels != NULL);\n\t\t// printf(\"~driver_base freeing %p\\n\", (void *)browser_pixels);\n\t\t// #ifdef EMSCRIPTEN\n\t\t// EM_ASM_({\n\t //  \tModule.debugPointer($0);\n\t\t// }, browser_pixels);\n\t\t// #endif\n\t\t// free_browser_pixels(browser_pixels);\n\t\t// browser_pixels = NULL;\n\t\t// assert(browser_pixels == NULL);\n\t\t// printf(\"~driver_base freed browser_pixels\\n\");\n\t}\n\n\t// the_buffer shall always be mapped through vm_acquire_framebuffer()\n\tif (the_buffer != VM_MAP_FAILED) {\n\t\tD(bug(\" releasing the_buffer at %p (%d bytes)\\n\", the_buffer, the_buffer_size));\n\t\tvm_release_framebuffer(the_buffer, the_buffer_size);\n\t\tthe_buffer = NULL;\n\t}\n\n\t// Free frame buffer(s)\n\tif (!use_vosf) {\n\t\tif (the_buffer_copy) {\n\t\t\tfree(the_buffer_copy);\n\t\t\tthe_buffer_copy = NULL;\n\t\t}\n\t}\n#ifdef ENABLE_VOSF\n\telse {\n\t\tif (the_host_buffer) {\n\t\t\tD(bug(\" freeing the_host_buffer at %p\\n\", the_host_buffer));\n\t\t\tfree(the_host_buffer);\n\t\t\tthe_host_buffer = NULL;\n\t\t}\n\t\tif (the_buffer_copy) {\n\t\t\tD(bug(\" freeing the_buffer_copy at %p\\n\", the_buffer_copy));\n\t\t\tfree(the_buffer_copy);\n\t\t\tthe_buffer_copy = NULL;\n\t\t}\n\n\t\t// Deinitialize VOSF\n\t\tvideo_vosf_exit();\n\t}\n#endif\n}\n\n// Palette has changed\nvoid driver_base::update_palette(void)\n{\n\tconst VIDEO_MODE &mode = monitor.get_current_mode();\n\n\t#ifndef EMSCRIPTEN\n\tif ((int)VIDEO_MODE_DEPTH <= VIDEO_DEPTH_8BIT)\n\t\tSDL_SetPalette(s, SDL_PHYSPAL, sdl_palette, 0, 256);\n\t#endif\n}\n\n// Disable mouse acceleration\nvoid driver_base::disable_mouse_accel(void)\n{\n}\n\n// Restore mouse acceleration to original value\nvoid driver_base::restore_mouse_accel(void)\n{\n}\n\n\nstatic uint8 *browser_pixels = NULL;\n\nuint8 *alloc_browser_pixels(int32 size_to_copy) {\n\tif (browser_pixels) {\n\t\treturn browser_pixels;\n\t}\n\treturn (uint8 *)malloc(size_to_copy * sizeof(uint8));\n}\n\n/*\n *  Windowed display driver\n */\n\nstatic bool SDL_display_opened = false;\n\n\n// Open display\ndriver_window::driver_window(SDL_monitor_desc &m)\n\t: driver_base(m), mouse_grabbed(false)\n{\n\tprintf(\"driver_window::driver_window\\n\");\n\tint width = VIDEO_MODE_X, height = VIDEO_MODE_Y;\n\tint aligned_height = (height + 15) & ~15;\n\n\t// Set absolute mouse mode\n\tADBSetRelMouseMode(mouse_grabbed);\n\n\t// This is ugly:\n\t// If we're switching resolutions (ie, not setting it for the first time),\n\t// there's a bug in SDL where the SDL_Surface created will not be properly\n\t// setup. The solution is to SDL_QuitSubSystem(SDL_INIT_VIDEO) before calling\n\t// SDL_SetVideoMode for the second time (SDL_SetVideoMode will call SDL_Init()\n\t// and all will be well). Without this, the video becomes corrupted (at least\n\t// on Mac OS X), after the resolution switch.\n\tif (SDL_display_opened)\n\t\tSDL_QuitSubSystem(SDL_INIT_VIDEO);\n\n\t// Create surface\n\tint depth = sdl_depth_of_video_depth(VIDEO_MODE_DEPTH);\n#ifdef EMSCRIPTEN\n\tdepth = 32; // always 32 is easier\n#else\n\tif ((s = SDL_SetVideoMode(width, height, depth, SDL_HWSURFACE)) == NULL)\n\t\treturn;\n#endif\n\n\tif (REUSE_VIDEO_BUFFER) {\n\t\tconst int bytes_per_pixel = VIDEO_MODE_ROW_BYTES / VIDEO_MODE_X;\n\t\tuint32 size_to_copy = VIDEO_MODE_X * bytes_per_pixel * VIDEO_MODE_Y;\n\n\t\t// printf(\"driver_window checking browser_pixels %p != %p \\n\", (void *)browser_pixels, (void *)NULL);\n\t\t// assert(browser_pixels == NULL);\n\t\tbrowser_pixels = alloc_browser_pixels(size_to_copy);\n\t\t// assert(browser_pixels);\n\t\t// printf(\"driver_window allocated %p\\n\", (void *)browser_pixels);\n\t\t#ifdef EMSCRIPTEN\n\t\tEM_ASM_({\n\t  \tModule.debugPointer($0);\n\t\t}, browser_pixels);\n\t\t#endif\n\t}\n\n\tSDL_display_opened = true;\n\n#ifdef ENABLE_VOSF\n\tprintf(\"using vosf\\n\");\n\tuse_vosf = true;\n\t// Allocate memory for frame buffer (SIZE is extended to page-boundary)\n\tthe_host_buffer = (uint8 *)s->pixels;\n\tthe_buffer_size = page_extend((aligned_height + 2) * s->pitch);\n\tthe_buffer = (uint8 *)vm_acquire_framebuffer(the_buffer_size);\n\tthe_buffer_copy = (uint8 *)malloc(the_buffer_size);\n\tD(bug(\"the_buffer = %p, the_buffer_copy = %p, the_host_buffer = %p\\n\", the_buffer, the_buffer_copy, the_host_buffer));\n\n\t// Check whether we can initialize the VOSF subsystem and it's profitable\n\tif (!video_vosf_init(m)) {\n\t\tWarningAlert(STR_VOSF_INIT_ERR);\n\t\tuse_vosf = false;\n\t}\n\telse if (!video_vosf_profitable()) {\n\t\tvideo_vosf_exit();\n\t\tprintf(\"VOSF acceleration is not profitable on this platform, disabling it\\n\");\n\t\tuse_vosf = false;\n\t}\n\tif (!use_vosf) {\n\t\tfree(the_buffer_copy);\n\t\tvm_release(the_buffer, the_buffer_size);\n\t\tthe_host_buffer = NULL;\n\t}\n#endif\n\tif (!use_vosf) {\n\t\tprintf(\"allocating the_buffer, the_buffer_copy\\n\");\n\t\t// Allocate memory for frame buffer\n\t\tthe_buffer_size = (aligned_height + 2) * s->pitch;\n\t\tthe_buffer_copy = (uint8 *)calloc(1, the_buffer_size);\n\t\t#ifdef BROWSER_VIDEO\n\t\tthe_buffer = (uint8 *)malloc(the_buffer_size);\n\t\t#else\n\t\tthe_buffer = (uint8 *)vm_acquire_framebuffer(the_buffer_size);\n\t\t#endif\n\t\tD(bug(\"the_buffer = %p, the_buffer_copy = %p\\n\", the_buffer, the_buffer_copy));\n\t}\n\t\n#ifdef SHEEPSHAVER\n\t// Create cursor\n\tif ((sdl_cursor = SDL_CreateCursor(MacCursor + 4, MacCursor + 36, 16, 16, 0, 0)) != NULL) {\n\t\tSDL_SetCursor(sdl_cursor);\n\t}\n#else\n\t// Hide cursor\n\tSDL_ShowCursor(0);\n#endif\n\n\t// Set window name/class\n\t#ifndef EMSCRIPTEN\n\tset_window_name(STR_WINDOW_TITLE);\n\t#endif\n\n\t// Init blitting routines\n\tSDL_PixelFormat *f = s->format;\n\tVisualFormat visualFormat;\n\tvisualFormat.depth = depth;\n\tvisualFormat.Rmask = f->Rmask;\n\tvisualFormat.Gmask = f->Gmask;\n\tvisualFormat.Bmask = f->Bmask;\n\tScreen_blitter_init(visualFormat, true, mac_depth_of_video_depth(VIDEO_MODE_DEPTH));\n\n\t// Load gray ramp to 8->16/32 expand map\n\tif (!IsDirectMode(mode)) {\n\t\tfor (int i=0; i<256; i++) {\n\t\t\t#ifdef EMSCRIPTEN\n\t\t\t\t\tExpandMap[i] = map_rgb(i, i, i, true);\n\t\t\t#else\n\t\t\t\t\tExpandMap[i] = SDL_MapRGB(f, i, i, i);\n\t\t\t#endif\t\t\t\t\n\t\t}\n\t}\n\t// Set frame buffer base\n\tset_mac_frame_buffer(monitor, VIDEO_MODE_DEPTH, true);\n\n\t// Everything went well\n\tinit_ok = true;\n}\n\n// Close display\ndriver_window::~driver_window()\n{\n\n#ifdef ENABLE_VOSF\n\tif (use_vosf)\n\t\tthe_host_buffer = NULL;\t// don't free() in driver_base dtor\n#endif\n#ifndef EMSCRIPTEN\n\tif (s)\n\t\tSDL_FreeSurface(s);\n#endif\n}\n\n// Toggle mouse grab\nvoid driver_window::toggle_mouse_grab(void)\n{\n\tif (mouse_grabbed)\n\t\tungrab_mouse();\n\telse\n\t\tgrab_mouse();\n}\n\n// Grab mouse, switch to relative mouse mode\nvoid driver_window::grab_mouse(void)\n{\n\tif (!mouse_grabbed) {\n\t\tSDL_GrabMode new_mode = set_grab_mode(SDL_GRAB_ON);\n\t\tif (new_mode == SDL_GRAB_ON) {\n\t\t\tset_window_name(STR_WINDOW_TITLE_GRABBED);\n\t\t\tdisable_mouse_accel();\n\t\t\tmouse_grabbed = true;\n\t\t}\n\t}\n}\n\n// Ungrab mouse, switch to absolute mouse mode\nvoid driver_window::ungrab_mouse(void)\n{\n\tif (mouse_grabbed) {\n\t\tSDL_GrabMode new_mode = set_grab_mode(SDL_GRAB_OFF);\n\t\tif (new_mode == SDL_GRAB_OFF) {\n\t\t\tset_window_name(STR_WINDOW_TITLE);\n\t\t\trestore_mouse_accel();\n\t\t\tmouse_grabbed = false;\n\t\t}\n\t}\n}\n\n// Mouse moved\nvoid driver_window::mouse_moved(int x, int y)\n{\n\tmouse_last_x = x; mouse_last_y = y;\n\tADBMouseMoved(x, y);\n}\n\n\n/*\n *  Full-screen display driver\n */\n\n// Open display\ndriver_fullscreen::driver_fullscreen(SDL_monitor_desc &m)\n\t: driver_base(m)\n{\n\tprintf(\"driver_fullscreen::driver_fullscreen\\n\");\n\tint width = VIDEO_MODE_X, height = VIDEO_MODE_Y;\n\tint aligned_height = (height + 15) & ~15;\n\n\t// Set absolute mouse mode\n\tADBSetRelMouseMode(false);\n\n\t// Create surface\n\tint depth = sdl_depth_of_video_depth(VIDEO_MODE_DEPTH);\n\tif ((s = SDL_SetVideoMode(width, height, depth, SDL_HWSURFACE | SDL_FULLSCREEN)) == NULL)\n\t\treturn;\n\n#ifdef ENABLE_VOSF\n\tuse_vosf = true;\n\t// Allocate memory for frame buffer (SIZE is extended to page-boundary)\n\tthe_host_buffer = (uint8 *)s->pixels;\n\tthe_buffer_size = page_extend((aligned_height + 2) * s->pitch);\n\tthe_buffer = (uint8 *)vm_acquire_framebuffer(the_buffer_size);\n\tthe_buffer_copy = (uint8 *)malloc(the_buffer_size);\n\tD(bug(\"the_buffer = %p, the_buffer_copy = %p, the_host_buffer = %p\\n\", the_buffer, the_buffer_copy, the_host_buffer));\n\n\t// Check whether we can initialize the VOSF subsystem and it's profitable\n\tif (!video_vosf_init(m)) {\n\t\tWarningAlert(STR_VOSF_INIT_ERR);\n\t\tuse_vosf = false;\n\t}\n\telse if (!video_vosf_profitable()) {\n\t\tvideo_vosf_exit();\n\t\tprintf(\"VOSF acceleration is not profitable on this platform, disabling it\\n\");\n\t\tuse_vosf = false;\n\t}\n\tif (!use_vosf) {\n\t\tfree(the_buffer_copy);\n\t\tvm_release(the_buffer, the_buffer_size);\n\t\tthe_host_buffer = NULL;\n\t}\n#endif\n\tif (!use_vosf) {\n\t\t// Allocate memory for frame buffer\n\t\tthe_buffer_size = (aligned_height + 2) * s->pitch;\n\t\tthe_buffer_copy = (uint8 *)calloc(1, the_buffer_size);\n\t\tthe_buffer = (uint8 *)vm_acquire_framebuffer(the_buffer_size);\n\t\tD(bug(\"the_buffer = %p, the_buffer_copy = %p\\n\", the_buffer, the_buffer_copy));\n\t}\n\t\n\t// Hide cursor\n\tSDL_ShowCursor(0);\n\n\t// Init blitting routines\n\tSDL_PixelFormat *f = s->format;\n\tVisualFormat visualFormat;\n\tvisualFormat.depth = depth;\n\tvisualFormat.Rmask = f->Rmask;\n\tvisualFormat.Gmask = f->Gmask;\n\tvisualFormat.Bmask = f->Bmask;\n\tScreen_blitter_init(visualFormat, true, mac_depth_of_video_depth(VIDEO_MODE_DEPTH));\n\n\t// Load gray ramp to 8->16/32 expand map\n\tif (!IsDirectMode(mode))\n\t\tfor (int i=0; i<256; i++)\n\t\t\tExpandMap[i] = SDL_MapRGB(f, i, i, i);\n\n\t// Set frame buffer base\n\tset_mac_frame_buffer(monitor, VIDEO_MODE_DEPTH, true);\n\n\t// Everything went well\n\tinit_ok = true;\n}\n\n// Close display\ndriver_fullscreen::~driver_fullscreen()\n{\n#ifdef ENABLE_VOSF\n\tif (use_vosf)\n\t\tthe_host_buffer = NULL;\t// don't free() in driver_base dtor\n#endif\n\tif (s)\n\t\tSDL_FreeSurface(s);\n\n\t// Show cursor\n\tSDL_ShowCursor(1);\n}\n\n\n/*\n *  Initialization\n */\n\n// Init keycode translation table\nstatic void keycode_init(void)\n{\n\tbool use_kc = PrefsFindBool(\"keycodes\");\n\tif (use_kc) {\n\n\t\t// Get keycode file path from preferences\n\t\tconst char *kc_path = PrefsFindString(\"keycodefile\");\n\n\t\t// Open keycode table\n\t\tFILE *f = fopen(kc_path ? kc_path : KEYCODE_FILE_NAME, \"r\");\n\t\tif (f == NULL) {\n\t\t\tchar str[256];\n\t\t\tsprintf(str, GetString(STR_KEYCODE_FILE_WARN), kc_path ? kc_path : KEYCODE_FILE_NAME, strerror(errno));\n\t\t\tWarningAlert(str);\n\t\t\treturn;\n\t\t}\n\n\t\t// Default translation table\n\t\tfor (int i=0; i<256; i++)\n\t\t\tkeycode_table[i] = -1;\n\n\t\t// Search for server vendor string, then read keycodes\n\t\tchar video_driver[256];\n\t\tSDL_VideoDriverName(video_driver, sizeof(video_driver));\n\t\tbool video_driver_found = false;\n\t\tchar line[256];\n\t\tint n_keys = 0;\n\t\twhile (fgets(line, sizeof(line) - 1, f)) {\n\t\t\t// Read line\n\t\t\tint len = strlen(line);\n\t\t\tif (len == 0)\n\t\t\t\tcontinue;\n\t\t\tline[len-1] = 0;\n\n\t\t\t// Comments begin with \"#\" or \";\"\n\t\t\tif (line[0] == '#' || line[0] == ';' || line[0] == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (video_driver_found) {\n\t\t\t\t// Skip aliases as long as we have read keycodes yet\n\t\t\t\t// Otherwise, it's another mapping and we have to stop\n\t\t\t\tstatic const char sdl_str[] = \"sdl\";\n\t\t\t\tif (strncmp(line, sdl_str, sizeof(sdl_str) - 1) == 0 && n_keys == 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// Read keycode\n\t\t\t\tint x_code, mac_code;\n\t\t\t\tif (sscanf(line, \"%d %d\", &x_code, &mac_code) == 2)\n\t\t\t\t\tkeycode_table[x_code & 0xff] = mac_code, n_keys++;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// Search for SDL video driver string\n\t\t\t\tstatic const char sdl_str[] = \"sdl\";\n\t\t\t\tif (strncmp(line, sdl_str, sizeof(sdl_str) - 1) == 0) {\n\t\t\t\t\tchar *p = line + sizeof(sdl_str);\n\t\t\t\t\tif (strstr(video_driver, p) == video_driver)\n\t\t\t\t\t\tvideo_driver_found = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Keycode file completely read\n\t\tfclose(f);\n\t\tuse_keycodes = video_driver_found;\n\n\t\t// Vendor not found? Then display warning\n\t\tif (!video_driver_found) {\n\t\t\tchar str[256];\n\t\t\tsprintf(str, GetString(STR_KEYCODE_VENDOR_WARN), video_driver, kc_path ? kc_path : KEYCODE_FILE_NAME);\n\t\t\tWarningAlert(str);\n\t\t\treturn;\n\t\t}\n\n\t\tD(bug(\"Using SDL/%s keycodes table, %d key mappings\\n\", video_driver, n_keys));\n\t}\n}\n\n// Open display for current mode\nbool SDL_monitor_desc::video_open(void)\n{\n\tD(bug(\"video_open()\\n\"));\n#if DEBUG\n\tconst VIDEO_MODE &mode = get_current_mode();\n\tD(bug(\"Current video mode:\\n\"));\n\tD(bug(\" %dx%d (ID %02x), %d bpp\\n\", VIDEO_MODE_X, VIDEO_MODE_Y, VIDEO_MODE_RESOLUTION, 1 << (VIDEO_MODE_DEPTH & 0x0f)));\n#endif\n\n\t// Create display driver object of requested type\n\tswitch (display_type) {\n\tcase DISPLAY_WINDOW:\n\t\tdrv = new(std::nothrow) driver_window(*this);\n\t\tbreak;\n\tcase DISPLAY_SCREEN:\n\t\tdrv = new(std::nothrow) driver_fullscreen(*this);\n\t\tbreak;\n\t}\n\tif (drv == NULL)\n\t\treturn false;\n\tif (!drv->init_ok) {\n\t\tdelete drv;\n\t\tdrv = NULL;\n\t\treturn false;\n\t}\n\n#ifdef WIN32\n\t// Chain in a new message handler for WM_DEVICECHANGE\n\tHWND the_window = GetMainWindowHandle();\n\tsdl_window_proc = (WNDPROC)GetWindowLongPtr(the_window, GWLP_WNDPROC);\n\tSetWindowLongPtr(the_window, GWLP_WNDPROC, (LONG_PTR)windows_message_handler);\n#endif\n\n\t// Initialize VideoRefresh function\n\tVideoRefreshInit();\n\n\t// Lock down frame buffer\n\tLOCK_FRAME_BUFFER;\n\n\t// Start redraw/input thread\n#ifndef USE_CPU_EMUL_SERVICES\n\tredraw_thread_cancel = false;\n\tredraw_thread_active = ((redraw_thread = SDL_CreateThread(redraw_func, NULL)) != NULL);\n\tif (!redraw_thread_active) {\n\t\tprintf(\"FATAL: cannot create redraw thread\\n\");\n\t\treturn false;\n\t}\n#else\n\tredraw_thread_active = true;\n#endif\n\treturn true;\n}\n\n#ifdef SHEEPSHAVER\nbool VideoInit(void)\n{\n\tconst bool classic = false;\n#else\nbool VideoInit(bool classic)\n{\n#endif\n\tclassic_mode = classic;\n\n#ifdef ENABLE_VOSF\n\t// Zero the mainBuffer structure\n\tmainBuffer.dirtyPages = NULL;\n\tmainBuffer.pageInfo = NULL;\n#endif\n\n\t#ifndef EMSCRIPTEN\n\t// Create Mutexes\n\tif ((sdl_events_lock = SDL_CreateMutex()) == NULL)\n\t\treturn false;\n\tif ((sdl_palette_lock = SDL_CreateMutex()) == NULL)\n\t\treturn false;\n\tif ((frame_buffer_lock = SDL_CreateMutex()) == NULL)\n\t\treturn false;\n\t#endif\n\n\t// Init keycode translation\n\tkeycode_init();\n\n\t// Read prefs\n\tframe_skip = PrefsFindInt32(\"frameskip\");\n\tmouse_wheel_mode = PrefsFindInt32(\"mousewheelmode\");\n\tmouse_wheel_lines = PrefsFindInt32(\"mousewheellines\");\n\n\t// Get screen mode from preferences\n\tmigrate_screen_prefs();\n\tconst char *mode_str = NULL;\n\tif (classic_mode)\n\t\tmode_str = \"win/512/342\";\n\telse\n\t\tmode_str = PrefsFindString(\"screen\");\n\n\t// Determine display type and default dimensions\n\tint default_width, default_height;\n\tif (classic) {\n\t\tdefault_width = 512;\n\t\tdefault_height = 384;\n\t}\n\telse {\n\t\tdefault_width = 640;\n\t\tdefault_height = 480;\n\t}\n\tdisplay_type = DISPLAY_WINDOW;\n\tif (mode_str) {\n\t\tif (sscanf(mode_str, \"win/%d/%d\", &default_width, &default_height) == 2)\n\t\t\tdisplay_type = DISPLAY_WINDOW;\n\t\telse if (sscanf(mode_str, \"dga/%d/%d\", &default_width, &default_height) == 2)\n\t\t\tdisplay_type = DISPLAY_SCREEN;\n\t}\n\tif (default_width <= 0)\n\t\tdefault_width = sdl_display_width();\n\telse if (default_width > sdl_display_width())\n\t\tdefault_width = sdl_display_width();\n\tif (default_height <= 0)\n\t\tdefault_height = sdl_display_height();\n\telse if (default_height > sdl_display_height())\n\t\tdefault_height = sdl_display_height();\n\n\t#ifdef EMSCRIPTEN\n\t\tscreen_depth = 32;\n\t#else\n\t\t// Mac screen depth follows X depth\n\t\tscreen_depth = SDL_GetVideoInfo()->vfmt->BitsPerPixel;\n\t#endif\n\tint default_depth;\n\tswitch (screen_depth) {\n\tcase 8:\n\t\tdefault_depth = VIDEO_DEPTH_8BIT;\n\t\tbreak;\n\tcase 15: case 16:\n\t\tdefault_depth = VIDEO_DEPTH_16BIT;\n\t\tbreak;\n\tcase 24: case 32:\n\t\tdefault_depth = VIDEO_DEPTH_32BIT;\n\t\tbreak;\n\tdefault:\n\t\tdefault_depth =  VIDEO_DEPTH_1BIT;\n\t\tbreak;\n\t}\n\n\t// Initialize list of video modes to try\n\tstruct {\n\t\tint w;\n\t\tint h;\n\t\tint resolution_id;\n\t}\n\tvideo_modes[] = {\n\t\t{   -1,   -1, 0x80 },\n\t\t{  512,  384, 0x80 },\n\t\t{  640,  480, 0x81 },\n\t\t{  800,  600, 0x82 },\n\t\t{ 1024,  768, 0x83 },\n\t\t{ 1152,  870, 0x84 },\n\t\t{ 1280, 1024, 0x85 },\n\t\t{ 1600, 1200, 0x86 },\n\t\t{ 0, }\n\t};\n\tvideo_modes[0].w = default_width;\n\tvideo_modes[0].h = default_height;\n\n\t// Construct list of supported modes\n\tif (display_type == DISPLAY_WINDOW) {\n\t\tif (classic)\n\t\t\tadd_mode(display_type, 512, 342, 0x80, 64, VIDEO_DEPTH_1BIT);\n\t\telse {\n\t\t\tfor (int i = 0; video_modes[i].w != 0; i++) {\n\t\t\t\tconst int w = video_modes[i].w;\n\t\t\t\tconst int h = video_modes[i].h;\n\t\t\t\tif (i > 0 && (w >= default_width || h >= default_height))\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int d = VIDEO_DEPTH_1BIT; d <= default_depth; d++)\n\t\t\t\t\tadd_mode(display_type, w, h, video_modes[i].resolution_id, TrivialBytesPerRow(w, (video_depth)d), d);\n\t\t\t}\n\t\t}\n\t} else if (display_type == DISPLAY_SCREEN) {\n\t\tfor (int i = 0; video_modes[i].w != 0; i++) {\n\t\t\tconst int w = video_modes[i].w;\n\t\t\tconst int h = video_modes[i].h;\n\t\t\tif (i > 0 && (w >= default_width || h >= default_height))\n\t\t\t\tcontinue;\n\t\t\tif (w == 512 && h == 384)\n\t\t\t\tcontinue;\n\t\t\tfor (int d = VIDEO_DEPTH_1BIT; d <= default_depth; d++)\n\t\t\t\tadd_mode(display_type, w, h, video_modes[i].resolution_id, TrivialBytesPerRow(w, (video_depth)d), d);\n\t\t}\n\t}\n\n\tif (VideoModes.empty()) {\n\t\tErrorAlert(STR_NO_XVISUAL_ERR);\n\t\treturn false;\n\t}\n\n\t// Find requested default mode with specified dimensions\n\tuint32 default_id;\n\tstd::vector<VIDEO_MODE>::const_iterator i, end = VideoModes.end();\n\tfor (i = VideoModes.begin(); i != end; ++i) {\n\t\tconst VIDEO_MODE & mode = (*i);\n\t\tif (VIDEO_MODE_X == default_width && VIDEO_MODE_Y == default_height && VIDEO_MODE_DEPTH == default_depth) {\n\t\t\tdefault_id = VIDEO_MODE_RESOLUTION;\n#ifdef SHEEPSHAVER\n\t\t\tstd::vector<VIDEO_MODE>::const_iterator begin = VideoModes.begin();\n\t\t\tcur_mode = distance(begin, i);\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == end) { // not found, use first available mode\n\t\tconst VIDEO_MODE & mode = VideoModes[0];\n\t\tdefault_depth = VIDEO_MODE_DEPTH;\n\t\tdefault_id = VIDEO_MODE_RESOLUTION;\n#ifdef SHEEPSHAVER\n\t\tcur_mode = 0;\n#endif\n\t}\n\n#ifdef SHEEPSHAVER\n\tfor (int i = 0; i < VideoModes.size(); i++)\n\t\tVModes[i] = VideoModes[i];\n\tVideoInfo *p = &VModes[VideoModes.size()];\n\tp->viType = DIS_INVALID;        // End marker\n\tp->viRowBytes = 0;\n\tp->viXsize = p->viYsize = 0;\n\tp->viAppleMode = 0;\n\tp->viAppleID = 0;\n#endif\n\n#if DEBUG\n\tD(bug(\"Available video modes:\\n\"));\n\tfor (i = VideoModes.begin(); i != end; ++i) {\n\t\tconst VIDEO_MODE & mode = (*i);\n\t\tint bits = 1 << VIDEO_MODE_DEPTH;\n\t\tif (bits == 16)\n\t\t\tbits = 15;\n\t\telse if (bits == 32)\n\t\t\tbits = 24;\n\t\tD(bug(\" %dx%d (ID %02x), %d colors\\n\", VIDEO_MODE_X, VIDEO_MODE_Y, VIDEO_MODE_RESOLUTION, 1 << bits));\n\t}\n#endif\n\n\t// Create SDL_monitor_desc for this (the only) display\n\tSDL_monitor_desc *monitor = new SDL_monitor_desc(VideoModes, (video_depth)default_depth, default_id);\n\tVideoMonitors.push_back(monitor);\n\n\t// Open display\n\treturn monitor->video_open();\n}\n\n\n/*\n *  Deinitialization\n */\n\n// Close display\nvoid SDL_monitor_desc::video_close(void)\n{\n\tD(bug(\"video_close()\\n\"));\n\n#ifdef WIN32\n\t// Remove message handler for WM_DEVICECHANGE\n\tHWND the_window = GetMainWindowHandle();\n\tSetWindowLongPtr(the_window, GWLP_WNDPROC, (LONG_PTR)sdl_window_proc);\n#endif\n\n\t// Stop redraw thread\n#ifndef USE_CPU_EMUL_SERVICES\n\tif (redraw_thread_active) {\n\t\tredraw_thread_cancel = true;\n\t\tSDL_WaitThread(redraw_thread, NULL);\n\t}\n#endif\n\tredraw_thread_active = false;\n\n\t// Unlock frame buffer\n\tUNLOCK_FRAME_BUFFER;\n\tD(bug(\" frame buffer unlocked\\n\"));\n\n\t// Close display\n\tdelete drv;\n\tdrv = NULL;\n}\n\nvoid VideoExit(void)\n{\n\t// Close displays\n\tvector<monitor_desc *>::iterator i, end = VideoMonitors.end();\n\tfor (i = VideoMonitors.begin(); i != end; ++i)\n\t\tdynamic_cast<SDL_monitor_desc *>(*i)->video_close();\n\n\t// Destroy locks\n\tif (frame_buffer_lock)\n\t\tSDL_DestroyMutex(frame_buffer_lock);\n\tif (sdl_palette_lock)\n\t\tSDL_DestroyMutex(sdl_palette_lock);\n\tif (sdl_events_lock)\n\t\tSDL_DestroyMutex(sdl_events_lock);\n}\n\n\n/*\n *  Close down full-screen mode (if bringing up error alerts is unsafe while in full-screen mode)\n */\n\nvoid VideoQuitFullScreen(void)\n{\n\tD(bug(\"VideoQuitFullScreen()\\n\"));\n\tquit_full_screen = true;\n}\n\n\n/*\n *  Mac VBL interrupt\n */\n\n/*\n *  Execute video VBL routine\n */\n\n#ifdef SHEEPSHAVER\nvoid VideoVBL(void)\n{\n\t// Emergency quit requested? Then quit\n\tif (emerg_quit)\n\t\tQuitEmulator();\n\n\t// Temporarily give up frame buffer lock (this is the point where\n\t// we are suspended when the user presses Ctrl-Tab)\n\tUNLOCK_FRAME_BUFFER;\n\tLOCK_FRAME_BUFFER;\n\n\t// Execute video VBL\n\tif (private_data != NULL && private_data->interruptsEnabled)\n\t\tVSLDoInterruptService(private_data->vslServiceID);\n}\n#else\nvoid VideoInterrupt(void)\n{\n\t// We must fill in the events queue in the same thread that did call SDL_SetVideoMode()\n\tSDL_PumpEvents();\n\n\t// Emergency quit requested? Then quit\n\tif (emerg_quit)\n\t\tQuitEmulator();\n\n\t// Temporarily give up frame buffer lock (this is the point where\n\t// we are suspended when the user presses Ctrl-Tab)\n\tUNLOCK_FRAME_BUFFER;\n\tLOCK_FRAME_BUFFER;\n}\n#endif\n\n\n/*\n *  Set palette\n */\n\n#ifdef SHEEPSHAVER\nvoid video_set_palette(void)\n{\n\tmonitor_desc * monitor = VideoMonitors[0];\n\tint n_colors = palette_size(monitor->get_current_mode().viAppleMode);\n\tuint8 pal[256 * 3];\n\tfor (int c = 0; c < n_colors; c++) {\n\t\tpal[c*3 + 0] = mac_pal[c].red;\n\t\tpal[c*3 + 1] = mac_pal[c].green;\n\t\tpal[c*3 + 2] = mac_pal[c].blue;\n\t}\n\tmonitor->set_palette(pal, n_colors);\n}\n#endif\n\n\nvoid SDL_monitor_desc::set_palette(uint8 *pal, int num_in)\n{\n\t// printf(\"set_palette\\n\");\n\tconst VIDEO_MODE &mode = get_current_mode();\n\n\t// FIXME: how can we handle the gamma ramp?\n\tif ((int)VIDEO_MODE_DEPTH > VIDEO_DEPTH_8BIT)\n\t\treturn;\n\n\tLOCK_PALETTE;\n\n\t// Convert colors to XColor array\n\tint num_out = 256;\n\tbool stretch = false;\n\tSDL_Color *p = sdl_palette;\n\tfor (int i=0; i<num_out; i++) {\n\t\tint c = (stretch ? (i * num_in) / num_out : i);\n\t\tp->r = pal[c*3 + 0] * 0x0101;\n\t\tp->g = pal[c*3 + 1] * 0x0101;\n\t\tp->b = pal[c*3 + 2] * 0x0101;\n\t\tp++;\n\t}\n\n\t// Recalculate pixel color expansion map\n\tif (!IsDirectMode(mode)) {\n\t\tfor (int i=0; i<256; i++) {\n\t\t\tint c = i & (num_in-1); // If there are less than 256 colors, we repeat the first entries (this makes color expansion easier)\n\t\t\t#ifdef EMSCRIPTEN\n\t\t\tExpandMap[i] = map_rgb(pal[c*3+0], pal[c*3+1], pal[c*3+2], true);\n\t\t\t#else\n\t\t\tExpandMap[i] = SDL_MapRGB(drv->s->format, pal[c*3+0], pal[c*3+1], pal[c*3+2]);\n\t\t\t#endif\n\t\t}\n\n#ifdef ENABLE_VOSF\n\t\tif (use_vosf) {\n\t\t\t// We have to redraw everything because the interpretation of pixel values changed\n\t\t\tLOCK_VOSF;\n\t\t\tPFLAG_SET_ALL;\n\t\t\tUNLOCK_VOSF;\n\t\t\tmemset(the_buffer_copy, 0, VIDEO_MODE_ROW_BYTES * VIDEO_MODE_Y);\n\t\t}\n#endif\n\t}\n\n\t// Tell redraw thread to change palette\n\tsdl_palette_changed = true;\n\n\tUNLOCK_PALETTE;\n}\n\n\n/*\n *  Switch video mode\n */\n\n#ifdef SHEEPSHAVER\nint16 video_mode_change(VidLocals *csSave, uint32 ParamPtr)\n{\n\t/* return if no mode change */\n\tif ((csSave->saveData == ReadMacInt32(ParamPtr + csData)) &&\n\t    (csSave->saveMode == ReadMacInt16(ParamPtr + csMode))) return noErr;\n\n\t/* first find video mode in table */\n\tfor (int i=0; VModes[i].viType != DIS_INVALID; i++) {\n\t\tif ((ReadMacInt16(ParamPtr + csMode) == VModes[i].viAppleMode) &&\n\t\t    (ReadMacInt32(ParamPtr + csData) == VModes[i].viAppleID)) {\n\t\t\tcsSave->saveMode = ReadMacInt16(ParamPtr + csMode);\n\t\t\tcsSave->saveData = ReadMacInt32(ParamPtr + csData);\n\t\t\tcsSave->savePage = ReadMacInt16(ParamPtr + csPage);\n\n\t\t\t// Disable interrupts and pause redraw thread\n\t\t\tDisableInterrupt();\n\t\t\tthread_stop_ack = false;\n\t\t\tthread_stop_req = true;\n\t\t\twhile (!thread_stop_ack) ;\n\n\t\t\tcur_mode = i;\n\t\t\tmonitor_desc *monitor = VideoMonitors[0];\n\t\t\tmonitor->switch_to_current_mode();\n\n\t\t\tWriteMacInt32(ParamPtr + csBaseAddr, screen_base);\n\t\t\tcsSave->saveBaseAddr=screen_base;\n\t\t\tcsSave->saveData=VModes[cur_mode].viAppleID;/* First mode ... */\n\t\t\tcsSave->saveMode=VModes[cur_mode].viAppleMode;\n\n\t\t\t// Enable interrupts and resume redraw thread\n\t\t\tthread_stop_req = false;\n\t\t\tEnableInterrupt();\n\t\t\treturn noErr;\n\t\t}\n\t}\n\treturn paramErr;\n}\n#endif\n\nvoid SDL_monitor_desc::switch_to_current_mode(void)\n{\n\t// Close and reopen display\n\tLOCK_EVENTS;\n\tvideo_close();\n\tvideo_open();\n\tUNLOCK_EVENTS;\n\n\tif (drv == NULL) {\n\t\tErrorAlert(STR_OPEN_WINDOW_ERR);\n\t\tQuitEmulator();\n\t}\n}\n\n\n/*\n *  Can we set the MacOS cursor image into the window?\n */\n\n#ifdef SHEEPSHAVER\nbool video_can_change_cursor(void)\n{\n#if defined(__APPLE__)\n\tstatic char driver[] = \"Quartz?\";\n\tstatic int quartzok = -1;\n\n\tif (display_type != DISPLAY_WINDOW)\n\t\treturn false;\n\n\tif (quartzok < 0) {\n\t\tif (SDL_VideoDriverName(driver, sizeof driver) == NULL || strncmp(driver, \"Quartz\", sizeof driver))\n\t\t\tquartzok = true;\n\t\telse {\n\t\t\t// Quartz driver bug prevents cursor changing in SDL 1.2.11 to 1.2.14.\n\t\t\tconst SDL_version *vp = SDL_Linked_Version();\n\t\t\tint version = SDL_VERSIONNUM(vp->major, vp->minor, vp->patch);\n\t\t\tquartzok = (version <= SDL_VERSIONNUM(1, 2, 10) || version >= SDL_VERSIONNUM(1, 2, 15));\n\t\t}\n\t}\n\n\treturn quartzok;\n#else\n\treturn true;\n#endif\n}\n#endif\n\n\n/*\n *  Set cursor image for window\n */\n\n#ifdef SHEEPSHAVER\nvoid video_set_cursor(void)\n{\n\t// Set new cursor image if it was changed\n\tif (sdl_cursor) {\n\t\tSDL_FreeCursor(sdl_cursor);\n\t\tsdl_cursor = SDL_CreateCursor(MacCursor + 4, MacCursor + 36, 16, 16, MacCursor[2], MacCursor[3]);\n\t\tif (sdl_cursor) {\n\t\t\tSDL_ShowCursor(private_data == NULL || private_data->cursorVisible);\n\t\t\tSDL_SetCursor(sdl_cursor);\n#ifdef WIN32\n\t\t\t// XXX Windows apparently needs an extra mouse event to\n\t\t\t// make the new cursor image visible\n\t\t\tint visible = SDL_ShowCursor(-1);\n\t\t\tif (visible) {\n\t\t\t\tint x, y;\n\t\t\t\tSDL_GetMouseState(&x, &y);\n\t\t\t\tSDL_WarpMouse(x, y);\n\t\t\t}\n#endif\n\t\t}\n\t}\n}\n#endif\n\n\n/*\n *  Keyboard-related utilify functions\n */\n\nstatic bool is_modifier_key(SDL_KeyboardEvent const & e)\n{\n\tswitch (e.keysym.sym) {\n\tcase SDLK_NUMLOCK:\n\tcase SDLK_CAPSLOCK:\n\tcase SDLK_SCROLLOCK:\n\tcase SDLK_RSHIFT:\n\tcase SDLK_LSHIFT:\n\tcase SDLK_RCTRL:\n\tcase SDLK_LCTRL:\n\tcase SDLK_RALT:\n\tcase SDLK_LALT:\n\tcase SDLK_RMETA:\n\tcase SDLK_LMETA:\n\tcase SDLK_LSUPER:\n\tcase SDLK_RSUPER:\n\tcase SDLK_MODE:\n\tcase SDLK_COMPOSE:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool is_ctrl_down(SDL_keysym const & ks)\n{\n\treturn ctrl_down || (ks.mod & KMOD_CTRL);\n}\n\n\n/*\n *  Translate key event to Mac keycode, returns -1 if no keycode was found\n *  and -2 if the key was recognized as a hotkey\n */\n\nstatic int kc_decode(SDL_keysym const & ks, bool key_down)\n{\n\tswitch (ks.sym) {\n\tcase SDLK_a: return 0x00;\n\tcase SDLK_b: return 0x0b;\n\tcase SDLK_c: return 0x08;\n\tcase SDLK_d: return 0x02;\n\tcase SDLK_e: return 0x0e;\n\tcase SDLK_f: return 0x03;\n\tcase SDLK_g: return 0x05;\n\tcase SDLK_h: return 0x04;\n\tcase SDLK_i: return 0x22;\n\tcase SDLK_j: return 0x26;\n\tcase SDLK_k: return 0x28;\n\tcase SDLK_l: return 0x25;\n\tcase SDLK_m: return 0x2e;\n\tcase SDLK_n: return 0x2d;\n\tcase SDLK_o: return 0x1f;\n\tcase SDLK_p: return 0x23;\n\tcase SDLK_q: return 0x0c;\n\tcase SDLK_r: return 0x0f;\n\tcase SDLK_s: return 0x01;\n\tcase SDLK_t: return 0x11;\n\tcase SDLK_u: return 0x20;\n\tcase SDLK_v: return 0x09;\n\tcase SDLK_w: return 0x0d;\n\tcase SDLK_x: return 0x07;\n\tcase SDLK_y: return 0x10;\n\tcase SDLK_z: return 0x06;\n\n\tcase SDLK_1: case SDLK_EXCLAIM: return 0x12;\n\tcase SDLK_2: case SDLK_AT: return 0x13;\n\tcase SDLK_3: case SDLK_HASH: return 0x14;\n\tcase SDLK_4: case SDLK_DOLLAR: return 0x15;\n\tcase SDLK_5: return 0x17;\n\tcase SDLK_6: return 0x16;\n\tcase SDLK_7: return 0x1a;\n\tcase SDLK_8: return 0x1c;\n\tcase SDLK_9: return 0x19;\n\tcase SDLK_0: return 0x1d;\n\n\tcase SDLK_BACKQUOTE: return 0x0a;\n\tcase SDLK_MINUS: case SDLK_UNDERSCORE: return 0x1b;\n\tcase SDLK_EQUALS: case SDLK_PLUS: return 0x18;\n\tcase SDLK_LEFTBRACKET: return 0x21;\n\tcase SDLK_RIGHTBRACKET: return 0x1e;\n\tcase SDLK_BACKSLASH: return 0x2a;\n\tcase SDLK_SEMICOLON: case SDLK_COLON: return 0x29;\n\tcase SDLK_QUOTE: case SDLK_QUOTEDBL: return 0x27;\n\tcase SDLK_COMMA: case SDLK_LESS: return 0x2b;\n\tcase SDLK_PERIOD: case SDLK_GREATER: return 0x2f;\n\tcase SDLK_SLASH: case SDLK_QUESTION: return 0x2c;\n\n\tcase SDLK_TAB: if (is_ctrl_down(ks)) {if (!key_down) drv->suspend(); return -2;} else return 0x30;\n\tcase SDLK_RETURN: return 0x24;\n\tcase SDLK_SPACE: return 0x31;\n\tcase SDLK_BACKSPACE: return 0x33;\n\n\tcase SDLK_DELETE: return 0x75;\n\tcase SDLK_INSERT: return 0x72;\n\tcase SDLK_HOME: case SDLK_HELP: return 0x73;\n\tcase SDLK_END: return 0x77;\n\tcase SDLK_PAGEUP: return 0x74;\n\tcase SDLK_PAGEDOWN: return 0x79;\n\n\tcase SDLK_LCTRL: return 0x36;\n\tcase SDLK_RCTRL: return 0x36;\n\tcase SDLK_LSHIFT: return 0x38;\n\tcase SDLK_RSHIFT: return 0x38;\n#if (defined(__APPLE__) && defined(__MACH__))\n\tcase SDLK_LALT: return 0x3a;\n\tcase SDLK_RALT: return 0x3a;\n\tcase SDLK_LMETA: return 0x37;\n\tcase SDLK_RMETA: return 0x37;\n#else\n\tcase SDLK_LALT: return 0x37;\n\tcase SDLK_RALT: return 0x37;\n\tcase SDLK_LMETA: return 0x3a;\n\tcase SDLK_RMETA: return 0x3a;\n#endif\n\tcase SDLK_LSUPER: return 0x3a; // \"Windows\" key\n\tcase SDLK_RSUPER: return 0x3a;\n\tcase SDLK_MENU: return 0x32;\n\tcase SDLK_CAPSLOCK: return 0x39;\n\tcase SDLK_NUMLOCK: return 0x47;\n\n\tcase SDLK_UP: return 0x3e;\n\tcase SDLK_DOWN: return 0x3d;\n\tcase SDLK_LEFT: return 0x3b;\n\tcase SDLK_RIGHT: return 0x3c;\n\n\tcase SDLK_ESCAPE: if (is_ctrl_down(ks)) {if (!key_down) { quit_full_screen = true; emerg_quit = true; } return -2;} else return 0x35;\n\n\tcase SDLK_F1: if (is_ctrl_down(ks)) {if (!key_down) SysMountFirstFloppy(); return -2;} else return 0x7a;\n\tcase SDLK_F2: return 0x78;\n\tcase SDLK_F3: return 0x63;\n\tcase SDLK_F4: return 0x76;\n\tcase SDLK_F5: if (is_ctrl_down(ks)) {if (!key_down) drv->toggle_mouse_grab(); return -2;} else return 0x60;\n\tcase SDLK_F6: return 0x61;\n\tcase SDLK_F7: return 0x62;\n\tcase SDLK_F8: return 0x64;\n\tcase SDLK_F9: return 0x65;\n\tcase SDLK_F10: return 0x6d;\n\tcase SDLK_F11: return 0x67;\n\tcase SDLK_F12: return 0x6f;\n\n\tcase SDLK_PRINT: return 0x69;\n\tcase SDLK_SCROLLOCK: return 0x6b;\n\tcase SDLK_PAUSE: return 0x71;\n\n\tcase SDLK_KP0: return 0x52;\n\tcase SDLK_KP1: return 0x53;\n\tcase SDLK_KP2: return 0x54;\n\tcase SDLK_KP3: return 0x55;\n\tcase SDLK_KP4: return 0x56;\n\tcase SDLK_KP5: return 0x57;\n\tcase SDLK_KP6: return 0x58;\n\tcase SDLK_KP7: return 0x59;\n\tcase SDLK_KP8: return 0x5b;\n\tcase SDLK_KP9: return 0x5c;\n\tcase SDLK_KP_PERIOD: return 0x41;\n\tcase SDLK_KP_PLUS: return 0x45;\n\tcase SDLK_KP_MINUS: return 0x4e;\n\tcase SDLK_KP_MULTIPLY: return 0x43;\n\tcase SDLK_KP_DIVIDE: return 0x4b;\n\tcase SDLK_KP_ENTER: return 0x4c;\n\tcase SDLK_KP_EQUALS: return 0x51;\n\t}\n\tD(bug(\"Unhandled SDL keysym: %d\\n\", ks.sym));\n\treturn -1;\n}\n\nstatic int event2keycode(SDL_KeyboardEvent const &ev, bool key_down)\n{\n\treturn kc_decode(ev.keysym, key_down);\n}\n\n\n/*\n *  SDL event handling\n */\n\n#define SDL_N_EVENTS_PER_HANDLER 1\n\nstatic void handle_events(void)\n{\n\tSDL_Event events[SDL_N_EVENTS_PER_HANDLER];\n\tconst int n_max_events = sizeof(events) / sizeof(events[0]);\n\tint n_events;\n\n\twhile ((n_events = SDL_PeepEvents(events, n_max_events, SDL_GETEVENT, sdl_eventmask)) > 0) {\n\t\tfor (int i = 0; i < n_events; i++) {\n\t\t\tSDL_Event const & event = events[i];\n\t\t\tswitch (event.type) {\n\n\t\t\t// Mouse button\n\t\t\tcase SDL_MOUSEBUTTONDOWN: {\n\t\t\t\tunsigned int button = event.button.button;\n\t\t\t\tif (button == SDL_BUTTON_LEFT)\n\t\t\t\t\tADBMouseDown(0);\n\t\t\t\telse if (button == SDL_BUTTON_RIGHT)\n\t\t\t\t\tADBMouseDown(1);\n\t\t\t\telse if (button == SDL_BUTTON_MIDDLE)\n\t\t\t\t\tADBMouseDown(2);\n\t\t\t\telse if (button < 6) {\t// Wheel mouse\n\t\t\t\t\tif (mouse_wheel_mode == 0) {\n\t\t\t\t\t\tint key = (button == 5) ? 0x79 : 0x74;\t// Page up/down\n\t\t\t\t\t\tADBKeyDown(key);\n\t\t\t\t\t\tADBKeyUp(key);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint key = (button == 5) ? 0x3d : 0x3e;\t// Cursor up/down\n\t\t\t\t\t\tfor(int i=0; i<mouse_wheel_lines; i++) {\n\t\t\t\t\t\t\tADBKeyDown(key);\n\t\t\t\t\t\t\tADBKeyUp(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase SDL_MOUSEBUTTONUP: {\n\t\t\t\tunsigned int button = event.button.button;\n\t\t\t\tif (button == SDL_BUTTON_LEFT)\n\t\t\t\t\tADBMouseUp(0);\n\t\t\t\telse if (button == SDL_BUTTON_RIGHT)\n\t\t\t\t\tADBMouseUp(1);\n\t\t\t\telse if (button == SDL_BUTTON_MIDDLE)\n\t\t\t\t\tADBMouseUp(2);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Mouse moved\n\t\t\tcase SDL_MOUSEMOTION:\n\t\t\t\tdrv->mouse_moved(event.motion.x, event.motion.y);\n\t\t\t\tbreak;\n\n\t\t\t// Keyboard\n\t\t\tcase SDL_KEYDOWN: {\n\t\t\t\tint code = -1;\n\t\t\t\tif (use_keycodes && !is_modifier_key(event.key)) {\n\t\t\t\t\tif (event2keycode(event.key, true) != -2)\t// This is called to process the hotkeys\n\t\t\t\t\t\tcode = keycode_table[event.key.keysym.scancode & 0xff];\n\t\t\t\t} else\n\t\t\t\t\tcode = event2keycode(event.key, true);\n\t\t\t\tif (code >= 0) {\n\t\t\t\t\tif (!emul_suspended) {\n\t\t\t\t\t\tif (code == 0x39) {\t// Caps Lock pressed\n\t\t\t\t\t\t\tif (caps_on) {\n\t\t\t\t\t\t\t\tADBKeyUp(code);\n\t\t\t\t\t\t\t\tcaps_on = false;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tADBKeyDown(code);\n\t\t\t\t\t\t\t\tcaps_on = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tADBKeyDown(code);\n\t\t\t\t\t\tif (code == 0x36)\n\t\t\t\t\t\t\tctrl_down = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (code == 0x31)\n\t\t\t\t\t\t\tdrv->resume();\t// Space wakes us up\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase SDL_KEYUP: {\n\t\t\t\tint code = -1;\n\t\t\t\tif (use_keycodes && !is_modifier_key(event.key)) {\n\t\t\t\t\tif (event2keycode(event.key, false) != -2)\t// This is called to process the hotkeys\n\t\t\t\t\t\tcode = keycode_table[event.key.keysym.scancode & 0xff];\n\t\t\t\t} else\n\t\t\t\t\tcode = event2keycode(event.key, false);\n\t\t\t\tif (code >= 0) {\n\t\t\t\t\tif (code == 0x39) {\t// Caps Lock released\n\t\t\t\t\t\tif (caps_on) {\n\t\t\t\t\t\t\tADBKeyUp(code);\n\t\t\t\t\t\t\tcaps_on = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tADBKeyDown(code);\n\t\t\t\t\t\t\tcaps_on = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tADBKeyUp(code);\n\t\t\t\t\tif (code == 0x36)\n\t\t\t\t\t\tctrl_down = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Hidden parts exposed, force complete refresh of window\n\t\t\tcase SDL_VIDEOEXPOSE:\n\t\t\t\tif (display_type == DISPLAY_WINDOW) {\n\t\t\t\t\tconst VIDEO_MODE &mode = VideoMonitors[0]->get_current_mode();\n#ifdef ENABLE_VOSF\n\t\t\t\t\tif (use_vosf) {\t\t\t// VOSF refresh\n\t\t\t\t\t\tLOCK_VOSF;\n\t\t\t\t\t\tPFLAG_SET_ALL;\n\t\t\t\t\t\tUNLOCK_VOSF;\n\t\t\t\t\t\tmemset(the_buffer_copy, 0, VIDEO_MODE_ROW_BYTES * VIDEO_MODE_Y);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\tmemset(the_buffer_copy, 0, VIDEO_MODE_ROW_BYTES * VIDEO_MODE_Y);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Window \"close\" widget clicked\n\t\t\tcase SDL_QUIT:\n\t\t\t\tADBKeyDown(0x7f);\t// Power key\n\t\t\t\tADBKeyUp(0x7f);\n\t\t\t\tbreak;\n\n\t\t\t// Application activate/deactivate; consume the event but otherwise ignore it\n\t\t\tcase SDL_ACTIVEEVENT:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic int sdl_fake_kc_decode(int kc)\n{\n\tswitch (kc) {\n\tcase 65: return 0x00;\n\tcase 66: return 0x0b;\n\tcase 67: return 0x08;\n\tcase 68: return 0x02;\n\tcase 69: return 0x0e;\n\tcase 70: return 0x03;\n\tcase 71: return 0x05;\n\tcase 72: return 0x04;\n\tcase 73: return 0x22;\n\tcase 74: return 0x26;\n\tcase 75: return 0x28;\n\tcase 76: return 0x25;\n\tcase 77: return 0x2e;\n\tcase 78: return 0x2d;\n\tcase 79: return 0x1f;\n\tcase 80: return 0x23;\n\tcase 81: return 0x0c;\n\tcase 82: return 0x0f;\n\tcase 83: return 0x01;\n\tcase 84: return 0x11;\n\tcase 85: return 0x20;\n\tcase 86: return 0x09;\n\tcase 87: return 0x0d;\n\tcase 88: return 0x07;\n\tcase 89: return 0x10;\n\tcase 90: return 0x06;\n\n\tcase 49: /*case SDLK_EXCLAIM:*/ return 0x12;\n\tcase 50: /*case SDLK_AT:*/ return 0x13;\n\tcase 51: /*case SDLK_HASH:*/ return 0x14;\n\tcase 52: /*case SDLK_DOLLAR:*/ return 0x15;\n\tcase 53: return 0x17;\n\tcase 54: return 0x16;\n\tcase 55: return 0x1a;\n\tcase 56: return 0x1c;\n\tcase 57: return 0x19;\n\tcase 48: return 0x1d;\n\n\tcase 192: return 0x0a;\n\tcase 189: /*case SDLK_UNDERSCORE:*/ return 0x1b;\n\tcase 187: /*case SDLK_PLUS:*/ return 0x18;\n\tcase 219: return 0x21;\n\tcase 221: return 0x1e;\n\tcase 220: return 0x2a;\n\tcase 186: /*case SDLK_COLON:*/ return 0x29;\n\tcase 222: /*case SDLK_QUOTEDBL:*/ return 0x27;\n\tcase 188: /*case SDLK_LESS:*/ return 0x2b;\n\tcase 190: /*case SDLK_GREATER:*/ return 0x2f;\n\tcase 191: /*case SDLK_QUESTION:*/ return 0x2c;\n\n\tcase 9: return 0x30;\n\tcase 13: return 0x24;\n\tcase 32: return 0x31;\n\tcase 8: return 0x33;\n\n\t// case SDLK_DELETE: return 0x75;\n\t// case SDLK_INSERT: return 0x72;\n\t// case SDLK_HOME: case SDLK_HELP: return 0x73;\n\t// case SDLK_END: return 0x77;\n\t// case SDLK_PAGEUP: return 0x74;\n\t// case SDLK_PAGEDOWN: return 0x79;\n\n\tcase 17: return 0x36;\n\t// case SDLK_RCTRL: return 0x36;\n\tcase 16: return 0x38;\n\t// case SDLK_RSHIFT: return 0x38;\n// if mac\n\tcase 18: return 0x3a;\n\t// case SDLK_RALT: return 0x3a;\n\tcase 91: return 0x37;\n\tcase 93: return 0x37;\n// else\n\t// case SDLK_LALT: return 0x37;\n\t// case SDLK_RALT: return 0x37;\n\t// case SDLK_LMETA: return 0x3a;\n\t// case SDLK_RMETA: return 0x3a;\n// endif\n\t// case SDLK_LSUPER: return 0x3a; // \"Windows\" key\n\t// case SDLK_RSUPER: return 0x3a;\n\t// case SDLK_MENU: return 0x32;\n\t// case SDLK_CAPSLOCK: return 0x39;\n\t// case SDLK_NUMLOCK: return 0x47;\n\n\tcase 38: return 0x3e;\n\tcase 40: return 0x3d;\n\tcase 37: return 0x3b;\n\tcase 39: return 0x3c;\n\n\tcase 27:  return 0x35;\n\n\t// case SDLK_F1: return 0x7a;\n\t// case SDLK_F2: return 0x78;\n\t// case SDLK_F3: return 0x63;\n\t// case SDLK_F4: return 0x76;\n\t// case SDLK_F5: return 0x60;\n\t// case SDLK_F6: return 0x61;\n\t// case SDLK_F7: return 0x62;\n\t// case SDLK_F8: return 0x64;\n\t// case SDLK_F9: return 0x65;\n\t// case SDLK_F10: return 0x6d;\n\t// case SDLK_F11: return 0x67;\n\t// case SDLK_F12: return 0x6f;\n\n\t// case SDLK_PRINT: return 0x69;\n\t// case SDLK_SCROLLOCK: return 0x6b;\n\t// case SDLK_PAUSE: return 0x71;\n\n\t// case SDLK_KP0: return 0x52;\n\t// case SDLK_KP1: return 0x53;\n\t// case SDLK_KP2: return 0x54;\n\t// case SDLK_KP3: return 0x55;\n\t// case SDLK_KP4: return 0x56;\n\t// case SDLK_KP5: return 0x57;\n\t// case SDLK_KP6: return 0x58;\n\t// case SDLK_KP7: return 0x59;\n\t// case SDLK_KP8: return 0x5b;\n\t// case SDLK_KP9: return 0x5c;\n\t// case SDLK_KP_PERIOD: return 0x41;\n\t// case SDLK_KP_PLUS: return 0x45;\n\t// case SDLK_KP_MINUS: return 0x4e;\n\t// case SDLK_KP_MULTIPLY: return 0x43;\n\t// case SDLK_KP_DIVIDE: return 0x4b;\n\t// case SDLK_KP_ENTER: return 0x4c;\n\t// case SDLK_KP_EQUALS: return 0x51;\n\t}\n\tprintf(\"Unhandled keycode: %d\\n\", kc);\n\treturn -1;\n}\n\nstatic void sdl_fake_read_input() {\n\t#ifdef EMSCRIPTEN\n\tint lock = EM_ASM_INT_V({\n\t\t\treturn Module.acquireInputLock();\n\t\t});\n\tif (lock) {\n\t\tint mouse_button_state = EM_ASM_INT_V({\n\t\t\treturn Module.getInputValue(Module.InputBufferAddresses.mouseButtonStateAddr);\n\t\t});\n\n\t\tif (mouse_button_state > -1) {\n\t\t\tif (mouse_button_state == 0) {\n\t\t\t\tADBMouseUp(0);\n\t\t\t} else {\n\t\t\t\tADBMouseDown(0);\n\t\t\t}\n\t\t}\n\n\t\tint has_mouse_move = EM_ASM_INT_V({\n\t\t\treturn Module.getInputValue(Module.InputBufferAddresses.mouseMoveFlagAddr);\n\t\t});\n\t\tif (has_mouse_move) {\n\t\t\tint dx = EM_ASM_INT_V({\n\t\t\t\treturn Module.getInputValue(Module.InputBufferAddresses.mouseMoveXDeltaAddr);\n\t\t\t});\n\n\t\t\tint dy = EM_ASM_INT_V({\n\t\t\t\treturn Module.getInputValue(Module.InputBufferAddresses.mouseMoveYDeltaAddr);\n\t\t\t});\n\n\t\t\t// printf(\"mousemove %d %d\\n\", dx, dy);\n\t\t\t// HACK\n\t\t\t// TODO make sure mouse move is flagged correctly\n\t\t\tif (dx > 0 && dy > 0) {\n\t\t\t\tdrv->mouse_moved(dx, dy);\n\t\t\t}\n\t\t}\n\n\t\tint has_key_event = EM_ASM_INT_V({\n\t\t\treturn Module.getInputValue(Module.InputBufferAddresses.keyEventFlagAddr);\n\t\t});\n\t\tif (has_key_event) {\n\t\t\tint keycode = EM_ASM_INT_V({\n\t\t\t\treturn Module.getInputValue(Module.InputBufferAddresses.keyCodeAddr);\n\t\t\t});\n\n\t\t\tint keystate = EM_ASM_INT_V({\n\t\t\t\treturn Module.getInputValue(Module.InputBufferAddresses.keyStateAddr);\n\t\t\t});\n\n\t\t\t// printf(\"keyevent %d %d\\n\", keycode, keystate);\n\t\t\tint adbkeycode = sdl_fake_kc_decode(keycode);\n\t\t\tif (keystate == 0) {\n\t\t\t\tADBKeyUp(adbkeycode);\n\t\t\t} else {\n\t\t\t\tADBKeyDown(adbkeycode);\n\t\t\t}\n\n\t\t}\n\n\t\tEM_ASM({\n\t\t\tModule.releaseInputLock();\n\t\t});\n\t}\n\t#endif\n}\n\n\n/*\n *  Window display update\n */\n\n// Static display update (fixed frame rate, but incremental)\nstatic void update_display_static(driver_base *drv)\n{\n\n\tprintf(\"update_display_static\\n\");\n\n\t// Incremental update code\n\tint wide = 0, high = 0, x1, x2, y1, y2, i, j;\n\tconst VIDEO_MODE &mode = drv->mode;\n\tint bytes_per_row = VIDEO_MODE_ROW_BYTES;\n\tuint8 *p, *p2;\n\n\t// Check for first line from top and first line from bottom that have changed\n\ty1 = 0;\n\tfor (j=0; j<VIDEO_MODE_Y; j++) {\n\t\tif (memcmp(&the_buffer[j * bytes_per_row], &the_buffer_copy[j * bytes_per_row], bytes_per_row)) {\n\t\t\ty1 = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\ty2 = y1 - 1;\n\tfor (j=VIDEO_MODE_Y-1; j>=y1; j--) {\n\t\tif (memcmp(&the_buffer[j * bytes_per_row], &the_buffer_copy[j * bytes_per_row], bytes_per_row)) {\n\t\t\ty2 = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\thigh = y2 - y1 + 1;\n\n\t// Check for first column from left and first column from right that have changed\n\tif (high) {\n\t\tif ((int)VIDEO_MODE_DEPTH < VIDEO_DEPTH_8BIT) {\n\t\t\tconst int src_bytes_per_row = bytes_per_row;\n\t\t\tconst int dst_bytes_per_row = drv->s->pitch;\n\t\t\tconst int pixels_per_byte = VIDEO_MODE_X / src_bytes_per_row;\n\n\t\t\tx1 = VIDEO_MODE_X / pixels_per_byte;\n\t\t\tfor (j = y1; j <= y2; j++) {\n\t\t\t\tp = &the_buffer[j * bytes_per_row];\n\t\t\t\tp2 = &the_buffer_copy[j * bytes_per_row];\n\t\t\t\tfor (i = 0; i < x1; i++) {\n\t\t\t\t\tif (*p != *p2) {\n\t\t\t\t\t\tx1 = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp++; p2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx2 = x1;\n\t\t\tfor (j = y1; j <= y2; j++) {\n\t\t\t\tp = &the_buffer[j * bytes_per_row];\n\t\t\t\tp2 = &the_buffer_copy[j * bytes_per_row];\n\t\t\t\tp += bytes_per_row;\n\t\t\t\tp2 += bytes_per_row;\n\t\t\t\tfor (i = (VIDEO_MODE_X / pixels_per_byte); i > x2; i--) {\n\t\t\t\t\tp--; p2--;\n\t\t\t\t\tif (*p != *p2) {\n\t\t\t\t\t\tx2 = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tx1 *= pixels_per_byte;\n\t\t\tx2 *= pixels_per_byte;\n\t\t\twide = (x2 - x1 + pixels_per_byte - 1) & -pixels_per_byte;\n\n\t\t\t// Update copy of the_buffer\n\t\t\tif (high && wide) {\n\n\t\t\t\t#ifndef EMSCRIPTEN\n\t\t\t\t// Lock surface, if required\n\t\t\t\tif (SDL_MUSTLOCK(drv->s))\n\t\t\t\t\tSDL_LockSurface(drv->s);\n\t\t\t\t#endif\n\n\t\t\t\t// Blit to screen surface\n\t\t\t\tint si = y1 * src_bytes_per_row + (x1 / pixels_per_byte);\n\t\t\t\tint di = y1 * dst_bytes_per_row + x1;\n\t\t\t\tfor (j = y1; j <= y2; j++) {\n\t\t\t\t\tmemcpy(the_buffer_copy + si, the_buffer + si, wide / pixels_per_byte);\n\t\t\t\t\tScreen_blit((uint8 *)drv->s->pixels + di, the_buffer + si, wide / pixels_per_byte);\n\t\t\t\t\tsi += src_bytes_per_row;\n\t\t\t\t\tdi += dst_bytes_per_row;\n\t\t\t\t}\n\n\t\t\t\t#ifndef EMSCRIPTEN\n\t\t\t\t// Unlock surface, if required\n\t\t\t\tif (SDL_MUSTLOCK(drv->s))\n\t\t\t\t\tSDL_UnlockSurface(drv->s);\n\n\t\t\t\t// Refresh display\n\t\t\t\tSDL_UpdateRect(drv->s, x1, y1, wide, high);\n\t\t\t\t#endif\n\t\t\t}\n\n\t\t} else {\n\t\t\tconst int bytes_per_pixel = VIDEO_MODE_ROW_BYTES / VIDEO_MODE_X;\n\t\t\tconst int dst_bytes_per_row = drv->s->pitch;\n\n\t\t\tx1 = VIDEO_MODE_X;\n\t\t\tfor (j=y1; j<=y2; j++) {\n\t\t\t\tp = &the_buffer[j * bytes_per_row];\n\t\t\t\tp2 = &the_buffer_copy[j * bytes_per_row];\n\t\t\t\tfor (i=0; i<x1*bytes_per_pixel; i++) {\n\t\t\t\t\tif (*p != *p2) {\n\t\t\t\t\t\tx1 = i / bytes_per_pixel;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp++; p2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx2 = x1;\n\t\t\tfor (j=y1; j<=y2; j++) {\n\t\t\t\tp = &the_buffer[j * bytes_per_row];\n\t\t\t\tp2 = &the_buffer_copy[j * bytes_per_row];\n\t\t\t\tp += bytes_per_row;\n\t\t\t\tp2 += bytes_per_row;\n\t\t\t\tfor (i=VIDEO_MODE_X*bytes_per_pixel; i>x2*bytes_per_pixel; i--) {\n\t\t\t\t\tp--;\n\t\t\t\t\tp2--;\n\t\t\t\t\tif (*p != *p2) {\n\t\t\t\t\t\tx2 = i / bytes_per_pixel;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twide = x2 - x1;\n\n\t\t\t// Update copy of the_buffer\n\t\t\tif (high && wide) {\n\n\t\t\t\t// Lock surface, if required\n\t\t\t\tif (SDL_MUSTLOCK(drv->s))\n\t\t\t\t\tSDL_LockSurface(drv->s);\n\n\t\t\t\t// Blit to screen surface\n\t\t\t\tfor (j=y1; j<=y2; j++) {\n\t\t\t\t\ti = j * bytes_per_row + x1 * bytes_per_pixel;\n\t\t\t\t\tint dst_i = j * dst_bytes_per_row + x1 * bytes_per_pixel;\n\t\t\t\t\tmemcpy(the_buffer_copy + i, the_buffer + i, bytes_per_pixel * wide);\n\t\t\t\t\tScreen_blit((uint8 *)drv->s->pixels + dst_i, the_buffer + i, bytes_per_pixel * wide);\n\t\t\t\t}\n\n\t\t\t\t// Unlock surface, if required\n\t\t\t\tif (SDL_MUSTLOCK(drv->s))\n\t\t\t\t\tSDL_UnlockSurface(drv->s);\n\n\t\t\t\t// Refresh display\n\t\t\t\tSDL_UpdateRect(drv->s, x1, y1, wide, high);\n\t\t\t}\n\t\t}\n\t}\n\n\t#ifdef EMSCRIPTEN\n\t// printf(\"macemuCopyFrameBuffer %p\\n\", the_buffer);\n\t// EM_ASM_({\n\t// \tmacemuCopyFrameBuffer($0);\n\t// }, the_buffer);\n\t#endif\n}\n\n// Static display update (fixed frame rate, bounding boxes based)\n// XXX use NQD bounding boxes to help detect dirty areas?\nstatic void update_display_static_bbox(driver_base *drv)\n{\n\n\tassert(Screen_blit);\n\tconst VIDEO_MODE &mode = drv->mode;\n\n\t// Allocate bounding boxes for SDL_UpdateRects()\n\tconst int N_PIXELS = 64;\n\tconst int n_x_boxes = (VIDEO_MODE_X + N_PIXELS - 1) / N_PIXELS;\n\tconst int n_y_boxes = (VIDEO_MODE_Y + N_PIXELS - 1) / N_PIXELS;\n\tSDL_Rect *boxes = (SDL_Rect *)alloca(sizeof(SDL_Rect) * n_x_boxes * n_y_boxes);\n\tint nr_boxes = 0;\n\n#ifdef EMSCRIPTEN\n\t// Update the surface from Mac screen\n\tconst int bytes_per_row = VIDEO_MODE_ROW_BYTES;\n\tconst int bytes_per_pixel = bytes_per_row / VIDEO_MODE_X;\n\tconst int dst_bytes_per_row = drv->s->pitch;\n\tuint32 size_to_copy = VIDEO_MODE_X * bytes_per_pixel * VIDEO_MODE_Y;\n\n\t// int x, y;\n\t// for (y = 0; y < VIDEO_MODE_Y; y += VIDEO_MODE_Y) {\n\t// \tint h = VIDEO_MODE_Y;\n\t// \tif (h > VIDEO_MODE_Y - y)\n\t// \t\th = VIDEO_MODE_Y - y;\n\t// \tfor (x = 0; x < VIDEO_MODE_X; x += VIDEO_MODE_X) {\n\t// \t\tint w = VIDEO_MODE_X;\n\t// \t\tif (w > VIDEO_MODE_X - x)\n\t// \t\t\tw = VIDEO_MODE_X - x;\n\t// \t\tconst int xs = w * bytes_per_pixel;\n\t// \t\tconst int xb = x * bytes_per_pixel;\n\t// \t\tfor (int j = y; j < (y + h); j++) {\n\t// \t\t\tconst int yb = j * bytes_per_row;\n\t// \t\t\tconst int dst_yb = j * dst_bytes_per_row;\n\t// \t\t\tmemcmp(&the_buffer[yb + xb], &the_buffer_copy[yb + xb], xs);\n\t// \t\t\tmemcpy(&the_buffer_copy[yb + xb], &the_buffer[yb + xb], xs);\n\t// \t\t\tScreen_blit((uint8 *)pixels + dst_yb + xb, the_buffer + yb + xb, xs);\n\t// \t\t}\n\t// \t}\n\t// }\n\n\tif (REUSE_VIDEO_BUFFER) {\n\t\t// uint8 *browser_pixels = drv->browser_pixels;\n\n\t\tassert(browser_pixels);\n\t\tScreen_blit((uint8 *)browser_pixels, the_buffer, size_to_copy);\n\t\tEM_ASM_({\n\t  \tModule.blit($0, $1, $2, $3, $4);\n\t\t}, browser_pixels, VIDEO_MODE_X, VIDEO_MODE_Y, 32, !IsDirectMode(mode));\n\t} else {\n\t\tuint8 *pixels = (uint8 *)alloca(sizeof(uint8) * size_to_copy);\n\t\tScreen_blit((uint8 *)pixels, the_buffer, size_to_copy);\n\t\tEM_ASM_({\n\t  \tModule.blit($0, $1, $2, $3, $4);\n\t\t}, pixels, VIDEO_MODE_X, VIDEO_MODE_Y, 32, !IsDirectMode(mode));\n\t}\n#else\n\t// Lock surface, if required\n\tif (SDL_MUSTLOCK(drv->s))\n\t\tSDL_LockSurface(drv->s);\n\n\t// Update the surface from Mac screen\n\tconst int bytes_per_row = VIDEO_MODE_ROW_BYTES;\n\tconst int bytes_per_pixel = bytes_per_row / VIDEO_MODE_X;\n\tconst int dst_bytes_per_row = drv->s->pitch;\n\tint x, y;\n\tfor (y = 0; y < VIDEO_MODE_Y; y += N_PIXELS) {\n\t\tint h = N_PIXELS;\n\t\tif (h > VIDEO_MODE_Y - y)\n\t\t\th = VIDEO_MODE_Y - y;\n\t\tfor (x = 0; x < VIDEO_MODE_X; x += N_PIXELS) {\n\t\t\tint w = N_PIXELS;\n\t\t\tif (w > VIDEO_MODE_X - x)\n\t\t\t\tw = VIDEO_MODE_X - x;\n\t\t\tconst int xs = w * bytes_per_pixel;\n\t\t\tconst int xb = x * bytes_per_pixel;\n\t\t\tbool dirty = false;\n\t\t\tfor (int j = y; j < (y + h); j++) {\n\t\t\t\tconst int yb = j * bytes_per_row;\n\t\t\t\tconst int dst_yb = j * dst_bytes_per_row;\n\t\t\t\tif (memcmp(&the_buffer[yb + xb], &the_buffer_copy[yb + xb], xs) != 0) {\n\t\t\t\t\tmemcpy(&the_buffer_copy[yb + xb], &the_buffer[yb + xb], xs);\n\t\t\t\t\tScreen_blit((uint8 *)drv->s->pixels + dst_yb + xb, the_buffer + yb + xb, xs);\n\t\t\t\t\tdirty = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dirty) {\n\t\t\t\tboxes[nr_boxes].x = x;\n\t\t\t\tboxes[nr_boxes].y = y;\n\t\t\t\tboxes[nr_boxes].w = w;\n\t\t\t\tboxes[nr_boxes].h = h;\n\t\t\t\tnr_boxes++;\n\t\t\t}\n\t\t}\n\t}\n\n\t// testing bad allocations\n\tif (REUSE_VIDEO_BUFFER) {\n\t\tuint32 size_to_copy = VIDEO_MODE_X * bytes_per_pixel * VIDEO_MODE_Y;\n\t\t// uint8 *browser_pixels = drv->browser_pixels;\n\n\t\tassert(browser_pixels);\n\t\tScreen_blit((uint8 *)browser_pixels, the_buffer, size_to_copy);\n\t}\n\n\t// Unlock surface, if required\n\tif (SDL_MUSTLOCK(drv->s))\n\t\tSDL_UnlockSurface(drv->s);\n\n\t// Refresh display\n\tif (nr_boxes)\n\t\tSDL_UpdateRects(drv->s, nr_boxes, boxes);\n#endif\n}\n\n\n// We suggest the compiler to inline the next two functions so that it\n// may specialise the code according to the current screen depth and\n// display type. A clever compiler would do that job by itself though...\n\n// NOTE: update_display_vosf is inlined too\n\nstatic inline void possibly_quit_dga_mode()\n{\n\t// Quit DGA mode if requested (something terrible has happened and we\n\t// want to give control back to the user)\n\tif (quit_full_screen) {\n\t\tquit_full_screen = false;\n\t\tdelete drv;\n\t\tdrv = NULL;\n\t}\n}\n\nstatic inline void possibly_ungrab_mouse()\n{\n\t// Ungrab mouse if requested (something terrible has happened and we\n\t// want to give control back to the user)\n\tif (quit_full_screen) {\n\t\tquit_full_screen = false;\n\t\tif (drv)\n\t\t\tdrv->ungrab_mouse();\n\t}\n}\n\nstatic inline void handle_palette_changes(void)\n{\n\tLOCK_PALETTE;\n\n\tif (sdl_palette_changed) {\n\t\tsdl_palette_changed = false;\n\t\tdrv->update_palette();\n\t}\n\n\tUNLOCK_PALETTE;\n}\n\nstatic void video_refresh_window_static(void);\n\nstatic void video_refresh_dga(void)\n{\n\t// Quit DGA mode if requested\n\tpossibly_quit_dga_mode();\n\tvideo_refresh_window_static();\n}\n\n#ifdef ENABLE_VOSF\n#if REAL_ADDRESSING || DIRECT_ADDRESSING\nstatic void video_refresh_dga_vosf(void)\n{\n\t// Quit DGA mode if requested\n\tpossibly_quit_dga_mode();\n\t\n\t// Update display (VOSF variant)\n\tstatic int tick_counter = 0;\n\tif (++tick_counter >= frame_skip) {\n\t\ttick_counter = 0;\n\t\tif (mainBuffer.dirty) {\n\t\t\tLOCK_VOSF;\n\t\t\tupdate_display_dga_vosf(static_cast<driver_fullscreen *>(drv));\n\t\t\tUNLOCK_VOSF;\n\t\t}\n\t}\n}\n#endif\n\nstatic void video_refresh_window_vosf(void)\n{\n\t// Ungrab mouse if requested\n\tpossibly_ungrab_mouse();\n\t\n\t// Update display (VOSF variant)\n\tstatic int tick_counter = 0;\n\tif (++tick_counter >= frame_skip) {\n\t\ttick_counter = 0;\n\t\tif (mainBuffer.dirty) {\n\t\t\tLOCK_VOSF;\n\t\t\tupdate_display_window_vosf(static_cast<driver_window *>(drv));\n\t\t\tUNLOCK_VOSF;\n\t\t}\n\t}\n}\n#endif // def ENABLE_VOSF\n\nstatic void video_refresh_window_static(void)\n{\n\n\t// Ungrab mouse if requested\n\tpossibly_ungrab_mouse();\n\n\t// Update display (static variant)\n\tstatic int tick_counter = 0;\n\tif (++tick_counter >= frame_skip) {\n\t\ttick_counter = 0;\n\t\tconst VIDEO_MODE &mode = drv->mode;\n\t\tif ((int)VIDEO_MODE_DEPTH >= VIDEO_DEPTH_8BIT)\n\t\t\tupdate_display_static_bbox(drv);\n\t\telse\n\t\t\tupdate_display_static(drv);\n\t}\n}\n\n\n/*\n *  Thread for screen refresh, input handling etc.\n */\n\nstatic void VideoRefreshInit(void)\n{\n\t// TODO: set up specialised 8bpp VideoRefresh handlers ?\n\tif (display_type == DISPLAY_SCREEN) {\n#if ENABLE_VOSF && (REAL_ADDRESSING || DIRECT_ADDRESSING)\n\t\tif (use_vosf)\n\t\t\tvideo_refresh = video_refresh_dga_vosf;\n\t\telse\n#endif\n\t\t\tvideo_refresh = video_refresh_dga;\n\t}\n\telse {\n#ifdef ENABLE_VOSF\n\t\tif (use_vosf)\n\t\t\tvideo_refresh = video_refresh_window_vosf;\n\t\telse\n#endif\n\t\t\tvideo_refresh = video_refresh_window_static;\n\t}\n}\n\nstatic inline void do_video_refresh(void)\n{\n\t#ifdef EMSCRIPTEN\n\tsdl_fake_read_input();\n\t#else\n\t// Handle SDL events\n\thandle_events();\n\t#endif\n\n\t// Update display\n\tvideo_refresh();\n\n\n\t// Set new palette if it was changed\n\thandle_palette_changes();\n}\n\n// This function is called on non-threaded platforms from a timer interrupt\nvoid VideoRefresh(void)\n{\n\t// We need to check redraw_thread_active to inhibit refreshed during\n\t// mode changes on non-threaded platforms\n\tif (!redraw_thread_active)\n\t\treturn;\n\n\t// Process pending events and update display\n\tdo_video_refresh();\n}\n\nconst int VIDEO_REFRESH_HZ = 60;\nconst int VIDEO_REFRESH_DELAY = 1000000 / VIDEO_REFRESH_HZ;\n\n#ifndef USE_CPU_EMUL_SERVICES\nstatic int redraw_func(void *arg)\n{\n\tuint64 start = GetTicks_usec();\n\tint64 ticks = 0;\n\tuint64 next = GetTicks_usec() + VIDEO_REFRESH_DELAY;\n\n\twhile (!redraw_thread_cancel) {\n\n\t\t// Wait\n\t\tnext += VIDEO_REFRESH_DELAY;\n\t\tint64 delay = next - GetTicks_usec();\n\t\tif (delay > 0)\n\t\t\tDelay_usec(delay);\n\t\telse if (delay < -VIDEO_REFRESH_DELAY)\n\t\t\tnext = GetTicks_usec();\n\t\tticks++;\n\n#ifdef SHEEPSHAVER\n\t\t// Pause if requested (during video mode switches)\n\t\tif (thread_stop_req) {\n\t\t\tthread_stop_ack = true;\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\t// Process pending events and update display\n\t\tdo_video_refresh();\n\t}\n\n\tuint64 end = GetTicks_usec();\n\tD(bug(\"%lld refreshes in %lld usec = %f refreshes/sec\\n\", ticks, end - start, ticks * 1000000.0 / (end - start)));\n\treturn 0;\n}\n#endif\n\n\n/*\n *  Record dirty area from NQD\n */\n\n#ifdef SHEEPSHAVER\nvoid video_set_dirty_area(int x, int y, int w, int h)\n{\n#ifdef ENABLE_VOSF\n\tconst VIDEO_MODE &mode = drv->mode;\n\tconst int screen_width = VIDEO_MODE_X;\n\tconst int screen_height = VIDEO_MODE_Y;\n\tconst int bytes_per_row = VIDEO_MODE_ROW_BYTES;\n\n\tif (use_vosf) {\n\t\tvosf_set_dirty_area(x, y, w, h, screen_width, screen_height, bytes_per_row);\n\t\treturn;\n\t}\n#endif\n\n\t// XXX handle dirty bounding boxes for non-VOSF modes\n}\n#endif\n","/*\n *  rpc_unix.cpp - Remote Procedure Calls, Unix specific backend\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *  Contributed by Gwenole Beauchesne\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/*\n *  NOTES:\n *  - this is subject to rewrite but the API is to be kept intact\n *  - this RPC system is very minimal and only suited for 1:1 communication\n *\n *  TODO:\n *  - better failure conditions\n *  - windows rpc\n */\n\n#include \"sysdeps.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n#include <netinet/in.h>\n\n#include \"rpc.h\"\n\n#define DEBUG 0\n#include \"debug.h\"\n\n#define NON_BLOCKING_IO 0\n\n#if defined __linux__\n#define USE_ABSTRACT_NAMESPACES 1\n#endif\n\n\n/* ====================================================================== */\n/* === PThreads Glue                                                  === */\n/* ====================================================================== */\n\n//#define USE_THREADS\n\n#ifndef USE_THREADS\n#define pthread_t void *\n#define pthread_cancel(th)\n#define pthread_join(th, ret)\n#define pthread_testcancel()\n#define pthread_create(th, attr, start, arg) dummy_thread_create()\nstatic inline int dummy_thread_create(void) { errno = ENOSYS; return -1; }\n\n#undef  pthread_mutex_t\n#define pthread_mutex_t volatile int\n#undef  pthread_mutex_lock\n#define pthread_mutex_lock(m) -1\n#undef  pthread_mutex_unlock\n#define pthread_mutex_unlock(m) -1\n#undef  PTHREAD_MUTEX_INITIALIZER\n#define PTHREAD_MUTEX_INITIALIZER 0\n#endif\n\n\n/* ====================================================================== */\n/* === RPC Connection Handling                                        === */\n/* ====================================================================== */\n\n// Connection type\nenum {\n  RPC_CONNECTION_SERVER,\n  RPC_CONNECTION_CLIENT,\n};\n\n// Connection status\nenum {\n  RPC_STATUS_IDLE,\n  RPC_STATUS_BUSY,\n};\n\n// Client / Server connection\nstruct rpc_connection_t {\n  int type;\n  int status;\n  int socket;\n  char *socket_path;\n  int server_socket;\n  int server_thread_active;\n  pthread_t server_thread;\n  rpc_method_descriptor_t *callbacks;\n  int n_callbacks;\n  int send_offset;\n  char send_buffer[BUFSIZ];\n};\n\n#define return_error(ERROR) do { error = (ERROR); goto do_return; } while (0)\n\n// Set connection status (XXX protect connection with a lock?)\nstatic inline void rpc_connection_set_status(rpc_connection_t *connection, int status)\n{\n  connection->status = status;\n}\n\n// Returns TRUE if the connection is busy (e.g. waiting for a reply)\nint rpc_connection_busy(rpc_connection_t *connection)\n{\n  return connection && connection->status == RPC_STATUS_BUSY;\n}\n\n// Prepare socket path for addr.sun_path[]\nstatic int _rpc_socket_path(char **pathp, const char *ident)\n{\n  int i, len;\n  len = strlen(ident);\n\n  if (pathp == NULL)\n\treturn 0;\n\n  char *path;\n#if USE_ABSTRACT_NAMESPACES\n  const int len_bias = 1;\n  if ((path = (char *)malloc(len + len_bias + 1)) == NULL)\n\treturn 0;\n  path[0] = 0;\n  strcpy(&path[len_bias], ident);\n#else\n  const int len_bias = 5;\n  if ((path = (char *)malloc(len + len_bias + 1)) == NULL)\n\treturn 0;\n  strcpy(path, \"/tmp/\");\n  for (i = 0; i < len; i++) {\n    char ch = ident[i];\n    if (ch == '/')\n      ch = '_';\n    path[len_bias + i] = ch;\n  }\n#endif\n  len += len_bias;\n  path[len] = '\\0';\n  if (*pathp)\n\tfree(*pathp);\n  *pathp = path;\n  return len;\n}\n\n// Initialize server-side RPC system\nrpc_connection_t *rpc_init_server(const char *ident)\n{\n  D(bug(\"rpc_init_server ident='%s'\\n\", ident));\n\n  rpc_connection_t *connection;\n  struct sockaddr_un addr;\n  socklen_t addr_len;\n\n  if (ident == NULL)\n\treturn NULL;\n\n  connection = (rpc_connection_t *)malloc(sizeof(*connection));\n  if (connection == NULL)\n\treturn NULL;\n  connection->type = RPC_CONNECTION_SERVER;\n  connection->status = RPC_STATUS_IDLE;\n  connection->socket = -1;\n  connection->server_thread_active = 0;\n  connection->callbacks = NULL;\n  connection->n_callbacks = 0;\n\n  if ((connection->server_socket = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {\n\tperror(\"server socket\");\n\tfree(connection);\n\treturn NULL;\n  }\n\n  memset(&addr, 0, sizeof(addr));\n  addr.sun_family = AF_UNIX;\n  connection->socket_path = NULL;\n  addr_len = _rpc_socket_path(&connection->socket_path, ident);\n  memcpy(&addr.sun_path[0], connection->socket_path, addr_len);\n  addr_len += sizeof(struct sockaddr_un) - sizeof(addr.sun_path);\n\n  if (bind(connection->server_socket, (struct sockaddr *)&addr, addr_len) < 0) {\n\tperror(\"server bind\");\n\tclose(connection->socket);\n\tfree(connection);\n\treturn NULL;\n  }\n\n  if (listen(connection->server_socket, 1) < 0) {\n\tperror(\"server listen\");\n\tclose(connection->socket);\n\tfree(connection);\n\treturn NULL;\n  }\n\n  return connection;\n}\n\n// Initialize client-side RPC system\nrpc_connection_t *rpc_init_client(const char *ident)\n{\n  D(bug(\"rpc_init_client ident='%s'\\n\", ident));\n\n  rpc_connection_t *connection;\n  struct sockaddr_un addr;\n  socklen_t addr_len;\n\n  if (ident == NULL)\n\treturn NULL;\n\n  connection = (rpc_connection_t *)malloc(sizeof(*connection));\n  if (connection == NULL)\n\treturn NULL;\n  connection->type = RPC_CONNECTION_CLIENT;\n  connection->status = RPC_STATUS_IDLE;\n  connection->server_socket = -1;\n  connection->callbacks = NULL;\n  connection->n_callbacks = 0;\n\n  if ((connection->socket = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {\n\tperror(\"client socket\");\n\tfree(connection);\n\treturn NULL;\n  }\n\n  memset(&addr, 0, sizeof(addr));\n  addr.sun_family = AF_UNIX;\n  connection->socket_path = NULL;\n  addr_len = _rpc_socket_path(&connection->socket_path, ident);\n  memcpy(&addr.sun_path[0], connection->socket_path, addr_len);\n  addr_len += sizeof(struct sockaddr_un) - sizeof(addr.sun_path);\n\n  // Wait at most 5 seconds for server to initialize\n  const int N_CONNECT_WAIT_DELAY = 10;\n  int n_connect_attempts = 5000 / N_CONNECT_WAIT_DELAY;\n  if (n_connect_attempts == 0)\n\tn_connect_attempts = 1;\n  while (n_connect_attempts > 0) {\n\tif (connect(connection->socket, (struct sockaddr *)&addr, addr_len) == 0)\n\t  break;\n\tif (n_connect_attempts > 1 && errno != ECONNREFUSED && errno != ENOENT) {\n\t  perror(\"client_connect\");\n\t  close(connection->socket);\n\t  free(connection);\n\t  return NULL;\n\t}\n\tn_connect_attempts--;\n\tusleep(N_CONNECT_WAIT_DELAY);\n  }\n  if (n_connect_attempts == 0) {\n\tclose(connection->socket);\n\tfree(connection);\n\treturn NULL;\n  }\n\n  return connection;\n}\n\n// Close RPC connection\nint rpc_exit(rpc_connection_t *connection)\n{\n  D(bug(\"rpc_exit\\n\"));\n\n  if (connection == NULL)\n\treturn RPC_ERROR_CONNECTION_NULL;\n\n  if (connection->socket_path) {\n\tif (connection->socket_path[0])\n\t  unlink(connection->socket_path);\n\tfree(connection->socket_path);\n  }\n\n  if (connection->type == RPC_CONNECTION_SERVER) {\n\tif (connection->server_thread_active) {\n\t  pthread_cancel(connection->server_thread);\n\t  pthread_join(connection->server_thread, NULL);\n\t}\n\tif (connection->socket != -1)\n\t  close(connection->socket);\n\tif (connection->server_socket != -1)\n\t  close(connection->server_socket);\n  }\n  else {\n\tif (connection->socket != -1)\n\t  close(connection->socket);\n  }\n\n  if (connection->callbacks)\n\tfree(connection->callbacks);\n  free(connection);\n\n  return RPC_ERROR_NO_ERROR;\n}\n\n// Wait for a message to arrive on the connection port\nstatic inline int _rpc_wait_dispatch(rpc_connection_t *connection, int timeout)\n{\n\tstruct timeval tv;\n\ttv.tv_sec  = timeout / 1000000;\n\ttv.tv_usec = timeout % 1000000;\n\n\tfd_set rfds;\n\tFD_ZERO(&rfds);\n\tFD_SET(connection->socket, &rfds);\n\treturn select(connection->socket + 1, &rfds, NULL, NULL, &tv);\n}\n\nint rpc_wait_dispatch(rpc_connection_t *connection, int timeout)\n{\n\tif (connection == NULL)\n\t\treturn RPC_ERROR_CONNECTION_NULL;\n\tif (connection->type != RPC_CONNECTION_SERVER)\n\t\treturn RPC_ERROR_CONNECTION_TYPE_MISMATCH;\n\n\treturn _rpc_wait_dispatch(connection, timeout);\n}\n\n// Process incoming messages in the background\nstatic void *rpc_server_func(void *arg)\n{\n  rpc_connection_t *connection = (rpc_connection_t *)arg;\n\n  int ret = rpc_listen_socket(connection);\n  if (ret < 0)\n\treturn NULL;\n\n  connection->server_thread_active = 1;\n  for (;;) {\n\t// XXX broken MacOS X doesn't implement cancellation points correctly\n\tpthread_testcancel();\n\n\t// wait for data to arrive\n\tint ret = _rpc_wait_dispatch(connection, 50000);\n\tif (ret == 0)\n\t  continue;\n\tif (ret < 0)\n\t  break;\n\n\trpc_dispatch(connection);\n  }\n  connection->server_thread_active = 0;\n  return NULL;\n}\n\n// Return listen socket of RPC connection\nint rpc_listen_socket(rpc_connection_t *connection)\n{\n  D(bug(\"rpc_listen_socket\\n\"));\n\n  if (connection == NULL)\n\treturn RPC_ERROR_CONNECTION_NULL;\n  if (connection->type != RPC_CONNECTION_SERVER)\n\treturn RPC_ERROR_CONNECTION_TYPE_MISMATCH;\n\n  struct sockaddr_un addr;\n  socklen_t addr_len = sizeof(addr);\n  if ((connection->socket = accept(connection->server_socket, (struct sockaddr *)&addr, &addr_len)) < 0) {\n\tperror(\"server accept\");\n\treturn RPC_ERROR_ERRNO_SET;\n  }\n\n#if NON_BLOCKING_IO\n  int val = fcntl(connection->socket, F_GETFL, 0);\n  if (val < 0) {\n\tperror(\"server fcntl F_GETFL\");\n\treturn RPC_ERROR_ERRNO_SET;\n  }\n  if (fcntl(connection->socket, F_SETFL, val | O_NONBLOCK) < 0) {\n\tperror(\"server fcntl F_SETFL\");\n\treturn RPC_ERROR_ERRNO_SET;\n  }\n#endif\n\n  return connection->socket;\n}\n\n// Listen for incoming messages on RPC connection\n#ifdef USE_THREADS\nint rpc_listen(rpc_connection_t *connection)\n{\n  D(bug(\"rpc_listen\\n\"));\n\n  if (pthread_create(&connection->server_thread, NULL, rpc_server_func, connection) != 0) {\n\tperror(\"server thread\");\n\treturn RPC_ERROR_ERRNO_SET;\n  }\n\n  return RPC_ERROR_NO_ERROR;\n}\n#endif\n\n\n/* ====================================================================== */\n/* === Message Passing                                                === */\n/* ====================================================================== */\n\n// Message markers\nenum {\n  RPC_MESSAGE_START\t\t= -3000,\n  RPC_MESSAGE_END\t\t= -3001,\n  RPC_MESSAGE_ACK\t\t= -3002,\n  RPC_MESSAGE_REPLY\t\t= -3003,\n  RPC_MESSAGE_FAILURE\t= -3004,\n};\n\n// Message type\nstruct rpc_message_t {\n  int socket;\n  int offset;\n  unsigned char buffer[BUFSIZ];\n};\n\n// User-defined marshalers\nstatic struct {\n  rpc_message_descriptor_t *descs;\n  int last;\n  int count;\n} g_message_descriptors = { NULL, 0, 0 };\nstatic pthread_mutex_t g_message_descriptors_lock = PTHREAD_MUTEX_INITIALIZER;\n\n// Add a user-defined marshaler\nstatic int rpc_message_add_callback(const rpc_message_descriptor_t *desc)\n{\n  D(bug(\"rpc_message_add_callback\\n\"));\n\n  const int N_ENTRIES_ALLOC = 8;\n  int error = RPC_ERROR_NO_ERROR;\n\n  pthread_mutex_lock(&g_message_descriptors_lock);\n  if (g_message_descriptors.descs == NULL) {\n\tg_message_descriptors.count = N_ENTRIES_ALLOC;\n\tif ((g_message_descriptors.descs = (rpc_message_descriptor_t *)malloc(g_message_descriptors.count * sizeof(g_message_descriptors.descs[0]))) == NULL) {\n\t  pthread_mutex_unlock(&g_message_descriptors_lock);\n\t  return RPC_ERROR_NO_MEMORY;\n\t}\n\tg_message_descriptors.last = 0;\n  }\n  else if (g_message_descriptors.last >= g_message_descriptors.count) {\n\tg_message_descriptors.count += N_ENTRIES_ALLOC;\n\tif ((g_message_descriptors.descs = (rpc_message_descriptor_t *)realloc(g_message_descriptors.descs, g_message_descriptors.count * sizeof(g_message_descriptors.descs[0]))) == NULL) {\n\t  pthread_mutex_unlock(&g_message_descriptors_lock);\n\t  return RPC_ERROR_NO_MEMORY;\n\t}\n  }\n\n  // XXX only one callback per ID\n  int i;\n  for (i = 0; i < g_message_descriptors.last; i++) {\n\tif (g_message_descriptors.descs[i].id == desc->id) {\n\t  pthread_mutex_unlock(&g_message_descriptors_lock);\n\t  return RPC_ERROR_NO_ERROR;\n\t}\n  }\n\n  g_message_descriptors.descs[g_message_descriptors.last++] = *desc;\n  pthread_mutex_unlock(&g_message_descriptors_lock);\n  return error;\n}\n\n// Add user-defined marshalers\nint rpc_message_add_callbacks(const rpc_message_descriptor_t *descs, int n_descs)\n{\n  D(bug(\"rpc_message_add_callbacks\\n\"));\n\n  int i, error;\n  for (i = 0; i < n_descs; i++) {\n\tif ((error = rpc_message_add_callback(&descs[i])) < 0)\n\t  return error;\n  }\n\n  return RPC_ERROR_NO_ERROR;\n}\n\n// Find user-defined marshaler\nstatic rpc_message_descriptor_t *rpc_message_find_descriptor(int id)\n{\n  D(bug(\"rpc_message_find_descriptor\\n\"));\n\n  if (g_message_descriptors.descs) {\n\tint i;\n\tfor (i = 0; i < g_message_descriptors.count; i++) {\n\t  if (g_message_descriptors.descs[i].id == id)\n\t\treturn &g_message_descriptors.descs[i];\n\t}\n  }\n\n  return NULL;\n}\n\n// Initialize message\nstatic inline void rpc_message_init(rpc_message_t *message, rpc_connection_t *connection)\n{\n  message->socket = connection->socket;\n  message->offset = 0;\n}\n\n// Send BYTES\nstatic inline int _rpc_message_send_bytes(rpc_message_t *message, unsigned char *bytes, int count)\n{\n  if (send(message->socket, bytes, count, 0) != count)\n\treturn RPC_ERROR_ERRNO_SET;\n  return RPC_ERROR_NO_ERROR;\n}\n\n// Send message on wire\nstatic inline int rpc_message_flush(rpc_message_t *message)\n{\n  int error = _rpc_message_send_bytes(message, message->buffer, message->offset);\n  message->offset = 0;\n  return error;\n}\n\n// Send BYTES (public interface, may need to flush internal buffer)\nint rpc_message_send_bytes(rpc_message_t *message, unsigned char *bytes, int count)\n{\n  if (message->offset > 0) {\n\tint error = rpc_message_flush(message);\n\tif (error != RPC_ERROR_NO_ERROR)\n\t  return error;\n  }\n  return _rpc_message_send_bytes(message, bytes, count);\n}\n\n// Send BYTES (buffered)\nstatic inline void _rpc_message_send_bytes_buffered(rpc_message_t *message, unsigned char *bytes, int count)\n{\n  memcpy(&message->buffer[message->offset], bytes, count);\n  message->offset += count;\n}\n\n// Send CHAR\nint rpc_message_send_char(rpc_message_t *message, char c)\n{\n  D(bug(\"  send CHAR '%c'\\n\", c));\n\n  unsigned char e_value = c;\n  if (message->offset + sizeof(e_value) >= sizeof(message->buffer)) {\n\tint error = rpc_message_flush(message);\n\tif (error != RPC_ERROR_NO_ERROR)\n\t  return error;\n  }\n  _rpc_message_send_bytes_buffered(message, (unsigned char *)&e_value, sizeof(e_value));\n  return RPC_ERROR_NO_ERROR;\n}\n\n// Send INT32\nint rpc_message_send_int32(rpc_message_t *message, int32_t value)\n{\n  D(bug(\"  send INT32 %d\\n\", value));\n\n  int32_t e_value = htonl(value);\n  if (message->offset + sizeof(e_value) >= sizeof(message->buffer)) {\n\tint error = rpc_message_flush(message);\n\tif (error != RPC_ERROR_NO_ERROR)\n\t  return error;\n  }\n  _rpc_message_send_bytes_buffered(message, (unsigned char *)&e_value, sizeof(e_value));\n  return RPC_ERROR_NO_ERROR;\n}\n\n// Send UINT32\nint rpc_message_send_uint32(rpc_message_t *message, uint32_t value)\n{\n  D(bug(\"  send UINT32 %u\\n\", value));\n\n  uint32_t e_value = htonl(value);\n  if (message->offset + sizeof(e_value) >= sizeof(message->buffer)) {\n\tint error = rpc_message_flush(message);\n\tif (error != RPC_ERROR_NO_ERROR)\n\t  return error;\n  }\n  _rpc_message_send_bytes_buffered(message, (unsigned char *)&e_value, sizeof(e_value));\n  return RPC_ERROR_NO_ERROR;\n}\n\n// Send STRING\nint rpc_message_send_string(rpc_message_t *message, const char *str)\n{\n  D(bug(\"  send STRING \\\"%s\\\"\\n\", str));\n\n  int error, length = str ? strlen(str) : 0;\n  uint32_t e_value = htonl(length);\n  if (message->offset + sizeof(e_value) >= sizeof(message->buffer)) {\n\terror = rpc_message_flush(message);\n\tif (error != RPC_ERROR_NO_ERROR)\n\t  return error;\n  }\n  _rpc_message_send_bytes_buffered(message, (unsigned char *)&e_value, sizeof(e_value));\n  error = rpc_message_flush(message);\n  if (error != RPC_ERROR_NO_ERROR)\n\treturn error;\n  D(bug(\"str=%p\\n\", str));\n  return _rpc_message_send_bytes(message, (unsigned char *)str, length);\n}\n\n// Send message arguments\nstatic int rpc_message_send_args(rpc_message_t *message, va_list args)\n{\n  int type;\n  rpc_message_descriptor_t *desc;\n  while ((type = va_arg(args, int)) != RPC_TYPE_INVALID) {\n\tint error = rpc_message_send_int32(message, type);\n\tif (error != RPC_ERROR_NO_ERROR)\n\t  return error;\n\tswitch (type) {\n\tcase RPC_TYPE_CHAR:\n\t  error = rpc_message_send_char(message, (char )va_arg(args, int));\n\t  break;\n\tcase RPC_TYPE_BOOLEAN:\n\tcase RPC_TYPE_INT32:\n\t  error = rpc_message_send_int32(message, va_arg(args, int));\n\t  break;\n\tcase RPC_TYPE_UINT32:\n\t  error = rpc_message_send_uint32(message, va_arg(args, unsigned int));\n\t  break;\n\tcase RPC_TYPE_STRING:\n\t  error = rpc_message_send_string(message, va_arg(args, char *));\n\t  break;\n\tcase RPC_TYPE_ARRAY: {\n\t  int i;\n\t  int array_type = va_arg(args, int32_t);\n\t  int array_size = va_arg(args, uint32_t);\n\t  if ((error = rpc_message_send_int32(message, array_type)) < 0)\n\t\treturn error;\n\t  if ((error = rpc_message_send_uint32(message, array_size)) < 0)\n\t\treturn error;\n\t  switch (array_type) {\n\t  case RPC_TYPE_CHAR: {\n\t\tunsigned char *array = va_arg(args, unsigned char *);\n\t\terror = rpc_message_flush(message);\n\t\tif (error != RPC_ERROR_NO_ERROR)\n\t\t  return error;\n\t\terror = _rpc_message_send_bytes(message, array, array_size);\n\t\tbreak;\n\t  }\n\t  case RPC_TYPE_BOOLEAN:\n\t  case RPC_TYPE_INT32: {\n\t\tint32_t *array = va_arg(args, int32_t *);\n\t\tfor (i = 0; i < array_size; i++) {\n\t\t  if ((error = rpc_message_send_int32(message, array[i])) < 0)\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t  }\n\t  case RPC_TYPE_UINT32: {\n\t\tuint32_t *array = va_arg(args, uint32_t *);\n\t\tfor (i = 0; i < array_size; i++) {\n\t\t  if ((error = rpc_message_send_uint32(message, array[i])) < 0)\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t  }\n\t  case RPC_TYPE_STRING: {\n\t\tchar **array = va_arg(args, char **);\n\t\tfor (i = 0; i < array_size; i++) {\n\t\t  if ((error = rpc_message_send_string(message, array[i])) < 0)\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t  }\n\t  default:\n\t\tif ((desc = rpc_message_find_descriptor(array_type)) != NULL) {\n\t\t  uint8_t *array = va_arg(args, uint8_t *);\n\t\t  for (i = 0; i < array_size; i++) {\n\t\t\tif ((error = desc->send_callback(message, &array[i * desc->size])) < 0)\n\t\t\t  break;\n\t\t  }\n\t\t}\n\t\telse {\n\t\t  fprintf(stderr, \"unknown array arg type %d to send\\n\", type);\n\t\t  error = RPC_ERROR_MESSAGE_ARGUMENT_UNKNOWN;\n\t\t}\n\t\tbreak;\n\t  }\n\t  break;\n\t}\n\tdefault:\n\t  if ((desc = rpc_message_find_descriptor(type)) != NULL)\n\t\terror = desc->send_callback(message, va_arg(args, uint8_t *));\n\t  else {\n\t\tfprintf(stderr, \"unknown arg type %d to send\\n\", type);\n\t\terror = RPC_ERROR_MESSAGE_ARGUMENT_UNKNOWN;\n\t  }\n\t  break;\n\t}\n\tif (error != RPC_ERROR_NO_ERROR)\n\t  return error;\n  }\n  return RPC_ERROR_NO_ERROR;\n}\n\n// Receive raw BYTES\nstatic inline int _rpc_message_recv_bytes(rpc_message_t *message, unsigned char *bytes, int count)\n{\n  do {\n\tint n = recv(message->socket, bytes, count, 0);\n\tif (n > 0) {\n\t  count -= n;\n\t  bytes += n;\n\t}\n\telse if (n == -1 && errno == EINTR)\n\t  continue;\n\telse {\n#if NON_BLOCKING_IO\n\t  if (errno == EAGAIN || errno == EWOULDBLOCK) {\n\t\t// wait for data to arrive\n\t\tfd_set rfds;\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(message->socket, &rfds);\n\t\tint ret = select(message->socket + 1, &rfds, NULL, NULL, NULL);\n\t\tif (ret > 0)\n\t\t  continue;\n\t  }\n#endif\n\t  return RPC_ERROR_ERRNO_SET;\n\t}\n  } while (count > 0);\n  return RPC_ERROR_NO_ERROR;\n}\n\nint rpc_message_recv_bytes(rpc_message_t *message, unsigned char *bytes, int count)\n{\n  return _rpc_message_recv_bytes(message, bytes, count);\n}\n\n// Receive CHAR\nint rpc_message_recv_char(rpc_message_t *message, char *ret)\n{\n  char r_value;\n  int error;\n  if ((error = _rpc_message_recv_bytes(message, (unsigned char *)&r_value, sizeof(r_value))) < 0)\n\treturn error;\n  *ret = r_value;\n  D(bug(\"  recv CHAR '%c'\\n\", *ret));\n  return RPC_ERROR_NO_ERROR;\n}\n\n// Receive INT32\nint rpc_message_recv_int32(rpc_message_t *message, int32_t *ret)\n{\n  int32_t r_value;\n  int error;\n  if ((error = _rpc_message_recv_bytes(message, (unsigned char *)&r_value, sizeof(r_value))) < 0)\n\treturn error;\n  *ret = ntohl(r_value);\n  D(bug(\"  recv INT32 %d\\n\", *ret));\n  return RPC_ERROR_NO_ERROR;\n}\n\n// Receive UINT32\nint rpc_message_recv_uint32(rpc_message_t *message, uint32_t *ret)\n{\n  uint32_t r_value;\n  int error;\n  if ((error = _rpc_message_recv_bytes(message, (unsigned char *)&r_value, sizeof(r_value))) < 0)\n\treturn error;\n  *ret = ntohl(r_value);\n  D(bug(\"  recv UINT32 %u\\n\", *ret));\n  return RPC_ERROR_NO_ERROR;\n}\n\n// Receive STRING\nint rpc_message_recv_string(rpc_message_t *message, char **ret)\n{\n  char *str;\n  int length;\n  uint32_t r_value;\n  int error;\n  if ((error = _rpc_message_recv_bytes(message, (unsigned char *)&r_value, sizeof(r_value))) < 0)\n\treturn error;\n  length = ntohl(r_value);\n  if (length == 0) {\n\tstr = NULL;\n  } else {\n\tif ((str = (char *)malloc(length + 1)) == NULL)\n\t  return RPC_ERROR_NO_MEMORY;\n\tif ((error = _rpc_message_recv_bytes(message, (unsigned char *)str, length)) < 0) {\n\t  free(str);\n\t  return error;\n\t}\n\tstr[length] = '\\0';\n  }\n  *ret = str;\n  D(bug(\"  recv STRING \\\"%s\\\"\\n\", *ret));\n  return RPC_ERROR_NO_ERROR;\n}\n\n// Receive message arguments\nstatic int rpc_message_recv_args(rpc_message_t *message, va_list args)\n{\n  int expected_type, error;\n  rpc_message_descriptor_t *desc;\n\n  while ((expected_type = va_arg(args, int)) != RPC_TYPE_INVALID) {\n\tvoid *p_value = va_arg(args, void *);\n\tint32_t type;\n\tif ((error = rpc_message_recv_int32(message, &type)) < 0)\n\t  return error;\n\tif (type != expected_type)\n\t  return RPC_ERROR_MESSAGE_ARGUMENT_MISMATCH;\n\tswitch (type) {\n\tcase RPC_TYPE_CHAR:\n\t  error = rpc_message_recv_char(message, (char *)p_value);\n\t  break;\n\tcase RPC_TYPE_BOOLEAN:\n\tcase RPC_TYPE_INT32:\n\t  error = rpc_message_recv_int32(message, (int32_t *)p_value);\n\t  break;\n\tcase RPC_TYPE_UINT32:\n\t  error = rpc_message_recv_uint32(message, (uint32_t *)p_value);\n\t  break;\n\tcase RPC_TYPE_STRING:\n\t  error = rpc_message_recv_string(message, (char **)p_value);\n\t  break;\n\tcase RPC_TYPE_ARRAY: {\n\t  int i;\n\t  int32_t array_type;\n\t  uint32_t array_size;\n\t  if ((error = rpc_message_recv_int32(message, &array_type)) < 0)\n\t\treturn error;\n\t  if ((error = rpc_message_recv_uint32(message, &array_size)) < 0)\n\t\treturn error;\n\t  p_value = va_arg(args, void *);\n\t  *((uint32_t *)p_value) = array_size;\n\t  p_value = va_arg(args, void *);\n\t  switch (array_type) {\n\t  case RPC_TYPE_CHAR: {\n\t\tunsigned char *array;\n\t\tif ((array = (unsigned char *)malloc(array_size * sizeof(*array))) == NULL)\n\t\t  return RPC_ERROR_NO_MEMORY;\n\t\terror = _rpc_message_recv_bytes(message, array, array_size);\n\t\tif (error != RPC_ERROR_NO_ERROR) {\n\t\t  free(array);\n\t\t  return error;\n\t\t}\n\t\t*((void **)p_value) = (void *)array;\n\t\tbreak;\n\t  }\n\t  case RPC_TYPE_BOOLEAN:\n\t  case RPC_TYPE_INT32: {\n\t\tint *array;\n\t\tif ((array = (int *)malloc(array_size * sizeof(*array))) == NULL)\n\t\t  return RPC_ERROR_NO_MEMORY;\n\t\tfor (i = 0; i < array_size; i++) {\n\t\t  int32_t value;\n\t\t  if ((error = rpc_message_recv_int32(message, &value)) < 0) {\n\t\t    free(array);\n\t\t\treturn error;\n\t\t  }\n\t\t  array[i] = value;\n\t\t}\n\t\t*((void **)p_value) = (void *)array;\n\t\tbreak;\n\t  }\n\t  case RPC_TYPE_UINT32: {\n\t\tunsigned int *array;\n\t\tif ((array = (unsigned int *)malloc(array_size * sizeof(*array))) == NULL)\n\t\t  return RPC_ERROR_NO_MEMORY;\n\t\tfor (i = 0; i < array_size; i++) {\n\t\t  uint32_t value;\n\t\t  if ((error = rpc_message_recv_uint32(message, &value)) < 0) {\n\t\t    free(array);\n\t\t\treturn error;\n\t\t  }\n\t\t  array[i] = value;\n\t\t}\n\t\t*((void **)p_value) = (void *)array;\n\t\tbreak;\n\t  }\n\t  case RPC_TYPE_STRING: {\n\t\tchar **array;\n\t\tif ((array = (char **)malloc(array_size * sizeof(*array))) == NULL)\n\t\t  return RPC_ERROR_NO_MEMORY;\n\t\tfor (i = 0; i < array_size; i++) {\n\t\t  char *str;\n\t\t  if ((error = rpc_message_recv_string(message, &str)) < 0) {\n\t\t    free(array);\n\t\t\treturn error;\n\t\t  }\n\t\t  array[i] = str;\n\t\t}\n\t\t*((void **)p_value) = (void *)array;\n\t\tbreak;\n\t  }\n\t  default:\n\t\tif ((desc = rpc_message_find_descriptor(array_type)) != NULL) {\n\t\t  char *array;\n\t\t  if ((array = (char *)malloc(array_size * desc->size)) == NULL)\n\t\t\treturn RPC_ERROR_NO_MEMORY;\n\t\t  for (i = 0; i < array_size; i++) {\n\t\t\tif ((error = desc->recv_callback(message, &array[i * desc->size])) < 0) {\n\t\t\t  free(array);\n\t\t\t  return error;\n\t\t\t}\n\t\t  }\n\t\t  *((void **)p_value) = array;\n\t\t}\n\t\telse {\n\t\t  fprintf(stderr, \"unknown array arg type %d to receive\\n\", type);\n\t\t  error = RPC_ERROR_MESSAGE_ARGUMENT_UNKNOWN;\n\t\t}\n\t\tbreak;\n\t  }\n\t  break;\n\t}\n\tdefault:\n\t  if ((desc = rpc_message_find_descriptor(type)) != NULL)\n\t\terror = desc->recv_callback(message, p_value);\n\t  else {\n\t\tfprintf(stderr, \"unknown arg type %d to send\\n\", type);\n\t\terror = RPC_ERROR_MESSAGE_ARGUMENT_UNKNOWN;\n\t  }\n\t  break;\n\t}\n\tif (error != RPC_ERROR_NO_ERROR)\n\t  return error;\n  }\n  return RPC_ERROR_NO_ERROR;\n}\n\n// Skip message argument\nstatic int rpc_message_skip_arg(rpc_message_t *message, int type)\n{\n  unsigned char dummy[BUFSIZ];\n  int error = RPC_ERROR_GENERIC;\n  switch (type) {\n  case RPC_TYPE_CHAR:\n\terror = _rpc_message_recv_bytes(message, dummy, 1);\n\tbreak;\n  case RPC_TYPE_BOOLEAN:\n  case RPC_TYPE_INT32:\n  case RPC_TYPE_UINT32:\n\terror = _rpc_message_recv_bytes(message, dummy, 4);\n\tbreak;\n  case RPC_TYPE_STRING: {\n\tint32_t length;\n\tif ((error = rpc_message_recv_int32(message, &length)) < 0)\n\t  return error;\n\twhile (length >= sizeof(dummy)) {\n\t  if ((error = _rpc_message_recv_bytes(message, dummy, sizeof(dummy))) < 0)\n\t\treturn error;\n\t  length -= sizeof(dummy);\n\t}\n\tif (length > 0) {\n\t  if ((error = _rpc_message_recv_bytes(message, dummy, length)) < 0)\n\t\treturn error;\n\t}\n\tbreak;\n  }\n  default:\n\tfprintf(stderr, \"unknown arg type %d to receive\\n\", type);\n\tbreak;\n  }\n  return error;\n}\n\n// Dispatch message received in the server loop\nint rpc_dispatch(rpc_connection_t *connection)\n{\n  rpc_message_t message;\n  rpc_message_init(&message, connection);\n\n  int32_t method, value, ret = RPC_MESSAGE_FAILURE;\n  if (rpc_message_recv_int32(&message, &value) != RPC_ERROR_NO_ERROR ||\n\t  value != RPC_MESSAGE_START)\n\treturn ret;\n\n  D(bug(\"receiving message\\n\"));\n  if (rpc_message_recv_int32(&message, &method) == RPC_ERROR_NO_ERROR &&\n\t  connection->callbacks != NULL) {\n\tint i;\n\tfor (i = 0; i < connection->n_callbacks; i++) {\n\t  if (connection->callbacks[i].id == method) {\n\t\tif (connection->callbacks[i].callback &&\n\t\t\tconnection->callbacks[i].callback(connection) == RPC_ERROR_NO_ERROR) {\n\t\t  if (rpc_message_recv_int32(&message, &value) == RPC_ERROR_NO_ERROR && value == RPC_MESSAGE_END)\n\t\t\tret = RPC_MESSAGE_ACK;\n\t\t  else {\n\t\t\tfprintf(stderr, \"corrupted message handler %d\\n\", method);\n\t\t\tfor (;;) {\n\t\t\t  if (rpc_message_skip_arg(&message, value) != RPC_ERROR_NO_ERROR)\n\t\t\t\tbreak;\n\t\t\t  if (rpc_message_recv_int32(&message, &value) != RPC_ERROR_NO_ERROR)\n\t\t\t\tbreak;\n\t\t\t  if (value == RPC_MESSAGE_END)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t  }\n\t\t  break;\n\t\t}\n\t  }\n\t}\n  }\n  rpc_message_send_int32(&message, ret);\n  rpc_message_flush(&message);\n  D(bug(\"  -- message received\\n\"));\n  return ret == RPC_MESSAGE_ACK ? method : ret;\n}\n\n\n/* ====================================================================== */\n/* === Method Callbacks Handling                                      === */\n/* ====================================================================== */\n\n// Add a user-defined method callback (server side)\nstatic int rpc_method_add_callback(rpc_connection_t *connection, const rpc_method_descriptor_t *desc)\n{\n  const int N_ENTRIES_ALLOC = 8;\n  int i;\n\n  // pre-allocate up to N_ENTRIES_ALLOC entries\n  if (connection->callbacks == NULL) {\n\tif ((connection->callbacks = (rpc_method_descriptor_t *)calloc(N_ENTRIES_ALLOC, sizeof(connection->callbacks[0]))) == NULL)\n\t  return RPC_ERROR_NO_MEMORY;\n\tconnection->n_callbacks = N_ENTRIES_ALLOC;\n  }\n\n  // look for a free slot\n  for (i = connection->n_callbacks - 1; i >= 0; i--) {\n\tif (connection->callbacks[i].callback == NULL)\n\t  break;\n  }\n\n  // none found, reallocate\n  if (i < 0) {\n\tif ((connection->callbacks = (rpc_method_descriptor_t *)realloc(connection->callbacks, (connection->n_callbacks + N_ENTRIES_ALLOC) * sizeof(connection->callbacks[0]))) == NULL)\n\t  return RPC_ERROR_NO_MEMORY;\n\ti = connection->n_callbacks;\n\tmemset(&connection->callbacks[i], 0, N_ENTRIES_ALLOC * sizeof(connection->callbacks[0]));\n\tconnection->n_callbacks += N_ENTRIES_ALLOC;\n  }\n\n  D(bug(\"rpc_method_add_callback for method %d in slot %d\\n\", desc->id, i));\n  connection->callbacks[i] = *desc;\n  return RPC_ERROR_NO_ERROR;\n}\n\n// Add user-defined method callbacks (server side)\nint rpc_method_add_callbacks(rpc_connection_t *connection, const rpc_method_descriptor_t *descs, int n_descs)\n{\n  D(bug(\"rpc_method_add_callbacks\\n\"));\n\n  if (connection == NULL)\n\treturn RPC_ERROR_CONNECTION_NULL;\n  if (connection->type != RPC_CONNECTION_SERVER)\n\treturn RPC_ERROR_CONNECTION_TYPE_MISMATCH;\n\n  while (--n_descs >= 0) {\n\tint error = rpc_method_add_callback(connection, &descs[n_descs]);\n\tif (error != RPC_ERROR_NO_ERROR)\n\t  return error;\n  }\n\n  return RPC_ERROR_NO_ERROR;\n}\n\n// Remove a user-defined method callback (common code)\nint rpc_method_remove_callback_id(rpc_connection_t *connection, int id)\n{\n  D(bug(\"rpc_method_remove_callback_id\\n\"));\n\n  if (connection->callbacks) {\n\tint i;\n\tfor (i = 0; i < connection->n_callbacks; i++) {\n\t  if (connection->callbacks[i].id == id) {\n\t\tconnection->callbacks[i].callback = NULL;\n\t\treturn RPC_ERROR_NO_ERROR;\n\t  }\n\t}\n  }\n\n  return RPC_ERROR_GENERIC;\n}\n\n// Remove user-defined method callbacks (server side)\nint rpc_method_remove_callbacks(rpc_connection_t *connection, const rpc_method_descriptor_t *callbacks, int n_callbacks)\n{\n  D(bug(\"rpc_method_remove_callbacks\\n\"));\n\n  if (connection == NULL)\n\treturn RPC_ERROR_CONNECTION_NULL;\n  if (connection->type != RPC_CONNECTION_SERVER)\n\treturn RPC_ERROR_CONNECTION_TYPE_MISMATCH;\n\n  while (--n_callbacks >= 0) {\n\tint error = rpc_method_remove_callback_id(connection, callbacks[n_callbacks].id);\n\tif (error != RPC_ERROR_NO_ERROR)\n\t  return error;\n  }\n\n  return RPC_ERROR_NO_ERROR;\n}\n\n\n/* ====================================================================== */\n/* === Remote Procedure Call (method invocation)                      === */\n/* ====================================================================== */\n\n// Invoke remote procedure (client side)\nint rpc_method_invoke(rpc_connection_t *connection, int method, ...)\n{\n  D(bug(\"rpc_method_invoke method=%d\\n\", method));\n\n  rpc_message_t message;\n  int error;\n  va_list args;\n\n  if (connection == NULL)\n\treturn RPC_ERROR_CONNECTION_NULL;\n  if (connection->type != RPC_CONNECTION_CLIENT)\n\treturn RPC_ERROR_CONNECTION_TYPE_MISMATCH;\n\n  rpc_message_init(&message, connection);\n  error = rpc_message_send_int32(&message, RPC_MESSAGE_START);\n  if (error != RPC_ERROR_NO_ERROR)\n\treturn error;\n  error = rpc_message_send_int32(&message, method);\n  if (error != RPC_ERROR_NO_ERROR)\n\treturn error;\n  va_start(args, method);\n  error = rpc_message_send_args(&message, args);\n  va_end(args);\n  if (error != RPC_ERROR_NO_ERROR)\n\treturn error;\n  error = rpc_message_send_int32(&message, RPC_MESSAGE_END);\n  if (error != RPC_ERROR_NO_ERROR)\n\treturn error;\n  error = rpc_message_flush(&message);\n  if (error != RPC_ERROR_NO_ERROR)\n\treturn error;\n  return RPC_ERROR_NO_ERROR;\n}\n\n// Retrieve procedure arguments (server side)\nint rpc_method_get_args(rpc_connection_t *connection, ...)\n{\n  D(bug(\"rpc_method_get_args\\n\"));\n\n  int error;\n  va_list args;\n  rpc_message_t message;\n\n  if (connection == NULL)\n\treturn RPC_ERROR_CONNECTION_NULL;\n  if (connection->type != RPC_CONNECTION_SERVER)\n\treturn RPC_ERROR_CONNECTION_TYPE_MISMATCH;\n\n  rpc_message_init(&message, connection);\n  va_start(args, connection);\n  error = rpc_message_recv_args(&message, args);\n  va_end(args);\n\n  return error;\n}\n\n// Wait for a reply from the remote procedure (client side)\nint rpc_method_wait_for_reply(rpc_connection_t *connection, ...)\n{\n  D(bug(\"rpc_method_wait_for_reply\\n\"));\n\n  int error, type;\n  int32_t ret;\n  va_list args;\n  rpc_message_t message;\n\n  if (connection == NULL)\n\treturn RPC_ERROR_CONNECTION_NULL;\n  if (connection->type != RPC_CONNECTION_CLIENT)\n\treturn RPC_ERROR_CONNECTION_TYPE_MISMATCH;\n\n  rpc_connection_set_status(connection, RPC_STATUS_BUSY);\n\n  rpc_message_init(&message, connection);\n  va_start(args, connection);\n  type = va_arg(args, int);\n  va_end(args);\n\n  if (type != RPC_TYPE_INVALID) {\n\terror = rpc_message_recv_int32(&message, &ret);\n\tif (error != RPC_ERROR_NO_ERROR)\n\t  return_error(error);\n\tif (ret != RPC_MESSAGE_REPLY) {\n\t  D(bug(\"TRUNCATED 1 [%d]\\n\", ret));\n\t  return_error(RPC_ERROR_MESSAGE_TRUNCATED);\n\t}\n\tva_start(args, connection);\n\terror = rpc_message_recv_args(&message, args);\n\tva_end(args);\n\tif (error != RPC_ERROR_NO_ERROR)\n\t  return_error(error);\n\terror = rpc_message_recv_int32(&message, &ret);\n\tif (error != RPC_ERROR_NO_ERROR)\n\t  return_error(error);\n\tif (ret != RPC_MESSAGE_END) {\n\t  D(bug(\"TRUNCATED 2 [%d]\\n\", ret));\n\t  return_error(RPC_ERROR_MESSAGE_TRUNCATED);\n\t}\n  }\n\n  error = rpc_message_recv_int32(&message, &ret);\n  if (error != RPC_ERROR_NO_ERROR)\n\treturn_error(error);\n  if (ret != RPC_MESSAGE_ACK) {\n\tD(bug(\"TRUNCATED 3 [%d]\\n\", ret));\n\treturn_error(RPC_ERROR_MESSAGE_TRUNCATED);\n  }\n\n  return_error(RPC_ERROR_NO_ERROR);\n\n do_return:\n  rpc_connection_set_status(connection, RPC_STATUS_IDLE);\n  return error;\n}\n\n// Send a reply to the client (server side)\nint rpc_method_send_reply(rpc_connection_t *connection, ...)\n{\n  D(bug(\"rpc_method_send_reply\\n\"));\n\n  rpc_message_t message;\n  int error;\n  va_list args;\n\n  if (connection == NULL)\n\treturn RPC_ERROR_GENERIC;\n  if (connection->type != RPC_CONNECTION_SERVER)\n\treturn RPC_ERROR_GENERIC;\n\n  rpc_message_init(&message, connection);\n  error = rpc_message_send_int32(&message, RPC_MESSAGE_REPLY);\n  if (error != RPC_ERROR_NO_ERROR)\n\treturn error;\n  va_start(args, connection);\n  error = rpc_message_send_args(&message, args);\n  va_end(args);\n  if (error != RPC_ERROR_NO_ERROR)\n\treturn error;\n  error = rpc_message_send_int32(&message, RPC_MESSAGE_END);\n  if (error != RPC_ERROR_NO_ERROR)\n\treturn error;\n  error = rpc_message_flush(&message);\n  if (error != RPC_ERROR_NO_ERROR)\n\treturn error;\n  return RPC_ERROR_NO_ERROR;\n}\n","/*\n *  ether.cpp - Ethernet device driver\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/*\n *  SEE ALSO\n *    Inside Macintosh: Devices, chapter 1 \"Device Manager\"\n *    Inside Macintosh: Networking, chapter 11 \"Ethernet, Token Ring, and FDDI\"\n *    Inside AppleTalk, chapter 3 \"Ethernet and TokenTalk Link Access Protocols\"\n */\n\n#include \"sysdeps.h\"\n\n#include <string.h>\n#include <map>\n\n#if SUPPORTS_UDP_TUNNEL\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <errno.h>\n#endif\n\n#include \"cpu_emulation.h\"\n#include \"main.h\"\n#include \"macos_util.h\"\n#include \"emul_op.h\"\n#include \"prefs.h\"\n#include \"ether.h\"\n#include \"ether_defs.h\"\n\n#ifndef NO_STD_NAMESPACE\nusing std::map;\n#endif\n\n#define DEBUG 0\n#include \"debug.h\"\n\n#define MONITOR 0\n\n\n#ifdef __BEOS__\n#define CLOSESOCKET closesocket\n#else\n#define CLOSESOCKET close\n#endif\n\n\n// Global variables\nuint8 ether_addr[6];\t\t\t// Ethernet address (set by ether_init())\nstatic bool net_open = false;\t// Flag: initialization succeeded, network device open (set by EtherInit())\n\nstatic bool udp_tunnel = false;\t// Flag: tunnelling AppleTalk over UDP using BSD socket API\nstatic uint16 udp_port;\nstatic int udp_socket = -1;\n\n// Mac address of driver data in MacOS RAM\nuint32 ether_data = 0;\n\n// Attached network protocols for UDP tunneling, maps protocol type to MacOS handler address\nstatic map<uint16, uint32> udp_protocols;\n\n\n/*\n *  Initialization\n */\n\nvoid EtherInit(void)\n{\n\tnet_open = false;\n\tudp_tunnel = false;\n\n#if SUPPORTS_UDP_TUNNEL\n\t// UDP tunnelling requested?\n\tif (PrefsFindBool(\"udptunnel\")) {\n\t\tudp_tunnel = true;\n\t\tudp_port = PrefsFindInt32(\"udpport\");\n\n\t\t// Open UDP socket\n\t\tudp_socket = socket(PF_INET, SOCK_DGRAM, 0);\n\t\tif (udp_socket < 0) {\n\t\t\tperror(\"socket\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Bind to specified address and port\n\t\tstruct sockaddr_in sa;\n\t\tmemset(&sa, 0, sizeof(sa));\n\t\tsa.sin_family = AF_INET;\n\t\tsa.sin_addr.s_addr = INADDR_ANY;\n\t\tsa.sin_port = htons(udp_port);\n\t\tif (bind(udp_socket, (struct sockaddr *)&sa, sizeof(sa)) < 0) {\n\t\t\tperror(\"bind\");\n\t\t\tCLOSESOCKET(udp_socket);\n\t\t\tudp_socket = -1;\n\t\t\treturn;\n\t\t}\n\n\t\t// Retrieve local IP address (or at least one of them)\n\t\tsocklen_t sa_length = sizeof(sa);\n\t\tgetsockname(udp_socket, (struct sockaddr *)&sa, &sa_length);\n\t\tuint32 udp_ip = sa.sin_addr.s_addr;\n\t\tif (udp_ip == INADDR_ANY || udp_ip == INADDR_LOOPBACK) {\n\t\t\tchar name[256];\n\t\t\tgethostname(name, sizeof(name));\n\t\t\tstruct hostent *local = gethostbyname(name);\n\t\t\tif (local)\n\t\t\t\tudp_ip = *(uint32 *)local->h_addr_list[0];\n\t\t}\n\t\tudp_ip = ntohl(udp_ip);\n\n\t\t// Construct dummy Ethernet address from local IP address\n\t\tether_addr[0] = 'B';\n\t\tether_addr[1] = '2';\n\t\tether_addr[2] = udp_ip >> 24;\n\t\tether_addr[3] = udp_ip >> 16;\n\t\tether_addr[4] = udp_ip >> 8;\n\t\tether_addr[5] = udp_ip;\n\t\tD(bug(\"Ethernet address %02x %02x %02x %02x %02x %02x\\n\", ether_addr[0], ether_addr[1], ether_addr[2], ether_addr[3], ether_addr[4], ether_addr[5]));\n\n\t\t// Set socket options\n\t\tint on = 1;\n#ifdef __BEOS__\n\t\tsetsockopt(udp_socket, SOL_SOCKET, SO_NONBLOCK, &on, sizeof(on));\n#else\n\t\tsetsockopt(udp_socket, SOL_SOCKET, SO_BROADCAST, &on, sizeof(on));\n\t\tioctl(udp_socket, FIONBIO, &on);\n#endif\n\n\t\t// Start thread for packet reception\n\t\tif (!ether_start_udp_thread(udp_socket)) {\n\t\t\tCLOSESOCKET(udp_socket);\n\t\t\tudp_socket = -1;\n\t\t\treturn;\n\t\t}\n\n\t\tnet_open = true;\n\t} else\n#endif\n\t\tif (ether_init())\n\t\t\tnet_open = true;\n}\n\n\n/*\n *  Deinitialization\n */\n\nvoid EtherExit(void)\n{\n\tif (net_open) {\n#if SUPPORTS_UDP_TUNNEL\n\t\tif (udp_tunnel) {\n\t\t\tif (udp_socket >= 0) {\n\t\t\t\tether_stop_udp_thread();\n\t\t\t\tCLOSESOCKET(udp_socket);\n\t\t\t\tudp_socket = -1;\n\t\t\t}\n\t\t} else\n#endif\n\t\t\tether_exit();\n\t\tnet_open = false;\n\t}\n}\n\n\n/*\n *  Reset\n */\n\nvoid EtherReset(void)\n{\n\tudp_protocols.clear();\n\tether_reset();\n}\n\n\n/*\n *  Check whether Ethernet address is AppleTalk or Ethernet broadcast address\n */\n\nstatic inline bool is_apple_talk_broadcast(uint8 *p)\n{\n\treturn p[0] == 0x09 && p[1] == 0x00 && p[2] == 0x07\n\t    && p[3] == 0xff && p[4] == 0xff && p[5] == 0xff;\n}\n\nstatic inline bool is_ethernet_broadcast(uint8 *p)\n{\n\treturn p[0] == 0xff && p[1] == 0xff && p[2] == 0xff\n\t    && p[3] == 0xff && p[4] == 0xff && p[5] == 0xff;\n}\n\n\n/*\n *  Driver Open() routine\n */\n\nint16 EtherOpen(uint32 pb, uint32 dce)\n{\n\tD(bug(\"EtherOpen\\n\"));\n\n\t// Allocate driver data\n\tM68kRegisters r;\n\tr.d[0] = SIZEOF_etherdata;\n\tExecute68kTrap(0xa71e, &r);\t\t// NewPtrSysClear()\n\tif (r.a[0] == 0)\n\t\treturn openErr;\n\tether_data = r.a[0];\n\tD(bug(\" data %08x\\n\", ether_data));\n\n\tWriteMacInt16(ether_data + ed_DeferredTask + qType, dtQType);\n\tWriteMacInt32(ether_data + ed_DeferredTask + dtAddr, ether_data + ed_Code);\n\tWriteMacInt32(ether_data + ed_DeferredTask + dtParam, ether_data + ed_Result);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Deferred function for signalling that packet write is complete (pointer to mydtResult in a1)\n\tWriteMacInt16(ether_data + ed_Code, 0x2019);\t\t\t//  move.l\t(a1)+,d0\t(result)\n\tWriteMacInt16(ether_data + ed_Code + 2, 0x2251);\t\t//  move.l\t(a1),a1\t\t(dce)\n\tWriteMacInt32(ether_data + ed_Code + 4, 0x207808fc);\t//  move.l\tJIODone,a0\n\tWriteMacInt16(ether_data + ed_Code + 8, 0x4ed0);\t\t//  jmp\t\t(a0)\n\n\tWriteMacInt32(ether_data + ed_DCE, dce);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ReadPacket/ReadRest routines\n\tWriteMacInt16(ether_data + ed_ReadPacket, 0x6010);\t\t//\tbra\t\t2\n\tWriteMacInt16(ether_data + ed_ReadPacket + 2, 0x3003);\t//  move.w\td3,d0\n\tWriteMacInt16(ether_data + ed_ReadPacket + 4, 0x9041);\t//  sub.w\td1,d0\n\tWriteMacInt16(ether_data + ed_ReadPacket + 6, 0x4a43);\t//  tst.w\td3\n\tWriteMacInt16(ether_data + ed_ReadPacket + 8, 0x6702);\t//  beq\t\t1\n\tWriteMacInt16(ether_data + ed_ReadPacket + 10, M68K_EMUL_OP_ETHER_READ_PACKET);\n\tWriteMacInt16(ether_data + ed_ReadPacket + 12, 0x3600);\t//1 move.w\td0,d3\n\tWriteMacInt16(ether_data + ed_ReadPacket + 14, 0x7000);\t//  moveq\t#0,d0\n\tWriteMacInt16(ether_data + ed_ReadPacket + 16, 0x4e75);\t//  rts\n\tWriteMacInt16(ether_data + ed_ReadPacket + 18, M68K_EMUL_OP_ETHER_READ_PACKET);\t//2\n\tWriteMacInt16(ether_data + ed_ReadPacket + 20, 0x4a43);\t//  tst.w\td3\n\tWriteMacInt16(ether_data + ed_ReadPacket + 22, 0x4e75);\t//  rts\n\treturn 0;\n}\n\n\n/*\n *  Driver Control() routine\n */\n\nint16 EtherControl(uint32 pb, uint32 dce)\n{\n\tuint16 code = ReadMacInt16(pb + csCode);\n\tD(bug(\"EtherControl %d\\n\", code));\n\tswitch (code) {\n\t\tcase 1:\t\t\t\t\t// KillIO\n\t\t\treturn -1;\n\n\t\tcase kENetAddMulti:\t\t// Add multicast address\n\t\t\tD(bug(\" AddMulti %08x%04x\\n\", ReadMacInt32(pb + eMultiAddr), ReadMacInt16(pb + eMultiAddr + 4)));\n\t\t\tif (net_open && !udp_tunnel)\n\t\t\t\treturn ether_add_multicast(pb);\n\t\t\treturn noErr;\n\n\t\tcase kENetDelMulti:\t\t// Delete multicast address\n\t\t\tD(bug(\" DelMulti %08x%04x\\n\", ReadMacInt32(pb + eMultiAddr), ReadMacInt16(pb + eMultiAddr + 4)));\n\t\t\tif (net_open && !udp_tunnel)\n\t\t\t\treturn ether_del_multicast(pb);\n\t\t\treturn noErr;\n\n\t\tcase kENetAttachPH: {\t// Attach protocol handler\n\t\t\tuint16 type = ReadMacInt16(pb + eProtType);\n\t\t\tuint32 handler = ReadMacInt32(pb + ePointer);\n\t\t\tD(bug(\" AttachPH prot %04x, handler %08x\\n\", type, handler));\n\t\t\tif (net_open) {\n\t\t\t\tif (udp_tunnel) {\n\t\t\t\t\tif (udp_protocols.find(type) != udp_protocols.end())\n\t\t\t\t\t\treturn lapProtErr;\n\t\t\t\t\tudp_protocols[type] = handler;\n\t\t\t\t} else\n\t\t\t\t\treturn ether_attach_ph(type, handler);\n\t\t\t}\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase kENetDetachPH: {\t// Detach protocol handler\n\t\t\tuint16 type = ReadMacInt16(pb + eProtType);\n\t\t\tD(bug(\" DetachPH prot %04x\\n\", type));\n\t\t\tif (net_open) {\n\t\t\t\tif (udp_tunnel) {\n\t\t\t\t\tif (udp_protocols.erase(type) == 0)\n\t\t\t\t\t\treturn lapProtErr;\n\t\t\t\t} else\n\t\t\t\t\treturn ether_detach_ph(type);\n\t\t\t}\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase kENetWrite: {\t\t// Transmit raw Ethernet packet\n\t\t\tuint32 wds = ReadMacInt32(pb + ePointer);\n\t\t\tD(bug(\" EtherWrite \"));\n\t\t\tif (ReadMacInt16(wds) < 14)\n\t\t\t\treturn eLenErr;\t// Header incomplete\n\n\t\t\t// Set source address\n\t\t\tuint32 hdr = ReadMacInt32(wds + 2);\n\t\t\tHost2Mac_memcpy(hdr + 6, ether_addr, 6);\n\t\t\tD(bug(\"to %08x%04x, type %04x\\n\", ReadMacInt32(hdr), ReadMacInt16(hdr + 4), ReadMacInt16(hdr + 12)));\n\n\t\t\tif (net_open) {\n#if SUPPORTS_UDP_TUNNEL\n\t\t\t\tif (udp_tunnel) {\n\n\t\t\t\t\t// Copy packet to buffer\n\t\t\t\t\tuint8 packet[1514];\n\t\t\t\t\tint len = ether_wds_to_buffer(wds, packet);\n\n\t\t\t\t\t// Extract destination address\n\t\t\t\t\tuint32 dest_ip;\n\t\t\t\t\tif (len >= 6 && packet[0] == 'B' && packet[1] == '2')\n\t\t\t\t\t\tdest_ip = (packet[2] << 24) | (packet[3] << 16) | (packet[4] << 8) | packet[5];\n\t\t\t\t\telse if (is_apple_talk_broadcast(packet) || is_ethernet_broadcast(packet))\n\t\t\t\t\t\tdest_ip = INADDR_BROADCAST;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn eMultiErr;\n\n#if MONITOR\n\t\t\t\t\tbug(\"Sending Ethernet packet:\\n\");\n\t\t\t\t\tfor (int i=0; i<len; i++) {\n\t\t\t\t\t\tbug(\"%02x \", packet[i]);\n\t\t\t\t\t}\n\t\t\t\t\tbug(\"\\n\");\n#endif\n\n\t\t\t\t\t// Send packet\n\t\t\t\t\tstruct sockaddr_in sa;\n\t\t\t\t\tsa.sin_family = AF_INET;\n\t\t\t\t\tsa.sin_addr.s_addr = htonl(dest_ip);\n\t\t\t\t\tsa.sin_port = htons(udp_port);\n\t\t\t\t\tif (sendto(udp_socket, packet, len, 0, (struct sockaddr *)&sa, sizeof(sa)) < 0) {\n\t\t\t\t\t\tD(bug(\"WARNING: Couldn't transmit packet\\n\"));\n\t\t\t\t\t\treturn excessCollsns;\n\t\t\t\t\t}\n\t\t\t\t} else\n#endif\n\t\t\t\t\treturn ether_write(wds);\n\t\t\t}\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase kENetGetInfo: {\t// Get device information/statistics\n\t\t\tD(bug(\" GetInfo buf %08x, size %d\\n\", ReadMacInt32(pb + ePointer), ReadMacInt16(pb + eBuffSize)));\n\n\t\t\t// Collect info (only ethernet address)\n\t\t\tuint8 buf[18];\n\t\t\tmemset(buf, 0, 18);\n\t\t\tmemcpy(buf, ether_addr, 6);\n\n\t\t\t// Transfer info to supplied buffer\n\t\t\tint16 size = ReadMacInt16(pb + eBuffSize);\n\t\t\tif (size > 18)\n\t\t\t\tsize = 18;\n\t\t\tWriteMacInt16(pb + eDataSize, size);\t// Number of bytes actually written\n\t\t\tHost2Mac_memcpy(ReadMacInt32(pb + ePointer), buf, size);\n\t\t\treturn noErr;\n\t\t}\n\n\t\tcase kENetSetGeneral:\t// Set general mode (always in general mode)\n\t\t\tD(bug(\" SetGeneral\\n\"));\n\t\t\treturn noErr;\n\n\t\tdefault:\n\t\t\tprintf(\"WARNING: Unknown EtherControl(%d)\\n\", code);\n\t\t\treturn controlErr;\n\t}\n}\n\n\n/*\n *  Ethernet ReadPacket routine\n */\n\nvoid EtherReadPacket(uint32 &src, uint32 &dest, uint32 &len, uint32 &remaining)\n{\n\tD(bug(\"EtherReadPacket src %08x, dest %08x, len %08x, remaining %08x\\n\", src, dest, len, remaining));\n\tuint32 todo = len > remaining ? remaining : len;\n\tMac2Mac_memcpy(dest, src, todo);\n\tsrc += todo;\n\tdest += todo;\n\tlen -= todo;\n\tremaining -= todo;\n}\n\n\n#if SUPPORTS_UDP_TUNNEL\n/*\n *  Read packet from UDP socket\n */\n\nvoid ether_udp_read(uint32 packet, int length, struct sockaddr_in *from)\n{\n\t// Drop packets sent by us\n\tif (memcmp(Mac2HostAddr(packet) + 6, ether_addr, 6) == 0)\n\t\treturn;\n\n#if MONITOR\n\tbug(\"Receiving Ethernet packet:\\n\");\n\tfor (int i=0; i<length; i++) {\n\t\tbug(\"%02x \", ReadMacInt8(packet + i));\n\t}\n\tbug(\"\\n\");\n#endif\n\n\t// Get packet type\n\tuint16 type = ReadMacInt16(packet + 12);\n\n\t// Look for protocol\n\tuint16 search_type = (type <= 1500 ? 0 : type);\n\tif (udp_protocols.find(search_type) == udp_protocols.end())\n\t\treturn;\n\tuint32 handler = udp_protocols[search_type];\n\tif (handler == 0)\n\t\treturn;\n\n\t// Copy header to RHA\n\tMac2Mac_memcpy(ether_data + ed_RHA, packet, 14);\n\tD(bug(\" header %08x%04x %08x%04x %04x\\n\", ReadMacInt32(ether_data + ed_RHA), ReadMacInt16(ether_data + ed_RHA + 4), ReadMacInt32(ether_data + ed_RHA + 6), ReadMacInt16(ether_data + ed_RHA + 10), ReadMacInt16(ether_data + ed_RHA + 12)));\n\n\t// Call protocol handler\n\tM68kRegisters r;\n\tr.d[0] = type;\t\t\t\t\t\t\t\t\t// Packet type\n\tr.d[1] = length - 14;\t\t\t\t\t\t\t// Remaining packet length (without header, for ReadPacket)\n\tr.a[0] = packet + 14;\t\t\t\t\t\t\t// Pointer to packet (Mac address, for ReadPacket)\n\tr.a[3] = ether_data + ed_RHA + 14;\t\t\t\t// Pointer behind header in RHA\n\tr.a[4] = ether_data + ed_ReadPacket;\t\t\t// Pointer to ReadPacket/ReadRest routines\n\tD(bug(\" calling protocol handler %08x, type %08x, length %08x, data %08x, rha %08x, read_packet %08x\\n\", handler, r.d[0], r.d[1], r.a[0], r.a[3], r.a[4]));\n\tExecute68k(handler, &r);\n}\n#endif\n\n\n/*\n *  Ethernet packet allocator\n */\n\n#if SIZEOF_VOID_P != 4 || REAL_ADDRESSING == 0\nstatic uint32 ether_packet = 0;\t\t\t// Ethernet packet (cached allocation)\nstatic uint32 n_ether_packets = 0;\t\t// Number of ethernet packets allocated so far (should be at most 1)\n\nEthernetPacket::EthernetPacket()\n{\n\t++n_ether_packets;\n\tif (ether_packet && n_ether_packets == 1)\n\t\tpacket = ether_packet;\n\telse {\n        M68kRegisters r;\n        r.d[0] = 1516;\n        Execute68kTrap(0xa71e, &r);\t\t// NewPtrSysClear()\n\t\tassert(r.a[0] != 0);\n\t\tpacket = r.a[0];\n\t\tif (ether_packet == 0)\n\t\t\tether_packet = packet;\n\t}\n}\n\nEthernetPacket::~EthernetPacket()\n{\n\t--n_ether_packets;\n\tif (packet != ether_packet) {\n\t\tM68kRegisters r;\n\t\tr.a[0] = packet;\n\t\tExecute68kTrap(0xa01f, &r);\t\t// DisposePtr\n\t}\n\tif (n_ether_packets > 0) {\n\t\tbug(\"WARNING: Nested allocation of ethernet packets!\\n\");\n\t}\n}\n#endif\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___TREE\n#define _LIBCPP___TREE\n\n#include <__config>\n#include <iterator>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _Compare, class _Allocator> class __tree;\ntemplate <class _Tp, class _NodePtr, class _DiffType>\n    class _LIBCPP_TEMPLATE_VIS __tree_iterator;\ntemplate <class _Tp, class _ConstNodePtr, class _DiffType>\n    class _LIBCPP_TEMPLATE_VIS __tree_const_iterator;\n\ntemplate <class _Pointer> class __tree_end_node;\ntemplate <class _VoidPtr> class __tree_node_base;\ntemplate <class _Tp, class _VoidPtr> class __tree_node;\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Value>\nunion __value_type;\n#else\ntemplate <class _Key, class _Value>\nstruct __value_type;\n#endif\n\ntemplate <class _Allocator> class __map_node_destructor;\ntemplate <class _TreeIterator> class _LIBCPP_TEMPLATE_VIS __map_iterator;\ntemplate <class _TreeIterator> class _LIBCPP_TEMPLATE_VIS __map_const_iterator;\n\n/*\n\n_NodePtr algorithms\n\nThe algorithms taking _NodePtr are red black tree algorithms.  Those\nalgorithms taking a parameter named __root should assume that __root\npoints to a proper red black tree (unless otherwise specified).\n\nEach algorithm herein assumes that __root->__parent_ points to a non-null\nstructure which has a member __left_ which points back to __root.  No other\nmember is read or written to at __root->__parent_.\n\n__root->__parent_ will be referred to below (in comments only) as end_node.\nend_node->__left_ is an externably accessible lvalue for __root, and can be\nchanged by node insertion and removal (without explicit reference to end_node).\n\nAll nodes (with the exception of end_node), even the node referred to as\n__root, have a non-null __parent_ field.\n\n*/\n\n// Returns:  true if __x is a left child of its parent, else false\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__tree_is_left_child(_NodePtr __x) _NOEXCEPT\n{\n    return __x == __x->__parent_->__left_;\n}\n\n// Determintes if the subtree rooted at __x is a proper red black subtree.  If\n//    __x is a proper subtree, returns the black height (null counts as 1).  If\n//    __x is an improper subtree, returns 0.\ntemplate <class _NodePtr>\nunsigned\n__tree_sub_invariant(_NodePtr __x)\n{\n    if (__x == nullptr)\n        return 1;\n    // parent consistency checked by caller\n    // check __x->__left_ consistency\n    if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)\n        return 0;\n    // check __x->__right_ consistency\n    if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)\n        return 0;\n    // check __x->__left_ != __x->__right_ unless both are nullptr\n    if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)\n        return 0;\n    // If this is red, neither child can be red\n    if (!__x->__is_black_)\n    {\n        if (__x->__left_ && !__x->__left_->__is_black_)\n            return 0;\n        if (__x->__right_ && !__x->__right_->__is_black_)\n            return 0;\n    }\n    unsigned __h = __tree_sub_invariant(__x->__left_);\n    if (__h == 0)\n        return 0;  // invalid left subtree\n    if (__h != __tree_sub_invariant(__x->__right_))\n        return 0;  // invalid or different height right subtree\n    return __h + __x->__is_black_;  // return black height of this node\n}\n\n// Determintes if the red black tree rooted at __root is a proper red black tree.\n//    __root == nullptr is a proper tree.  Returns true is __root is a proper\n//    red black tree, else returns false.\ntemplate <class _NodePtr>\nbool\n__tree_invariant(_NodePtr __root)\n{\n    if (__root == nullptr)\n        return true;\n    // check __x->__parent_ consistency\n    if (__root->__parent_ == nullptr)\n        return false;\n    if (!__tree_is_left_child(__root))\n        return false;\n    // root must be black\n    if (!__root->__is_black_)\n        return false;\n    // do normal node checks\n    return __tree_sub_invariant(__root) != 0;\n}\n\n// Returns:  pointer to the left-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_min(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__left_ != nullptr)\n        __x = __x->__left_;\n    return __x;\n}\n\n// Returns:  pointer to the right-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_max(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__right_ != nullptr)\n        __x = __x->__right_;\n    return __x;\n}\n\n// Returns:  pointer to the next in-order node after __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_next(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__right_ != nullptr)\n        return __tree_min(__x->__right_);\n    while (!__tree_is_left_child(__x))\n        __x = __x->__parent_unsafe();\n    return __x->__parent_unsafe();\n}\n\ntemplate <class _EndNodePtr, class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_EndNodePtr\n__tree_next_iter(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__right_ != nullptr)\n        return static_cast<_EndNodePtr>(__tree_min(__x->__right_));\n    while (!__tree_is_left_child(__x))\n        __x = __x->__parent_unsafe();\n    return static_cast<_EndNodePtr>(__x->__parent_);\n}\n\n// Returns:  pointer to the previous in-order node before __x.\n// Precondition:  __x != nullptr.\n// Note: __x may be the end node.\ntemplate <class _NodePtr, class _EndNodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_prev_iter(_EndNodePtr __x) _NOEXCEPT\n{\n    if (__x->__left_ != nullptr)\n        return __tree_max(__x->__left_);\n    _NodePtr __xx = static_cast<_NodePtr>(__x);\n    while (__tree_is_left_child(__xx))\n        __xx = __xx->__parent_unsafe();\n    return __xx->__parent_unsafe();\n}\n\n// Returns:  pointer to a node which has no children\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_leaf(_NodePtr __x) _NOEXCEPT\n{\n    while (true)\n    {\n        if (__x->__left_ != nullptr)\n        {\n            __x = __x->__left_;\n            continue;\n        }\n        if (__x->__right_ != nullptr)\n        {\n            __x = __x->__right_;\n            continue;\n        }\n        break;\n    }\n    return __x;\n}\n\n// Effects:  Makes __x->__right_ the subtree root with __x as its left child\n//           while preserving in-order order.\n// Precondition:  __x->__right_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_left_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__right_;\n    __x->__right_ = __y->__left_;\n    if (__x->__right_ != nullptr)\n        __x->__right_->__set_parent(__x);\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_unsafe()->__right_ = __y;\n    __y->__left_ = __x;\n    __x->__set_parent(__y);\n}\n\n// Effects:  Makes __x->__left_ the subtree root with __x as its right child\n//           while preserving in-order order.\n// Precondition:  __x->__left_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_right_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__left_;\n    __x->__left_ = __y->__right_;\n    if (__x->__left_ != nullptr)\n        __x->__left_->__set_parent(__x);\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_unsafe()->__right_ = __y;\n    __y->__right_ = __x;\n    __x->__set_parent(__y);\n}\n\n// Effects:  Rebalances __root after attaching __x to a leaf.\n// Precondition:  __root != nulptr && __x != nullptr.\n//                __x has no children.\n//                __x == __root or == a direct or indirect child of __root.\n//                If __x were to be unlinked from __root (setting __root to\n//                  nullptr if __root == __x), __tree_invariant(__root) == true.\n// Postcondition: __tree_invariant(end_node->__left_) == true.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_balance_after_insert(_NodePtr __root, _NodePtr __x) _NOEXCEPT\n{\n    __x->__is_black_ = __x == __root;\n    while (__x != __root && !__x->__parent_unsafe()->__is_black_)\n    {\n        // __x->__parent_ != __root because __x->__parent_->__is_black == false\n        if (__tree_is_left_child(__x->__parent_unsafe()))\n        {\n            _NodePtr __y = __x->__parent_unsafe()->__parent_unsafe()->__right_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = true;\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (!__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_unsafe();\n                    __tree_left_rotate(__x);\n                }\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = true;\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = false;\n                __tree_right_rotate(__x);\n                break;\n            }\n        }\n        else\n        {\n            _NodePtr __y = __x->__parent_unsafe()->__parent_->__left_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = true;\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_unsafe();\n                    __tree_right_rotate(__x);\n                }\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = true;\n                __x = __x->__parent_unsafe();\n                __x->__is_black_ = false;\n                __tree_left_rotate(__x);\n                break;\n            }\n        }\n    }\n}\n\n// Precondition:  __root != nullptr && __z != nullptr.\n//                __tree_invariant(__root) == true.\n//                __z == __root or == a direct or indirect child of __root.\n// Effects:  unlinks __z from the tree rooted at __root, rebalancing as needed.\n// Postcondition: __tree_invariant(end_node->__left_) == true && end_node->__left_\n//                nor any of its children refer to __z.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_remove(_NodePtr __root, _NodePtr __z) _NOEXCEPT\n{\n    // __z will be removed from the tree.  Client still needs to destruct/deallocate it\n    // __y is either __z, or if __z has two children, __tree_next(__z).\n    // __y will have at most one child.\n    // __y will be the initial hole in the tree (make the hole at a leaf)\n    _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ?\n                    __z : __tree_next(__z);\n    // __x is __y's possibly null single child\n    _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;\n    // __w is __x's possibly null uncle (will become __x's sibling)\n    _NodePtr __w = nullptr;\n    // link __x to __y's parent, and find __w\n    if (__x != nullptr)\n        __x->__parent_ = __y->__parent_;\n    if (__tree_is_left_child(__y))\n    {\n        __y->__parent_->__left_ = __x;\n        if (__y != __root)\n            __w = __y->__parent_unsafe()->__right_;\n        else\n            __root = __x;  // __w == nullptr\n    }\n    else\n    {\n        __y->__parent_unsafe()->__right_ = __x;\n        // __y can't be root if it is a right child\n        __w = __y->__parent_->__left_;\n    }\n    bool __removed_black = __y->__is_black_;\n    // If we didn't remove __z, do so now by splicing in __y for __z,\n    //    but copy __z's color.  This does not impact __x or __w.\n    if (__y != __z)\n    {\n        // __z->__left_ != nulptr but __z->__right_ might == __x == nullptr\n        __y->__parent_ = __z->__parent_;\n        if (__tree_is_left_child(__z))\n            __y->__parent_->__left_ = __y;\n        else\n            __y->__parent_unsafe()->__right_ = __y;\n        __y->__left_ = __z->__left_;\n        __y->__left_->__set_parent(__y);\n        __y->__right_ = __z->__right_;\n        if (__y->__right_ != nullptr)\n            __y->__right_->__set_parent(__y);\n        __y->__is_black_ = __z->__is_black_;\n        if (__root == __z)\n            __root = __y;\n    }\n    // There is no need to rebalance if we removed a red, or if we removed\n    //     the last node.\n    if (__removed_black && __root != nullptr)\n    {\n        // Rebalance:\n        // __x has an implicit black color (transferred from the removed __y)\n        //    associated with it, no matter what its color is.\n        // If __x is __root (in which case it can't be null), it is supposed\n        //    to be black anyway, and if it is doubly black, then the double\n        //    can just be ignored.\n        // If __x is red (in which case it can't be null), then it can absorb\n        //    the implicit black just by setting its color to black.\n        // Since __y was black and only had one child (which __x points to), __x\n        //   is either red with no children, else null, otherwise __y would have\n        //   different black heights under left and right pointers.\n        // if (__x == __root || __x != nullptr && !__x->__is_black_)\n        if (__x != nullptr)\n            __x->__is_black_ = true;\n        else\n        {\n            //  Else __x isn't root, and is \"doubly black\", even though it may\n            //     be null.  __w can not be null here, else the parent would\n            //     see a black height >= 2 on the __x side and a black height\n            //     of 1 on the __w side (__w must be a non-null black or a red\n            //     with a non-null black child).\n            while (true)\n            {\n                if (!__tree_is_left_child(__w))  // if x is left child\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_unsafe()->__is_black_ = false;\n                        __tree_left_rotate(__w->__parent_unsafe());\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__left_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__left_->__right_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_unsafe();\n                        // __x can no longer be null\n                        if (__x == __root || !__x->__is_black_)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_unsafe()->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__right_ == nullptr || __w->__right_->__is_black_)\n                        {\n                            // __w left child is non-null and red\n                            __w->__left_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_right_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_unsafe();\n                        }\n                        // __w has a right red child, left child may be null\n                        __w->__is_black_ = __w->__parent_unsafe()->__is_black_;\n                        __w->__parent_unsafe()->__is_black_ = true;\n                        __w->__right_->__is_black_ = true;\n                        __tree_left_rotate(__w->__parent_unsafe());\n                        break;\n                    }\n                }\n                else\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_unsafe()->__is_black_ = false;\n                        __tree_right_rotate(__w->__parent_unsafe());\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__right_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__right_->__left_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_unsafe();\n                        // __x can no longer be null\n                        if (!__x->__is_black_ || __x == __root)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_unsafe()->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__left_ == nullptr || __w->__left_->__is_black_)\n                        {\n                            // __w right child is non-null and red\n                            __w->__right_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_left_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_unsafe();\n                        }\n                        // __w has a left red child, right child may be null\n                        __w->__is_black_ = __w->__parent_unsafe()->__is_black_;\n                        __w->__parent_unsafe()->__is_black_ = true;\n                        __w->__left_->__is_black_ = true;\n                        __tree_right_rotate(__w->__parent_unsafe());\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// node traits\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp>\nstruct __is_tree_value_type_imp : false_type {};\n\ntemplate <class _Key, class _Value>\nstruct __is_tree_value_type_imp<__value_type<_Key, _Value>> : true_type {};\n\ntemplate <class ..._Args>\nstruct __is_tree_value_type : false_type {};\n\ntemplate <class _One>\nstruct __is_tree_value_type<_One> : __is_tree_value_type_imp<typename __uncvref<_One>::type> {};\n#endif\n\ntemplate <class _Tp>\nstruct __tree_key_value_types {\n  typedef _Tp key_type;\n  typedef _Tp __node_value_type;\n  typedef _Tp __container_value_type;\n  static const bool __is_map = false;\n\n  _LIBCPP_INLINE_VISIBILITY\n  static key_type const& __get_key(_Tp const& __v) {\n    return __v;\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type const& __get_value(__node_value_type const& __v) {\n    return __v;\n  }\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type* __get_ptr(__node_value_type& __n) {\n    return _VSTD::addressof(__n);\n  }\n\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY\n  static  __container_value_type&& __move(__node_value_type& __v) {\n    return _VSTD::move(__v);\n  }\n#endif\n};\n\ntemplate <class _Key, class _Tp>\nstruct __tree_key_value_types<__value_type<_Key, _Tp> > {\n  typedef _Key                                         key_type;\n  typedef _Tp                                          mapped_type;\n  typedef __value_type<_Key, _Tp>                      __node_value_type;\n  typedef pair<const _Key, _Tp>                        __container_value_type;\n  typedef pair<_Key, _Tp>                              __nc_value_type;\n  typedef __container_value_type                       __map_value_type;\n  static const bool __is_map = true;\n\n  _LIBCPP_INLINE_VISIBILITY\n  static key_type const&\n  __get_key(__node_value_type const& __t) {\n    return __t.__cc.first;\n  }\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,\n      key_type const&>::type\n  __get_key(_Up& __t) {\n    return __t.first;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type const&\n  __get_value(__node_value_type const& __t) {\n    return __t.__cc;\n  }\n\n  template <class _Up>\n  _LIBCPP_INLINE_VISIBILITY\n  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,\n      __container_value_type const&>::type\n  __get_value(_Up& __t) {\n    return __t;\n  }\n\n  _LIBCPP_INLINE_VISIBILITY\n  static __container_value_type* __get_ptr(__node_value_type& __n) {\n    return _VSTD::addressof(__n.__cc);\n  }\n\n#ifndef _LIBCPP_CXX03_LANG\n  _LIBCPP_INLINE_VISIBILITY\n  static  __nc_value_type&& __move(__node_value_type& __v) {\n    return _VSTD::move(__v.__nc);\n  }\n#endif\n};\n\ntemplate <class _VoidPtr>\nstruct __tree_node_base_types {\n  typedef _VoidPtr                                               __void_pointer;\n\n  typedef __tree_node_base<__void_pointer>                      __node_base_type;\n  typedef typename __rebind_pointer<_VoidPtr, __node_base_type>::type\n                                                             __node_base_pointer;\n\n  typedef __tree_end_node<__node_base_pointer>                  __end_node_type;\n  typedef typename __rebind_pointer<_VoidPtr, __end_node_type>::type\n                                                             __end_node_pointer;\n#if defined(_LIBCPP_ABI_TREE_REMOVE_NODE_POINTER_UB)\n  typedef __end_node_pointer __parent_pointer;\n#else\n  typedef typename conditional<\n      is_pointer<__end_node_pointer>::value,\n        __end_node_pointer,\n        __node_base_pointer>::type __parent_pointer;\n#endif\n\nprivate:\n  static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),\n                  \"_VoidPtr does not point to unqualified void type\");\n};\n\ntemplate <class _Tp, class _AllocPtr, class _KVTypes = __tree_key_value_types<_Tp>,\n         bool = _KVTypes::__is_map>\nstruct __tree_map_pointer_types {};\n\ntemplate <class _Tp, class _AllocPtr, class _KVTypes>\nstruct __tree_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {\n  typedef typename _KVTypes::__map_value_type   _Mv;\n  typedef typename __rebind_pointer<_AllocPtr, _Mv>::type\n                                                       __map_value_type_pointer;\n  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type\n                                                 __const_map_value_type_pointer;\n};\n\ntemplate <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>\nstruct __tree_node_types;\n\ntemplate <class _NodePtr, class _Tp, class _VoidPtr>\nstruct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr> >\n    : public __tree_node_base_types<_VoidPtr>,\n             __tree_key_value_types<_Tp>,\n             __tree_map_pointer_types<_Tp, _VoidPtr>\n{\n  typedef __tree_node_base_types<_VoidPtr> __base;\n  typedef __tree_key_value_types<_Tp>      __key_base;\n  typedef __tree_map_pointer_types<_Tp, _VoidPtr> __map_pointer_base;\npublic:\n\n  typedef typename pointer_traits<_NodePtr>::element_type       __node_type;\n  typedef _NodePtr                                              __node_pointer;\n\n  typedef _Tp                                                 __node_value_type;\n  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type\n                                                      __node_value_type_pointer;\n  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type\n                                                __const_node_value_type_pointer;\n#if defined(_LIBCPP_ABI_TREE_REMOVE_NODE_POINTER_UB)\n  typedef typename __base::__end_node_pointer __iter_pointer;\n#else\n  typedef typename conditional<\n      is_pointer<__node_pointer>::value,\n        typename __base::__end_node_pointer,\n        __node_pointer>::type __iter_pointer;\n#endif\nprivate:\n    static_assert(!is_const<__node_type>::value,\n                \"_NodePtr should never be a pointer to const\");\n    static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,\n                          _NodePtr>::value), \"_VoidPtr does not rebind to _NodePtr.\");\n};\n\ntemplate <class _ValueTp, class _VoidPtr>\nstruct __make_tree_node_types {\n  typedef typename __rebind_pointer<_VoidPtr, __tree_node<_ValueTp, _VoidPtr> >::type\n                                                                        _NodePtr;\n  typedef __tree_node_types<_NodePtr> type;\n};\n\n// node\n\ntemplate <class _Pointer>\nclass __tree_end_node\n{\npublic:\n    typedef _Pointer pointer;\n    pointer __left_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_end_node() _NOEXCEPT : __left_() {}\n};\n\ntemplate <class _VoidPtr>\nclass __tree_node_base\n    : public __tree_node_base_types<_VoidPtr>::__end_node_type\n{\n    typedef __tree_node_base_types<_VoidPtr> _NodeBaseTypes;\n\npublic:\n    typedef typename _NodeBaseTypes::__node_base_pointer pointer;\n    typedef typename _NodeBaseTypes::__parent_pointer __parent_pointer;\n\n    pointer          __right_;\n    __parent_pointer __parent_;\n    bool __is_black_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __parent_unsafe() const { return static_cast<pointer>(__parent_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_parent(pointer __p) {\n        __parent_ = static_cast<__parent_pointer>(__p);\n    }\n\nprivate:\n  ~__tree_node_base() _LIBCPP_EQUAL_DELETE;\n  __tree_node_base(__tree_node_base const&) _LIBCPP_EQUAL_DELETE;\n  __tree_node_base& operator=(__tree_node_base const&) _LIBCPP_EQUAL_DELETE;\n};\n\ntemplate <class _Tp, class _VoidPtr>\nclass __tree_node\n    : public __tree_node_base<_VoidPtr>\n{\npublic:\n    typedef _Tp __node_value_type;\n\n    __node_value_type __value_;\n\nprivate:\n  ~__tree_node() _LIBCPP_EQUAL_DELETE;\n  __tree_node(__tree_node const&) _LIBCPP_EQUAL_DELETE;\n  __tree_node& operator=(__tree_node const&) _LIBCPP_EQUAL_DELETE;\n};\n\n\ntemplate <class _Allocator>\nclass __tree_node_destructor\n{\n    typedef _Allocator                                      allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n\npublic:\n    typedef typename __alloc_traits::pointer                pointer;\nprivate:\n    typedef __tree_node_types<pointer> _NodeTypes;\n    allocator_type& __na_;\n\n    __tree_node_destructor& operator=(const __tree_node_destructor&);\n\npublic:\n    bool __value_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_node_destructor(allocator_type& __na, bool __val = false) _NOEXCEPT\n        : __na_(__na),\n          __value_constructed(__val)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__value_constructed)\n            __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n\n    template <class> friend class __map_node_destructor;\n};\n\n\ntemplate <class _Tp, class _NodePtr, class _DiffType>\nclass _LIBCPP_TEMPLATE_VIS __tree_iterator\n{\n    typedef __tree_node_types<_NodePtr>                     _NodeTypes;\n    typedef _NodePtr                                        __node_pointer;\n    typedef typename _NodeTypes::__node_base_pointer        __node_base_pointer;\n    typedef typename _NodeTypes::__end_node_pointer         __end_node_pointer;\n    typedef typename _NodeTypes::__iter_pointer             __iter_pointer;\n    typedef pointer_traits<__node_pointer> __pointer_traits;\n\n    __iter_pointer __ptr_;\n\npublic:\n    typedef bidirectional_iterator_tag                     iterator_category;\n    typedef _Tp                                            value_type;\n    typedef _DiffType                                      difference_type;\n    typedef value_type&                                    reference;\n    typedef typename _NodeTypes::__node_value_type_pointer pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const\n        {return __get_np()->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__get_np()->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator++() {\n      __ptr_ = static_cast<__iter_pointer>(\n          __tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));\n      return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator++(int)\n        {__tree_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator--() {\n      __ptr_ = static_cast<__iter_pointer>(__tree_prev_iter<__node_base_pointer>(\n          static_cast<__end_node_pointer>(__ptr_)));\n      return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator--(int)\n        {__tree_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY \n        bool operator==(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_iterator(__end_node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }\n    template <class, class, class> friend class __tree;\n    template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS __tree_const_iterator;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __map_iterator;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;\n    template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS set;\n    template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS multiset;\n};\n\ntemplate <class _Tp, class _NodePtr, class _DiffType>\nclass _LIBCPP_TEMPLATE_VIS __tree_const_iterator\n{\n    typedef __tree_node_types<_NodePtr>                     _NodeTypes;\n    typedef typename _NodeTypes::__node_pointer             __node_pointer;\n    typedef typename _NodeTypes::__node_base_pointer        __node_base_pointer;\n    typedef typename _NodeTypes::__end_node_pointer         __end_node_pointer;\n    typedef typename _NodeTypes::__iter_pointer             __iter_pointer;\n    typedef pointer_traits<__node_pointer> __pointer_traits;\n\n    __iter_pointer __ptr_;\n\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef _Tp                                                  value_type;\n    typedef _DiffType                                            difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_const_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\nprivate:\n    typedef __tree_iterator<value_type, __node_pointer, difference_type>\n                                                           __non_const_iterator;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator(__non_const_iterator __p) _NOEXCEPT\n        : __ptr_(__p.__ptr_) {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const\n        {return __get_np()->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__get_np()->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator++() {\n      __ptr_ = static_cast<__iter_pointer>(\n          __tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));\n      return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator++(int)\n        {__tree_const_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator--() {\n      __ptr_ = static_cast<__iter_pointer>(__tree_prev_iter<__node_base_pointer>(\n          static_cast<__end_node_pointer>(__ptr_)));\n      return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator--(int)\n        {__tree_const_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_const_iterator(__node_pointer __p) _NOEXCEPT\n        : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_const_iterator(__end_node_pointer __p) _NOEXCEPT\n        : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }\n\n    template <class, class, class> friend class __tree;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;\n    template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS set;\n    template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS multiset;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __map_const_iterator;\n\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nclass __tree\n{\npublic:\n    typedef _Tp                                      value_type;\n    typedef _Compare                                 value_compare;\n    typedef _Allocator                               allocator_type;\n\nprivate:\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __make_tree_node_types<value_type,\n        typename __alloc_traits::void_pointer>::type\n                                                    _NodeTypes;\n    typedef typename _NodeTypes::key_type           key_type;\npublic:\n    typedef typename _NodeTypes::__node_value_type      __node_value_type;\n    typedef typename _NodeTypes::__container_value_type __container_value_type;\n\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n\npublic:\n    typedef typename _NodeTypes::__void_pointer        __void_pointer;\n\n    typedef typename _NodeTypes::__node_type           __node;\n    typedef typename _NodeTypes::__node_pointer        __node_pointer;\n\n    typedef typename _NodeTypes::__node_base_type      __node_base;\n    typedef typename _NodeTypes::__node_base_pointer   __node_base_pointer;\n\n    typedef typename _NodeTypes::__end_node_type       __end_node_t;\n    typedef typename _NodeTypes::__end_node_pointer    __end_node_ptr;\n\n    typedef typename _NodeTypes::__parent_pointer      __parent_pointer;\n    typedef typename _NodeTypes::__iter_pointer        __iter_pointer;\n\n    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;\n    typedef allocator_traits<__node_allocator>         __node_traits;\n\nprivate:\n    // check for sane allocator pointer rebinding semantics. Rebinding the\n    // allocator for a new pointer type should be exactly the same as rebinding\n    // the pointer using 'pointer_traits'.\n    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),\n                  \"Allocator does not rebind pointers in a sane manner.\");\n    typedef typename __rebind_alloc_helper<__node_traits, __node_base>::type\n        __node_base_allocator;\n    typedef allocator_traits<__node_base_allocator> __node_base_traits;\n    static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),\n                 \"Allocator does not rebind pointers in a sane manner.\");\n\nprivate:\n    __iter_pointer                                     __begin_node_;\n    __compressed_pair<__end_node_t, __node_allocator>  __pair1_;\n    __compressed_pair<size_type, value_compare>        __pair3_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iter_pointer __end_node() _NOEXCEPT\n    {\n        return static_cast<__iter_pointer>(\n                pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())\n        );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __iter_pointer __end_node() const _NOEXCEPT\n    {\n        return static_cast<__iter_pointer>(\n            pointer_traits<__end_node_ptr>::pointer_to(\n                const_cast<__end_node_t&>(__pair1_.first())\n            )\n        );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n          __node_allocator& __node_alloc() _NOEXCEPT {return __pair1_.second();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __pair1_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n          __iter_pointer& __begin_node() _NOEXCEPT {return __begin_node_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const __iter_pointer& __begin_node() const _NOEXCEPT {return __begin_node_;}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type __alloc() const _NOEXCEPT\n        {return allocator_type(__node_alloc());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n          size_type& size() _NOEXCEPT {return __pair3_.first();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& size() const _NOEXCEPT {return __pair3_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n          value_compare& value_comp() _NOEXCEPT {return __pair3_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_compare& value_comp() const _NOEXCEPT\n        {return __pair3_.second();}\npublic:\n\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __root() const _NOEXCEPT\n        {return static_cast<__node_pointer>(__end_node()->__left_);}\n\n    __node_base_pointer* __root_ptr() const _NOEXCEPT {\n        return _VSTD::addressof(__end_node()->__left_);\n    }\n\n    typedef __tree_iterator<value_type, __node_pointer, difference_type>             iterator;\n    typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;\n\n    explicit __tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value);\n    explicit __tree(const allocator_type& __a);\n    __tree(const value_compare& __comp, const allocator_type& __a);\n    __tree(const __tree& __t);\n    __tree& operator=(const __tree& __t);\n    template <class _InputIterator>\n        void __assign_unique(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        void __assign_multi(_InputIterator __first, _InputIterator __last);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __tree(__tree&& __t)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<value_compare>::value);\n    __tree(__tree&& __t, const allocator_type& __a);\n    __tree& operator=(__tree&& __t)\n        _NOEXCEPT_(\n            __node_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<value_compare>::value &&\n            is_nothrow_move_assignable<__node_allocator>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~__tree();\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin()  _NOEXCEPT {return       iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return const_iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return       iterator(__end_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return const_iterator(__end_node());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n        {return std::min<size_type>(\n                __node_traits::max_size(__node_alloc()),\n                numeric_limits<difference_type >::max());}\n\n    void clear() _NOEXCEPT;\n\n    void swap(__tree& __t)\n#if _LIBCPP_STD_VER <= 11\n        _NOEXCEPT_(\n            __is_nothrow_swappable<value_compare>::value\n            && (!__node_traits::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<__node_allocator>::value)\n            );\n#else\n        _NOEXCEPT_(__is_nothrow_swappable<value_compare>::value);\n#endif\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class _Key, class ..._Args>\n    pair<iterator, bool>\n    __emplace_unique_key_args(_Key const&, _Args&&... __args);\n    template <class _Key, class ..._Args>\n    iterator\n    __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&&...);\n\n    template <class... _Args>\n    pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);\n\n    template <class... _Args>\n    iterator __emplace_hint_unique_impl(const_iterator __p, _Args&&... __args);\n\n    template <class... _Args>\n    iterator __emplace_multi(_Args&&... __args);\n\n    template <class... _Args>\n    iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique(_Pp&& __x) {\n        return __emplace_unique_extract_key(_VSTD::forward<_Pp>(__x),\n                                            __can_extract_key<_Pp, key_type>());\n    }\n\n    template <class _First, class _Second>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        __can_extract_map_key<_First, key_type, __container_value_type>::value,\n        pair<iterator, bool>\n    >::type __emplace_unique(_First&& __f, _Second&& __s) {\n        return __emplace_unique_key_args(__f, _VSTD::forward<_First>(__f),\n                                              _VSTD::forward<_Second>(__s));\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique(_Args&&... __args) {\n        return __emplace_unique_impl(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {\n      return __emplace_unique_impl(_VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {\n      return __emplace_unique_key_args(__x, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {\n      return __emplace_unique_key_args(__x.first, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_hint_unique(const_iterator __p, _Pp&& __x) {\n        return __emplace_hint_unique_extract_key(__p, _VSTD::forward<_Pp>(__x),\n                                            __can_extract_key<_Pp, key_type>());\n    }\n\n    template <class _First, class _Second>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<\n        __can_extract_map_key<_First, key_type, __container_value_type>::value,\n        iterator\n    >::type __emplace_hint_unique(const_iterator __p, _First&& __f, _Second&& __s) {\n        return __emplace_hint_unique_key_args(__p, __f,\n                                              _VSTD::forward<_First>(__f),\n                                              _VSTD::forward<_Second>(__s));\n    }\n\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_hint_unique(const_iterator __p, _Args&&... __args) {\n        return __emplace_hint_unique_impl(__p, _VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_fail_tag) {\n      return __emplace_hint_unique_impl(__p, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_self_tag) {\n      return __emplace_hint_unique_key_args(__p, __x, _VSTD::forward<_Pp>(__x));\n    }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_first_tag) {\n      return __emplace_hint_unique_key_args(__p, __x.first, _VSTD::forward<_Pp>(__x));\n    }\n\n#else\n    template <class _Key, class _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __emplace_unique_key_args(_Key const&, _Args& __args);\n    template <class _Key, class _Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(const __container_value_type& __v) {\n        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), __v);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_unique(const_iterator __p, const __container_value_type& __v) {\n        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), __v);\n    }\n\n#ifdef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const __container_value_type& __v);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const_iterator __p, const __container_value_type& __v);\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(__container_value_type&& __v) {\n        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), _VSTD::move(__v));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_unique(const_iterator __p, __container_value_type&& __v) {\n        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), _VSTD::move(__v));\n    }\n\n    template <class _Vp, class = typename enable_if<\n            !is_same<typename __unconstref<_Vp>::type,\n                     __container_value_type\n            >::value\n        >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> __insert_unique(_Vp&& __v) {\n        return __emplace_unique(_VSTD::forward<_Vp>(__v));\n    }\n\n    template <class _Vp, class = typename enable_if<\n            !is_same<typename __unconstref<_Vp>::type,\n                     __container_value_type\n            >::value\n        >::type>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_unique(const_iterator __p, _Vp&& __v) {\n        return __emplace_hint_unique(__p, _VSTD::forward<_Vp>(__v));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(__container_value_type&& __v) {\n        return __emplace_multi(_VSTD::move(__v));\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const_iterator __p, __container_value_type&& __v) {\n        return __emplace_hint_multi(__p, _VSTD::move(__v));\n    }\n\n    template <class _Vp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(_Vp&& __v) {\n        return __emplace_multi(_VSTD::forward<_Vp>(__v));\n    }\n\n    template <class _Vp>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __insert_multi(const_iterator __p, _Vp&& __v) {\n        return __emplace_hint_multi(__p, _VSTD::forward<_Vp>(__v));\n    }\n\n#endif // !_LIBCPP_CXX03_LANG\n\n    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);\n    iterator             __node_insert_unique(const_iterator __p,\n                                              __node_pointer __nd);\n\n    iterator __node_insert_multi(__node_pointer __nd);\n    iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __f, const_iterator __l);\n    template <class _Key>\n        size_type __erase_unique(const _Key& __k);\n    template <class _Key>\n        size_type __erase_multi(const _Key& __k);\n\n    void __insert_node_at(__parent_pointer     __parent,\n                          __node_base_pointer& __child,\n                          __node_base_pointer __new_node);\n\n    template <class _Key>\n        iterator find(const _Key& __v);\n    template <class _Key>\n        const_iterator find(const _Key& __v) const;\n\n    template <class _Key>\n        size_type __count_unique(const _Key& __k) const;\n    template <class _Key>\n        size_type __count_multi(const _Key& __k) const;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator lower_bound(const _Key& __v)\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __lower_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __iter_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator lower_bound(const _Key& __v) const\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __lower_bound(const _Key& __v,\n                                     __node_pointer __root,\n                                     __iter_pointer __result) const;\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator upper_bound(const _Key& __v)\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __upper_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __iter_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator upper_bound(const _Key& __v) const\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __upper_bound(const _Key& __v,\n                                     __node_pointer __root,\n                                     __iter_pointer __result) const;\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_unique(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_unique(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_multi(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_multi(const _Key& __k) const;\n\n    typedef __tree_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n    __node_holder remove(const_iterator __p) _NOEXCEPT;\nprivate:\n    __node_base_pointer&\n        __find_leaf_low(__parent_pointer& __parent, const key_type& __v);\n    __node_base_pointer&\n        __find_leaf_high(__parent_pointer& __parent, const key_type& __v);\n    __node_base_pointer&\n        __find_leaf(const_iterator __hint,\n                    __parent_pointer& __parent, const key_type& __v);\n    // FIXME: Make this function const qualified. Unfortunetly doing so\n    // breaks existing code which uses non-const callable comparators.\n    template <class _Key>\n    __node_base_pointer&\n        __find_equal(__parent_pointer& __parent, const _Key& __v);\n    template <class _Key>\n    _LIBCPP_INLINE_VISIBILITY __node_base_pointer&\n    __find_equal(__parent_pointer& __parent, const _Key& __v) const {\n      return const_cast<__tree*>(this)->__find_equal(__parent, __v);\n    }\n    template <class _Key>\n    __node_base_pointer&\n        __find_equal(const_iterator __hint, __parent_pointer& __parent,\n                     __node_base_pointer& __dummy,\n                     const _Key& __v);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class ..._Args>\n    __node_holder __construct_node(_Args&& ...__args);\n#else\n    __node_holder __construct_node(const __container_value_type& __v);\n#endif\n\n    void destroy(__node_pointer __nd) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t)\n        {__copy_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, true_type)\n        {\n        if (__node_alloc() != __t.__node_alloc())\n        \tclear();\n        __node_alloc() = __t.__node_alloc();\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree&, false_type) {}\n\n    void __move_assign(__tree& __t, false_type);\n    void __move_assign(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n                   is_nothrow_move_assignable<__node_allocator>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<__node_allocator>::value)\n        {__move_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n        {__node_alloc() = _VSTD::move(__t.__node_alloc());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree&, false_type) _NOEXCEPT {}\n\n    __node_pointer __detach();\n    static __node_pointer __detach(__node_pointer);\n\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value)\n    : __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)\n    : __begin_node_(__iter_pointer()),\n      __pair1_(__node_allocator(__a)),\n      __pair3_(0)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,\n                                           const allocator_type& __a)\n    : __begin_node_(__iter_pointer()),\n      __pair1_(__node_allocator(__a)),\n      __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\n// Precondition:  size() != 0\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach()\n{\n    __node_pointer __cache = static_cast<__node_pointer>(__begin_node());\n    __begin_node() = __end_node();\n    __end_node()->__left_->__parent_ = nullptr;\n    __end_node()->__left_ = nullptr;\n    size() = 0;\n    // __cache->__left_ == nullptr\n    if (__cache->__right_ != nullptr)\n        __cache = static_cast<__node_pointer>(__cache->__right_);\n    // __cache->__left_ == nullptr\n    // __cache->__right_ == nullptr\n    return __cache;\n}\n\n// Precondition:  __cache != nullptr\n//    __cache->left_ == nullptr\n//    __cache->right_ == nullptr\n//    This is no longer a red-black tree\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach(__node_pointer __cache)\n{\n    if (__cache->__parent_ == nullptr)\n        return nullptr;\n    if (__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))\n    {\n        __cache->__parent_->__left_ = nullptr;\n        __cache = static_cast<__node_pointer>(__cache->__parent_);\n        if (__cache->__right_ == nullptr)\n            return __cache;\n        return static_cast<__node_pointer>(__tree_leaf(__cache->__right_));\n    }\n    // __cache is right child\n    __cache->__parent_unsafe()->__right_ = nullptr;\n    __cache = static_cast<__node_pointer>(__cache->__parent_);\n    if (__cache->__left_ == nullptr)\n        return __cache;\n    return static_cast<__node_pointer>(__tree_leaf(__cache->__left_));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t)\n{\n    if (this != &__t)\n    {\n        value_comp() = __t.value_comp();\n        __copy_assign_alloc(__t);\n        __assign_multi(__t.begin(), __t.end());\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_unique(_InputIterator __first, _InputIterator __last)\n{\n    typedef iterator_traits<_InputIterator> _ITraits;\n    typedef typename _ITraits::value_type _ItValueType;\n    static_assert((is_same<_ItValueType, __container_value_type>::value),\n                  \"__assign_unique may only be called with the containers value type\");\n\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_unique(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_unique(*__first);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)\n{\n    typedef iterator_traits<_InputIterator> _ITraits;\n    typedef typename _ITraits::value_type _ItValueType;\n    static_assert((is_same<_ItValueType, __container_value_type>::value ||\n                  is_same<_ItValueType, __node_value_type>::value),\n                  \"__assign_multi may only be called with the containers value type\"\n                  \" or the nodes value type\");\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_multi(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_multi(_NodeTypes::__get_value(*__first));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)\n    : __begin_node_(__iter_pointer()),\n      __pair1_(__node_traits::select_on_container_copy_construction(__t.__node_alloc())),\n      __pair3_(0, __t.value_comp())\n{\n    __begin_node() = __end_node();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t)\n    _NOEXCEPT_(\n        is_nothrow_move_constructible<__node_allocator>::value &&\n        is_nothrow_move_constructible<value_compare>::value)\n    : __begin_node_(_VSTD::move(__t.__begin_node_)),\n      __pair1_(_VSTD::move(__t.__pair1_)),\n      __pair3_(_VSTD::move(__t.__pair3_))\n{\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t, const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __pair3_(0, _VSTD::move(__t.value_comp()))\n{\n    if (__a == __t.__alloc())\n    {\n        if (__t.size() == 0)\n            __begin_node() = __end_node();\n        else\n        {\n            __begin_node() = __t.__begin_node();\n            __end_node()->__left_ = __t.__end_node()->__left_;\n            __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());\n            size() = __t.size();\n            __t.__begin_node() = __t.__end_node();\n            __t.__end_node()->__left_ = nullptr;\n            __t.size() = 0;\n        }\n    }\n    else\n    {\n        __begin_node() = __end_node();\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n               is_nothrow_move_assignable<__node_allocator>::value)\n{\n    destroy(static_cast<__node_pointer>(__end_node()->__left_));\n    __begin_node_ = __t.__begin_node_;\n    __pair1_.first() = __t.__pair1_.first();\n    __move_assign_alloc(__t);\n    __pair3_ = _VSTD::move(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, false_type)\n{\n    if (__node_alloc() == __t.__node_alloc())\n        __move_assign(__t, true_type());\n    else\n    {\n        value_comp() = _VSTD::move(__t.value_comp());\n        const_iterator __e = end();\n        if (size() != 0)\n        {\n            __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                while (__cache != nullptr && __t.size() != 0)\n                {\n                    __cache->__value_ = _VSTD::move(__t.remove(__t.begin())->__value_);\n                    __node_pointer __next = __detach(__cache);\n                    __node_insert_multi(__cache);\n                    __cache = __next;\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n                throw;\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__cache != nullptr)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n            }\n        }\n        while (__t.size() != 0)\n            __insert_multi(__e, _NodeTypes::__move(__t.remove(__t.begin())->__value_));\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t)\n    _NOEXCEPT_(\n        __node_traits::propagate_on_container_move_assignment::value &&\n        is_nothrow_move_assignable<value_compare>::value &&\n        is_nothrow_move_assignable<__node_allocator>::value)\n        \n{\n    __move_assign(__t, integral_constant<bool,\n                  __node_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::~__tree()\n{\n    static_assert((is_copy_constructible<value_compare>::value),\n                 \"Comparator must be copy-constructible.\");\n    destroy(__root());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) _NOEXCEPT\n{\n    if (__nd != nullptr)\n    {\n        destroy(static_cast<__node_pointer>(__nd->__left_));\n        destroy(static_cast<__node_pointer>(__nd->__right_));\n        __node_allocator& __na = __node_alloc();\n        __node_traits::destroy(__na, _NodeTypes::__get_ptr(__nd->__value_));\n        __node_traits::deallocate(__na, __nd, 1);\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)\n#if _LIBCPP_STD_VER <= 11\n        _NOEXCEPT_(\n            __is_nothrow_swappable<value_compare>::value\n            && (!__node_traits::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<__node_allocator>::value)\n            )\n#else\n        _NOEXCEPT_(__is_nothrow_swappable<value_compare>::value)\n#endif\n{\n    using _VSTD::swap;\n    swap(__begin_node_, __t.__begin_node_);\n    swap(__pair1_.first(), __t.__pair1_.first());\n    __swap_allocator(__node_alloc(), __t.__node_alloc());\n    __pair3_.swap(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());\n    if (__t.size() == 0)\n        __t.__begin_node() = __t.__end_node();\n    else\n        __t.__end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__t.__end_node());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::clear() _NOEXCEPT\n{\n    destroy(__root());\n    size() = 0;\n    __begin_node() = __end_node();\n    __end_node()->__left_ = nullptr;\n}\n\n// Find lower_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(__parent_pointer& __parent,\n                                                   const key_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__parent_pointer>(__nd);\n                    return __nd->__right_;\n                }\n            }\n            else\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__parent_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__parent_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find upper_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(__parent_pointer& __parent,\n                                                    const key_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__parent_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__parent_pointer>(__nd);\n                    return __nd->__right_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__parent_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find leaf place to insert closest to __hint\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,\n                                               __parent_pointer& __parent,\n                                               const key_type& __v)\n{\n    if (__hint == end() || !value_comp()(*__hint, __v))  // check before\n    {\n        // __v <= *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || !value_comp()(__v, *--__prior))\n        {\n            // *prev(__hint) <= __v <= *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__parent_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__parent_pointer>(__prior.__ptr_);\n                return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;\n            }\n        }\n        // __v < *prev(__hint)\n        return __find_leaf_high(__parent, __v);\n    }\n    // else __v > *__hint\n    return __find_leaf_low(__parent, __v);\n}\n\n// Find place to insert if __v doesn't exist\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(__parent_pointer& __parent,\n                                                const _Key& __v)\n{\n    __node_pointer __nd = __root();\n    __node_base_pointer* __nd_ptr = __root_ptr();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr) {\n                    __nd_ptr = _VSTD::addressof(__nd->__left_);\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                } else {\n                    __parent = static_cast<__parent_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr) {\n                    __nd_ptr = _VSTD::addressof(__nd->__right_);\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                } else {\n                    __parent = static_cast<__parent_pointer>(__nd);\n                    return __nd->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__parent_pointer>(__nd);\n                return *__nd_ptr;\n            }\n        }\n    }\n    __parent = static_cast<__parent_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find place to insert if __v doesn't exist\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,\n                                                __parent_pointer& __parent,\n                                                __node_base_pointer& __dummy,\n                                                const _Key& __v)\n{\n    if (__hint == end() || value_comp()(__v, *__hint))  // check before\n    {\n        // __v < *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || value_comp()(*--__prior, __v))\n        {\n            // *prev(__hint) < __v < *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__parent_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__parent_pointer>(__prior.__ptr_);\n                return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;\n            }\n        }\n        // __v <= *prev(__hint)\n        return __find_equal(__parent, __v);\n    }\n    else if (value_comp()(*__hint, __v))  // check after\n    {\n        // *__hint < __v\n        const_iterator __next = _VSTD::next(__hint);\n        if (__next == end() || value_comp()(__v, *__next))\n        {\n            // *__hint < __v < *_VSTD::next(__hint)\n            if (__hint.__get_np()->__right_ == nullptr)\n            {\n                __parent = static_cast<__parent_pointer>(__hint.__ptr_);\n                return static_cast<__node_base_pointer>(__hint.__ptr_)->__right_;\n            }\n            else\n            {\n                __parent = static_cast<__parent_pointer>(__next.__ptr_);\n                return __parent->__left_;\n            }\n        }\n        // *next(__hint) <= __v\n        return __find_equal(__parent, __v);\n    }\n    // else __v == *__hint\n    __parent = static_cast<__parent_pointer>(__hint.__ptr_);\n    __dummy = static_cast<__node_base_pointer>(__hint.__ptr_);\n    return __dummy;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__insert_node_at(__parent_pointer     __parent,\n                                                    __node_base_pointer& __child,\n                                                    __node_base_pointer  __new_node)\n{\n    __new_node->__left_   = nullptr;\n    __new_node->__right_  = nullptr;\n    __new_node->__parent_ = __parent;\n    // __new_node->__is_black_ is initialized in __tree_balance_after_insert\n    __child = __new_node;\n    if (__begin_node()->__left_ != nullptr)\n        __begin_node() = static_cast<__iter_pointer>(__begin_node()->__left_);\n    __tree_balance_after_insert(__end_node()->__left_, __child);\n    ++size();\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class... _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args)\n#else\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args& __args)\n#endif\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n#else\n        __node_holder __h = __construct_node(__args);\n#endif\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(\n    const_iterator __p, _Key const& __k, _Args&&... __args)\n#else\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key, class _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(\n    const_iterator __p, _Key const& __k, _Args& __args)\n#endif\n{\n    __parent_pointer __parent;\n    __node_base_pointer __dummy;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n#ifndef _LIBCPP_CXX03_LANG\n        __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n#else\n        __node_holder __h = __construct_node(__args);\n#endif\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args&& ...__args)\n{\n    static_assert(!__is_tree_value_type<_Args...>::value,\n                  \"Cannot construct from __value_type\");\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__value_constructed = true;\n    return __h;\n}\n\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique_impl(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_impl(const_iterator __p, _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __parent_pointer __parent;\n    __node_base_pointer __dummy;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__h->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,\n                                                        _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__h->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\n\n#else  // _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(const __container_value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#ifdef _LIBCPP_CXX03_LANG\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const __container_value_type& __v)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__v));\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const_iterator __p, const __container_value_type& __v)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__v));\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n#endif\n\ntemplate <class _Tp, class _Compare, class _Allocator>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(__node_pointer __nd)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(const_iterator __p,\n                                                        __node_pointer __nd)\n{\n    __parent_pointer __parent;\n    __node_base_pointer __dummy;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__nd->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,\n                                                       __node_pointer __nd)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__nd->__value_));\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p)\n{\n    __node_pointer __np = __p.__get_np();\n    iterator __r(__p.__ptr_);\n    ++__r;\n    if (__begin_node() == __p.__ptr_)\n        __begin_node() = __r.__ptr_;\n    --size();\n    __node_allocator& __na = __node_alloc();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    __node_traits::destroy(__na, _NodeTypes::__get_ptr(\n        const_cast<__node_value_type&>(*__p)));\n    __node_traits::deallocate(__na, __np, 1);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l)\n{\n    while (__f != __l)\n        __f = erase(__f);\n    return iterator(__l.__ptr_);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k)\n{\n    iterator __i = find(__k);\n    if (__i == end())\n        return 0;\n    erase(__i);\n    return 1;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k)\n{\n    pair<iterator, iterator> __p = __equal_range_multi(__k);\n    size_type __r = 0;\n    for (; __p.first != __p.second; ++__r)\n        __p.first = erase(__p.first);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v)\n{\n    iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const\n{\n    const_iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const\n{\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const\n{\n    __iter_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__rt);\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _VSTD::distance(\n                __lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),\n                __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result)\n            );\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __iter_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = static_cast<__iter_pointer>(__root);\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __iter_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = static_cast<__iter_pointer>(__root);\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __iter_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__root);\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __iter_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__root);\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __iter_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__rt);\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(iterator(__rt),\n                      iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__iter_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __iter_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__rt);\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(const_iterator(__rt),\n                      const_iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__iter_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __iter_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__rt);\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),\n                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __iter_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = static_cast<__iter_pointer>(__rt);\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),\n                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) _NOEXCEPT\n{\n    __node_pointer __np = __p.__get_np();\n    if (__begin_node() == __p.__ptr_)\n    {\n        if (__np->__right_ != nullptr)\n            __begin_node() = static_cast<__iter_pointer>(__np->__right_);\n        else\n            __begin_node() = static_cast<__iter_pointer>(__np->__parent_);\n    }\n    --size();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    return __node_holder(__np, _Dp(__node_alloc(), true));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__tree<_Tp, _Compare, _Allocator>& __x,\n     __tree<_Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___TREE\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL_BASE\n#define _LIBCPP_FUNCTIONAL_BASE\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <new>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Arg, class _Result>\nstruct _LIBCPP_TEMPLATE_VIS unary_function\n{\n    typedef _Arg    argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nstruct _LIBCPP_TEMPLATE_VIS binary_function\n{\n    typedef _Arg1   first_argument_type;\n    typedef _Arg2   second_argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Tp>\nstruct __has_result_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::result_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TEMPLATE_VIS less : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY \n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x < __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS less<void>\n{\n    template <class _T1, class _T2> \n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n    _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u)))\n    -> decltype        (_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u))\n        { return        _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n// __weak_result_type\n\ntemplate <class _Tp>\nstruct __derives_from_unary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _Ap, class _Rp>\n        static unary_function<_Ap, _Rp>\n        __test(const volatile unary_function<_Ap, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp>\nstruct __derives_from_binary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _A1, class _A2, class _Rp>\n        static binary_function<_A1, _A2, _Rp>\n        __test(const volatile binary_function<_A1, _A2, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp, bool = __derives_from_unary_function<_Tp>::value>\nstruct __maybe_derive_from_unary_function  // bool is true\n    : public __derives_from_unary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_unary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __derives_from_binary_function<_Tp>::value>\nstruct __maybe_derive_from_binary_function  // bool is true\n    : public __derives_from_binary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_binary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __has_result_type<_Tp>::value>\nstruct __weak_result_type_imp // bool is true\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n    typedef typename _Tp::result_type result_type;\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type_imp<_Tp, false>\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type\n    : public __weak_result_type_imp<_Tp>\n{\n};\n\n// 0 argument case\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp ()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (&)()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (*)()>\n{\n    typedef _Rp result_type;\n};\n\n// 1 argument case\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (&)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (*)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)()>\n    : public unary_function<_Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const>\n    : public unary_function<const _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() volatile>\n    : public unary_function<volatile _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const volatile>\n    : public unary_function<const volatile _Cp*, _Rp>\n{\n};\n\n// 2 argument case\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (*)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (&)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1)>\n    : public binary_function<_Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const>\n    : public binary_function<const _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>\n    : public binary_function<volatile _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>\n    : public binary_function<const volatile _Cp*, _A1, _Rp>\n{\n};\n\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n// 3 or more arguments\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>\n{\n    typedef _Rp result_type;\n};\n\n#endif // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp, class ..._Args>\nstruct __invoke_return\n{\n    typedef decltype(__invoke(_VSTD::declval<_Tp>(), _VSTD::declval<_Args>()...)) type;\n};\n\n#else // defined(_LIBCPP_CXX03_LANG)\n\n#include <__functional_base_03>\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\n\ntemplate <class _Ret>\nstruct __invoke_void_return_wrapper\n{\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class ..._Args>\n    static _Ret __call(_Args&&... __args) {\n        return __invoke(_VSTD::forward<_Args>(__args)...);\n    }\n#else\n    template <class _Fn>\n    static _Ret __call(_Fn __f) {\n        return __invoke(__f);\n    }\n\n    template <class _Fn, class _A0>\n    static _Ret __call(_Fn __f, _A0& __a0) {\n        return __invoke(__f, __a0);\n    }\n\n    template <class _Fn, class _A0, class _A1>\n    static _Ret __call(_Fn __f, _A0& __a0, _A1& __a1) {\n        return __invoke(__f, __a0, __a1);\n    }\n\n    template <class _Fn, class _A0, class _A1, class _A2>\n    static _Ret __call(_Fn __f, _A0& __a0, _A1& __a1, _A2& __a2){\n        return __invoke(__f, __a0, __a1, __a2);\n    }\n#endif\n};\n\ntemplate <>\nstruct __invoke_void_return_wrapper<void>\n{\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class ..._Args>\n    static void __call(_Args&&... __args) {\n        __invoke(_VSTD::forward<_Args>(__args)...);\n    }\n#else\n    template <class _Fn>\n    static void __call(_Fn __f) {\n        __invoke(__f);\n    }\n\n    template <class _Fn, class _A0>\n    static void __call(_Fn __f, _A0& __a0) {\n        __invoke(__f, __a0);\n    }\n\n    template <class _Fn, class _A0, class _A1>\n    static void __call(_Fn __f, _A0& __a0, _A1& __a1) {\n        __invoke(__f, __a0, __a1);\n    }\n\n    template <class _Fn, class _A0, class _A1, class _A2>\n    static void __call(_Fn __f, _A0& __a0, _A1& __a1, _A2& __a2) {\n        __invoke(__f, __a0, __a1, __a2);\n    }\n#endif\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS reference_wrapper\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type* __f_;\n\npublic:\n    // construct/copy/destroy\n    _LIBCPP_INLINE_VISIBILITY reference_wrapper(type& __f) _NOEXCEPT\n        : __f_(_VSTD::addressof(__f)) {}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    private: reference_wrapper(type&&); public: // = delete; // do not bind to temps\n#endif\n\n    // access\n    _LIBCPP_INLINE_VISIBILITY operator type&    () const _NOEXCEPT {return *__f_;}\n    _LIBCPP_INLINE_VISIBILITY          type& get() const _NOEXCEPT {return *__f_;}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    // invoke\n    template <class... _ArgTypes>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_of<type&, _ArgTypes...>::type\n    operator() (_ArgTypes&&... __args) const {\n        return __invoke(get(), _VSTD::forward<_ArgTypes>(__args)...);\n    }\n#else\n\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return<type>::type\n    operator() () const {\n        return __invoke(get());\n    }\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0>::type\n    operator() (_A0& __a0) const {\n        return __invoke(get(), __a0);\n    }\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return0<type, _A0 const>::type\n    operator() (_A0 const& __a0) const {\n        return __invoke(get(), __a0);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1>::type\n    operator() (_A0& __a0, _A1& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1>::type\n    operator() (_A0 const& __a0, _A1& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0, _A1 const>::type\n    operator() (_A0& __a0, _A1 const& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return1<type, _A0 const, _A1 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1) const {\n        return __invoke(get(), __a0, __a1);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2>::type\n    operator() (_A0& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1, _A2 const>::type\n    operator() (_A0& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1, _A2 const>::type\n    operator() (_A0 const& __a0, _A1& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0, _A1 const, _A2 const>::type\n    operator() (_A0& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n\n    template <class _A0, class _A1, class _A2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename __invoke_return2<type, _A0 const, _A1 const, _A2 const>::type\n    operator() (_A0 const& __a0, _A1 const& __a1, _A2 const& __a2) const {\n        return __invoke(get(), __a0, __a1, __a2);\n    }\n#endif // _LIBCPP_HAS_NO_VARIADICS\n};\n\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(_Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<_Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return ref(__t.get());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(const _Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<const _Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return cref(__t.get());\n}\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp> void ref(const _Tp&&) = delete;\ntemplate <class _Tp> void cref(const _Tp&&) = delete;\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp1, class _Tp2 = void>\nstruct __is_transparent\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_transparent* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp1>(0)) == 1;\n};\n#endif\n\n// allocator_arg_t\n\nstruct _LIBCPP_TEMPLATE_VIS allocator_arg_t { };\n\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_MEMORY)\nextern const allocator_arg_t allocator_arg;\n#else\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n#endif\n\n// uses_allocator\n\ntemplate <class _Tp>\nstruct __has_allocator_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::allocator_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>\nstruct __uses_allocator\n    : public integral_constant<bool,\n        is_convertible<_Alloc, typename _Tp::allocator_type>::value>\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct __uses_allocator<_Tp, _Alloc, false>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct _LIBCPP_TEMPLATE_VIS uses_allocator\n    : public __uses_allocator<_Tp, _Alloc>\n{\n};\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _Tp, class _Alloc>\nconstexpr size_t uses_allocator_v = uses_allocator<_Tp, _Alloc>::value;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// allocator construction\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor_imp\n{\n    typedef typename __uncvref<_Alloc>::type _RawAlloc;\n    static const bool __ua = uses_allocator<_Tp, _RawAlloc>::value;\n    static const bool __ic =\n        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;\n    static const int value = __ua ? 2 - __ic : 0;\n};\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor\n    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>\n    {};\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)...);\n}\n\n// FIXME: This should have a version which takes a non-const alloc.\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (allocator_arg, __a, _VSTD::forward<_Args>(__args)...);\n}\n\n// FIXME: This should have a version which takes a non-const alloc.\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)..., __a);\n}\n\n// FIXME: Theis should have a version which takes a non-const alloc.\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args)\n{ \n    __user_alloc_construct_impl( \n             __uses_alloc_ctor<_Tp, _Allocator>(), \n             __storage, __a, _VSTD::forward<_Args>(__args)...\n        );\n}\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL_BASE\n","/*\n *  ether.h - Ethernet device driver\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef ETHER_H\n#define ETHER_H\n\nstruct sockaddr_in;\n\nextern void EtherInit(void);\nextern void EtherExit(void);\n\nextern int16 EtherOpen(uint32 pb, uint32 dce);\nextern int16 EtherControl(uint32 pb, uint32 dce);\nextern void EtherReadPacket(uint32 &src, uint32 &dest, uint32 &len, uint32 &remaining);\n\n// System specific and internal functions/data\nextern void EtherReset(void);\nextern void EtherInterrupt(void);\n\nextern bool ether_init(void);\nextern void ether_exit(void);\nextern void ether_reset(void);\nextern int16 ether_add_multicast(uint32 pb);\nextern int16 ether_del_multicast(uint32 pb);\nextern int16 ether_attach_ph(uint16 type, uint32 handler);\nextern int16 ether_detach_ph(uint16 type);\nextern int16 ether_write(uint32 wds);\nextern bool ether_start_udp_thread(int socket_fd);\nextern void ether_stop_udp_thread(void);\nextern void ether_udp_read(uint32 packet, int length, struct sockaddr_in *from);\n\nextern uint8 ether_addr[6];\t// Ethernet address (set by ether_init())\n\n// Ethernet driver data in MacOS RAM\nenum {\n\ted_DeferredTask = 0,\t// Deferred Task struct\n\ted_Code = 20,\t\t\t// DT code is stored here\n\ted_Result = 30,\t\t\t// Result for DT\n\ted_DCE = 34,\t\t\t// DCE for DT (must come directly behind ed_Result)\n\ted_RHA = 38,\t\t\t// Read header area\n\ted_ReadPacket = 52,\t\t// ReadPacket/ReadRest routines\n\tSIZEOF_etherdata = 76\n};\n\nextern uint32 ether_data;\t// Mac address of driver data in MacOS RAM\n\n// Ethernet packet allocator (optimized for 32-bit platforms in real addressing mode)\nclass EthernetPacket {\n#if SIZEOF_VOID_P == 4 && REAL_ADDRESSING\n\tuint8 packet[1516];\n public:\n\tuint32 addr(void) const { return (uint32)packet; }\n#else\n\tuint32 packet;\n public:\n\tEthernetPacket();\n\t~EthernetPacket();\n\tuint32 addr(void) const { return packet; }\n#endif\n};\n\n// Copy packet data from WDS to linear buffer (must hold at least 1514 bytes),\n// returns packet length\nstatic inline int ether_wds_to_buffer(uint32 wds, uint8 *p)\n{\n\tint len = 0;\n\twhile (len < 1514) {\n\t\tint w = ReadMacInt16(wds);\n\t\tif (w == 0)\n\t\t\tbreak;\n\t\tMac2Host_memcpy(p, ReadMacInt32(wds + 2), w);\n\t\tlen += w;\n\t\tp += w;\n\t\twds += 6;\n\t}\n\treturn len;\n}\n\n#endif\n","/*\nOriginal code by Lee Thomason (www.grinninglizard.com)\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any\ndamages arising from the use of this software.\n\nPermission is granted to anyone to use this software for any\npurpose, including commercial applications, and to alter it and\nredistribute it freely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must\nnot claim that you wrote the original software. If you use this\nsoftware in a product, an acknowledgment in the product documentation\nwould be appreciated but is not required.\n\n2. Altered source versions must be plainly marked as such, and\nmust not be misrepresented as being the original software.\n\n3. This notice may not be removed or altered from any source\ndistribution.\n*/\n\n#ifndef TINYXML2_INCLUDED\n#define TINYXML2_INCLUDED\n\n#if defined(ANDROID_NDK) || defined(__BORLANDC__)\n#   include <ctype.h>\n#   include <limits.h>\n#   include <stdio.h>\n#   include <stdlib.h>\n#   include <string.h>\n#   include <stdarg.h>\n#else\n#   include <cctype>\n#   include <climits>\n#   include <cstdio>\n#   include <cstdlib>\n#   include <cstring>\n#   include <cstdarg>\n#endif\n\n/*\n   TODO: intern strings instead of allocation.\n*/\n/*\n\tgcc:\n        g++ -Wall -DDEBUG tinyxml2.cpp xmltest.cpp -o gccxmltest.exe\n\n    Formatting, Artistic Style:\n        AStyle.exe --style=1tbs --indent-switches --break-closing-brackets --indent-preprocessor tinyxml2.cpp tinyxml2.h\n*/\n\n#if defined( _DEBUG ) || defined( DEBUG ) || defined (__DEBUG__)\n#   ifndef DEBUG\n#       define DEBUG\n#   endif\n#endif\n\n\n#if defined(DEBUG)\n#   if defined(_MSC_VER)\n#       define TIXMLASSERT( x )           if ( !(x)) { __debugbreak(); } //if ( !(x)) WinDebugBreak()\n#   elif defined (ANDROID_NDK)\n#       include <android/log.h>\n#       define TIXMLASSERT( x )           if ( !(x)) { __android_log_assert( \"assert\", \"grinliz\", \"ASSERT in '%s' at %d.\", __FILE__, __LINE__ ); }\n#   else\n#       include <assert.h>\n#       define TIXMLASSERT                assert\n#   endif\n#   else\n#       define TIXMLASSERT( x )           {}\n#endif\n\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1400 )\n// Microsoft visual studio, version 2005 and higher.\n/*int _snprintf_s(\n   char *buffer,\n   size_t sizeOfBuffer,\n   size_t count,\n   const char *format [,\n\t  argument] ...\n);*/\ninline int TIXML_SNPRINTF( char* buffer, size_t size, const char* format, ... )\n{\n    va_list va;\n    va_start( va, format );\n    int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );\n    va_end( va );\n    return result;\n}\n#define TIXML_SSCANF   sscanf_s\n#else\n// GCC version 3 and higher\n//#warning( \"Using sn* functions.\" )\n#define TIXML_SNPRINTF snprintf\n#define TIXML_SSCANF   sscanf\n#endif\n\nstatic const int TIXML2_MAJOR_VERSION = 1;\nstatic const int TIXML2_MINOR_VERSION = 0;\nstatic const int TIXML2_PATCH_VERSION = 11;\n\nnamespace tinyxml2\n{\nclass XMLDocument;\nclass XMLElement;\nclass XMLAttribute;\nclass XMLComment;\nclass XMLNode;\nclass XMLText;\nclass XMLDeclaration;\nclass XMLUnknown;\n\nclass XMLPrinter;\n\n/*\n\tA class that wraps strings. Normally stores the start and end\n\tpointers into the XML file itself, and will apply normalization\n\tand entity translation if actually read. Can also store (and memory\n\tmanage) a traditional char[]\n*/\nclass StrPair\n{\npublic:\n    enum {\n        NEEDS_ENTITY_PROCESSING\t\t\t= 0x01,\n        NEEDS_NEWLINE_NORMALIZATION\t\t= 0x02,\n        COLLAPSE_WHITESPACE\t\t\t\t= 0x04,\n\n        TEXT_ELEMENT\t\t            = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,\n        TEXT_ELEMENT_LEAVE_ENTITIES\t\t= NEEDS_NEWLINE_NORMALIZATION,\n        ATTRIBUTE_NAME\t\t            = 0,\n        ATTRIBUTE_VALUE\t\t            = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,\n        ATTRIBUTE_VALUE_LEAVE_ENTITIES  = NEEDS_NEWLINE_NORMALIZATION,\n        COMMENT\t\t\t\t            = NEEDS_NEWLINE_NORMALIZATION\n    };\n\n    StrPair() : _flags( 0 ), _start( 0 ), _end( 0 ) {}\n    ~StrPair();\n\n    void Set( char* start, char* end, int flags ) {\n        Reset();\n        _start  = start;\n        _end    = end;\n        _flags  = flags | NEEDS_FLUSH;\n    }\n\n    const char* GetStr();\n\n    bool Empty() const {\n        return _start == _end;\n    }\n\n    void SetInternedStr( const char* str ) {\n        Reset();\n        _start = const_cast<char*>(str);\n    }\n\n    void SetStr( const char* str, int flags=0 );\n\n    char* ParseText( char* in, const char* endTag, int strFlags );\n    char* ParseName( char* in );\n\nprivate:\n    void Reset();\n    void CollapseWhitespace();\n\n    enum {\n        NEEDS_FLUSH = 0x100,\n        NEEDS_DELETE = 0x200\n    };\n\n    // After parsing, if *end != 0, it can be set to zero.\n    int     _flags;\n    char*   _start;\n    char*   _end;\n};\n\n\n/*\n\tA dynamic array of Plain Old Data. Doesn't support constructors, etc.\n\tHas a small initial memory pool, so that low or no usage will not\n\tcause a call to new/delete\n*/\ntemplate <class T, int INIT>\nclass DynArray\n{\npublic:\n    DynArray< T, INIT >() {\n        _mem = _pool;\n        _allocated = INIT;\n        _size = 0;\n    }\n\n    ~DynArray() {\n        if ( _mem != _pool ) {\n            delete [] _mem;\n        }\n    }\n\n    void Push( T t ) {\n        EnsureCapacity( _size+1 );\n        _mem[_size++] = t;\n    }\n\n    T* PushArr( int count ) {\n        EnsureCapacity( _size+count );\n        T* ret = &_mem[_size];\n        _size += count;\n        return ret;\n    }\n\n    T Pop() {\n        return _mem[--_size];\n    }\n\n    void PopArr( int count ) {\n        TIXMLASSERT( _size >= count );\n        _size -= count;\n    }\n\n    bool Empty() const\t\t\t\t\t{\n        return _size == 0;\n    }\n\n    T& operator[](int i)\t\t\t\t{\n        TIXMLASSERT( i>= 0 && i < _size );\n        return _mem[i];\n    }\n\n    const T& operator[](int i) const\t{\n        TIXMLASSERT( i>= 0 && i < _size );\n        return _mem[i];\n    }\n\n    int Size() const\t\t\t\t\t{\n        return _size;\n    }\n\n    int Capacity() const\t\t\t\t{\n        return _allocated;\n    }\n\n    const T* Mem() const\t\t\t\t{\n        return _mem;\n    }\n\n    T* Mem()\t\t\t\t\t\t\t{\n        return _mem;\n    }\n\nprivate:\n    void EnsureCapacity( int cap ) {\n        if ( cap > _allocated ) {\n            int newAllocated = cap * 2;\n            T* newMem = new T[newAllocated];\n            memcpy( newMem, _mem, sizeof(T)*_size );\t// warning: not using constructors, only works for PODs\n            if ( _mem != _pool ) {\n                delete [] _mem;\n            }\n            _mem = newMem;\n            _allocated = newAllocated;\n        }\n    }\n\n    T*  _mem;\n    T   _pool[INIT];\n    int _allocated;\t\t// objects allocated\n    int _size;\t\t\t// number objects in use\n};\n\n\n/*\n\tParent virtual class of a pool for fast allocation\n\tand deallocation of objects.\n*/\nclass MemPool\n{\npublic:\n    MemPool() {}\n    virtual ~MemPool() {}\n\n    virtual int ItemSize() const = 0;\n    virtual void* Alloc() = 0;\n    virtual void Free( void* ) = 0;\n    virtual void SetTracked() = 0;\n};\n\n\n/*\n\tTemplate child class to create pools of the correct type.\n*/\ntemplate< int SIZE >\nclass MemPoolT : public MemPool\n{\npublic:\n    MemPoolT() : _root(0), _currentAllocs(0), _nAllocs(0), _maxAllocs(0), _nUntracked(0)\t{}\n    ~MemPoolT() {\n        // Delete the blocks.\n        for( int i=0; i<_blockPtrs.Size(); ++i ) {\n            delete _blockPtrs[i];\n        }\n    }\n\n    virtual int ItemSize() const\t{\n        return SIZE;\n    }\n    int CurrentAllocs() const\t\t{\n        return _currentAllocs;\n    }\n\n    virtual void* Alloc() {\n        if ( !_root ) {\n            // Need a new block.\n            Block* block = new Block();\n            _blockPtrs.Push( block );\n\n            for( int i=0; i<COUNT-1; ++i ) {\n                block->chunk[i].next = &block->chunk[i+1];\n            }\n            block->chunk[COUNT-1].next = 0;\n            _root = block->chunk;\n        }\n        void* result = _root;\n        _root = _root->next;\n\n        ++_currentAllocs;\n        if ( _currentAllocs > _maxAllocs ) {\n            _maxAllocs = _currentAllocs;\n        }\n        _nAllocs++;\n        _nUntracked++;\n        return result;\n    }\n    virtual void Free( void* mem ) {\n        if ( !mem ) {\n            return;\n        }\n        --_currentAllocs;\n        Chunk* chunk = (Chunk*)mem;\n#ifdef DEBUG\n        memset( chunk, 0xfe, sizeof(Chunk) );\n#endif\n        chunk->next = _root;\n        _root = chunk;\n    }\n    void Trace( const char* name ) {\n        printf( \"Mempool %s watermark=%d [%dk] current=%d size=%d nAlloc=%d blocks=%d\\n\",\n                name, _maxAllocs, _maxAllocs*SIZE/1024, _currentAllocs, SIZE, _nAllocs, _blockPtrs.Size() );\n    }\n\n    void SetTracked() {\n        _nUntracked--;\n    }\n\n    int Untracked() const {\n        return _nUntracked;\n    }\n\n\t// This number is perf sensitive. 4k seems like a good tradeoff on my machine.\n\t// The test file is large, 170k.\n\t// Release:\t\tVS2010 gcc(no opt)\n\t//\t\t1k:\t\t4000\n\t//\t\t2k:\t\t4000\n\t//\t\t4k:\t\t3900\t21000\n\t//\t\t16k:\t5200\n\t//\t\t32k:\t4300\n\t//\t\t64k:\t4000\t21000\n    enum { COUNT = (4*1024)/SIZE }; // Some compilers do not accept to use COUNT in private part if COUNT is private\n\nprivate:\n    union Chunk {\n        Chunk*  next;\n        char    mem[SIZE];\n    };\n    struct Block {\n        Chunk chunk[COUNT];\n    };\n    DynArray< Block*, 10 > _blockPtrs;\n    Chunk* _root;\n\n    int _currentAllocs;\n    int _nAllocs;\n    int _maxAllocs;\n    int _nUntracked;\n};\n\n\n\n/**\n\tImplements the interface to the \"Visitor pattern\" (see the Accept() method.)\n\tIf you call the Accept() method, it requires being passed a XMLVisitor\n\tclass to handle callbacks. For nodes that contain other nodes (Document, Element)\n\tyou will get called with a VisitEnter/VisitExit pair. Nodes that are always leafs\n\tare simply called with Visit().\n\n\tIf you return 'true' from a Visit method, recursive parsing will continue. If you return\n\tfalse, <b>no children of this node or its sibilings</b> will be visited.\n\n\tAll flavors of Visit methods have a default implementation that returns 'true' (continue\n\tvisiting). You need to only override methods that are interesting to you.\n\n\tGenerally Accept() is called on the TiXmlDocument, although all nodes support visiting.\n\n\tYou should never change the document from a callback.\n\n\t@sa XMLNode::Accept()\n*/\nclass XMLVisitor\n{\npublic:\n    virtual ~XMLVisitor() {}\n\n    /// Visit a document.\n    virtual bool VisitEnter( const XMLDocument& /*doc*/ )\t\t\t{\n        return true;\n    }\n    /// Visit a document.\n    virtual bool VisitExit( const XMLDocument& /*doc*/ )\t\t\t{\n        return true;\n    }\n\n    /// Visit an element.\n    virtual bool VisitEnter( const XMLElement& /*element*/, const XMLAttribute* /*firstAttribute*/ )\t{\n        return true;\n    }\n    /// Visit an element.\n    virtual bool VisitExit( const XMLElement& /*element*/ )\t\t\t{\n        return true;\n    }\n\n    /// Visit a declaration.\n    virtual bool Visit( const XMLDeclaration& /*declaration*/ )\t\t{\n        return true;\n    }\n    /// Visit a text node.\n    virtual bool Visit( const XMLText& /*text*/ )\t\t\t\t\t{\n        return true;\n    }\n    /// Visit a comment node.\n    virtual bool Visit( const XMLComment& /*comment*/ )\t\t\t\t{\n        return true;\n    }\n    /// Visit an unknown node.\n    virtual bool Visit( const XMLUnknown& /*unknown*/ )\t\t\t\t{\n        return true;\n    }\n};\n\n\n/*\n\tUtility functionality.\n*/\nclass XMLUtil\n{\npublic:\n    // Anything in the high order range of UTF-8 is assumed to not be whitespace. This isn't\n    // correct, but simple, and usually works.\n    static const char* SkipWhiteSpace( const char* p )\t{\n        while( !IsUTF8Continuation(*p) && isspace( *reinterpret_cast<const unsigned char*>(p) ) ) {\n            ++p;\n        }\n        return p;\n    }\n    static char* SkipWhiteSpace( char* p )\t\t\t\t{\n        while( !IsUTF8Continuation(*p) && isspace( *reinterpret_cast<unsigned char*>(p) ) )\t\t{\n            ++p;\n        }\n        return p;\n    }\n    static bool IsWhiteSpace( char p )\t\t\t\t\t{\n        return !IsUTF8Continuation(p) && isspace( static_cast<unsigned char>(p) );\n    }\n    \n    inline static bool IsNameStartChar( unsigned char ch ) {\n        return ( ( ch < 128 ) ? isalpha( ch ) : 1 )\n               || ch == ':'\n               || ch == '_';\n    }\n    \n    inline static bool IsNameChar( unsigned char ch ) {\n        return IsNameStartChar( ch )\n               || isdigit( ch )\n               || ch == '.'\n               || ch == '-';\n    }\n\n    inline static bool StringEqual( const char* p, const char* q, int nChar=INT_MAX )  {\n        int n = 0;\n        if ( p == q ) {\n            return true;\n        }\n        while( *p && *q && *p == *q && n<nChar ) {\n            ++p;\n            ++q;\n            ++n;\n        }\n        if ( (n == nChar) || ( *p == 0 && *q == 0 ) ) {\n            return true;\n        }\n        return false;\n    }\n    \n    inline static int IsUTF8Continuation( const char p ) {\n        return p & 0x80;\n    }\n\n    static const char* ReadBOM( const char* p, bool* hasBOM );\n    // p is the starting location,\n    // the UTF-8 value of the entity will be placed in value, and length filled in.\n    static const char* GetCharacterRef( const char* p, char* value, int* length );\n    static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );\n\n    // converts primitive types to strings\n    static void ToStr( int v, char* buffer, int bufferSize );\n    static void ToStr( unsigned v, char* buffer, int bufferSize );\n    static void ToStr( bool v, char* buffer, int bufferSize );\n    static void ToStr( float v, char* buffer, int bufferSize );\n    static void ToStr( double v, char* buffer, int bufferSize );\n\n    // converts strings to primitive types\n    static bool\tToInt( const char* str, int* value );\n    static bool ToUnsigned( const char* str, unsigned* value );\n    static bool\tToBool( const char* str, bool* value );\n    static bool\tToFloat( const char* str, float* value );\n    static bool ToDouble( const char* str, double* value );\n};\n\n\n/** XMLNode is a base class for every object that is in the\n\tXML Document Object Model (DOM), except XMLAttributes.\n\tNodes have siblings, a parent, and children which can\n\tbe navigated. A node is always in a XMLDocument.\n\tThe type of a XMLNode can be queried, and it can\n\tbe cast to its more defined type.\n\n\tA XMLDocument allocates memory for all its Nodes.\n\tWhen the XMLDocument gets deleted, all its Nodes\n\twill also be deleted.\n\n\t@verbatim\n\tA Document can contain:\tElement\t(container or leaf)\n\t\t\t\t\t\t\tComment (leaf)\n\t\t\t\t\t\t\tUnknown (leaf)\n\t\t\t\t\t\t\tDeclaration( leaf )\n\n\tAn Element can contain:\tElement (container or leaf)\n\t\t\t\t\t\t\tText\t(leaf)\n\t\t\t\t\t\t\tAttributes (not on tree)\n\t\t\t\t\t\t\tComment (leaf)\n\t\t\t\t\t\t\tUnknown (leaf)\n\n\t@endverbatim\n*/\nclass XMLNode\n{\n    friend class XMLDocument;\n    friend class XMLElement;\npublic:\n\n    /// Get the XMLDocument that owns this XMLNode.\n    const XMLDocument* GetDocument() const\t{\n        return _document;\n    }\n    /// Get the XMLDocument that owns this XMLNode.\n    XMLDocument* GetDocument()\t\t\t\t{\n        return _document;\n    }\n\n    /// Safely cast to an Element, or null.\n    virtual XMLElement*\t\tToElement()\t\t{\n        return 0;\n    }\n    /// Safely cast to Text, or null.\n    virtual XMLText*\t\tToText()\t\t{\n        return 0;\n    }\n    /// Safely cast to a Comment, or null.\n    virtual XMLComment*\t\tToComment()\t\t{\n        return 0;\n    }\n    /// Safely cast to a Document, or null.\n    virtual XMLDocument*\tToDocument()\t{\n        return 0;\n    }\n    /// Safely cast to a Declaration, or null.\n    virtual XMLDeclaration*\tToDeclaration()\t{\n        return 0;\n    }\n    /// Safely cast to an Unknown, or null.\n    virtual XMLUnknown*\t\tToUnknown()\t\t{\n        return 0;\n    }\n\n    virtual const XMLElement*\t\tToElement() const\t\t{\n        return 0;\n    }\n    virtual const XMLText*\t\t\tToText() const\t\t\t{\n        return 0;\n    }\n    virtual const XMLComment*\t\tToComment() const\t\t{\n        return 0;\n    }\n    virtual const XMLDocument*\t\tToDocument() const\t\t{\n        return 0;\n    }\n    virtual const XMLDeclaration*\tToDeclaration() const\t{\n        return 0;\n    }\n    virtual const XMLUnknown*\t\tToUnknown() const\t\t{\n        return 0;\n    }\n\n    /** The meaning of 'value' changes for the specific type.\n    \t@verbatim\n    \tDocument:\tempty\n    \tElement:\tname of the element\n    \tComment:\tthe comment text\n    \tUnknown:\tthe tag contents\n    \tText:\t\tthe text string\n    \t@endverbatim\n    */\n    const char* Value() const\t\t\t{\n        return _value.GetStr();\n    }\n\n    /** Set the Value of an XML node.\n    \t@sa Value()\n    */\n    void SetValue( const char* val, bool staticMem=false );\n\n    /// Get the parent of this node on the DOM.\n    const XMLNode*\tParent() const\t\t\t{\n        return _parent;\n    }\n\n    XMLNode* Parent()\t\t\t\t\t\t{\n        return _parent;\n    }\n\n    /// Returns true if this node has no children.\n    bool NoChildren() const\t\t\t\t\t{\n        return !_firstChild;\n    }\n\n    /// Get the first child node, or null if none exists.\n    const XMLNode*  FirstChild() const\t\t{\n        return _firstChild;\n    }\n\n    XMLNode*\t\tFirstChild()\t\t\t{\n        return _firstChild;\n    }\n\n    /** Get the first child element, or optionally the first child\n        element with the specified name.\n    */\n    const XMLElement* FirstChildElement( const char* value=0 ) const;\n\n    XMLElement* FirstChildElement( const char* value=0 )\t{\n        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->FirstChildElement( value ));\n    }\n\n    /// Get the last child node, or null if none exists.\n    const XMLNode*\tLastChild() const\t\t\t\t\t\t{\n        return _lastChild;\n    }\n\n    XMLNode*\t\tLastChild()\t\t\t\t\t\t\t\t{\n        return const_cast<XMLNode*>(const_cast<const XMLNode*>(this)->LastChild() );\n    }\n\n    /** Get the last child element or optionally the last child\n        element with the specified name.\n    */\n    const XMLElement* LastChildElement( const char* value=0 ) const;\n\n    XMLElement* LastChildElement( const char* value=0 )\t{\n        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->LastChildElement(value) );\n    }\n\n    /// Get the previous (left) sibling node of this node.\n    const XMLNode*\tPreviousSibling() const\t\t\t\t\t{\n        return _prev;\n    }\n\n    XMLNode*\tPreviousSibling()\t\t\t\t\t\t\t{\n        return _prev;\n    }\n\n    /// Get the previous (left) sibling element of this node, with an opitionally supplied name.\n    const XMLElement*\tPreviousSiblingElement( const char* value=0 ) const ;\n\n    XMLElement*\tPreviousSiblingElement( const char* value=0 ) {\n        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->PreviousSiblingElement( value ) );\n    }\n\n    /// Get the next (right) sibling node of this node.\n    const XMLNode*\tNextSibling() const\t\t\t\t\t\t{\n        return _next;\n    }\n\n    XMLNode*\tNextSibling()\t\t\t\t\t\t\t\t{\n        return _next;\n    }\n\n    /// Get the next (right) sibling element of this node, with an opitionally supplied name.\n    const XMLElement*\tNextSiblingElement( const char* value=0 ) const;\n\n    XMLElement*\tNextSiblingElement( const char* value=0 )\t{\n        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->NextSiblingElement( value ) );\n    }\n\n    /**\n    \tAdd a child node as the last (right) child.\n    */\n    XMLNode* InsertEndChild( XMLNode* addThis );\n\n    XMLNode* LinkEndChild( XMLNode* addThis )\t{\n        return InsertEndChild( addThis );\n    }\n    /**\n    \tAdd a child node as the first (left) child.\n    */\n    XMLNode* InsertFirstChild( XMLNode* addThis );\n    /**\n    \tAdd a node after the specified child node.\n    */\n    XMLNode* InsertAfterChild( XMLNode* afterThis, XMLNode* addThis );\n\n    /**\n    \tDelete all the children of this node.\n    */\n    void DeleteChildren();\n\n    /**\n    \tDelete a child of this node.\n    */\n    void DeleteChild( XMLNode* node );\n\n    /**\n    \tMake a copy of this node, but not its children.\n    \tYou may pass in a Document pointer that will be\n    \tthe owner of the new Node. If the 'document' is\n    \tnull, then the node returned will be allocated\n    \tfrom the current Document. (this->GetDocument())\n\n    \tNote: if called on a XMLDocument, this will return null.\n    */\n    virtual XMLNode* ShallowClone( XMLDocument* document ) const = 0;\n\n    /**\n    \tTest if 2 nodes are the same, but don't test children.\n    \tThe 2 nodes do not need to be in the same Document.\n\n    \tNote: if called on a XMLDocument, this will return false.\n    */\n    virtual bool ShallowEqual( const XMLNode* compare ) const = 0;\n\n    /** Accept a hierarchical visit of the nodes in the TinyXML DOM. Every node in the\n    \tXML tree will be conditionally visited and the host will be called back\n    \tvia the TiXmlVisitor interface.\n\n    \tThis is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse\n    \tthe XML for the callbacks, so the performance of TinyXML is unchanged by using this\n    \tinterface versus any other.)\n\n    \tThe interface has been based on ideas from:\n\n    \t- http://www.saxproject.org/\n    \t- http://c2.com/cgi/wiki?HierarchicalVisitorPattern\n\n    \tWhich are both good references for \"visiting\".\n\n    \tAn example of using Accept():\n    \t@verbatim\n    \tTiXmlPrinter printer;\n    \ttinyxmlDoc.Accept( &printer );\n    \tconst char* xmlcstr = printer.CStr();\n    \t@endverbatim\n    */\n    virtual bool Accept( XMLVisitor* visitor ) const = 0;\n\n    // internal\n    virtual char* ParseDeep( char*, StrPair* );\n\nprotected:\n    XMLNode( XMLDocument* );\n    virtual ~XMLNode();\n    XMLNode( const XMLNode& );\t// not supported\n    XMLNode& operator=( const XMLNode& );\t// not supported\n\n    XMLDocument*\t_document;\n    XMLNode*\t\t_parent;\n    mutable StrPair\t_value;\n\n    XMLNode*\t\t_firstChild;\n    XMLNode*\t\t_lastChild;\n\n    XMLNode*\t\t_prev;\n    XMLNode*\t\t_next;\n\nprivate:\n    MemPool*\t\t_memPool;\n    void Unlink( XMLNode* child );\n};\n\n\n/** XML text.\n\n\tNote that a text node can have child element nodes, for example:\n\t@verbatim\n\t<root>This is <b>bold</b></root>\n\t@endverbatim\n\n\tA text node can have 2 ways to output the next. \"normal\" output\n\tand CDATA. It will default to the mode it was parsed from the XML file and\n\tyou generally want to leave it alone, but you can change the output mode with\n\tSetCDATA() and query it with CDATA().\n*/\nclass XMLText : public XMLNode\n{\n    friend class XMLBase;\n    friend class XMLDocument;\npublic:\n    virtual bool Accept( XMLVisitor* visitor ) const;\n\n    virtual XMLText* ToText()\t\t\t{\n        return this;\n    }\n    virtual const XMLText* ToText() const\t{\n        return this;\n    }\n\n    /// Declare whether this should be CDATA or standard text.\n    void SetCData( bool isCData )\t\t\t{\n        _isCData = isCData;\n    }\n    /// Returns true if this is a CDATA text element.\n    bool CData() const\t\t\t\t\t\t{\n        return _isCData;\n    }\n\n    char* ParseDeep( char*, StrPair* endTag );\n    virtual XMLNode* ShallowClone( XMLDocument* document ) const;\n    virtual bool ShallowEqual( const XMLNode* compare ) const;\n\nprotected:\n    XMLText( XMLDocument* doc )\t: XMLNode( doc ), _isCData( false )\t{}\n    virtual ~XMLText()\t\t\t\t\t\t\t\t\t\t\t\t{}\n    XMLText( const XMLText& );\t// not supported\n    XMLText& operator=( const XMLText& );\t// not supported\n\nprivate:\n    bool _isCData;\n};\n\n\n/** An XML Comment. */\nclass XMLComment : public XMLNode\n{\n    friend class XMLDocument;\npublic:\n    virtual XMLComment*\tToComment()\t\t\t\t\t{\n        return this;\n    }\n    virtual const XMLComment* ToComment() const\t\t{\n        return this;\n    }\n\n    virtual bool Accept( XMLVisitor* visitor ) const;\n\n    char* ParseDeep( char*, StrPair* endTag );\n    virtual XMLNode* ShallowClone( XMLDocument* document ) const;\n    virtual bool ShallowEqual( const XMLNode* compare ) const;\n\nprotected:\n    XMLComment( XMLDocument* doc );\n    virtual ~XMLComment();\n    XMLComment( const XMLComment& );\t// not supported\n    XMLComment& operator=( const XMLComment& );\t// not supported\n\nprivate:\n};\n\n\n/** In correct XML the declaration is the first entry in the file.\n\t@verbatim\n\t\t<?xml version=\"1.0\" standalone=\"yes\"?>\n\t@endverbatim\n\n\tTinyXML2 will happily read or write files without a declaration,\n\thowever.\n\n\tThe text of the declaration isn't interpreted. It is parsed\n\tand written as a string.\n*/\nclass XMLDeclaration : public XMLNode\n{\n    friend class XMLDocument;\npublic:\n    virtual XMLDeclaration*\tToDeclaration()\t\t\t\t\t{\n        return this;\n    }\n    virtual const XMLDeclaration* ToDeclaration() const\t\t{\n        return this;\n    }\n\n    virtual bool Accept( XMLVisitor* visitor ) const;\n\n    char* ParseDeep( char*, StrPair* endTag );\n    virtual XMLNode* ShallowClone( XMLDocument* document ) const;\n    virtual bool ShallowEqual( const XMLNode* compare ) const;\n\nprotected:\n    XMLDeclaration( XMLDocument* doc );\n    virtual ~XMLDeclaration();\n    XMLDeclaration( const XMLDeclaration& );\t// not supported\n    XMLDeclaration& operator=( const XMLDeclaration& );\t// not supported\n};\n\n\n/** Any tag that tinyXml doesn't recognize is saved as an\n\tunknown. It is a tag of text, but should not be modified.\n\tIt will be written back to the XML, unchanged, when the file\n\tis saved.\n\n\tDTD tags get thrown into TiXmlUnknowns.\n*/\nclass XMLUnknown : public XMLNode\n{\n    friend class XMLDocument;\npublic:\n    virtual XMLUnknown*\tToUnknown()\t\t\t\t\t{\n        return this;\n    }\n    virtual const XMLUnknown* ToUnknown() const\t\t{\n        return this;\n    }\n\n    virtual bool Accept( XMLVisitor* visitor ) const;\n\n    char* ParseDeep( char*, StrPair* endTag );\n    virtual XMLNode* ShallowClone( XMLDocument* document ) const;\n    virtual bool ShallowEqual( const XMLNode* compare ) const;\n\nprotected:\n    XMLUnknown( XMLDocument* doc );\n    virtual ~XMLUnknown();\n    XMLUnknown( const XMLUnknown& );\t// not supported\n    XMLUnknown& operator=( const XMLUnknown& );\t// not supported\n};\n\n\nenum XMLError {\n    XML_NO_ERROR = 0,\n    XML_SUCCESS = 0,\n\n    XML_NO_ATTRIBUTE,\n    XML_WRONG_ATTRIBUTE_TYPE,\n\n    XML_ERROR_FILE_NOT_FOUND,\n    XML_ERROR_FILE_COULD_NOT_BE_OPENED,\n    XML_ERROR_FILE_READ_ERROR,\n    XML_ERROR_ELEMENT_MISMATCH,\n    XML_ERROR_PARSING_ELEMENT,\n    XML_ERROR_PARSING_ATTRIBUTE,\n    XML_ERROR_IDENTIFYING_TAG,\n    XML_ERROR_PARSING_TEXT,\n    XML_ERROR_PARSING_CDATA,\n    XML_ERROR_PARSING_COMMENT,\n    XML_ERROR_PARSING_DECLARATION,\n    XML_ERROR_PARSING_UNKNOWN,\n    XML_ERROR_EMPTY_DOCUMENT,\n    XML_ERROR_MISMATCHED_ELEMENT,\n    XML_ERROR_PARSING,\n\n    XML_CAN_NOT_CONVERT_TEXT,\n    XML_NO_TEXT_NODE\n};\n\n\n/** An attribute is a name-value pair. Elements have an arbitrary\n\tnumber of attributes, each with a unique name.\n\n\t@note The attributes are not XMLNodes. You may only query the\n\tNext() attribute in a list.\n*/\nclass XMLAttribute\n{\n    friend class XMLElement;\npublic:\n    /// The name of the attribute.\n    const char* Name() const {\n        return _name.GetStr();\n    }\n    /// The value of the attribute.\n    const char* Value() const {\n        return _value.GetStr();\n    }\n    /// The next attribute in the list.\n    const XMLAttribute* Next() const {\n        return _next;\n    }\n\n    /** IntAttribute interprets the attribute as an integer, and returns the value.\n        If the value isn't an integer, 0 will be returned. There is no error checking;\n    \tuse QueryIntAttribute() if you need error checking.\n    */\n    int\t\t IntValue() const\t\t\t\t{\n        int i=0;\n        QueryIntValue( &i );\n        return i;\n    }\n    /// Query as an unsigned integer. See IntAttribute()\n    unsigned UnsignedValue() const\t\t\t{\n        unsigned i=0;\n        QueryUnsignedValue( &i );\n        return i;\n    }\n    /// Query as a boolean. See IntAttribute()\n    bool\t BoolValue() const\t\t\t\t{\n        bool b=false;\n        QueryBoolValue( &b );\n        return b;\n    }\n    /// Query as a double. See IntAttribute()\n    double \t DoubleValue() const\t\t\t{\n        double d=0;\n        QueryDoubleValue( &d );\n        return d;\n    }\n    /// Query as a float. See IntAttribute()\n    float\t FloatValue() const\t\t\t\t{\n        float f=0;\n        QueryFloatValue( &f );\n        return f;\n    }\n\n    /** QueryIntAttribute interprets the attribute as an integer, and returns the value\n    \tin the provided paremeter. The function will return XML_NO_ERROR on success,\n    \tand XML_WRONG_ATTRIBUTE_TYPE if the conversion is not successful.\n    */\n    XMLError QueryIntValue( int* value ) const;\n    /// See QueryIntAttribute\n    XMLError QueryUnsignedValue( unsigned int* value ) const;\n    /// See QueryIntAttribute\n    XMLError QueryBoolValue( bool* value ) const;\n    /// See QueryIntAttribute\n    XMLError QueryDoubleValue( double* value ) const;\n    /// See QueryIntAttribute\n    XMLError QueryFloatValue( float* value ) const;\n\n    /// Set the attribute to a string value.\n    void SetAttribute( const char* value );\n    /// Set the attribute to value.\n    void SetAttribute( int value );\n    /// Set the attribute to value.\n    void SetAttribute( unsigned value );\n    /// Set the attribute to value.\n    void SetAttribute( bool value );\n    /// Set the attribute to value.\n    void SetAttribute( double value );\n    /// Set the attribute to value.\n    void SetAttribute( float value );\n\nprivate:\n    enum { BUF_SIZE = 200 };\n\n    XMLAttribute() : _next( 0 ) {}\n    virtual ~XMLAttribute()\t{}\n\n    XMLAttribute( const XMLAttribute& );\t// not supported\n    void operator=( const XMLAttribute& );\t// not supported\n    void SetName( const char* name );\n\n    char* ParseDeep( char* p, bool processEntities );\n\n    mutable StrPair _name;\n    mutable StrPair _value;\n    XMLAttribute*   _next;\n    MemPool*        _memPool;\n};\n\n\n/** The element is a container class. It has a value, the element name,\n\tand can contain other elements, text, comments, and unknowns.\n\tElements also contain an arbitrary number of attributes.\n*/\nclass XMLElement : public XMLNode\n{\n    friend class XMLBase;\n    friend class XMLDocument;\npublic:\n    /// Get the name of an element (which is the Value() of the node.)\n    const char* Name() const\t\t{\n        return Value();\n    }\n    /// Set the name of the element.\n    void SetName( const char* str, bool staticMem=false )\t{\n        SetValue( str, staticMem );\n    }\n\n    virtual XMLElement* ToElement()\t\t\t\t{\n        return this;\n    }\n    virtual const XMLElement* ToElement() const {\n        return this;\n    }\n    virtual bool Accept( XMLVisitor* visitor ) const;\n\n    /** Given an attribute name, Attribute() returns the value\n    \tfor the attribute of that name, or null if none\n    \texists. For example:\n\n    \t@verbatim\n    \tconst char* value = ele->Attribute( \"foo\" );\n    \t@endverbatim\n\n    \tThe 'value' parameter is normally null. However, if specified,\n    \tthe attribute will only be returned if the 'name' and 'value'\n    \tmatch. This allow you to write code:\n\n    \t@verbatim\n    \tif ( ele->Attribute( \"foo\", \"bar\" ) ) callFooIsBar();\n    \t@endverbatim\n\n    \trather than:\n    \t@verbatim\n    \tif ( ele->Attribute( \"foo\" ) ) {\n    \t\tif ( strcmp( ele->Attribute( \"foo\" ), \"bar\" ) == 0 ) callFooIsBar();\n    \t}\n    \t@endverbatim\n    */\n    const char* Attribute( const char* name, const char* value=0 ) const;\n\n    /** Given an attribute name, IntAttribute() returns the value\n    \tof the attribute interpreted as an integer. 0 will be\n    \treturned if there is an error. For a method with error\n    \tchecking, see QueryIntAttribute()\n    */\n    int\t\t IntAttribute( const char* name ) const\t\t{\n        int i=0;\n        QueryIntAttribute( name, &i );\n        return i;\n    }\n    /// See IntAttribute()\n    unsigned UnsignedAttribute( const char* name ) const {\n        unsigned i=0;\n        QueryUnsignedAttribute( name, &i );\n        return i;\n    }\n    /// See IntAttribute()\n    bool\t BoolAttribute( const char* name ) const\t{\n        bool b=false;\n        QueryBoolAttribute( name, &b );\n        return b;\n    }\n    /// See IntAttribute()\n    double \t DoubleAttribute( const char* name ) const\t{\n        double d=0;\n        QueryDoubleAttribute( name, &d );\n        return d;\n    }\n    /// See IntAttribute()\n    float\t FloatAttribute( const char* name ) const\t{\n        float f=0;\n        QueryFloatAttribute( name, &f );\n        return f;\n    }\n\n    /** Given an attribute name, QueryIntAttribute() returns\n    \tXML_NO_ERROR, XML_WRONG_ATTRIBUTE_TYPE if the conversion\n    \tcan't be performed, or XML_NO_ATTRIBUTE if the attribute\n    \tdoesn't exist. If successful, the result of the conversion\n    \twill be written to 'value'. If not successful, nothing will\n    \tbe written to 'value'. This allows you to provide default\n    \tvalue:\n\n    \t@verbatim\n    \tint value = 10;\n    \tQueryIntAttribute( \"foo\", &value );\t\t// if \"foo\" isn't found, value will still be 10\n    \t@endverbatim\n    */\n    XMLError QueryIntAttribute( const char* name, int* value ) const\t\t\t\t{\n        const XMLAttribute* a = FindAttribute( name );\n        if ( !a ) {\n            return XML_NO_ATTRIBUTE;\n        }\n        return a->QueryIntValue( value );\n    }\n    /// See QueryIntAttribute()\n    XMLError QueryUnsignedAttribute( const char* name, unsigned int* value ) const\t{\n        const XMLAttribute* a = FindAttribute( name );\n        if ( !a ) {\n            return XML_NO_ATTRIBUTE;\n        }\n        return a->QueryUnsignedValue( value );\n    }\n    /// See QueryIntAttribute()\n    XMLError QueryBoolAttribute( const char* name, bool* value ) const\t\t\t\t{\n        const XMLAttribute* a = FindAttribute( name );\n        if ( !a ) {\n            return XML_NO_ATTRIBUTE;\n        }\n        return a->QueryBoolValue( value );\n    }\n    /// See QueryIntAttribute()\n    XMLError QueryDoubleAttribute( const char* name, double* value ) const\t\t\t{\n        const XMLAttribute* a = FindAttribute( name );\n        if ( !a ) {\n            return XML_NO_ATTRIBUTE;\n        }\n        return a->QueryDoubleValue( value );\n    }\n    /// See QueryIntAttribute()\n    XMLError QueryFloatAttribute( const char* name, float* value ) const\t\t\t{\n        const XMLAttribute* a = FindAttribute( name );\n        if ( !a ) {\n            return XML_NO_ATTRIBUTE;\n        }\n        return a->QueryFloatValue( value );\n    }\n\n\t\n    /** Given an attribute name, QueryAttribute() returns\n    \tXML_NO_ERROR, XML_WRONG_ATTRIBUTE_TYPE if the conversion\n    \tcan't be performed, or XML_NO_ATTRIBUTE if the attribute\n    \tdoesn't exist. It is overloaded for the primitive types,\n\t\tand is a generally more convenient replacement of\n\t\tQueryIntAttribute() and related functions.\n\t\t\n\t\tIf successful, the result of the conversion\n    \twill be written to 'value'. If not successful, nothing will\n    \tbe written to 'value'. This allows you to provide default\n    \tvalue:\n\n    \t@verbatim\n    \tint value = 10;\n    \tQueryAttribute( \"foo\", &value );\t\t// if \"foo\" isn't found, value will still be 10\n    \t@endverbatim\n    */\n\tint QueryAttribute( const char* name, int* value ) const {\n\t\treturn QueryIntAttribute( name, value );\n\t}\n\n\tint QueryAttribute( const char* name, unsigned int* value ) const {\n\t\treturn QueryUnsignedAttribute( name, value );\n\t}\n\n\tint QueryAttribute( const char* name, bool* value ) const {\n\t\treturn QueryBoolAttribute( name, value );\n\t}\n\n\tint QueryAttribute( const char* name, double* value ) const {\n\t\treturn QueryDoubleAttribute( name, value );\n\t}\n\n\tint QueryAttribute( const char* name, float* value ) const {\n\t\treturn QueryFloatAttribute( name, value );\n\t}\n\n\t/// Sets the named attribute to value.\n    void SetAttribute( const char* name, const char* value )\t{\n        XMLAttribute* a = FindOrCreateAttribute( name );\n        a->SetAttribute( value );\n    }\n    /// Sets the named attribute to value.\n    void SetAttribute( const char* name, int value )\t\t\t{\n        XMLAttribute* a = FindOrCreateAttribute( name );\n        a->SetAttribute( value );\n    }\n    /// Sets the named attribute to value.\n    void SetAttribute( const char* name, unsigned value )\t\t{\n        XMLAttribute* a = FindOrCreateAttribute( name );\n        a->SetAttribute( value );\n    }\n    /// Sets the named attribute to value.\n    void SetAttribute( const char* name, bool value )\t\t\t{\n        XMLAttribute* a = FindOrCreateAttribute( name );\n        a->SetAttribute( value );\n    }\n    /// Sets the named attribute to value.\n    void SetAttribute( const char* name, double value )\t\t{\n        XMLAttribute* a = FindOrCreateAttribute( name );\n        a->SetAttribute( value );\n    }\n\n    /**\n    \tDelete an attribute.\n    */\n    void DeleteAttribute( const char* name );\n\n    /// Return the first attribute in the list.\n    const XMLAttribute* FirstAttribute() const {\n        return _rootAttribute;\n    }\n    /// Query a specific attribute in the list.\n    const XMLAttribute* FindAttribute( const char* name ) const;\n\n    /** Convenience function for easy access to the text inside an element. Although easy\n    \tand concise, GetText() is limited compared to getting the TiXmlText child\n    \tand accessing it directly.\n\n    \tIf the first child of 'this' is a TiXmlText, the GetText()\n    \treturns the character string of the Text node, else null is returned.\n\n    \tThis is a convenient method for getting the text of simple contained text:\n    \t@verbatim\n    \t<foo>This is text</foo>\n    \t\tconst char* str = fooElement->GetText();\n    \t@endverbatim\n\n    \t'str' will be a pointer to \"This is text\".\n\n    \tNote that this function can be misleading. If the element foo was created from\n    \tthis XML:\n    \t@verbatim\n    \t\t<foo><b>This is text</b></foo>\n    \t@endverbatim\n\n    \tthen the value of str would be null. The first child node isn't a text node, it is\n    \tanother element. From this XML:\n    \t@verbatim\n    \t\t<foo>This is <b>text</b></foo>\n    \t@endverbatim\n    \tGetText() will return \"This is \".\n    */\n    const char* GetText() const;\n\n    /**\n    \tConvenience method to query the value of a child text node. This is probably best\n    \tshown by example. Given you have a document is this form:\n    \t@verbatim\n    \t\t<point>\n    \t\t\t<x>1</x>\n    \t\t\t<y>1.4</y>\n    \t\t</point>\n    \t@endverbatim\n\n    \tThe QueryIntText() and similar functions provide a safe and easier way to get to the\n    \t\"value\" of x and y.\n\n    \t@verbatim\n    \t\tint x = 0;\n    \t\tfloat y = 0;\t// types of x and y are contrived for example\n    \t\tconst XMLElement* xElement = pointElement->FirstChildElement( \"x\" );\n    \t\tconst XMLElement* yElement = pointElement->FirstChildElement( \"y\" );\n    \t\txElement->QueryIntText( &x );\n    \t\tyElement->QueryFloatText( &y );\n    \t@endverbatim\n\n    \t@returns XML_SUCCESS (0) on success, XML_CAN_NOT_CONVERT_TEXT if the text cannot be converted\n    \t\t\t to the requested type, and XML_NO_TEXT_NODE if there is no child text to query.\n\n    */\n    XMLError QueryIntText( int* ival ) const;\n    /// See QueryIntText()\n    XMLError QueryUnsignedText( unsigned* uval ) const;\n    /// See QueryIntText()\n    XMLError QueryBoolText( bool* bval ) const;\n    /// See QueryIntText()\n    XMLError QueryDoubleText( double* dval ) const;\n    /// See QueryIntText()\n    XMLError QueryFloatText( float* fval ) const;\n\n    // internal:\n    enum {\n        OPEN,\t\t// <foo>\n        CLOSED,\t\t// <foo/>\n        CLOSING\t\t// </foo>\n    };\n    int ClosingType() const {\n        return _closingType;\n    }\n    char* ParseDeep( char* p, StrPair* endTag );\n    virtual XMLNode* ShallowClone( XMLDocument* document ) const;\n    virtual bool ShallowEqual( const XMLNode* compare ) const;\n\nprivate:\n    XMLElement( XMLDocument* doc );\n    virtual ~XMLElement();\n    XMLElement( const XMLElement& );\t// not supported\n    void operator=( const XMLElement& );\t// not supported\n\n    XMLAttribute* FindAttribute( const char* name );\n    XMLAttribute* FindOrCreateAttribute( const char* name );\n    //void LinkAttribute( XMLAttribute* attrib );\n    char* ParseAttributes( char* p );\n\n    int _closingType;\n    // The attribute list is ordered; there is no 'lastAttribute'\n    // because the list needs to be scanned for dupes before adding\n    // a new attribute.\n    XMLAttribute* _rootAttribute;\n};\n\n\nenum Whitespace {\n    PRESERVE_WHITESPACE,\n    COLLAPSE_WHITESPACE\n};\n\n\n/** A Document binds together all the functionality.\n\tIt can be saved, loaded, and printed to the screen.\n\tAll Nodes are connected and allocated to a Document.\n\tIf the Document is deleted, all its Nodes are also deleted.\n*/\nclass XMLDocument : public XMLNode\n{\n    friend class XMLElement;\npublic:\n    /// constructor\n    XMLDocument( bool processEntities = true, Whitespace = PRESERVE_WHITESPACE );\n    ~XMLDocument();\n\n    virtual XMLDocument* ToDocument()\t\t\t\t{\n        return this;\n    }\n    virtual const XMLDocument* ToDocument() const\t{\n        return this;\n    }\n\n    /**\n    \tParse an XML file from a character string.\n    \tReturns XML_NO_ERROR (0) on success, or\n    \tan errorID.\n\n    \tYou may optionally pass in the 'nBytes', which is\n    \tthe number of bytes which will be parsed. If not\n    \tspecified, TinyXML will assume 'xml' points to a\n    \tnull terminated string.\n    */\n    XMLError Parse( const char* xml, size_t nBytes=(size_t)(-1) );\n\n    /**\n    \tLoad an XML file from disk.\n    \tReturns XML_NO_ERROR (0) on success, or\n    \tan errorID.\n    */\n    XMLError LoadFile( const char* filename );\n\n    /**\n    \tLoad an XML file from disk. You are responsible\n    \tfor providing and closing the FILE*.\n\n    \tReturns XML_NO_ERROR (0) on success, or\n    \tan errorID.\n    */\n    XMLError LoadFile( FILE* );\n\n    /**\n    \tSave the XML file to disk.\n    \tReturns XML_NO_ERROR (0) on success, or\n    \tan errorID.\n    */\n    XMLError SaveFile( const char* filename, bool compact = false );\n\n    /**\n    \tSave the XML file to disk. You are responsible\n    \tfor providing and closing the FILE*.\n\n    \tReturns XML_NO_ERROR (0) on success, or\n    \tan errorID.\n    */\n    XMLError SaveFile( FILE* fp, bool compact = false );\n\n    bool ProcessEntities() const\t\t{\n        return _processEntities;\n    }\n    Whitespace WhitespaceMode() const\t{\n        return _whitespace;\n    }\n\n    /**\n    \tReturns true if this document has a leading Byte Order Mark of UTF8.\n    */\n    bool HasBOM() const {\n        return _writeBOM;\n    }\n    /** Sets whether to write the BOM when writing the file.\n    */\n    void SetBOM( bool useBOM ) {\n        _writeBOM = useBOM;\n    }\n\n    /** Return the root element of DOM. Equivalent to FirstChildElement().\n        To get the first node, use FirstChild().\n    */\n    XMLElement* RootElement()\t\t\t\t{\n        return FirstChildElement();\n    }\n    const XMLElement* RootElement() const\t{\n        return FirstChildElement();\n    }\n\n    /** Print the Document. If the Printer is not provided, it will\n        print to stdout. If you provide Printer, this can print to a file:\n    \t@verbatim\n    \tXMLPrinter printer( fp );\n    \tdoc.Print( &printer );\n    \t@endverbatim\n\n    \tOr you can use a printer to print to memory:\n    \t@verbatim\n    \tXMLPrinter printer;\n    \tdoc->Print( &printer );\n    \t// printer.CStr() has a const char* to the XML\n    \t@endverbatim\n    */\n    void Print( XMLPrinter* streamer=0 );\n    virtual bool Accept( XMLVisitor* visitor ) const;\n\n    /**\n    \tCreate a new Element associated with\n    \tthis Document. The memory for the Element\n    \tis managed by the Document.\n    */\n    XMLElement* NewElement( const char* name );\n    /**\n    \tCreate a new Comment associated with\n    \tthis Document. The memory for the Comment\n    \tis managed by the Document.\n    */\n    XMLComment* NewComment( const char* comment );\n    /**\n    \tCreate a new Text associated with\n    \tthis Document. The memory for the Text\n    \tis managed by the Document.\n    */\n    XMLText* NewText( const char* text );\n    /**\n    \tCreate a new Declaration associated with\n    \tthis Document. The memory for the object\n    \tis managed by the Document.\n\n    \tIf the 'text' param is null, the standard\n    \tdeclaration is used.:\n    \t@verbatim\n    \t\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    \t@endverbatim\n    */\n    XMLDeclaration* NewDeclaration( const char* text=0 );\n    /**\n    \tCreate a new Unknown associated with\n    \tthis Document. The memory forthe object\n    \tis managed by the Document.\n    */\n    XMLUnknown* NewUnknown( const char* text );\n\n    /**\n    \tDelete a node associated with this document.\n    \tIt will be unlinked from the DOM.\n    */\n    void DeleteNode( XMLNode* node )\t{\n        node->_parent->DeleteChild( node );\n    }\n\n    void SetError( XMLError error, const char* str1, const char* str2 );\n\n    /// Return true if there was an error parsing the document.\n    bool Error() const {\n        return _errorID != XML_NO_ERROR;\n    }\n    /// Return the errorID.\n    XMLError  ErrorID() const {\n        return _errorID;\n    }\n    /// Return a possibly helpful diagnostic location or string.\n    const char* GetErrorStr1() const {\n        return _errorStr1;\n    }\n    /// Return a possibly helpful secondary diagnostic location or string.\n    const char* GetErrorStr2() const {\n        return _errorStr2;\n    }\n    /// If there is an error, print it to stdout.\n    void PrintError() const;\n    \n    /// Clear the document, resetting it to the initial state.\n    void Clear();\n\n    // internal\n    char* Identify( char* p, XMLNode** node );\n\n    virtual XMLNode* ShallowClone( XMLDocument* /*document*/ ) const\t{\n        return 0;\n    }\n    virtual bool ShallowEqual( const XMLNode* /*compare*/ ) const\t{\n        return false;\n    }\n\nprivate:\n    XMLDocument( const XMLDocument& );\t// not supported\n    void operator=( const XMLDocument& );\t// not supported\n\n    bool        _writeBOM;\n    bool        _processEntities;\n    XMLError    _errorID;\n    Whitespace  _whitespace;\n    const char* _errorStr1;\n    const char* _errorStr2;\n    char*       _charBuffer;\n\n    MemPoolT< sizeof(XMLElement) >\t _elementPool;\n    MemPoolT< sizeof(XMLAttribute) > _attributePool;\n    MemPoolT< sizeof(XMLText) >\t\t _textPool;\n    MemPoolT< sizeof(XMLComment) >\t _commentPool;\n};\n\n\n/**\n\tA XMLHandle is a class that wraps a node pointer with null checks; this is\n\tan incredibly useful thing. Note that XMLHandle is not part of the TinyXML\n\tDOM structure. It is a separate utility class.\n\n\tTake an example:\n\t@verbatim\n\t<Document>\n\t\t<Element attributeA = \"valueA\">\n\t\t\t<Child attributeB = \"value1\" />\n\t\t\t<Child attributeB = \"value2\" />\n\t\t</Element>\n\t</Document>\n\t@endverbatim\n\n\tAssuming you want the value of \"attributeB\" in the 2nd \"Child\" element, it's very\n\teasy to write a *lot* of code that looks like:\n\n\t@verbatim\n\tXMLElement* root = document.FirstChildElement( \"Document\" );\n\tif ( root )\n\t{\n\t\tXMLElement* element = root->FirstChildElement( \"Element\" );\n\t\tif ( element )\n\t\t{\n\t\t\tXMLElement* child = element->FirstChildElement( \"Child\" );\n\t\t\tif ( child )\n\t\t\t{\n\t\t\t\tXMLElement* child2 = child->NextSiblingElement( \"Child\" );\n\t\t\t\tif ( child2 )\n\t\t\t\t{\n\t\t\t\t\t// Finally do something useful.\n\t@endverbatim\n\n\tAnd that doesn't even cover \"else\" cases. XMLHandle addresses the verbosity\n\tof such code. A XMLHandle checks for null pointers so it is perfectly safe\n\tand correct to use:\n\n\t@verbatim\n\tXMLHandle docHandle( &document );\n\tXMLElement* child2 = docHandle.FirstChild( \"Document\" ).FirstChild( \"Element\" ).FirstChild().NextSibling().ToElement();\n\tif ( child2 )\n\t{\n\t\t// do something useful\n\t@endverbatim\n\n\tWhich is MUCH more concise and useful.\n\n\tIt is also safe to copy handles - internally they are nothing more than node pointers.\n\t@verbatim\n\tXMLHandle handleCopy = handle;\n\t@endverbatim\n\n\tSee also XMLConstHandle, which is the same as XMLHandle, but operates on const objects.\n*/\nclass XMLHandle\n{\npublic:\n    /// Create a handle from any node (at any depth of the tree.) This can be a null pointer.\n    XMLHandle( XMLNode* node )\t\t\t\t\t\t\t\t\t\t\t\t{\n        _node = node;\n    }\n    /// Create a handle from a node.\n    XMLHandle( XMLNode& node )\t\t\t\t\t\t\t\t\t\t\t\t{\n        _node = &node;\n    }\n    /// Copy constructor\n    XMLHandle( const XMLHandle& ref )\t\t\t\t\t\t\t\t\t\t{\n        _node = ref._node;\n    }\n    /// Assignment\n    XMLHandle& operator=( const XMLHandle& ref )\t\t\t\t\t\t\t{\n        _node = ref._node;\n        return *this;\n    }\n\n    /// Get the first child of this handle.\n    XMLHandle FirstChild() \t\t\t\t\t\t\t\t\t\t\t\t\t{\n        return XMLHandle( _node ? _node->FirstChild() : 0 );\n    }\n    /// Get the first child element of this handle.\n    XMLHandle FirstChildElement( const char* value=0 )\t\t\t\t\t\t{\n        return XMLHandle( _node ? _node->FirstChildElement( value ) : 0 );\n    }\n    /// Get the last child of this handle.\n    XMLHandle LastChild()\t\t\t\t\t\t\t\t\t\t\t\t\t{\n        return XMLHandle( _node ? _node->LastChild() : 0 );\n    }\n    /// Get the last child element of this handle.\n    XMLHandle LastChildElement( const char* _value=0 )\t\t\t\t\t\t{\n        return XMLHandle( _node ? _node->LastChildElement( _value ) : 0 );\n    }\n    /// Get the previous sibling of this handle.\n    XMLHandle PreviousSibling()\t\t\t\t\t\t\t\t\t\t\t\t{\n        return XMLHandle( _node ? _node->PreviousSibling() : 0 );\n    }\n    /// Get the previous sibling element of this handle.\n    XMLHandle PreviousSiblingElement( const char* _value=0 )\t\t\t\t{\n        return XMLHandle( _node ? _node->PreviousSiblingElement( _value ) : 0 );\n    }\n    /// Get the next sibling of this handle.\n    XMLHandle NextSibling()\t\t\t\t\t\t\t\t\t\t\t\t\t{\n        return XMLHandle( _node ? _node->NextSibling() : 0 );\n    }\n    /// Get the next sibling element of this handle.\n    XMLHandle NextSiblingElement( const char* _value=0 )\t\t\t\t\t{\n        return XMLHandle( _node ? _node->NextSiblingElement( _value ) : 0 );\n    }\n\n    /// Safe cast to XMLNode. This can return null.\n    XMLNode* ToNode()\t\t\t\t\t\t\t{\n        return _node;\n    }\n    /// Safe cast to XMLElement. This can return null.\n    XMLElement* ToElement() \t\t\t\t\t{\n        return ( ( _node && _node->ToElement() ) ? _node->ToElement() : 0 );\n    }\n    /// Safe cast to XMLText. This can return null.\n    XMLText* ToText() \t\t\t\t\t\t\t{\n        return ( ( _node && _node->ToText() ) ? _node->ToText() : 0 );\n    }\n    /// Safe cast to XMLUnknown. This can return null.\n    XMLUnknown* ToUnknown() \t\t\t\t\t{\n        return ( ( _node && _node->ToUnknown() ) ? _node->ToUnknown() : 0 );\n    }\n    /// Safe cast to XMLDeclaration. This can return null.\n    XMLDeclaration* ToDeclaration() \t\t\t{\n        return ( ( _node && _node->ToDeclaration() ) ? _node->ToDeclaration() : 0 );\n    }\n\nprivate:\n    XMLNode* _node;\n};\n\n\n/**\n\tA variant of the XMLHandle class for working with const XMLNodes and Documents. It is the\n\tsame in all regards, except for the 'const' qualifiers. See XMLHandle for API.\n*/\nclass XMLConstHandle\n{\npublic:\n    XMLConstHandle( const XMLNode* node )\t\t\t\t\t\t\t\t\t\t\t{\n        _node = node;\n    }\n    XMLConstHandle( const XMLNode& node )\t\t\t\t\t\t\t\t\t\t\t{\n        _node = &node;\n    }\n    XMLConstHandle( const XMLConstHandle& ref )\t\t\t\t\t\t\t\t\t\t{\n        _node = ref._node;\n    }\n\n    XMLConstHandle& operator=( const XMLConstHandle& ref )\t\t\t\t\t\t\t{\n        _node = ref._node;\n        return *this;\n    }\n\n    const XMLConstHandle FirstChild() const\t\t\t\t\t\t\t\t\t\t\t{\n        return XMLConstHandle( _node ? _node->FirstChild() : 0 );\n    }\n    const XMLConstHandle FirstChildElement( const char* value=0 ) const\t\t\t\t{\n        return XMLConstHandle( _node ? _node->FirstChildElement( value ) : 0 );\n    }\n    const XMLConstHandle LastChild()\tconst\t\t\t\t\t\t\t\t\t\t{\n        return XMLConstHandle( _node ? _node->LastChild() : 0 );\n    }\n    const XMLConstHandle LastChildElement( const char* _value=0 ) const\t\t\t\t{\n        return XMLConstHandle( _node ? _node->LastChildElement( _value ) : 0 );\n    }\n    const XMLConstHandle PreviousSibling() const\t\t\t\t\t\t\t\t\t{\n        return XMLConstHandle( _node ? _node->PreviousSibling() : 0 );\n    }\n    const XMLConstHandle PreviousSiblingElement( const char* _value=0 ) const\t\t{\n        return XMLConstHandle( _node ? _node->PreviousSiblingElement( _value ) : 0 );\n    }\n    const XMLConstHandle NextSibling() const\t\t\t\t\t\t\t\t\t\t{\n        return XMLConstHandle( _node ? _node->NextSibling() : 0 );\n    }\n    const XMLConstHandle NextSiblingElement( const char* _value=0 ) const\t\t\t{\n        return XMLConstHandle( _node ? _node->NextSiblingElement( _value ) : 0 );\n    }\n\n\n    const XMLNode* ToNode() const\t\t\t\t{\n        return _node;\n    }\n    const XMLElement* ToElement() const\t\t\t{\n        return ( ( _node && _node->ToElement() ) ? _node->ToElement() : 0 );\n    }\n    const XMLText* ToText() const\t\t\t\t{\n        return ( ( _node && _node->ToText() ) ? _node->ToText() : 0 );\n    }\n    const XMLUnknown* ToUnknown() const\t\t\t{\n        return ( ( _node && _node->ToUnknown() ) ? _node->ToUnknown() : 0 );\n    }\n    const XMLDeclaration* ToDeclaration() const\t{\n        return ( ( _node && _node->ToDeclaration() ) ? _node->ToDeclaration() : 0 );\n    }\n\nprivate:\n    const XMLNode* _node;\n};\n\n\n/**\n\tPrinting functionality. The XMLPrinter gives you more\n\toptions than the XMLDocument::Print() method.\n\n\tIt can:\n\t-# Print to memory.\n\t-# Print to a file you provide.\n\t-# Print XML without a XMLDocument.\n\n\tPrint to Memory\n\n\t@verbatim\n\tXMLPrinter printer;\n\tdoc->Print( &printer );\n\tSomeFunction( printer.CStr() );\n\t@endverbatim\n\n\tPrint to a File\n\n\tYou provide the file pointer.\n\t@verbatim\n\tXMLPrinter printer( fp );\n\tdoc.Print( &printer );\n\t@endverbatim\n\n\tPrint without a XMLDocument\n\n\tWhen loading, an XML parser is very useful. However, sometimes\n\twhen saving, it just gets in the way. The code is often set up\n\tfor streaming, and constructing the DOM is just overhead.\n\n\tThe Printer supports the streaming case. The following code\n\tprints out a trivially simple XML file without ever creating\n\tan XML document.\n\n\t@verbatim\n\tXMLPrinter printer( fp );\n\tprinter.OpenElement( \"foo\" );\n\tprinter.PushAttribute( \"foo\", \"bar\" );\n\tprinter.CloseElement();\n\t@endverbatim\n*/\nclass XMLPrinter : public XMLVisitor\n{\npublic:\n    /** Construct the printer. If the FILE* is specified,\n    \tthis will print to the FILE. Else it will print\n    \tto memory, and the result is available in CStr().\n    \tIf 'compact' is set to true, then output is created\n    \twith only required whitespace and newlines.\n    */\n    XMLPrinter( FILE* file=0, bool compact = false );\n    ~XMLPrinter()\t{}\n\n    /** If streaming, write the BOM and declaration. */\n    void PushHeader( bool writeBOM, bool writeDeclaration );\n    /** If streaming, start writing an element.\n        The element must be closed with CloseElement()\n    */\n    void OpenElement( const char* name );\n    /// If streaming, add an attribute to an open element.\n    void PushAttribute( const char* name, const char* value );\n    void PushAttribute( const char* name, int value );\n    void PushAttribute( const char* name, unsigned value );\n    void PushAttribute( const char* name, bool value );\n    void PushAttribute( const char* name, double value );\n    /// If streaming, close the Element.\n    void CloseElement();\n\n    /// Add a text node.\n    void PushText( const char* text, bool cdata=false );\n    /// Add a text node from an integer.\n    void PushText( int value );\n    /// Add a text node from an unsigned.\n    void PushText( unsigned value );\n    /// Add a text node from a bool.\n    void PushText( bool value );\n    /// Add a text node from a float.\n    void PushText( float value );\n    /// Add a text node from a double.\n    void PushText( double value );\n\n    /// Add a comment\n    void PushComment( const char* comment );\n\n    void PushDeclaration( const char* value );\n    void PushUnknown( const char* value );\n\n    virtual bool VisitEnter( const XMLDocument& /*doc*/ );\n    virtual bool VisitExit( const XMLDocument& /*doc*/ )\t\t\t{\n        return true;\n    }\n\n    virtual bool VisitEnter( const XMLElement& element, const XMLAttribute* attribute );\n    virtual bool VisitExit( const XMLElement& element );\n\n    virtual bool Visit( const XMLText& text );\n    virtual bool Visit( const XMLComment& comment );\n    virtual bool Visit( const XMLDeclaration& declaration );\n    virtual bool Visit( const XMLUnknown& unknown );\n\n    /**\n    \tIf in print to memory mode, return a pointer to\n    \tthe XML file in memory.\n    */\n    const char* CStr() const {\n        return _buffer.Mem();\n    }\n    /**\n    \tIf in print to memory mode, return the size\n    \tof the XML file in memory. (Note the size returned\n    \tincludes the terminating null.)\n    */\n    int CStrSize() const {\n        return _buffer.Size();\n    }\n\nprivate:\n    void SealElement();\n    void PrintSpace( int depth );\n    void PrintString( const char*, bool restrictedEntitySet );\t// prints out, after detecting entities.\n    void Print( const char* format, ... );\n\n    bool _elementJustOpened;\n    bool _firstElement;\n    FILE* _fp;\n    int _depth;\n    int _textDepth;\n    bool _processEntities;\n    bool _compactMode;\n\n    enum {\n        ENTITY_RANGE = 64,\n        BUF_SIZE = 200\n    };\n    bool _entityFlag[ENTITY_RANGE];\n    bool _restrictedEntityFlag[ENTITY_RANGE];\n\n    DynArray< const char*, 10 > _stack;\n    DynArray< char, 20 > _buffer;\n#ifdef _MSC_VER\n    DynArray< char, 20 > _accumulator;\n#endif\n};\n\n\n}\t// tinyxml2\n\n\n#endif // TINYXML2_INCLUDED\n","/*\r\nOriginal code by Lee Thomason (www.grinninglizard.com)\r\n\r\nThis software is provided 'as-is', without any express or implied\r\nwarranty. In no event will the authors be held liable for any\r\ndamages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you must\r\nnot claim that you wrote the original software. If you use this\r\nsoftware in a product, an acknowledgment in the product documentation\r\nwould be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"tinyxml2.h\"\r\n\r\n#include <new>\t\t// yes, this one new style header, is in the Android SDK.\r\n#   ifdef ANDROID_NDK\r\n#   include <stddef.h>\r\n#else\r\n#   include <cstddef>\r\n#endif\r\n\r\nstatic const char LINE_FEED\t\t\t\t= (char)0x0a;\t\t\t// all line endings are normalized to LF\r\nstatic const char LF = LINE_FEED;\r\nstatic const char CARRIAGE_RETURN\t\t= (char)0x0d;\t\t\t// CR gets filtered out\r\nstatic const char CR = CARRIAGE_RETURN;\r\nstatic const char SINGLE_QUOTE\t\t\t= '\\'';\r\nstatic const char DOUBLE_QUOTE\t\t\t= '\\\"';\r\n\r\n// Bunch of unicode info at:\r\n//\t\thttp://www.unicode.org/faq/utf_bom.html\r\n//\tef bb bf (Microsoft \"lead bytes\") - designates UTF-8\r\n\r\nstatic const unsigned char TIXML_UTF_LEAD_0 = 0xefU;\r\nstatic const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;\r\nstatic const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;\r\n\r\n\r\n#define DELETE_NODE( node )\t{\t\t\t\\\r\n        if ( node ) {\t\t\t\t\t\t\\\r\n            MemPool* pool = node->_memPool;\t\\\r\n            node->~XMLNode();\t\t\t\t\\\r\n            pool->Free( node );\t\t\t\t\\\r\n        }\t\t\t\t\t\t\t\t\t\\\r\n    }\r\n#define DELETE_ATTRIBUTE( attrib ) {\t\t\\\r\n        if ( attrib ) {\t\t\t\t\t\t\t\\\r\n            MemPool* pool = attrib->_memPool;\t\\\r\n            attrib->~XMLAttribute();\t\t\t\\\r\n            pool->Free( attrib );\t\t\t\t\\\r\n        }\t\t\t\t\t\t\t\t\t\t\\\r\n    }\r\n\r\nnamespace tinyxml2\r\n{\r\n\r\nstruct Entity {\r\n    const char* pattern;\r\n    int length;\r\n    char value;\r\n};\r\n\r\nstatic const int NUM_ENTITIES = 5;\r\nstatic const Entity entities[NUM_ENTITIES] = {\r\n    { \"quot\", 4,\tDOUBLE_QUOTE },\r\n    { \"amp\", 3,\t\t'&'  },\r\n    { \"apos\", 4,\tSINGLE_QUOTE },\r\n    { \"lt\",\t2, \t\t'<'\t },\r\n    { \"gt\",\t2,\t\t'>'\t }\r\n};\r\n\r\n\r\nStrPair::~StrPair()\r\n{\r\n    Reset();\r\n}\r\n\r\n\r\nvoid StrPair::Reset()\r\n{\r\n    if ( _flags & NEEDS_DELETE ) {\r\n        delete [] _start;\r\n    }\r\n    _flags = 0;\r\n    _start = 0;\r\n    _end = 0;\r\n}\r\n\r\n\r\nvoid StrPair::SetStr( const char* str, int flags )\r\n{\r\n    Reset();\r\n    size_t len = strlen( str );\r\n    _start = new char[ len+1 ];\r\n    memcpy( _start, str, len+1 );\r\n    _end = _start + len;\r\n    _flags = flags | NEEDS_DELETE;\r\n}\r\n\r\n\r\nchar* StrPair::ParseText( char* p, const char* endTag, int strFlags )\r\n{\r\n    TIXMLASSERT( endTag && *endTag );\r\n\r\n    char* start = p;\t// fixme: hides a member\r\n    char  endChar = *endTag;\r\n    size_t length = strlen( endTag );\r\n\r\n    // Inner loop of text parsing.\r\n    while ( *p ) {\r\n        if ( *p == endChar && strncmp( p, endTag, length ) == 0 ) {\r\n            Set( start, p, strFlags );\r\n            return p + length;\r\n        }\r\n        ++p;\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nchar* StrPair::ParseName( char* p )\r\n{\r\n    char* start = p;\r\n\r\n    if ( !start || !(*start) ) {\r\n        return 0;\r\n    }\r\n\r\n    while( *p && ( p == start ? XMLUtil::IsNameStartChar( *p ) : XMLUtil::IsNameChar( *p ) )) {\r\n        ++p;\r\n    }\r\n\r\n    if ( p > start ) {\r\n        Set( start, p, 0 );\r\n        return p;\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nvoid StrPair::CollapseWhitespace()\r\n{\r\n    // Trim leading space.\r\n    _start = XMLUtil::SkipWhiteSpace( _start );\r\n\r\n    if ( _start && *_start ) {\r\n        char* p = _start;\t// the read pointer\r\n        char* q = _start;\t// the write pointer\r\n\r\n        while( *p ) {\r\n            if ( XMLUtil::IsWhiteSpace( *p )) {\r\n                p = XMLUtil::SkipWhiteSpace( p );\r\n                if ( *p == 0 ) {\r\n                    break;    // don't write to q; this trims the trailing space.\r\n                }\r\n                *q = ' ';\r\n                ++q;\r\n            }\r\n            *q = *p;\r\n            ++q;\r\n            ++p;\r\n        }\r\n        *q = 0;\r\n    }\r\n}\r\n\r\n\r\nconst char* StrPair::GetStr()\r\n{\r\n    if ( _flags & NEEDS_FLUSH ) {\r\n        *_end = 0;\r\n        _flags ^= NEEDS_FLUSH;\r\n\r\n        if ( _flags ) {\r\n            char* p = _start;\t// the read pointer\r\n            char* q = _start;\t// the write pointer\r\n\r\n            while( p < _end ) {\r\n                if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == CR ) {\r\n                    // CR-LF pair becomes LF\r\n                    // CR alone becomes LF\r\n                    // LF-CR becomes LF\r\n                    if ( *(p+1) == LF ) {\r\n                        p += 2;\r\n                    }\r\n                    else {\r\n                        ++p;\r\n                    }\r\n                    *q++ = LF;\r\n                }\r\n                else if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == LF ) {\r\n                    if ( *(p+1) == CR ) {\r\n                        p += 2;\r\n                    }\r\n                    else {\r\n                        ++p;\r\n                    }\r\n                    *q++ = LF;\r\n                }\r\n                else if ( (_flags & NEEDS_ENTITY_PROCESSING) && *p == '&' ) {\r\n                    // Entities handled by tinyXML2:\r\n                    // - special entities in the entity table [in/out]\r\n                    // - numeric character reference [in]\r\n                    //   &#20013; or &#x4e2d;\r\n\r\n                    if ( *(p+1) == '#' ) {\r\n                        char buf[10] = { 0 };\r\n                        int len;\r\n                        p = const_cast<char*>( XMLUtil::GetCharacterRef( p, buf, &len ) );\r\n                        for( int i=0; i<len; ++i ) {\r\n                            *q++ = buf[i];\r\n                        }\r\n                        TIXMLASSERT( q <= p );\r\n                    }\r\n                    else {\r\n                        int i=0;\r\n                        for(; i<NUM_ENTITIES; ++i ) {\r\n                            if (    strncmp( p+1, entities[i].pattern, entities[i].length ) == 0\r\n                                    && *(p+entities[i].length+1) == ';' ) {\r\n                                // Found an entity convert;\r\n                                *q = entities[i].value;\r\n                                ++q;\r\n                                p += entities[i].length + 2;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if ( i == NUM_ENTITIES ) {\r\n                            // fixme: treat as error?\r\n                            ++p;\r\n                            ++q;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    *q = *p;\r\n                    ++p;\r\n                    ++q;\r\n                }\r\n            }\r\n            *q = 0;\r\n        }\r\n        // The loop below has plenty going on, and this\r\n        // is a less useful mode. Break it out.\r\n        if ( _flags & COLLAPSE_WHITESPACE ) {\r\n            CollapseWhitespace();\r\n        }\r\n        _flags = (_flags & NEEDS_DELETE);\r\n    }\r\n    return _start;\r\n}\r\n\r\n\r\n\r\n\r\n// --------- XMLUtil ----------- //\r\n\r\nconst char* XMLUtil::ReadBOM( const char* p, bool* bom )\r\n{\r\n    *bom = false;\r\n    const unsigned char* pu = reinterpret_cast<const unsigned char*>(p);\r\n    // Check for BOM:\r\n    if (    *(pu+0) == TIXML_UTF_LEAD_0\r\n            && *(pu+1) == TIXML_UTF_LEAD_1\r\n            && *(pu+2) == TIXML_UTF_LEAD_2 ) {\r\n        *bom = true;\r\n        p += 3;\r\n    }\r\n    return p;\r\n}\r\n\r\n\r\nvoid XMLUtil::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )\r\n{\r\n    const unsigned long BYTE_MASK = 0xBF;\r\n    const unsigned long BYTE_MARK = 0x80;\r\n    const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\r\n\r\n    if (input < 0x80) {\r\n        *length = 1;\r\n    }\r\n    else if ( input < 0x800 ) {\r\n        *length = 2;\r\n    }\r\n    else if ( input < 0x10000 ) {\r\n        *length = 3;\r\n    }\r\n    else if ( input < 0x200000 ) {\r\n        *length = 4;\r\n    }\r\n    else {\r\n        *length = 0;    // This code won't covert this correctly anyway.\r\n        return;\r\n    }\r\n\r\n    output += *length;\r\n\r\n    // Scary scary fall throughs.\r\n    switch (*length) {\r\n        case 4:\r\n            --output;\r\n            *output = (char)((input | BYTE_MARK) & BYTE_MASK);\r\n            input >>= 6;\r\n        case 3:\r\n            --output;\r\n            *output = (char)((input | BYTE_MARK) & BYTE_MASK);\r\n            input >>= 6;\r\n        case 2:\r\n            --output;\r\n            *output = (char)((input | BYTE_MARK) & BYTE_MASK);\r\n            input >>= 6;\r\n        case 1:\r\n            --output;\r\n            *output = (char)(input | FIRST_BYTE_MARK[*length]);\r\n        default:\r\n            break;\r\n    }\r\n}\r\n\r\n\r\nconst char* XMLUtil::GetCharacterRef( const char* p, char* value, int* length )\r\n{\r\n    // Presume an entity, and pull it out.\r\n    *length = 0;\r\n\r\n    if ( *(p+1) == '#' && *(p+2) ) {\r\n        unsigned long ucs = 0;\r\n        ptrdiff_t delta = 0;\r\n        unsigned mult = 1;\r\n\r\n        if ( *(p+2) == 'x' ) {\r\n            // Hexadecimal.\r\n            if ( !*(p+3) ) {\r\n                return 0;\r\n            }\r\n\r\n            const char* q = p+3;\r\n            q = strchr( q, ';' );\r\n\r\n            if ( !q || !*q ) {\r\n                return 0;\r\n            }\r\n\r\n            delta = q-p;\r\n            --q;\r\n\r\n            while ( *q != 'x' ) {\r\n                if ( *q >= '0' && *q <= '9' ) {\r\n                    ucs += mult * (*q - '0');\r\n                }\r\n                else if ( *q >= 'a' && *q <= 'f' ) {\r\n                    ucs += mult * (*q - 'a' + 10);\r\n                }\r\n                else if ( *q >= 'A' && *q <= 'F' ) {\r\n                    ucs += mult * (*q - 'A' + 10 );\r\n                }\r\n                else {\r\n                    return 0;\r\n                }\r\n                mult *= 16;\r\n                --q;\r\n            }\r\n        }\r\n        else {\r\n            // Decimal.\r\n            if ( !*(p+2) ) {\r\n                return 0;\r\n            }\r\n\r\n            const char* q = p+2;\r\n            q = strchr( q, ';' );\r\n\r\n            if ( !q || !*q ) {\r\n                return 0;\r\n            }\r\n\r\n            delta = q-p;\r\n            --q;\r\n\r\n            while ( *q != '#' ) {\r\n                if ( *q >= '0' && *q <= '9' ) {\r\n                    ucs += mult * (*q - '0');\r\n                }\r\n                else {\r\n                    return 0;\r\n                }\r\n                mult *= 10;\r\n                --q;\r\n            }\r\n        }\r\n        // convert the UCS to UTF-8\r\n        ConvertUTF32ToUTF8( ucs, value, length );\r\n        return p + delta + 1;\r\n    }\r\n    return p+1;\r\n}\r\n\r\n\r\nvoid XMLUtil::ToStr( int v, char* buffer, int bufferSize )\r\n{\r\n    TIXML_SNPRINTF( buffer, bufferSize, \"%d\", v );\r\n}\r\n\r\n\r\nvoid XMLUtil::ToStr( unsigned v, char* buffer, int bufferSize )\r\n{\r\n    TIXML_SNPRINTF( buffer, bufferSize, \"%u\", v );\r\n}\r\n\r\n\r\nvoid XMLUtil::ToStr( bool v, char* buffer, int bufferSize )\r\n{\r\n    TIXML_SNPRINTF( buffer, bufferSize, \"%d\", v ? 1 : 0 );\r\n}\r\n\r\n\r\nvoid XMLUtil::ToStr( float v, char* buffer, int bufferSize )\r\n{\r\n    TIXML_SNPRINTF( buffer, bufferSize, \"%g\", v );\r\n}\r\n\r\n\r\nvoid XMLUtil::ToStr( double v, char* buffer, int bufferSize )\r\n{\r\n    TIXML_SNPRINTF( buffer, bufferSize, \"%g\", v );\r\n}\r\n\r\n\r\nbool XMLUtil::ToInt( const char* str, int* value )\r\n{\r\n    if ( TIXML_SSCANF( str, \"%d\", value ) == 1 ) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nbool XMLUtil::ToUnsigned( const char* str, unsigned *value )\r\n{\r\n    if ( TIXML_SSCANF( str, \"%u\", value ) == 1 ) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nbool XMLUtil::ToBool( const char* str, bool* value )\r\n{\r\n    int ival = 0;\r\n    if ( ToInt( str, &ival )) {\r\n        *value = (ival==0) ? false : true;\r\n        return true;\r\n    }\r\n    if ( StringEqual( str, \"true\" ) ) {\r\n        *value = true;\r\n        return true;\r\n    }\r\n    else if ( StringEqual( str, \"false\" ) ) {\r\n        *value = false;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nbool XMLUtil::ToFloat( const char* str, float* value )\r\n{\r\n    if ( TIXML_SSCANF( str, \"%f\", value ) == 1 ) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nbool XMLUtil::ToDouble( const char* str, double* value )\r\n{\r\n    if ( TIXML_SSCANF( str, \"%lf\", value ) == 1 ) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nchar* XMLDocument::Identify( char* p, XMLNode** node )\r\n{\r\n    XMLNode* returnNode = 0;\r\n    char* start = p;\r\n    p = XMLUtil::SkipWhiteSpace( p );\r\n    if( !p || !*p ) {\r\n        return p;\r\n    }\r\n\r\n    // What is this thing?\r\n    // - Elements start with a letter or underscore, but xml is reserved.\r\n    // - Comments: <!--\r\n    // - Decleration: <?\r\n    // - Everthing else is unknown to tinyxml.\r\n    //\r\n\r\n    static const char* xmlHeader\t\t= { \"<?\" };\r\n    static const char* commentHeader\t= { \"<!--\" };\r\n    static const char* dtdHeader\t\t= { \"<!\" };\r\n    static const char* cdataHeader\t\t= { \"<![CDATA[\" };\r\n    static const char* elementHeader\t= { \"<\" };\t// and a header for everything else; check last.\r\n\r\n    static const int xmlHeaderLen\t\t= 2;\r\n    static const int commentHeaderLen\t= 4;\r\n    static const int dtdHeaderLen\t\t= 2;\r\n    static const int cdataHeaderLen\t\t= 9;\r\n    static const int elementHeaderLen\t= 1;\r\n\r\n#if defined(_MSC_VER)\r\n#pragma warning ( push )\r\n#pragma warning ( disable : 4127 )\r\n#endif\r\n    TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLUnknown ) );\t\t// use same memory pool\r\n    TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLDeclaration ) );\t// use same memory pool\r\n#if defined(_MSC_VER)\r\n#pragma warning (pop)\r\n#endif\r\n    if ( XMLUtil::StringEqual( p, xmlHeader, xmlHeaderLen ) ) {\r\n        returnNode = new (_commentPool.Alloc()) XMLDeclaration( this );\r\n        returnNode->_memPool = &_commentPool;\r\n        p += xmlHeaderLen;\r\n    }\r\n    else if ( XMLUtil::StringEqual( p, commentHeader, commentHeaderLen ) ) {\r\n        returnNode = new (_commentPool.Alloc()) XMLComment( this );\r\n        returnNode->_memPool = &_commentPool;\r\n        p += commentHeaderLen;\r\n    }\r\n    else if ( XMLUtil::StringEqual( p, cdataHeader, cdataHeaderLen ) ) {\r\n        XMLText* text = new (_textPool.Alloc()) XMLText( this );\r\n        returnNode = text;\r\n        returnNode->_memPool = &_textPool;\r\n        p += cdataHeaderLen;\r\n        text->SetCData( true );\r\n    }\r\n    else if ( XMLUtil::StringEqual( p, dtdHeader, dtdHeaderLen ) ) {\r\n        returnNode = new (_commentPool.Alloc()) XMLUnknown( this );\r\n        returnNode->_memPool = &_commentPool;\r\n        p += dtdHeaderLen;\r\n    }\r\n    else if ( XMLUtil::StringEqual( p, elementHeader, elementHeaderLen ) ) {\r\n        returnNode = new (_elementPool.Alloc()) XMLElement( this );\r\n        returnNode->_memPool = &_elementPool;\r\n        p += elementHeaderLen;\r\n    }\r\n    else {\r\n        returnNode = new (_textPool.Alloc()) XMLText( this );\r\n        returnNode->_memPool = &_textPool;\r\n        p = start;\t// Back it up, all the text counts.\r\n    }\r\n\r\n    *node = returnNode;\r\n    return p;\r\n}\r\n\r\n\r\nbool XMLDocument::Accept( XMLVisitor* visitor ) const\r\n{\r\n    if ( visitor->VisitEnter( *this ) ) {\r\n        for ( const XMLNode* node=FirstChild(); node; node=node->NextSibling() ) {\r\n            if ( !node->Accept( visitor ) ) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return visitor->VisitExit( *this );\r\n}\r\n\r\n\r\n// --------- XMLNode ----------- //\r\n\r\nXMLNode::XMLNode( XMLDocument* doc ) :\r\n    _document( doc ),\r\n    _parent( 0 ),\r\n    _firstChild( 0 ), _lastChild( 0 ),\r\n    _prev( 0 ), _next( 0 )\r\n{\r\n}\r\n\r\n\r\nXMLNode::~XMLNode()\r\n{\r\n    DeleteChildren();\r\n    if ( _parent ) {\r\n        _parent->Unlink( this );\r\n    }\r\n}\r\n\r\n\r\nvoid XMLNode::SetValue( const char* str, bool staticMem )\r\n{\r\n    if ( staticMem ) {\r\n        _value.SetInternedStr( str );\r\n    }\r\n    else {\r\n        _value.SetStr( str );\r\n    }\r\n}\r\n\r\n\r\nvoid XMLNode::DeleteChildren()\r\n{\r\n    while( _firstChild ) {\r\n        XMLNode* node = _firstChild;\r\n        Unlink( node );\r\n\r\n        DELETE_NODE( node );\r\n    }\r\n    _firstChild = _lastChild = 0;\r\n}\r\n\r\n\r\nvoid XMLNode::Unlink( XMLNode* child )\r\n{\r\n    TIXMLASSERT( child->_parent == this );\r\n    if ( child == _firstChild ) {\r\n        _firstChild = _firstChild->_next;\r\n    }\r\n    if ( child == _lastChild ) {\r\n        _lastChild = _lastChild->_prev;\r\n    }\r\n\r\n    if ( child->_prev ) {\r\n        child->_prev->_next = child->_next;\r\n    }\r\n    if ( child->_next ) {\r\n        child->_next->_prev = child->_prev;\r\n    }\r\n    child->_parent = 0;\r\n}\r\n\r\n\r\nvoid XMLNode::DeleteChild( XMLNode* node )\r\n{\r\n    TIXMLASSERT( node->_parent == this );\r\n    DELETE_NODE( node );\r\n}\r\n\r\n\r\nXMLNode* XMLNode::InsertEndChild( XMLNode* addThis )\r\n{\r\n    if ( _lastChild ) {\r\n        TIXMLASSERT( _firstChild );\r\n        TIXMLASSERT( _lastChild->_next == 0 );\r\n        _lastChild->_next = addThis;\r\n        addThis->_prev = _lastChild;\r\n        _lastChild = addThis;\r\n\r\n        addThis->_next = 0;\r\n    }\r\n    else {\r\n        TIXMLASSERT( _firstChild == 0 );\r\n        _firstChild = _lastChild = addThis;\r\n\r\n        addThis->_prev = 0;\r\n        addThis->_next = 0;\r\n    }\r\n    addThis->_parent = this;\r\n    addThis->_memPool->SetTracked();\r\n    return addThis;\r\n}\r\n\r\n\r\nXMLNode* XMLNode::InsertFirstChild( XMLNode* addThis )\r\n{\r\n    if ( _firstChild ) {\r\n        TIXMLASSERT( _lastChild );\r\n        TIXMLASSERT( _firstChild->_prev == 0 );\r\n\r\n        _firstChild->_prev = addThis;\r\n        addThis->_next = _firstChild;\r\n        _firstChild = addThis;\r\n\r\n        addThis->_prev = 0;\r\n    }\r\n    else {\r\n        TIXMLASSERT( _lastChild == 0 );\r\n        _firstChild = _lastChild = addThis;\r\n\r\n        addThis->_prev = 0;\r\n        addThis->_next = 0;\r\n    }\r\n    addThis->_parent = this;\r\n    addThis->_memPool->SetTracked();\r\n    return addThis;\r\n}\r\n\r\n\r\nXMLNode* XMLNode::InsertAfterChild( XMLNode* afterThis, XMLNode* addThis )\r\n{\r\n    TIXMLASSERT( afterThis->_parent == this );\r\n    if ( afterThis->_parent != this ) {\r\n        return 0;\r\n    }\r\n\r\n    if ( afterThis->_next == 0 ) {\r\n        // The last node or the only node.\r\n        return InsertEndChild( addThis );\r\n    }\r\n    addThis->_prev = afterThis;\r\n    addThis->_next = afterThis->_next;\r\n    afterThis->_next->_prev = addThis;\r\n    afterThis->_next = addThis;\r\n    addThis->_parent = this;\r\n    addThis->_memPool->SetTracked();\r\n    return addThis;\r\n}\r\n\r\n\r\n\r\n\r\nconst XMLElement* XMLNode::FirstChildElement( const char* value ) const\r\n{\r\n    for( XMLNode* node=_firstChild; node; node=node->_next ) {\r\n        XMLElement* element = node->ToElement();\r\n        if ( element ) {\r\n            if ( !value || XMLUtil::StringEqual( element->Name(), value ) ) {\r\n                return element;\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nconst XMLElement* XMLNode::LastChildElement( const char* value ) const\r\n{\r\n    for( XMLNode* node=_lastChild; node; node=node->_prev ) {\r\n        XMLElement* element = node->ToElement();\r\n        if ( element ) {\r\n            if ( !value || XMLUtil::StringEqual( element->Name(), value ) ) {\r\n                return element;\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nconst XMLElement* XMLNode::NextSiblingElement( const char* value ) const\r\n{\r\n    for( XMLNode* element=this->_next; element; element = element->_next ) {\r\n        if (    element->ToElement()\r\n                && (!value || XMLUtil::StringEqual( value, element->Value() ))) {\r\n            return element->ToElement();\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nconst XMLElement* XMLNode::PreviousSiblingElement( const char* value ) const\r\n{\r\n    for( XMLNode* element=_prev; element; element = element->_prev ) {\r\n        if (    element->ToElement()\r\n                && (!value || XMLUtil::StringEqual( value, element->Value() ))) {\r\n            return element->ToElement();\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nchar* XMLNode::ParseDeep( char* p, StrPair* parentEnd )\r\n{\r\n    // This is a recursive method, but thinking about it \"at the current level\"\r\n    // it is a pretty simple flat list:\r\n    //\t\t<foo/>\r\n    //\t\t<!-- comment -->\r\n    //\r\n    // With a special case:\r\n    //\t\t<foo>\r\n    //\t\t</foo>\r\n    //\t\t<!-- comment -->\r\n    //\r\n    // Where the closing element (/foo) *must* be the next thing after the opening\r\n    // element, and the names must match. BUT the tricky bit is that the closing\r\n    // element will be read by the child.\r\n    //\r\n    // 'endTag' is the end tag for this node, it is returned by a call to a child.\r\n    // 'parentEnd' is the end tag for the parent, which is filled in and returned.\r\n\r\n    while( p && *p ) {\r\n        XMLNode* node = 0;\r\n\r\n        p = _document->Identify( p, &node );\r\n        if ( p == 0 || node == 0 ) {\r\n            break;\r\n        }\r\n\r\n        StrPair endTag;\r\n        p = node->ParseDeep( p, &endTag );\r\n        if ( !p ) {\r\n            DELETE_NODE( node );\r\n            node = 0;\r\n            if ( !_document->Error() ) {\r\n                _document->SetError( XML_ERROR_PARSING, 0, 0 );\r\n            }\r\n            break;\r\n        }\r\n\r\n        // We read the end tag. Return it to the parent.\r\n        if ( node->ToElement() && node->ToElement()->ClosingType() == XMLElement::CLOSING ) {\r\n            if ( parentEnd ) {\r\n                *parentEnd = static_cast<XMLElement*>(node)->_value;\r\n            }\r\n\t\t\tnode->_memPool->SetTracked();\t// created and then immediately deleted.\r\n            DELETE_NODE( node );\r\n            return p;\r\n        }\r\n\r\n        // Handle an end tag returned to this level.\r\n        // And handle a bunch of annoying errors.\r\n        XMLElement* ele = node->ToElement();\r\n        if ( ele ) {\r\n            if ( endTag.Empty() && ele->ClosingType() == XMLElement::OPEN ) {\r\n                _document->SetError( XML_ERROR_MISMATCHED_ELEMENT, node->Value(), 0 );\r\n                p = 0;\r\n            }\r\n            else if ( !endTag.Empty() && ele->ClosingType() != XMLElement::OPEN ) {\r\n                _document->SetError( XML_ERROR_MISMATCHED_ELEMENT, node->Value(), 0 );\r\n                p = 0;\r\n            }\r\n            else if ( !endTag.Empty() ) {\r\n                if ( !XMLUtil::StringEqual( endTag.GetStr(), node->Value() )) {\r\n                    _document->SetError( XML_ERROR_MISMATCHED_ELEMENT, node->Value(), 0 );\r\n                    p = 0;\r\n                }\r\n            }\r\n        }\r\n        if ( p == 0 ) {\r\n            DELETE_NODE( node );\r\n            node = 0;\r\n        }\r\n        if ( node ) {\r\n            this->InsertEndChild( node );\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n// --------- XMLText ---------- //\r\nchar* XMLText::ParseDeep( char* p, StrPair* )\r\n{\r\n    const char* start = p;\r\n    if ( this->CData() ) {\r\n        p = _value.ParseText( p, \"]]>\", StrPair::NEEDS_NEWLINE_NORMALIZATION );\r\n        if ( !p ) {\r\n            _document->SetError( XML_ERROR_PARSING_CDATA, start, 0 );\r\n        }\r\n        return p;\r\n    }\r\n    else {\r\n        int flags = _document->ProcessEntities() ? StrPair::TEXT_ELEMENT : StrPair::TEXT_ELEMENT_LEAVE_ENTITIES;\r\n        if ( _document->WhitespaceMode() == COLLAPSE_WHITESPACE ) {\r\n            flags |= StrPair::COLLAPSE_WHITESPACE;\r\n        }\r\n\r\n        p = _value.ParseText( p, \"<\", flags );\r\n        if ( !p ) {\r\n            _document->SetError( XML_ERROR_PARSING_TEXT, start, 0 );\r\n        }\r\n        if ( p && *p ) {\r\n            return p-1;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nXMLNode* XMLText::ShallowClone( XMLDocument* doc ) const\r\n{\r\n    if ( !doc ) {\r\n        doc = _document;\r\n    }\r\n    XMLText* text = doc->NewText( Value() );\t// fixme: this will always allocate memory. Intern?\r\n    text->SetCData( this->CData() );\r\n    return text;\r\n}\r\n\r\n\r\nbool XMLText::ShallowEqual( const XMLNode* compare ) const\r\n{\r\n    return ( compare->ToText() && XMLUtil::StringEqual( compare->ToText()->Value(), Value() ));\r\n}\r\n\r\n\r\nbool XMLText::Accept( XMLVisitor* visitor ) const\r\n{\r\n    return visitor->Visit( *this );\r\n}\r\n\r\n\r\n// --------- XMLComment ---------- //\r\n\r\nXMLComment::XMLComment( XMLDocument* doc ) : XMLNode( doc )\r\n{\r\n}\r\n\r\n\r\nXMLComment::~XMLComment()\r\n{\r\n}\r\n\r\n\r\nchar* XMLComment::ParseDeep( char* p, StrPair* )\r\n{\r\n    // Comment parses as text.\r\n    const char* start = p;\r\n    p = _value.ParseText( p, \"-->\", StrPair::COMMENT );\r\n    if ( p == 0 ) {\r\n        _document->SetError( XML_ERROR_PARSING_COMMENT, start, 0 );\r\n    }\r\n    return p;\r\n}\r\n\r\n\r\nXMLNode* XMLComment::ShallowClone( XMLDocument* doc ) const\r\n{\r\n    if ( !doc ) {\r\n        doc = _document;\r\n    }\r\n    XMLComment* comment = doc->NewComment( Value() );\t// fixme: this will always allocate memory. Intern?\r\n    return comment;\r\n}\r\n\r\n\r\nbool XMLComment::ShallowEqual( const XMLNode* compare ) const\r\n{\r\n    return ( compare->ToComment() && XMLUtil::StringEqual( compare->ToComment()->Value(), Value() ));\r\n}\r\n\r\n\r\nbool XMLComment::Accept( XMLVisitor* visitor ) const\r\n{\r\n    return visitor->Visit( *this );\r\n}\r\n\r\n\r\n// --------- XMLDeclaration ---------- //\r\n\r\nXMLDeclaration::XMLDeclaration( XMLDocument* doc ) : XMLNode( doc )\r\n{\r\n}\r\n\r\n\r\nXMLDeclaration::~XMLDeclaration()\r\n{\r\n    //printf( \"~XMLDeclaration\\n\" );\r\n}\r\n\r\n\r\nchar* XMLDeclaration::ParseDeep( char* p, StrPair* )\r\n{\r\n    // Declaration parses as text.\r\n    const char* start = p;\r\n    p = _value.ParseText( p, \"?>\", StrPair::NEEDS_NEWLINE_NORMALIZATION );\r\n    if ( p == 0 ) {\r\n        _document->SetError( XML_ERROR_PARSING_DECLARATION, start, 0 );\r\n    }\r\n    return p;\r\n}\r\n\r\n\r\nXMLNode* XMLDeclaration::ShallowClone( XMLDocument* doc ) const\r\n{\r\n    if ( !doc ) {\r\n        doc = _document;\r\n    }\r\n    XMLDeclaration* dec = doc->NewDeclaration( Value() );\t// fixme: this will always allocate memory. Intern?\r\n    return dec;\r\n}\r\n\r\n\r\nbool XMLDeclaration::ShallowEqual( const XMLNode* compare ) const\r\n{\r\n    return ( compare->ToDeclaration() && XMLUtil::StringEqual( compare->ToDeclaration()->Value(), Value() ));\r\n}\r\n\r\n\r\n\r\nbool XMLDeclaration::Accept( XMLVisitor* visitor ) const\r\n{\r\n    return visitor->Visit( *this );\r\n}\r\n\r\n// --------- XMLUnknown ---------- //\r\n\r\nXMLUnknown::XMLUnknown( XMLDocument* doc ) : XMLNode( doc )\r\n{\r\n}\r\n\r\n\r\nXMLUnknown::~XMLUnknown()\r\n{\r\n}\r\n\r\n\r\nchar* XMLUnknown::ParseDeep( char* p, StrPair* )\r\n{\r\n    // Unknown parses as text.\r\n    const char* start = p;\r\n\r\n    p = _value.ParseText( p, \">\", StrPair::NEEDS_NEWLINE_NORMALIZATION );\r\n    if ( !p ) {\r\n        _document->SetError( XML_ERROR_PARSING_UNKNOWN, start, 0 );\r\n    }\r\n    return p;\r\n}\r\n\r\n\r\nXMLNode* XMLUnknown::ShallowClone( XMLDocument* doc ) const\r\n{\r\n    if ( !doc ) {\r\n        doc = _document;\r\n    }\r\n    XMLUnknown* text = doc->NewUnknown( Value() );\t// fixme: this will always allocate memory. Intern?\r\n    return text;\r\n}\r\n\r\n\r\nbool XMLUnknown::ShallowEqual( const XMLNode* compare ) const\r\n{\r\n    return ( compare->ToUnknown() && XMLUtil::StringEqual( compare->ToUnknown()->Value(), Value() ));\r\n}\r\n\r\n\r\nbool XMLUnknown::Accept( XMLVisitor* visitor ) const\r\n{\r\n    return visitor->Visit( *this );\r\n}\r\n\r\n// --------- XMLAttribute ---------- //\r\nchar* XMLAttribute::ParseDeep( char* p, bool processEntities )\r\n{\r\n    // Parse using the name rules: bug fix, was using ParseText before\r\n    p = _name.ParseName( p );\r\n    if ( !p || !*p ) {\r\n        return 0;\r\n    }\r\n\r\n    // Skip white space before =\r\n    p = XMLUtil::SkipWhiteSpace( p );\r\n    if ( !p || *p != '=' ) {\r\n        return 0;\r\n    }\r\n\r\n    ++p;\t// move up to opening quote\r\n    p = XMLUtil::SkipWhiteSpace( p );\r\n    if ( *p != '\\\"' && *p != '\\'' ) {\r\n        return 0;\r\n    }\r\n\r\n    char endTag[2] = { *p, 0 };\r\n    ++p;\t// move past opening quote\r\n\r\n    p = _value.ParseText( p, endTag, processEntities ? StrPair::ATTRIBUTE_VALUE : StrPair::ATTRIBUTE_VALUE_LEAVE_ENTITIES );\r\n    return p;\r\n}\r\n\r\n\r\nvoid XMLAttribute::SetName( const char* n )\r\n{\r\n    _name.SetStr( n );\r\n}\r\n\r\n\r\nXMLError XMLAttribute::QueryIntValue( int* value ) const\r\n{\r\n    if ( XMLUtil::ToInt( Value(), value )) {\r\n        return XML_NO_ERROR;\r\n    }\r\n    return XML_WRONG_ATTRIBUTE_TYPE;\r\n}\r\n\r\n\r\nXMLError XMLAttribute::QueryUnsignedValue( unsigned int* value ) const\r\n{\r\n    if ( XMLUtil::ToUnsigned( Value(), value )) {\r\n        return XML_NO_ERROR;\r\n    }\r\n    return XML_WRONG_ATTRIBUTE_TYPE;\r\n}\r\n\r\n\r\nXMLError XMLAttribute::QueryBoolValue( bool* value ) const\r\n{\r\n    if ( XMLUtil::ToBool( Value(), value )) {\r\n        return XML_NO_ERROR;\r\n    }\r\n    return XML_WRONG_ATTRIBUTE_TYPE;\r\n}\r\n\r\n\r\nXMLError XMLAttribute::QueryFloatValue( float* value ) const\r\n{\r\n    if ( XMLUtil::ToFloat( Value(), value )) {\r\n        return XML_NO_ERROR;\r\n    }\r\n    return XML_WRONG_ATTRIBUTE_TYPE;\r\n}\r\n\r\n\r\nXMLError XMLAttribute::QueryDoubleValue( double* value ) const\r\n{\r\n    if ( XMLUtil::ToDouble( Value(), value )) {\r\n        return XML_NO_ERROR;\r\n    }\r\n    return XML_WRONG_ATTRIBUTE_TYPE;\r\n}\r\n\r\n\r\nvoid XMLAttribute::SetAttribute( const char* v )\r\n{\r\n    _value.SetStr( v );\r\n}\r\n\r\n\r\nvoid XMLAttribute::SetAttribute( int v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    _value.SetStr( buf );\r\n}\r\n\r\n\r\nvoid XMLAttribute::SetAttribute( unsigned v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    _value.SetStr( buf );\r\n}\r\n\r\n\r\nvoid XMLAttribute::SetAttribute( bool v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    _value.SetStr( buf );\r\n}\r\n\r\nvoid XMLAttribute::SetAttribute( double v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    _value.SetStr( buf );\r\n}\r\n\r\nvoid XMLAttribute::SetAttribute( float v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    _value.SetStr( buf );\r\n}\r\n\r\n\r\n// --------- XMLElement ---------- //\r\nXMLElement::XMLElement( XMLDocument* doc ) : XMLNode( doc ),\r\n    _closingType( 0 ),\r\n    _rootAttribute( 0 )\r\n{\r\n}\r\n\r\n\r\nXMLElement::~XMLElement()\r\n{\r\n    while( _rootAttribute ) {\r\n        XMLAttribute* next = _rootAttribute->_next;\r\n        DELETE_ATTRIBUTE( _rootAttribute );\r\n        _rootAttribute = next;\r\n    }\r\n}\r\n\r\n\r\nXMLAttribute* XMLElement::FindAttribute( const char* name )\r\n{\r\n    XMLAttribute* a = 0;\r\n    for( a=_rootAttribute; a; a = a->_next ) {\r\n        if ( XMLUtil::StringEqual( a->Name(), name ) ) {\r\n            return a;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nconst XMLAttribute* XMLElement::FindAttribute( const char* name ) const\r\n{\r\n    XMLAttribute* a = 0;\r\n    for( a=_rootAttribute; a; a = a->_next ) {\r\n        if ( XMLUtil::StringEqual( a->Name(), name ) ) {\r\n            return a;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nconst char* XMLElement::Attribute( const char* name, const char* value ) const\r\n{\r\n    const XMLAttribute* a = FindAttribute( name );\r\n    if ( !a ) {\r\n        return 0;\r\n    }\r\n    if ( !value || XMLUtil::StringEqual( a->Value(), value )) {\r\n        return a->Value();\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nconst char* XMLElement::GetText() const\r\n{\r\n    if ( FirstChild() && FirstChild()->ToText() ) {\r\n        return FirstChild()->ToText()->Value();\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nXMLError XMLElement::QueryIntText( int* ival ) const\r\n{\r\n    if ( FirstChild() && FirstChild()->ToText() ) {\r\n        const char* t = FirstChild()->ToText()->Value();\r\n        if ( XMLUtil::ToInt( t, ival ) ) {\r\n            return XML_SUCCESS;\r\n        }\r\n        return XML_CAN_NOT_CONVERT_TEXT;\r\n    }\r\n    return XML_NO_TEXT_NODE;\r\n}\r\n\r\n\r\nXMLError XMLElement::QueryUnsignedText( unsigned* uval ) const\r\n{\r\n    if ( FirstChild() && FirstChild()->ToText() ) {\r\n        const char* t = FirstChild()->ToText()->Value();\r\n        if ( XMLUtil::ToUnsigned( t, uval ) ) {\r\n            return XML_SUCCESS;\r\n        }\r\n        return XML_CAN_NOT_CONVERT_TEXT;\r\n    }\r\n    return XML_NO_TEXT_NODE;\r\n}\r\n\r\n\r\nXMLError XMLElement::QueryBoolText( bool* bval ) const\r\n{\r\n    if ( FirstChild() && FirstChild()->ToText() ) {\r\n        const char* t = FirstChild()->ToText()->Value();\r\n        if ( XMLUtil::ToBool( t, bval ) ) {\r\n            return XML_SUCCESS;\r\n        }\r\n        return XML_CAN_NOT_CONVERT_TEXT;\r\n    }\r\n    return XML_NO_TEXT_NODE;\r\n}\r\n\r\n\r\nXMLError XMLElement::QueryDoubleText( double* dval ) const\r\n{\r\n    if ( FirstChild() && FirstChild()->ToText() ) {\r\n        const char* t = FirstChild()->ToText()->Value();\r\n        if ( XMLUtil::ToDouble( t, dval ) ) {\r\n            return XML_SUCCESS;\r\n        }\r\n        return XML_CAN_NOT_CONVERT_TEXT;\r\n    }\r\n    return XML_NO_TEXT_NODE;\r\n}\r\n\r\n\r\nXMLError XMLElement::QueryFloatText( float* fval ) const\r\n{\r\n    if ( FirstChild() && FirstChild()->ToText() ) {\r\n        const char* t = FirstChild()->ToText()->Value();\r\n        if ( XMLUtil::ToFloat( t, fval ) ) {\r\n            return XML_SUCCESS;\r\n        }\r\n        return XML_CAN_NOT_CONVERT_TEXT;\r\n    }\r\n    return XML_NO_TEXT_NODE;\r\n}\r\n\r\n\r\n\r\nXMLAttribute* XMLElement::FindOrCreateAttribute( const char* name )\r\n{\r\n    XMLAttribute* last = 0;\r\n    XMLAttribute* attrib = 0;\r\n    for( attrib = _rootAttribute;\r\n            attrib;\r\n            last = attrib, attrib = attrib->_next ) {\r\n        if ( XMLUtil::StringEqual( attrib->Name(), name ) ) {\r\n            break;\r\n        }\r\n    }\r\n    if ( !attrib ) {\r\n        attrib = new (_document->_attributePool.Alloc() ) XMLAttribute();\r\n        attrib->_memPool = &_document->_attributePool;\r\n        if ( last ) {\r\n            last->_next = attrib;\r\n        }\r\n        else {\r\n            _rootAttribute = attrib;\r\n        }\r\n        attrib->SetName( name );\r\n        attrib->_memPool->SetTracked(); // always created and linked.\r\n    }\r\n    return attrib;\r\n}\r\n\r\n\r\nvoid XMLElement::DeleteAttribute( const char* name )\r\n{\r\n    XMLAttribute* prev = 0;\r\n    for( XMLAttribute* a=_rootAttribute; a; a=a->_next ) {\r\n        if ( XMLUtil::StringEqual( name, a->Name() ) ) {\r\n            if ( prev ) {\r\n                prev->_next = a->_next;\r\n            }\r\n            else {\r\n                _rootAttribute = a->_next;\r\n            }\r\n            DELETE_ATTRIBUTE( a );\r\n            break;\r\n        }\r\n        prev = a;\r\n    }\r\n}\r\n\r\n\r\nchar* XMLElement::ParseAttributes( char* p )\r\n{\r\n    const char* start = p;\r\n    XMLAttribute* prevAttribute = 0;\r\n\r\n    // Read the attributes.\r\n    while( p ) {\r\n        p = XMLUtil::SkipWhiteSpace( p );\r\n        if ( !p || !(*p) ) {\r\n            _document->SetError( XML_ERROR_PARSING_ELEMENT, start, Name() );\r\n            return 0;\r\n        }\r\n\r\n        // attribute.\r\n        if (XMLUtil::IsNameStartChar( *p ) ) {\r\n            XMLAttribute* attrib = new (_document->_attributePool.Alloc() ) XMLAttribute();\r\n            attrib->_memPool = &_document->_attributePool;\r\n\t\t\tattrib->_memPool->SetTracked();\r\n\r\n            p = attrib->ParseDeep( p, _document->ProcessEntities() );\r\n            if ( !p || Attribute( attrib->Name() ) ) {\r\n                DELETE_ATTRIBUTE( attrib );\r\n                _document->SetError( XML_ERROR_PARSING_ATTRIBUTE, start, p );\r\n                return 0;\r\n            }\r\n            // There is a minor bug here: if the attribute in the source xml\r\n            // document is duplicated, it will not be detected and the\r\n            // attribute will be doubly added. However, tracking the 'prevAttribute'\r\n            // avoids re-scanning the attribute list. Preferring performance for\r\n            // now, may reconsider in the future.\r\n            if ( prevAttribute ) {\r\n                prevAttribute->_next = attrib;\r\n            }\r\n            else {\r\n                _rootAttribute = attrib;\r\n            }\r\n            prevAttribute = attrib;\r\n        }\r\n        // end of the tag\r\n        else if ( *p == '/' && *(p+1) == '>' ) {\r\n            _closingType = CLOSED;\r\n            return p+2;\t// done; sealed element.\r\n        }\r\n        // end of the tag\r\n        else if ( *p == '>' ) {\r\n            ++p;\r\n            break;\r\n        }\r\n        else {\r\n            _document->SetError( XML_ERROR_PARSING_ELEMENT, start, p );\r\n            return 0;\r\n        }\r\n    }\r\n    return p;\r\n}\r\n\r\n\r\n//\r\n//\t<ele></ele>\r\n//\t<ele>foo<b>bar</b></ele>\r\n//\r\nchar* XMLElement::ParseDeep( char* p, StrPair* strPair )\r\n{\r\n    // Read the element name.\r\n    p = XMLUtil::SkipWhiteSpace( p );\r\n    if ( !p ) {\r\n        return 0;\r\n    }\r\n\r\n    // The closing element is the </element> form. It is\r\n    // parsed just like a regular element then deleted from\r\n    // the DOM.\r\n    if ( *p == '/' ) {\r\n        _closingType = CLOSING;\r\n        ++p;\r\n    }\r\n\r\n    p = _value.ParseName( p );\r\n    if ( _value.Empty() ) {\r\n        return 0;\r\n    }\r\n\r\n    p = ParseAttributes( p );\r\n    if ( !p || !*p || _closingType ) {\r\n        return p;\r\n    }\r\n\r\n    p = XMLNode::ParseDeep( p, strPair );\r\n    return p;\r\n}\r\n\r\n\r\n\r\nXMLNode* XMLElement::ShallowClone( XMLDocument* doc ) const\r\n{\r\n    if ( !doc ) {\r\n        doc = _document;\r\n    }\r\n    XMLElement* element = doc->NewElement( Value() );\t\t\t\t\t// fixme: this will always allocate memory. Intern?\r\n    for( const XMLAttribute* a=FirstAttribute(); a; a=a->Next() ) {\r\n        element->SetAttribute( a->Name(), a->Value() );\t\t\t\t\t// fixme: this will always allocate memory. Intern?\r\n    }\r\n    return element;\r\n}\r\n\r\n\r\nbool XMLElement::ShallowEqual( const XMLNode* compare ) const\r\n{\r\n    const XMLElement* other = compare->ToElement();\r\n    if ( other && XMLUtil::StringEqual( other->Value(), Value() )) {\r\n\r\n        const XMLAttribute* a=FirstAttribute();\r\n        const XMLAttribute* b=other->FirstAttribute();\r\n\r\n        while ( a && b ) {\r\n            if ( !XMLUtil::StringEqual( a->Value(), b->Value() ) ) {\r\n                return false;\r\n            }\r\n            a = a->Next();\r\n            b = b->Next();\r\n        }\r\n        if ( a || b ) {\r\n            // different count\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nbool XMLElement::Accept( XMLVisitor* visitor ) const\r\n{\r\n    if ( visitor->VisitEnter( *this, _rootAttribute ) ) {\r\n        for ( const XMLNode* node=FirstChild(); node; node=node->NextSibling() ) {\r\n            if ( !node->Accept( visitor ) ) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return visitor->VisitExit( *this );\r\n}\r\n\r\n\r\n// --------- XMLDocument ----------- //\r\nXMLDocument::XMLDocument( bool processEntities, Whitespace whitespace ) :\r\n    XMLNode( 0 ),\r\n    _writeBOM( false ),\r\n    _processEntities( processEntities ),\r\n    _errorID( XML_NO_ERROR ),\r\n    _whitespace( whitespace ),\r\n    _errorStr1( 0 ),\r\n    _errorStr2( 0 ),\r\n    _charBuffer( 0 )\r\n{\r\n    _document = this;\t// avoid warning about 'this' in initializer list\r\n}\r\n\r\n\r\nXMLDocument::~XMLDocument()\r\n{\r\n    DeleteChildren();\r\n    delete [] _charBuffer;\r\n\r\n#if 0\r\n    _textPool.Trace( \"text\" );\r\n    _elementPool.Trace( \"element\" );\r\n    _commentPool.Trace( \"comment\" );\r\n    _attributePool.Trace( \"attribute\" );\r\n#endif\r\n\r\n#ifdef DEBUG\r\n\tif ( Error() == false ) {\r\n\t\tTIXMLASSERT( _elementPool.CurrentAllocs()   == _elementPool.Untracked() );\r\n\t\tTIXMLASSERT( _attributePool.CurrentAllocs() == _attributePool.Untracked() );\r\n\t\tTIXMLASSERT( _textPool.CurrentAllocs()      == _textPool.Untracked() );\r\n\t\tTIXMLASSERT( _commentPool.CurrentAllocs()   == _commentPool.Untracked() );\r\n\t}\r\n#endif\r\n}\r\n\r\n\r\nvoid XMLDocument::Clear()\r\n{\r\n    DeleteChildren();\r\n\r\n    _errorID = XML_NO_ERROR;\r\n    _errorStr1 = 0;\r\n    _errorStr2 = 0;\r\n\r\n    delete [] _charBuffer;\r\n    _charBuffer = 0;\r\n}\r\n\r\n\r\nXMLElement* XMLDocument::NewElement( const char* name )\r\n{\r\n    XMLElement* ele = new (_elementPool.Alloc()) XMLElement( this );\r\n    ele->_memPool = &_elementPool;\r\n    ele->SetName( name );\r\n    return ele;\r\n}\r\n\r\n\r\nXMLComment* XMLDocument::NewComment( const char* str )\r\n{\r\n    XMLComment* comment = new (_commentPool.Alloc()) XMLComment( this );\r\n    comment->_memPool = &_commentPool;\r\n    comment->SetValue( str );\r\n    return comment;\r\n}\r\n\r\n\r\nXMLText* XMLDocument::NewText( const char* str )\r\n{\r\n    XMLText* text = new (_textPool.Alloc()) XMLText( this );\r\n    text->_memPool = &_textPool;\r\n    text->SetValue( str );\r\n    return text;\r\n}\r\n\r\n\r\nXMLDeclaration* XMLDocument::NewDeclaration( const char* str )\r\n{\r\n    XMLDeclaration* dec = new (_commentPool.Alloc()) XMLDeclaration( this );\r\n    dec->_memPool = &_commentPool;\r\n    dec->SetValue( str ? str : \"xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"\" );\r\n    return dec;\r\n}\r\n\r\n\r\nXMLUnknown* XMLDocument::NewUnknown( const char* str )\r\n{\r\n    XMLUnknown* unk = new (_commentPool.Alloc()) XMLUnknown( this );\r\n    unk->_memPool = &_commentPool;\r\n    unk->SetValue( str );\r\n    return unk;\r\n}\r\n\r\n\r\nXMLError XMLDocument::LoadFile( const char* filename )\r\n{\r\n    Clear();\r\n    FILE* fp = 0;\r\n\r\n#if defined(_MSC_VER) && (_MSC_VER >= 1400 )\r\n    errno_t err = fopen_s(&fp, filename, \"rb\" );\r\n    if ( !fp || err) {\r\n#else\r\n    fp = fopen( filename, \"rb\" );\r\n    if ( !fp) {\r\n#endif\r\n        SetError( XML_ERROR_FILE_NOT_FOUND, filename, 0 );\r\n        return _errorID;\r\n    }\r\n    LoadFile( fp );\r\n    fclose( fp );\r\n    return _errorID;\r\n}\r\n\r\n\r\nXMLError XMLDocument::LoadFile( FILE* fp )\r\n{\r\n    Clear();\r\n\r\n    fseek( fp, 0, SEEK_END );\r\n    size_t size = ftell( fp );\r\n    fseek( fp, 0, SEEK_SET );\r\n\r\n    if ( size == 0 ) {\r\n        return _errorID;\r\n    }\r\n\r\n    _charBuffer = new char[size+1];\r\n    size_t read = fread( _charBuffer, 1, size, fp );\r\n    if ( read != size ) {\r\n        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );\r\n        return _errorID;\r\n    }\r\n\r\n    _charBuffer[size] = 0;\r\n\r\n    const char* p = _charBuffer;\r\n    p = XMLUtil::SkipWhiteSpace( p );\r\n    p = XMLUtil::ReadBOM( p, &_writeBOM );\r\n    if ( !p || !*p ) {\r\n        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );\r\n        return _errorID;\r\n    }\r\n\r\n    ParseDeep( _charBuffer + (p-_charBuffer), 0 );\r\n    return _errorID;\r\n}\r\n\r\n\r\nXMLError XMLDocument::SaveFile( const char* filename, bool compact )\r\n{\r\n    FILE* fp = 0;\r\n#if defined(_MSC_VER) && (_MSC_VER >= 1400 )\r\n    errno_t err = fopen_s(&fp, filename, \"w\" );\r\n    if ( !fp || err) {\r\n#else\r\n    fp = fopen( filename, \"w\" );\r\n    if ( !fp) {\r\n#endif\r\n        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, filename, 0 );\r\n        return _errorID;\r\n    }\r\n    SaveFile(fp, compact);\r\n    fclose( fp );\r\n    return _errorID;\r\n}\r\n\r\n\r\nXMLError XMLDocument::SaveFile( FILE* fp, bool compact )\r\n{\r\n    XMLPrinter stream( fp, compact );\r\n    Print( &stream );\r\n    return _errorID;\r\n}\r\n\r\n\r\nXMLError XMLDocument::Parse( const char* p, size_t len )\r\n{\r\n    Clear();\r\n\r\n    if ( !p || !*p ) {\r\n        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );\r\n        return _errorID;\r\n    }\r\n    if ( len == (size_t)(-1) ) {\r\n        len = strlen( p );\r\n    }\r\n    _charBuffer = new char[ len+1 ];\r\n    memcpy( _charBuffer, p, len );\r\n    _charBuffer[len] = 0;\r\n\r\n    p = XMLUtil::SkipWhiteSpace( p );\r\n    p = XMLUtil::ReadBOM( p, &_writeBOM );\r\n    if ( !p || !*p ) {\r\n        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );\r\n        return _errorID;\r\n    }\r\n\r\n    ParseDeep( _charBuffer, 0 );\r\n    return _errorID;\r\n}\r\n\r\n\r\nvoid XMLDocument::Print( XMLPrinter* streamer )\r\n{\r\n    XMLPrinter stdStreamer( stdout );\r\n    if ( !streamer ) {\r\n        streamer = &stdStreamer;\r\n    }\r\n    Accept( streamer );\r\n}\r\n\r\n\r\nvoid XMLDocument::SetError( XMLError error, const char* str1, const char* str2 )\r\n{\r\n    _errorID = error;\r\n    _errorStr1 = str1;\r\n    _errorStr2 = str2;\r\n}\r\n\r\n\r\nvoid XMLDocument::PrintError() const\r\n{\r\n    if ( _errorID ) {\r\n        static const int LEN = 20;\r\n        char buf1[LEN] = { 0 };\r\n        char buf2[LEN] = { 0 };\r\n\r\n        if ( _errorStr1 ) {\r\n            TIXML_SNPRINTF( buf1, LEN, \"%s\", _errorStr1 );\r\n        }\r\n        if ( _errorStr2 ) {\r\n            TIXML_SNPRINTF( buf2, LEN, \"%s\", _errorStr2 );\r\n        }\r\n\r\n        printf( \"XMLDocument error id=%d str1=%s str2=%s\\n\",\r\n                _errorID, buf1, buf2 );\r\n    }\r\n}\r\n\r\n\r\nXMLPrinter::XMLPrinter( FILE* file, bool compact ) :\r\n    _elementJustOpened( false ),\r\n    _firstElement( true ),\r\n    _fp( file ),\r\n    _depth( 0 ),\r\n    _textDepth( -1 ),\r\n    _processEntities( true ),\r\n    _compactMode( compact )\r\n{\r\n    for( int i=0; i<ENTITY_RANGE; ++i ) {\r\n        _entityFlag[i] = false;\r\n        _restrictedEntityFlag[i] = false;\r\n    }\r\n    for( int i=0; i<NUM_ENTITIES; ++i ) {\r\n        TIXMLASSERT( entities[i].value < ENTITY_RANGE );\r\n        if ( entities[i].value < ENTITY_RANGE ) {\r\n            _entityFlag[ (int)entities[i].value ] = true;\r\n        }\r\n    }\r\n    _restrictedEntityFlag[(int)'&'] = true;\r\n    _restrictedEntityFlag[(int)'<'] = true;\r\n    _restrictedEntityFlag[(int)'>'] = true;\t// not required, but consistency is nice\r\n    _buffer.Push( 0 );\r\n}\r\n\r\n\r\nvoid XMLPrinter::Print( const char* format, ... )\r\n{\r\n    va_list     va;\r\n    va_start( va, format );\r\n\r\n    if ( _fp ) {\r\n        vfprintf( _fp, format, va );\r\n    }\r\n    else {\r\n        // This seems brutally complex. Haven't figured out a better\r\n        // way on windows.\r\n#ifdef _MSC_VER\r\n        int len = -1;\r\n        int expand = 1000;\r\n        while ( len < 0 ) {\r\n            len = vsnprintf_s( _accumulator.Mem(), _accumulator.Capacity(), _TRUNCATE, format, va );\r\n            if ( len < 0 ) {\r\n                expand *= 3/2;\r\n                _accumulator.PushArr( expand );\r\n            }\r\n        }\r\n        char* p = _buffer.PushArr( len ) - 1;\r\n        memcpy( p, _accumulator.Mem(), len+1 );\r\n#else\r\n        int len = vsnprintf( 0, 0, format, va );\r\n        // Close out and re-start the va-args\r\n        va_end( va );\r\n        va_start( va, format );\r\n        char* p = _buffer.PushArr( len ) - 1;\r\n        vsnprintf( p, len+1, format, va );\r\n#endif\r\n    }\r\n    va_end( va );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PrintSpace( int depth )\r\n{\r\n    for( int i=0; i<depth; ++i ) {\r\n        Print( \"    \" );\r\n    }\r\n}\r\n\r\n\r\nvoid XMLPrinter::PrintString( const char* p, bool restricted )\r\n{\r\n    // Look for runs of bytes between entities to print.\r\n    const char* q = p;\r\n    const bool* flag = restricted ? _restrictedEntityFlag : _entityFlag;\r\n\r\n    if ( _processEntities ) {\r\n        while ( *q ) {\r\n            // Remember, char is sometimes signed. (How many times has that bitten me?)\r\n            if ( *q > 0 && *q < ENTITY_RANGE ) {\r\n                // Check for entities. If one is found, flush\r\n                // the stream up until the entity, write the\r\n                // entity, and keep looking.\r\n                if ( flag[(unsigned)(*q)] ) {\r\n                    while ( p < q ) {\r\n                        Print( \"%c\", *p );\r\n                        ++p;\r\n                    }\r\n                    for( int i=0; i<NUM_ENTITIES; ++i ) {\r\n                        if ( entities[i].value == *q ) {\r\n                            Print( \"&%s;\", entities[i].pattern );\r\n                            break;\r\n                        }\r\n                    }\r\n                    ++p;\r\n                }\r\n            }\r\n            ++q;\r\n        }\r\n    }\r\n    // Flush the remaining string. This will be the entire\r\n    // string if an entity wasn't found.\r\n    if ( !_processEntities || (q-p > 0) ) {\r\n        Print( \"%s\", p );\r\n    }\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushHeader( bool writeBOM, bool writeDec )\r\n{\r\n    static const unsigned char bom[] = { TIXML_UTF_LEAD_0, TIXML_UTF_LEAD_1, TIXML_UTF_LEAD_2, 0 };\r\n    if ( writeBOM ) {\r\n        Print( \"%s\", bom );\r\n    }\r\n    if ( writeDec ) {\r\n        PushDeclaration( \"xml version=\\\"1.0\\\"\" );\r\n    }\r\n}\r\n\r\n\r\nvoid XMLPrinter::OpenElement( const char* name )\r\n{\r\n    if ( _elementJustOpened ) {\r\n        SealElement();\r\n    }\r\n    _stack.Push( name );\r\n\r\n    if ( _textDepth < 0 && !_firstElement && !_compactMode ) {\r\n        Print( \"\\n\" );\r\n        PrintSpace( _depth );\r\n    }\r\n\r\n    Print( \"<%s\", name );\r\n    _elementJustOpened = true;\r\n    _firstElement = false;\r\n    ++_depth;\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushAttribute( const char* name, const char* value )\r\n{\r\n    TIXMLASSERT( _elementJustOpened );\r\n    Print( \" %s=\\\"\", name );\r\n    PrintString( value, false );\r\n    Print( \"\\\"\" );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushAttribute( const char* name, int v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    PushAttribute( name, buf );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushAttribute( const char* name, unsigned v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    PushAttribute( name, buf );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushAttribute( const char* name, bool v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    PushAttribute( name, buf );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushAttribute( const char* name, double v )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( v, buf, BUF_SIZE );\r\n    PushAttribute( name, buf );\r\n}\r\n\r\n\r\nvoid XMLPrinter::CloseElement()\r\n{\r\n    --_depth;\r\n    const char* name = _stack.Pop();\r\n\r\n    if ( _elementJustOpened ) {\r\n        Print( \"/>\" );\r\n    }\r\n    else {\r\n        if ( _textDepth < 0 && !_compactMode) {\r\n            Print( \"\\n\" );\r\n            PrintSpace( _depth );\r\n        }\r\n        Print( \"</%s>\", name );\r\n    }\r\n\r\n    if ( _textDepth == _depth ) {\r\n        _textDepth = -1;\r\n    }\r\n    if ( _depth == 0 && !_compactMode) {\r\n        Print( \"\\n\" );\r\n    }\r\n    _elementJustOpened = false;\r\n}\r\n\r\n\r\nvoid XMLPrinter::SealElement()\r\n{\r\n    _elementJustOpened = false;\r\n    Print( \">\" );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushText( const char* text, bool cdata )\r\n{\r\n    _textDepth = _depth-1;\r\n\r\n    if ( _elementJustOpened ) {\r\n        SealElement();\r\n    }\r\n    if ( cdata ) {\r\n        Print( \"<![CDATA[\" );\r\n        Print( \"%s\", text );\r\n        Print( \"]]>\" );\r\n    }\r\n    else {\r\n        PrintString( text, true );\r\n    }\r\n}\r\n\r\nvoid XMLPrinter::PushText( int value )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( value, buf, BUF_SIZE );\r\n    PushText( buf, false );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushText( unsigned value )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( value, buf, BUF_SIZE );\r\n    PushText( buf, false );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushText( bool value )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( value, buf, BUF_SIZE );\r\n    PushText( buf, false );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushText( float value )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( value, buf, BUF_SIZE );\r\n    PushText( buf, false );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushText( double value )\r\n{\r\n    char buf[BUF_SIZE];\r\n    XMLUtil::ToStr( value, buf, BUF_SIZE );\r\n    PushText( buf, false );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushComment( const char* comment )\r\n{\r\n    if ( _elementJustOpened ) {\r\n        SealElement();\r\n    }\r\n    if ( _textDepth < 0 && !_firstElement && !_compactMode) {\r\n        Print( \"\\n\" );\r\n        PrintSpace( _depth );\r\n    }\r\n    _firstElement = false;\r\n    Print( \"<!--%s-->\", comment );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushDeclaration( const char* value )\r\n{\r\n    if ( _elementJustOpened ) {\r\n        SealElement();\r\n    }\r\n    if ( _textDepth < 0 && !_firstElement && !_compactMode) {\r\n        Print( \"\\n\" );\r\n        PrintSpace( _depth );\r\n    }\r\n    _firstElement = false;\r\n    Print( \"<?%s?>\", value );\r\n}\r\n\r\n\r\nvoid XMLPrinter::PushUnknown( const char* value )\r\n{\r\n    if ( _elementJustOpened ) {\r\n        SealElement();\r\n    }\r\n    if ( _textDepth < 0 && !_firstElement && !_compactMode) {\r\n        Print( \"\\n\" );\r\n        PrintSpace( _depth );\r\n    }\r\n    _firstElement = false;\r\n    Print( \"<!%s>\", value );\r\n}\r\n\r\n\r\nbool XMLPrinter::VisitEnter( const XMLDocument& doc )\r\n{\r\n    _processEntities = doc.ProcessEntities();\r\n    if ( doc.HasBOM() ) {\r\n        PushHeader( true, false );\r\n    }\r\n    return true;\r\n}\r\n\r\n\r\nbool XMLPrinter::VisitEnter( const XMLElement& element, const XMLAttribute* attribute )\r\n{\r\n    OpenElement( element.Name() );\r\n    while ( attribute ) {\r\n        PushAttribute( attribute->Name(), attribute->Value() );\r\n        attribute = attribute->Next();\r\n    }\r\n    return true;\r\n}\r\n\r\n\r\nbool XMLPrinter::VisitExit( const XMLElement& )\r\n{\r\n    CloseElement();\r\n    return true;\r\n}\r\n\r\n\r\nbool XMLPrinter::Visit( const XMLText& text )\r\n{\r\n    PushText( text.Value(), text.CData() );\r\n    return true;\r\n}\r\n\r\n\r\nbool XMLPrinter::Visit( const XMLComment& comment )\r\n{\r\n    PushComment( comment.Value() );\r\n    return true;\r\n}\r\n\r\nbool XMLPrinter::Visit( const XMLDeclaration& declaration )\r\n{\r\n    PushDeclaration( declaration.Value() );\r\n    return true;\r\n}\r\n\r\n\r\nbool XMLPrinter::Visit( const XMLUnknown& unknown )\r\n{\r\n    PushUnknown( unknown.Value() );\r\n    return true;\r\n}\r\n\r\n}   // namespace tinyxml2\r\n\r\n","/*\n *  rsrc_patches.cpp - Resource patches\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include <string.h>\n\n#include \"sysdeps.h\"\n#include \"cpu_emulation.h\"\n#include \"macos_util.h\"\n#include \"main.h\"\n#include \"prefs.h\"\n#include \"emul_op.h\"\n#include \"audio.h\"\n#include \"audio_defs.h\"\n#include \"rsrc_patches.h\"\n\n#if ENABLE_MON\n#include \"mon.h\"\n#endif\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n/*\n *  Search resource for byte string, return offset (or 0)\n */\n\nstatic uint32 find_rsrc_data(const uint8 *rsrc, uint32 max, const uint8 *search, uint32 search_len, uint32 ofs = 0)\n{\n\twhile (ofs < max - search_len) {\n\t\tif (!memcmp(rsrc + ofs, search, search_len))\n\t\t\treturn ofs;\n\t\tofs++;\n\t}\n\treturn 0;\n}\n\n\n/*\n *  Install SynchIdleTime() patch\n */\n\nstatic void patch_idle_time(uint8 *p, uint32 size, int n = 1)\n{\n\tif (!PrefsFindBool(\"idlewait\"))\n\t\treturn;\n\n\tstatic const uint8 dat[] = {0x70, 0x03, 0xa0, 0x9f};\n\tuint32 base = find_rsrc_data(p, size, dat, sizeof(dat));\n\tif (base) {\n\t\tuint8 *pbase = p + base - 0x80;\n\t\tstatic const uint8 dat2[] = {0x20, 0x78, 0x02, 0xb6, 0x41, 0xe8, 0x00, 0x80};\n\t\tbase = find_rsrc_data(pbase, 0x80, dat2, sizeof(dat2));\n\t\tif (base) {\n\t\t\tuint16 *p16 = (uint16 *)(pbase + base);\n\t\t\t*p16++ = htons(M68K_EMUL_OP_IDLE_TIME);\n\t\t\t*p16 = htons(M68K_NOP);\n\t\t\tFlushCodeCache(pbase + base, 4);\n\t\t\tD(bug(\"  patch %d applied\\n\", n));\n\t\t}\n\t}\n}\n\n\n/*\n *  Resource patches via vCheckLoad\n */\n\nvoid CheckLoad(uint32 type, int16 id, uint8 *p, uint32 size)\n{\n\tuint16 *p16;\n\tuint32 base;\n\tD(bug(\"vCheckLoad %c%c%c%c (%08x) ID %d, data %p, size %d\\n\", (char)(type >> 24), (char)((type >> 16) & 0xff), (char )((type >> 8) & 0xff), (char )(type & 0xff), type, id, p, size));\n\t\n\tif (type == FOURCC('b','o','o','t') && id == 3) {\n\t\tD(bug(\" boot 3 found\\n\"));\n\n\t\t// Set boot stack pointer (7.5, 7.6, 7.6.1, 8.0)\n\t\tstatic const uint8 dat[] = {0x22, 0x00, 0xe4, 0x89, 0x90, 0x81, 0x22, 0x40};\n\t\tbase = find_rsrc_data(p, size, dat, sizeof(dat));\n\t\tif (base) {\n\t\t\tp16 = (uint16 *)(p + base + 6);\n\t\t\t*p16 = htons(M68K_EMUL_OP_FIX_BOOTSTACK);\n\t\t\tFlushCodeCache(p + base + 6, 2);\n\t\t\tD(bug(\"  patch 1 applied\\n\"));\n\t\t}\n\n#if !ROM_IS_WRITE_PROTECTED\n\t\t// Set fake handle at 0x0000 to some safe place (so broken Mac programs won't write into Mac ROM) (7.1, 7.5, 8.0)\n\t\tstatic const uint8 dat2[] = {0x20, 0x78, 0x02, 0xae, 0xd1, 0xfc, 0x00, 0x01, 0x00, 0x00, 0x21, 0xc8, 0x00, 0x00};\n\t\tbase = find_rsrc_data(p, size, dat2, sizeof(dat2));\n\t\tif (base) {\n\t\t\tp16 = (uint16 *)(p + base);\n\n#if defined(USE_SCRATCHMEM_SUBTERFUGE)\n\t\t\t// Set 0x0000 to scratch memory area\n\t\t\textern uint8 *ScratchMem;\n\t\t\tconst uint32 ScratchMemBase = Host2MacAddr(ScratchMem);\n\t\t\t*p16++ = htons(0x207c);\t\t\t// move.l\t#ScratchMem,a0\n\t\t\t*p16++ = htons(ScratchMemBase >> 16);\n\t\t\t*p16++ = htons(ScratchMemBase);\n\t\t\t*p16++ = htons(M68K_NOP);\n\t\t\t*p16 = htons(M68K_NOP);\n#else\n#error System specific handling for writable ROM is required here\n#endif\n\t\t\tFlushCodeCache(p + base, 14);\n\t\t\tD(bug(\"  patch 2 applied\\n\"));\n\t\t}\n\n\t} else if (type == FOURCC('b','o','o','t') && id == 2) {\n\t\tD(bug(\" boot 2 found\\n\"));\n\n\t\t// Set fake handle at 0x0000 to some safe place (so broken Mac programs won't write into Mac ROM) (7.1, 7.5, 8.0)\n\t\tstatic const uint8 dat[] = {0x20, 0x78, 0x02, 0xae, 0xd1, 0xfc, 0x00, 0x01, 0x00, 0x00, 0x21, 0xc8, 0x00, 0x00};\n\t\tbase = find_rsrc_data(p, size, dat, sizeof(dat));\n\t\tif (base) {\n\t\t\tp16 = (uint16 *)(p + base);\n\n#if defined(USE_SCRATCHMEM_SUBTERFUGE)\n\t\t\t// Set 0x0000 to scratch memory area\n\t\t\textern uint8 *ScratchMem;\n\t\t\tconst uint32 ScratchMemBase = Host2MacAddr(ScratchMem);\n\t\t\t*p16++ = htons(0x207c);\t\t\t// move.l\t#ScratchMem,a0\n\t\t\t*p16++ = htons(ScratchMemBase >> 16);\n\t\t\t*p16++ = htons(ScratchMemBase);\n\t\t\t*p16++ = htons(M68K_NOP);\n\t\t\t*p16 = htons(M68K_NOP);\n#else\n#error System specific handling for writable ROM is required here\n#endif\n\t\t\tFlushCodeCache(p + base, 14);\n\t\t\tD(bug(\"  patch 1 applied\\n\"));\n\t\t}\n#endif\n\n\t} else if (type == FOURCC('P','T','C','H') && id == 630) {\n\t\tD(bug(\"PTCH 630 found\\n\"));\n\n\t\t// Don't replace Time Manager (Classic ROM, 6.0.3)\n\t\tstatic const uint8 dat[] = {0x30, 0x3c, 0x00, 0x58, 0xa2, 0x47};\n\t\tbase = find_rsrc_data(p, size, dat, sizeof(dat));\n\t\tif (base) {\n\t\t\tp16 = (uint16 *)(p + base);\n\t\t\tp16[2] = htons(M68K_NOP);\n\t\t\tp16[7] = htons(M68K_NOP);\n\t\t\tp16[12] = htons(M68K_NOP);\n\t\t\tFlushCodeCache(p + base, 26);\n\t\t\tD(bug(\"  patch 1 applied\\n\"));\n\t\t}\n\n\t\t// Don't replace Time Manager (Classic ROM, 6.0.8)\n\t\tstatic const uint8 dat2[] = {0x70, 0x58, 0xa2, 0x47};\n\t\tbase = find_rsrc_data(p, size, dat2, sizeof(dat2));\n\t\tif (base) {\n\t\t\tp16 = (uint16 *)(p + base);\n\t\t\tp16[1] = htons(M68K_NOP);\n\t\t\tp16[5] = htons(M68K_NOP);\n\t\t\tp16[9] = htons(M68K_NOP);\n\t\t\tFlushCodeCache(p + base, 20);\n\t\t\tD(bug(\"  patch 1 applied\\n\"));\n\t\t}\n\n\t} else if (type == FOURCC('p','t','c','h') && id == 26) {\n\t\tD(bug(\" ptch 26 found\\n\"));\n\n\t\t// Trap ABC4 is initialized with absolute ROM address (7.1, 7.5, 7.6, 7.6.1, 8.0)\n\t\tstatic const uint8 dat[] = {0x40, 0x83, 0x36, 0x10};\n\t\tbase = find_rsrc_data(p, size, dat, sizeof(dat));\n\t\tif (base) {\n\t\t\tp16 = (uint16 *)(p + base);\n\t\t\t*p16++ = htons((ROMBaseMac + 0x33610) >> 16);\n\t\t\t*p16 = htons((ROMBaseMac + 0x33610) & 0xffff);\n\t\t\tFlushCodeCache(p + base, 4);\n\t\t\tD(bug(\"  patch 1 applied\\n\"));\n\t\t}\n\n\t} else if (type == FOURCC('p','t','c','h') && id == 34) {\n\t\tD(bug(\" ptch 34 found\\n\"));\n\n\t\t// Don't wait for VIA (Classic ROM, 6.0.8)\n\t\tstatic const uint8 dat[] = {0x22, 0x78, 0x01, 0xd4, 0x10, 0x11, 0x02, 0x00, 0x00, 0x30};\n\t\tbase = find_rsrc_data(p, size, dat, sizeof(dat));\n\t\tif (base) {\n\t\t\tp16 = (uint16 *)(p + base + 14);\n\t\t\t*p16 = htons(M68K_NOP);\n\t\t\tFlushCodeCache(p + base + 14, 2);\n\t\t\tD(bug(\"  patch 1 applied\\n\"));\n\t\t}\n\n\t\t// Don't replace ADBOp() (Classic ROM, 6.0.8)\n\t\tstatic const uint8 dat2[] = {0x21, 0xc0, 0x05, 0xf0};\n\t\tbase = find_rsrc_data(p, size, dat2, sizeof(dat2));\n\t\tif (base) {\n\t\t\tp16 = (uint16 *)(p + base);\n\t\t\t*p16++ = htons(M68K_NOP);\n\t\t\t*p16 = htons(M68K_NOP);\n\t\t\tFlushCodeCache(p + base, 4);\n\t\t\tD(bug(\"  patch 2 applied\\n\"));\n\t\t}\n\n\t} else if (type == FOURCC('g','p','c','h') && id == 750) {\n\t\tD(bug(\" gpch 750 found\\n\"));\n\n\t\t// Don't use PTEST instruction in BlockMove() (7.5, 7.6, 7.6.1, 8.0)\n\t\tstatic const uint8 dat[] = {0x20, 0x5f, 0x22, 0x5f, 0x0c, 0x38, 0x00, 0x04, 0x01, 0x2f};\n\t\tbase = find_rsrc_data(p, size, dat, sizeof(dat));\n\t\tif (base) {\n\t\t\tp16 = (uint16 *)(p + base + 4);\n\t\t\t*p16++ = htons(M68K_EMUL_OP_BLOCK_MOVE);\n\t\t\t*p16++ = htons(0x7000);\n\t\t\t*p16 = htons(M68K_RTS);\n\t\t\tFlushCodeCache(p + base + 4, 6);\n\t\t\tD(bug(\"  patch 1 applied\\n\"));\n\t\t}\n\n\t\t// Patch SynchIdleTime()\n\t\tpatch_idle_time(p, size, 2);\n\n\t} else if (type == FOURCC('l','p','c','h') && id == 24) {\n\t\tD(bug(\" lpch 24 found\\n\"));\n\n\t\t// Don't replace Time Manager (7.0.1, 7.1, 7.5, 7.6, 7.6.1, 8.0)\n\t\tstatic const uint8 dat[] = {0x70, 0x59, 0xa2, 0x47};\n\t\tbase = find_rsrc_data(p, size, dat, sizeof(dat));\n\t\tif (base) {\n\t\t\tp16 = (uint16 *)(p + base + 2);\n\t\t\t*p16++ = htons(M68K_NOP);\n\t\t\tp16 += 3;\n\t\t\t*p16++ = htons(M68K_NOP);\n\t\t\tp16 += 7;\n\t\t\t*p16 = htons(M68K_NOP);\n\t\t\tFlushCodeCache(p + base + 2, 28);\n\t\t\tD(bug(\"  patch 1 applied\\n\"));\n\t\t}\n\n\t} else if (type == FOURCC('l','p','c','h') && id == 31) {\n\t\tD(bug(\" lpch 31 found\\n\"));\n\n\t\t// Don't write to VIA in vSoundDead() (7.0.1, 7.1, 7.5, 7.6, 7.6.1, 8.0)\n\t\tstatic const uint8 dat[] = {0x20, 0x78, 0x01, 0xd4, 0x08, 0xd0, 0x00, 0x07, 0x4e, 0x75};\n\t\tbase = find_rsrc_data(p, size, dat, sizeof(dat));\n\t\tif (base) {\n\t\t\tp16 = (uint16 *)(p + base);\n\t\t\t*p16 = htons(M68K_RTS);\n\t\t\tFlushCodeCache(p + base, 2);\n\t\t\tD(bug(\"  patch 1 applied\\n\"));\n\t\t}\n\n\t\t// Don't replace SCSI manager (7.1, 7.5, 7.6.1, 8.0)\n\t\tstatic const uint8 dat2[] = {0x0c, 0x6f, 0x00, 0x0e, 0x00, 0x04, 0x66, 0x0c};\n\t\tbase = find_rsrc_data(p, size, dat2, sizeof(dat2));\n\t\tif (base) {\n\t\t\tp16 = (uint16 *)(p + base);\n\t\t\t*p16++ = htons(M68K_EMUL_OP_SCSI_DISPATCH);\n\t\t\t*p16++ = htons(0x2e49);\t\t// move.l\ta1,a7\n\t\t\t*p16 = htons(M68K_JMP_A0);\n\t\t\tFlushCodeCache(p + base, 6);\n\t\t\tD(bug(\"  patch 2 applied\\n\"));\n\t\t}\n\n\t\t// Patch SynchIdleTime()\n\t\tpatch_idle_time(p, size, 3);\n\n\t} else if (type == FOURCC('t','h','n','g') && id == -16563) {\n\t\tD(bug(\" thng -16563 found\\n\"));\n\n\t\t// Set audio component flags (7.5, 7.6, 7.6.1, 8.0)\n\t\t*(uint32 *)(p + componentFlags) = htonl(audio_component_flags);\n\t\tD(bug(\"  patch 1 applied\\n\"));\n\n\t} else if (type == FOURCC('s','i','f','t') && id == -16563) {\n\t\tD(bug(\" sift -16563 found\\n\"));\n\n\t\t// Replace audio component (7.5, 7.6, 7.6.1, 8.0)\n\t\tp16 = (uint16 *)p;\n\t\t*p16++ = htons(0x4e56); *p16++ = htons(0x0000);\t// link\t\ta6,#0\n\t\t*p16++ = htons(0x48e7); *p16++ = htons(0x8018);\t// movem.l\td0/a3-a4,-(sp)\n\t\t*p16++ = htons(0x266e); *p16++ = htons(0x000c);\t// movea.l\t12(a6),a3\n\t\t*p16++ = htons(0x286e); *p16++ = htons(0x0008);\t// movea.l\t8(a6),a4\n\t\t*p16++ = htons(M68K_EMUL_OP_AUDIO);\n\t\t*p16++ = htons(0x2d40); *p16++ = htons(0x0010);\t// move.l\td0,16(a6)\n\t\t*p16++ = htons(0x4cdf); *p16++ = htons(0x1801);\t// movem.l\t(sp)+,d0/a3-a4\n\t\t*p16++ = htons(0x4e5e);\t\t\t\t\t\t\t// unlk\t\ta6\n\t\t*p16++ = htons(0x4e74); *p16++ = htons(0x0008);\t// rtd\t\t#8\n\t\tFlushCodeCache(p, 32);\n\t\tD(bug(\"  patch 1 applied\\n\"));\n\n\t} else if (type == FOURCC('i','n','s','t') && id == -19069) {\n\t\tD(bug(\" inst -19069 found\\n\"));\n\n\t\t// Don't replace Microseconds (QuickTime 2.0)\n\t\tstatic const uint8 dat[] = {0x30, 0x3c, 0xa1, 0x93, 0xa2, 0x47};\n\t\tbase = find_rsrc_data(p, size, dat, sizeof(dat));\n\t\tif (base) {\n\t\t\tp16 = (uint16 *)(p + base + 4);\n\t\t\t*p16 = htons(M68K_NOP);\n\t\t\tFlushCodeCache(p + base + 4, 2);\n\t\t\tD(bug(\"  patch 1 applied\\n\"));\n\t\t}\n\n\t} else if (type == FOURCC('D','R','V','R') && id == -20066) {\n\t\tD(bug(\"DRVR -20066 found\\n\"));\n\n\t\t// Don't access SCC in .Infra driver\n\t\tstatic const uint8 dat[] = {0x28, 0x78, 0x01, 0xd8, 0x48, 0xc7, 0x20, 0x0c, 0xd0, 0x87, 0x20, 0x40, 0x1c, 0x10};\n\t\tbase = find_rsrc_data(p, size, dat, sizeof(dat));\n\t\tif (base) {\n\t\t\tp16 = (uint16 *)(p + base + 12);\n\t\t\t*p16 = htons(0x7a00);\t// moveq #0,d6\n\t\t\tFlushCodeCache(p + base + 12, 2);\n\t\t\tD(bug(\"  patch 1 applied\\n\"));\n\t\t}\n\n\t} else if (type == FOURCC('l','t','l','k') && id == 0) {\n\t\tD(bug(\" ltlk 0 found\\n\"));\n\n\t\t// Disable LocalTalk (7.0.1, 7.5, 7.6, 7.6.1, 8.0)\n\t\tp16 = (uint16 *)p;\n\t\t*p16++ = htons(M68K_JMP_A0);\n\t\t*p16++ = htons(0x7000);\n\t\t*p16 = htons(M68K_RTS);\n\t\tFlushCodeCache(p, 6);\n\t\tD(bug(\"  patch 1 applied\\n\"));\n\n\t} else if (type == FOURCC('D','R','V','R') && id == 41) {\n\t\tD(bug(\" DRVR 41 found\\n\"));\n\t\t\n\t\t// Don't access ROM85 as it it was a pointer to a ROM version number (8.0, 8.1)\n\t\tstatic const uint8 dat[] = {0x3a, 0x2e, 0x00, 0x0a, 0x55, 0x4f, 0x3e, 0xb8, 0x02, 0x8e, 0x30, 0x1f, 0x48, 0xc0, 0x24, 0x40, 0x20, 0x40};\n\t\tbase = find_rsrc_data(p, size, dat, sizeof(dat));\n\t\tif (base) {\n\t\t\tp16 = (uint16 *)(p + base + 4);\n\t\t\t*p16++ = htons(0x303c);\t\t// move.l\t#ROM85,%d0\n\t\t\t*p16++ = htons(0x028e);\n\t\t\t*p16++ = htons(M68K_NOP);\n\t\t\t*p16++ = htons(M68K_NOP);\n\t\t\tFlushCodeCache(p + base + 4, 8);\n\t\t\tD(bug(\"  patch 1 applied\\n\"));\n\t\t}\n\t}\n}\n","/*\n *  main_unix.cpp - Startup code for Unix\n *\n *  Basilisk II (C) Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"sysdeps.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n\n#ifdef USE_SDL\n# include <SDL.h>\n#endif\n\n#ifndef USE_SDL_VIDEO\n# include <X11/Xlib.h>\n#endif\n\n#ifdef HAVE_PTHREADS\n# include <pthread.h>\n#endif\n\n#if defined(EMSCRIPTEN) && !defined(__EMSCRIPTEN_PTHREADS__)\n# include <audio.h>\n#endif\n\n#if REAL_ADDRESSING || DIRECT_ADDRESSING\n# include <sys/mman.h>\n#endif\n\n#if !EMULATED_68K && defined(__NetBSD__)\n# include <m68k/sync_icache.h> \n# include <m68k/frame.h>\n# include <sys/param.h>\n# include <sys/sysctl.h>\nstruct sigstate {\n\tint ss_flags;\n\tstruct frame ss_frame;\n\tstruct fpframe ss_fpstate;\n};\n# define SS_FPSTATE  0x02\n# define SS_USERREGS 0x04\n#endif\n\n#ifdef ENABLE_GTK\n# include <gtk/gtk.h>\n# include <gdk/gdk.h>\n# ifdef HAVE_GNOMEUI\n#  include <gnome.h>\n# endif\n#endif\n\n#ifdef ENABLE_XF86_DGA\n# include <X11/Xutil.h>\n# include <X11/extensions/Xxf86dga.h>\n#endif\n\n#ifndef EMSCRIPTEN\n#define OSX_BACKTRACE 1\n#endif\n#ifdef OSX_BACKTRACE\n#include <execinfo.h>\n#endif\n\n#include <string>\nusing std::string;\n\n#include \"cpu_emulation.h\"\n#include \"sys.h\"\n#include \"rom_patches.h\"\n#include \"xpram.h\"\n#include \"timer.h\"\n#include \"video.h\"\n#include \"emul_op.h\"\n#include \"prefs.h\"\n#include \"prefs_editor.h\"\n#include \"macos_util.h\"\n#include \"user_strings.h\"\n#include \"version.h\"\n#include \"main.h\"\n#include \"vm_alloc.h\"\n#include \"sigsegv.h\"\n#include \"rpc.h\"\n\n#ifdef EMSCRIPTEN\n#include <emscripten.h>\n#endif\n\n\n#if USE_JIT\nextern void flush_icache_range(uint8 *start, uint32 size); // from compemu_support.cpp\n#endif\n\n#ifdef ENABLE_MON\n# include \"mon.h\"\n#endif\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n// Constants\nconst char ROM_FILE_NAME[] = \"ROM\";\n#if !EMULATED_68K\nconst int SIG_STACK_SIZE = SIGSTKSZ;\t// Size of signal stack\n#endif\nconst int SCRATCH_MEM_SIZE = 0x10000;\t// Size of scratch memory area\n\n\n#if !EMULATED_68K\n// RAM and ROM pointers\nuint32 RAMBaseMac;\t\t// RAM base (Mac address space)\nuint8 *RAMBaseHost;\t\t// RAM base (host address space)\nuint32 RAMSize;\t\t\t// Size of RAM\nuint32 ROMBaseMac;\t\t// ROM base (Mac address space)\nuint8 *ROMBaseHost;\t\t// ROM base (host address space)\nuint32 ROMSize;\t\t\t// Size of ROM\n#endif\n\n\n// CPU and FPU type, addressing mode\nint CPUType;\nbool CPUIs68060;\nint FPUType;\nbool TwentyFourBitAddressing;\n\n\n// Global variables\n#ifndef USE_SDL_VIDEO\nextern char *x_display_name;\t\t\t\t\t\t// X11 display name\nextern Display *x_display;\t\t\t\t\t\t\t// X11 display handle\n#ifdef X11_LOCK_TYPE\nX11_LOCK_TYPE x_display_lock = X11_LOCK_INIT;\t\t// X11 display lock\n#endif\n#endif\n\nstatic uint8 last_xpram[XPRAM_SIZE];\t\t\t\t// Buffer for monitoring XPRAM changes\n\n#ifdef HAVE_PTHREADS\n#if !EMULATED_68K\nstatic pthread_t emul_thread;\t\t\t\t\t\t// Handle of MacOS emulation thread (main thread)\n#endif\n\nstatic bool xpram_thread_active = false;\t\t\t// Flag: XPRAM watchdog installed\nstatic volatile bool xpram_thread_cancel = false;\t// Flag: Cancel XPRAM thread\nstatic pthread_t xpram_thread;\t\t\t\t\t\t// XPRAM watchdog\n\nstatic bool tick_thread_active = false;\t\t\t\t// Flag: 60Hz thread installed\nstatic volatile bool tick_thread_cancel = false;\t// Flag: Cancel 60Hz thread\nstatic pthread_t tick_thread;\t\t\t\t\t\t// 60Hz thread\nstatic pthread_attr_t tick_thread_attr;\t\t\t\t// 60Hz thread attributes\n\nstatic pthread_mutex_t intflag_lock = PTHREAD_MUTEX_INITIALIZER;\t// Mutex to protect InterruptFlags\n#define LOCK_INTFLAGS pthread_mutex_lock(&intflag_lock)\n#define UNLOCK_INTFLAGS pthread_mutex_unlock(&intflag_lock)\n\n#else\n\n#define LOCK_INTFLAGS\n#define UNLOCK_INTFLAGS\n\n#endif\n\n#if !EMULATED_68K\n#define SIG_IRQ SIGUSR1\nstatic struct sigaction sigirq_sa;\t// Virtual 68k interrupt signal\nstatic struct sigaction sigill_sa;\t// Illegal instruction\nstatic void *sig_stack = NULL;\t\t// Stack for signal handlers\nuint16 EmulatedSR;\t\t\t\t\t// Emulated bits of SR (supervisor bit and interrupt mask)\n#endif\n\n#if USE_SCRATCHMEM_SUBTERFUGE\nuint8 *ScratchMem = NULL;\t\t\t// Scratch memory for Mac ROM writes\n#endif\n\n#if !defined(HAVE_PTHREADS)\nstatic struct sigaction timer_sa;\t// sigaction used for timer\n\n#if defined(HAVE_TIMER_CREATE) && defined(_POSIX_REALTIME_SIGNALS)\n#define SIG_TIMER SIGRTMIN\nstatic timer_t timer;\t\t\t\t// 60Hz timer\n#endif\n#endif // !HAVE_PTHREADS\n\n#ifdef ENABLE_MON\nstatic struct sigaction sigint_sa;\t// sigaction for SIGINT handler\nstatic void sigint_handler(...);\n#endif\n\n#if REAL_ADDRESSING\nstatic bool lm_area_mapped = false;\t// Flag: Low Memory area mmap()ped\n#endif\n\nstatic rpc_connection_t *gui_connection = NULL;\t// RPC connection to the GUI\nstatic const char *gui_connection_path = NULL;\t// GUI connection identifier\n\n\n// Prototypes\nstatic void *xpram_func(void *arg);\nstatic void *tick_func(void *arg);\nstatic void one_tick(...);\n#if !EMULATED_68K\nstatic void sigirq_handler(int sig, int code, struct sigcontext *scp);\nstatic void sigill_handler(int sig, int code, struct sigcontext *scp);\nextern \"C\" void EmulOpTrampoline(void);\n#endif\n\n\n/*\n *  Ersatz functions\n */\n\nextern \"C\" {\n\n#ifndef HAVE_STRDUP\nchar *strdup(const char *s)\n{\n\tchar *n = (char *)malloc(strlen(s) + 1);\n\tstrcpy(n, s);\n\treturn n;\n}\n#endif\n\n}\n\n\n/*\n *  Helpers to map memory that can be accessed from the Mac side\n */\n\n// NOTE: VM_MAP_32BIT is only used when compiling a 64-bit JIT on specific platforms\nvoid *vm_acquire_mac(size_t size)\n{\n\treturn vm_acquire(size, VM_MAP_DEFAULT | VM_MAP_32BIT);\n}\n\nstatic int vm_acquire_mac_fixed(void *addr, size_t size)\n{\n\treturn vm_acquire_fixed(addr, size, VM_MAP_DEFAULT | VM_MAP_32BIT);\n}\n\n\n/*\n *  SIGSEGV handler\n */\n\nstatic sigsegv_return_t sigsegv_handler(sigsegv_info_t *sip)\n{\n\tconst uintptr fault_address = (uintptr_t)sigsegv_get_fault_address(sip);\n#if ENABLE_VOSF\n\t// Handle screen fault\n\textern bool Screen_fault_handler(sigsegv_info_t *sip);\n\tif (Screen_fault_handler(sip))\n\t\treturn SIGSEGV_RETURN_SUCCESS;\n#endif\n\n#ifdef HAVE_SIGSEGV_SKIP_INSTRUCTION\n\t// Ignore writes to ROM\n\tif (((uintptr)fault_address - (uintptr)ROMBaseHost) < ROMSize)\n\t\treturn SIGSEGV_RETURN_SKIP_INSTRUCTION;\n\n\t// Ignore all other faults, if requested\n\tif (PrefsFindBool(\"ignoresegv\"))\n\t\treturn SIGSEGV_RETURN_SKIP_INSTRUCTION;\n#endif\n\n\treturn SIGSEGV_RETURN_FAILURE;\n}\n\n/*\n *  Dump state when everything went wrong after a SEGV\n */\n\nstatic void sigsegv_dump_state(sigsegv_info_t *sip)\n{\n\tconst sigsegv_address_t fault_address = sigsegv_get_fault_address(sip);\n\tconst sigsegv_address_t fault_instruction = sigsegv_get_fault_instruction_address(sip);\n\tfprintf(stderr, \"Caught SIGSEGV at address %p\", fault_address);\n\tif (fault_instruction != SIGSEGV_INVALID_ADDRESS)\n\t\tfprintf(stderr, \" [IP=%p]\", fault_instruction);\n\tfprintf(stderr, \"\\n\");\n#if EMULATED_68K\n\tuaecptr nextpc;\n\textern void m68k_dumpstate(uaecptr *nextpc);\n\tm68k_dumpstate(&nextpc);\n#endif\n#if USE_JIT && JIT_DEBUG\n\textern void compiler_dumpstate(void);\n\tcompiler_dumpstate();\n#endif\n\tVideoQuitFullScreen();\n#ifdef ENABLE_MON\n\tconst char *arg[4] = {\"mon\", \"-m\", \"-r\", NULL};\n\tmon(3, arg);\n#endif\n\tQuitEmulator();\n}\n\n\n/*\n *  Update virtual clock and trigger interrupts if necessary\n */\n\n#ifdef USE_CPU_EMUL_SERVICES\nstatic uint64 n_check_ticks = 0;\nstatic uint64 emulated_ticks_start = 0;\nstatic uint64 emulated_ticks_count = 0;\nstatic int64 emulated_ticks_current = 0;\nstatic int32 emulated_ticks_quantum = 1000;\nint32 emulated_ticks = emulated_ticks_quantum;\n\nvoid cpu_do_check_ticks(void)\n{\n#if DEBUG\n\tn_check_ticks++;\n#endif\n\n\tuint64 now;\n\tstatic uint64 next = 0;\n\tif (next == 0)\n\t\tnext = emulated_ticks_start = GetTicks_usec();\n\n\t// Update total instructions count\n\tif (emulated_ticks <= 0) {\n\t\temulated_ticks_current += (emulated_ticks_quantum - emulated_ticks);\n\t\t// XXX: can you really have a machine fast enough to overflow\n\t\t// a 63-bit m68k instruction counter within 16 ms?\n\t\tif (emulated_ticks_current < 0) {\n\t\t\tprintf(\"WARNING: Overflowed 63-bit m68k instruction counter in less than 16 ms!\\n\");\n\t\t\tgoto recalibrate_quantum;\n\t\t}\n\t}\n\n\t// Check for interrupt opportunity\n\tnow = GetTicks_usec();\n\tif (next < now) {\n\n\t\tone_tick();\n\t\tdo {\n\t\t\tnext += 16625;\n\t\t} while (next < now);\n\t\temulated_ticks_count++;\n\n\t\t// Recalibrate 1000 Hz quantum every 10 ticks\n\t\tstatic uint64 last = 0;\n\t\tif (last == 0)\n\t\t\tlast = now;\n\t\telse if (now - last > 166250) {\n\t\t  recalibrate_quantum:\n\t\t\temulated_ticks_quantum = ((uint64)emulated_ticks_current * 1000) / (now - last);\n\t\t\temulated_ticks_current = 0;\n\t\t\tlast = now;\n\t\t}\n\t}\n\n\t// Update countdown\n\tif (emulated_ticks <= 0)\n\t\temulated_ticks += emulated_ticks_quantum;\n}\n#endif\n\n#ifdef OSX_BACKTRACE\nvoid segfaulthandler(int sig) {\n  void *array[10];\n  size_t size;\n\n  // get void*'s for all entries on the stack\n  size = backtrace(array, 10);\n\n  // print out all the frames to stderr\n  fprintf(stderr, \"Error: signal %d:\\n\", sig);\n  backtrace_symbols_fd(array, size, STDERR_FILENO);\n  exit(1);\n}\n#endif\n\n/*\n *  Main program\n */\n\nstatic void usage(const char *prg_name)\n{\n\tprintf(\n\t\t\"Usage: %s [OPTION...]\\n\"\n\t\t\"\\nUnix options:\\n\"\n\t\t\"  --config FILE\\n    read/write configuration from/to FILE\\n\"\n\t\t\"  --display STRING\\n    X display to use\\n\"\n\t\t\"  --break ADDRESS\\n    set ROM breakpoint\\n\"\n\t\t\"  --rominfo\\n    dump ROM information\\n\", prg_name\n\t);\n\tLoadPrefs(NULL); // read the prefs file so PrefsPrintUsage() will print the correct default values\n\tPrefsPrintUsage();\n\texit(0);\n}\n\n#ifdef __EMSCRIPTEN_PTHREADS__\nstatic int main_argc;\nstatic char **main_argv;\nstatic pthread_t main_thread;\nstatic pthread_attr_t main_thread_attr;\nvoid Set_pthread_attr (pthread_attr_t *attr, int priority);\nvoid *main_thread_func(void *arg);\n\nint fake_main(int argc, char **argv);\nvoid emscripten_step();\n\n\n#endif\n\nint main(int argc, char **argv)\n{\n#ifdef __EMSCRIPTEN_PTHREADS__\n\tmain_argc = argc;\n\tmain_argv = argv;\n\n\tSet_pthread_attr(&main_thread_attr, 0);\n\tprintf(\"spawining main thread\\n\");\n\tpthread_create(&main_thread, NULL, main_thread_func, NULL);\n\temscripten_set_main_loop(*emscripten_step, 1, true);\n\n}\n\nvoid emscripten_step()\n{\n\n}\n\nvoid *main_thread_func(void *arg)\n{\n\tprintf(\"main_thread_func\\n\");\n\tfake_main(main_argc, main_argv);\n}\nint fake_main(int argc, char **argv)\n{\n#endif // __EMSCRIPTEN_PTHREADS__\n\tconst char *vmdir = NULL;\n\tchar str[256];\n\n\tprintf(\"fake_main\\n\");\n\n\t// Initialize variables\n\tRAMBaseHost = NULL;\n\tROMBaseHost = NULL;\n\tsrand(time(NULL));\n\ttzset();\n\n#ifdef OSX_BACKTRACE\n  signal(SIGSEGV, segfaulthandler);   // install our handler\n#endif\n\n\t// Print some info\n\tprintf(GetString(STR_ABOUT_TEXT1), VERSION_MAJOR, VERSION_MINOR);\n\tprintf(\" %s\\n\", GetString(STR_ABOUT_TEXT2));\n\n\t// Parse command line arguments\n\tfor (int i=1; i<argc; i++) {\n\t\tif (strcmp(argv[i], \"--help\") == 0) {\n\t\t\tusage(argv[0]);\n#ifndef USE_SDL_VIDEO\n\t\t} else if (strcmp(argv[i], \"--display\") == 0) {\n\t\t\ti++; // don't remove the argument, gtk_init() needs it too\n\t\t\tif (i < argc)\n\t\t\t\tx_display_name = strdup(argv[i]);\n#endif\n\t\t} else if (strcmp(argv[i], \"--gui-connection\") == 0) {\n\t\t\targv[i++] = NULL;\n\t\t\tif (i < argc) {\n\t\t\t\tgui_connection_path = argv[i];\n\t\t\t\targv[i] = NULL;\n\t\t\t}\n\t\t} else if (strcmp(argv[i], \"--break\") == 0) {\n\t\t\targv[i++] = NULL;\n\t\t\tif (i < argc) {\n\t\t\t\tROMBreakpoint = strtol(argv[i], NULL, 0);\n\t\t\t\targv[i] = NULL;\n\t\t\t}\n\t\t} else if (strcmp(argv[i], \"--config\") == 0) {\n\t\t\targv[i++] = NULL;\n\t\t\tif (i < argc) {\n\t\t\t\textern string UserPrefsPath; // from prefs_unix.cpp\n\t\t\t\tUserPrefsPath = argv[i];\n\t\t\t\targv[i] = NULL;\n\t\t\t}\n\t\t} else if (strcmp(argv[i], \"--rominfo\") == 0) {\n\t\t\targv[i] = NULL;\n\t\t\tPrintROMInfo = true;\n\t\t}\n\t}\n\n\t// Remove processed arguments\n\tfor (int i=1; i<argc; i++) {\n\t\tint k;\n\t\tfor (k=i; k<argc; k++)\n\t\t\tif (argv[k] != NULL)\n\t\t\t\tbreak;\n\t\tif (k > i) {\n\t\t\tk -= i;\n\t\t\tfor (int j=i+k; j<argc; j++)\n\t\t\t\targv[j-k] = argv[j];\n\t\t\targc -= k;\n\t\t}\n\t}\n\n\t// Connect to the external GUI\n\tif (gui_connection_path) {\n\t\tif ((gui_connection = rpc_init_client(gui_connection_path)) == NULL) {\n\t\t\tfprintf(stderr, \"Failed to initialize RPC client connection to the GUI\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n#ifdef ENABLE_GTK\n\tif (!gui_connection) {\n#ifdef HAVE_GNOMEUI\n\t\t// Init GNOME/GTK\n\t\tchar version[16];\n\t\tsprintf(version, \"%d.%d\", VERSION_MAJOR, VERSION_MINOR);\n\t\tgnome_init(\"Basilisk II\", version, argc, argv);\n#else\n\t\t// Init GTK\n\t\tgtk_set_locale();\n\t\tgtk_init(&argc, &argv);\n#endif\n\t}\n#endif\n\n\t// Read preferences\n\tPrefsInit(vmdir, argc, argv);\n\n\t// Any command line arguments left?\n\tfor (int i=1; i<argc; i++) {\n\t\tif (argv[i][0] == '-') {\n\t\t\tfprintf(stderr, \"Unrecognized option '%s'\\n\", argv[i]);\n\t\t\tusage(argv[0]);\n\t\t}\n\t}\n\n#ifndef USE_SDL_VIDEO\n\t// Open display\n\tx_display = XOpenDisplay(x_display_name);\n\tif (x_display == NULL) {\n\t\tchar str[256];\n\t\tsprintf(str, GetString(STR_NO_XSERVER_ERR), XDisplayName(x_display_name));\n\t\tErrorAlert(str);\n\t\tQuitEmulator();\n\t}\n\n#if defined(ENABLE_XF86_DGA) && !defined(ENABLE_MON)\n\t// Fork out, so we can return from fullscreen mode when things get ugly\n\tXF86DGAForkApp(DefaultScreen(x_display));\n#endif\n#endif\n\n#ifndef EMSCRIPTEN\n#ifdef USE_SDL\n\t// Initialize SDL system\n\tint sdl_flags = 0;\n#ifdef USE_SDL_VIDEO\n\tsdl_flags |= SDL_INIT_VIDEO;\n#endif\n#ifdef USE_SDL_AUDIO\n\tsdl_flags |= SDL_INIT_AUDIO;\n#endif\n\tassert(sdl_flags != 0);\n\tif (SDL_Init(sdl_flags) == -1) {\n\t\tchar str[256];\n\t\tsprintf(str, \"Could not initialize SDL: %s.\\n\", SDL_GetError());\n\t\tErrorAlert(str);\n\t\tQuitEmulator();\n\t}\n\tatexit(SDL_Quit);\n#endif\n#endif // not EMSCRIPTEN\n\n\t// Init system routines\n\tSysInit();\n\n\t// Show preferences editor\n\tif (!gui_connection && !PrefsFindBool(\"nogui\"))\n\t\tif (!PrefsEditor())\n\t\t\tQuitEmulator();\n\n#ifdef HAVE_MACH_EXCEPTIONS\n\n\tprintf(\"HAVE_MACH_EXCEPTIONS\");\n\t// Install the handler for SIGSEGV\n\tif (!sigsegv_install_handler(sigsegv_handler)) {\n\t\tsprintf(str, GetString(STR_SIG_INSTALL_ERR), \"SIGSEGV\", strerror(errno));\n\t\tErrorAlert(str);\n\t\tQuitEmulator();\n\t}\n\t\n\t// Register dump state function when we got mad after a segfault\n\tsigsegv_set_dump_state(sigsegv_dump_state);\n\n#endif\n\n\t// Read RAM size\n\tRAMSize = PrefsFindInt32(\"ramsize\") & 0xfff00000;\t// Round down to 1MB boundary\n\tif (RAMSize < 1024*1024) {\n\t\tWarningAlert(GetString(STR_SMALL_RAM_WARN));\n\t\tRAMSize = 1024*1024;\n\t}\n\tif (RAMSize > 1023*1024*1024)\t\t\t\t\t\t// Cap to 1023MB (APD crashes at 1GB)\n\t\tRAMSize = 1023*1024*1024;\n\n#if REAL_ADDRESSING || DIRECT_ADDRESSING\n\tRAMSize = RAMSize & -getpagesize();\t\t\t\t\t// Round down to page boundary\n#endif\n\t\n\t// Initialize VM system\n\tvm_init();\n\n#if REAL_ADDRESSING\n\t// Flag: RAM and ROM are contigously allocated from address 0\n\tbool memory_mapped_from_zero = false;\n\n\t// Make sure to map RAM & ROM at address 0 only on platforms that\n\t// supports linker scripts to relocate the Basilisk II executable\n\t// above 0x70000000\n#if HAVE_LINKER_SCRIPT\n\tconst bool can_map_all_memory = true;\n#else\n\tconst bool can_map_all_memory = false;\n#endif\n\t\n\t// Try to allocate all memory from 0x0000, if it is not known to crash\n\tif (can_map_all_memory && (vm_acquire_mac_fixed(0, RAMSize + 0x100000) == 0)) {\n\t\tD(bug(\"Could allocate RAM and ROM from 0x0000\\n\"));\n\t\tmemory_mapped_from_zero = true;\n\t}\n\t\n#ifndef PAGEZERO_HACK\n\t// Otherwise, just create the Low Memory area (0x0000..0x2000)\n\telse if (vm_acquire_mac_fixed(0, 0x2000) == 0) {\n\t\tD(bug(\"Could allocate the Low Memory globals\\n\"));\n\t\tlm_area_mapped = true;\n\t}\n\t\n\t// Exit on failure\n\telse {\n\t\tsprintf(str, GetString(STR_LOW_MEM_MMAP_ERR), strerror(errno));\n\t\tErrorAlert(str);\n\t\tQuitEmulator();\n\t}\n#endif\n#endif /* REAL_ADDRESSING */\n\n\t// Create areas for Mac RAM and ROM\n#if REAL_ADDRESSING\n\tif (memory_mapped_from_zero) {\n\t\tRAMBaseHost = (uint8 *)0;\n\t\tROMBaseHost = RAMBaseHost + RAMSize;\n\t}\n\telse\n#endif\n\t{\n\t\tuint8 *ram_rom_area = (uint8 *)vm_acquire_mac(RAMSize + 0x100000);\n\t\tif (ram_rom_area == VM_MAP_FAILED) {\t\n\t\t\tErrorAlert(STR_NO_MEM_ERR);\n\t\t\tQuitEmulator();\n\t\t}\n\t\tRAMBaseHost = ram_rom_area;\n\t\tROMBaseHost = RAMBaseHost + RAMSize;\n\t}\n\n#if USE_SCRATCHMEM_SUBTERFUGE\n\t// Allocate scratch memory\n\tScratchMem = (uint8 *)vm_acquire_mac(SCRATCH_MEM_SIZE);\n\tif (ScratchMem == VM_MAP_FAILED) {\n\t\tErrorAlert(STR_NO_MEM_ERR);\n\t\tQuitEmulator();\n\t}\n\tScratchMem += SCRATCH_MEM_SIZE/2;\t// ScratchMem points to middle of block\n#endif\n\n#if DIRECT_ADDRESSING\n\t// RAMBaseMac shall always be zero\n\tMEMBaseDiff = (uintptr)RAMBaseHost;\n\tRAMBaseMac = 0;\n\tROMBaseMac = Host2MacAddr(ROMBaseHost);\n#endif\n#if REAL_ADDRESSING\n\tRAMBaseMac = Host2MacAddr(RAMBaseHost);\n\tROMBaseMac = Host2MacAddr(ROMBaseHost);\n#endif\n\tD(bug(\"Mac RAM starts at %p (%08x)\\n\", RAMBaseHost, RAMBaseMac));\n\tD(bug(\"Mac ROM starts at %p (%08x)\\n\", ROMBaseHost, ROMBaseMac));\n\t\n\t// Get rom file path from preferences\n\tconst char *rom_path = PrefsFindString(\"rom\");\n\n\tprintf(\"rom_path %s\\n\", rom_path);\n\n\t// Load Mac ROM\n\tint rom_fd = open(rom_path ? rom_path : ROM_FILE_NAME, O_RDONLY);\n\tif (rom_fd < 0) {\n\t\tErrorAlert(STR_NO_ROM_FILE_ERR);\n\t\tQuitEmulator();\n\t}\n\tprintf(\"%s\", GetString(STR_READING_ROM_FILE));\n\tROMSize = lseek(rom_fd, 0, SEEK_END);\n\tif (ROMSize != 64*1024 && ROMSize != 128*1024 && ROMSize != 256*1024 && ROMSize != 512*1024 && ROMSize != 1024*1024) {\n\t\tErrorAlert(STR_ROM_SIZE_ERR);\n\t\tclose(rom_fd);\n\t\tQuitEmulator();\n\t}\n\tlseek(rom_fd, 0, SEEK_SET);\n\tif (read(rom_fd, ROMBaseHost, ROMSize) != (ssize_t)ROMSize) {\n\t\tErrorAlert(STR_ROM_FILE_READ_ERR);\n\t\tclose(rom_fd);\n\t\tQuitEmulator();\n\t}\n\n#if !EMULATED_68K\n\t// Get CPU model\n\tint mib[2] = {CTL_HW, HW_MODEL};\n\tchar *model;\n\tsize_t model_len;\n\tsysctl(mib, 2, NULL, &model_len, NULL, 0);\n\tmodel = (char *)malloc(model_len);\n\tsysctl(mib, 2, model, &model_len, NULL, 0);\n\tD(bug(\"Model: %s\\n\", model));\n\n\t// Set CPU and FPU type\n\tCPUIs68060 = false;\n\tif (strstr(model, \"020\"))\n\t\tCPUType = 2;\n\telse if (strstr(model, \"030\"))\n\t\tCPUType = 3;\n\telse if (strstr(model, \"040\"))\n\t\tCPUType = 4;\n\telse if (strstr(model, \"060\")) {\n\t\tCPUType = 4;\n\t\tCPUIs68060 = true;\n\t} else {\n\t\tprintf(\"WARNING: Cannot detect CPU type, assuming 68020\\n\");\n\t\tCPUType = 2;\n\t}\n\tFPUType = 1;\t// NetBSD has an FPU emulation, so the FPU ought to be available at all times\n\tTwentyFourBitAddressing = false;\n#endif\n\tprintf(\"Initialize everything\\n\");\n\n\t// Initialize everything\n\tif (!InitAll(vmdir))\n\t\tQuitEmulator();\n\tD(bug(\"Initialization complete\\n\"));\n\n#if !EMULATED_68K\n\t// (Virtual) supervisor mode, disable interrupts\n\tEmulatedSR = 0x2700;\n\n#ifdef HAVE_PTHREADS\n\t// Get handle of main thread\n\temul_thread = pthread_self();\n#endif\n\n\t// Create and install stack for signal handlers\n\tsig_stack = malloc(SIG_STACK_SIZE);\n\tD(bug(\"Signal stack at %p\\n\", sig_stack));\n\tif (sig_stack == NULL) {\n\t\tErrorAlert(STR_NOT_ENOUGH_MEMORY_ERR);\n\t\tQuitEmulator();\n\t}\n\tstack_t new_stack;\n\tnew_stack.ss_sp = sig_stack;\n\tnew_stack.ss_flags = 0;\n\tnew_stack.ss_size = SIG_STACK_SIZE;\n\tif (sigaltstack(&new_stack, NULL) < 0) {\n\t\tsprintf(str, GetString(STR_SIGALTSTACK_ERR), strerror(errno));\n\t\tErrorAlert(str);\n\t\tQuitEmulator();\n\t}\n\n\t// Install SIGILL handler for emulating privileged instructions and\n\t// executing A-Trap and EMUL_OP opcodes\n\tsigemptyset(&sigill_sa.sa_mask);\t// Block virtual 68k interrupts during SIGILL handling\n\tsigaddset(&sigill_sa.sa_mask, SIG_IRQ);\n\tsigaddset(&sigill_sa.sa_mask, SIGALRM);\n\tsigill_sa.sa_handler = (void (*)(int))sigill_handler;\n\tsigill_sa.sa_flags = SA_ONSTACK;\n\tif (sigaction(SIGILL, &sigill_sa, NULL) < 0) {\n\t\tsprintf(str, GetString(STR_SIG_INSTALL_ERR), \"SIGILL\", strerror(errno));\n\t\tErrorAlert(str);\n\t\tQuitEmulator();\n\t}\n\n\t// Install virtual 68k interrupt signal handler\n\tsigemptyset(&sigirq_sa.sa_mask);\n\tsigaddset(&sigirq_sa.sa_mask, SIGALRM);\n\tsigirq_sa.sa_handler = (void (*)(int))sigirq_handler;\n\tsigirq_sa.sa_flags = SA_ONSTACK | SA_RESTART;\n\tif (sigaction(SIG_IRQ, &sigirq_sa, NULL) < 0) {\n\t\tsprintf(str, GetString(STR_SIG_INSTALL_ERR), \"SIG_IRQ\", strerror(errno));\n\t\tErrorAlert(str);\n\t\tQuitEmulator();\n\t}\n#endif\n\n#ifdef ENABLE_MON\n\t// Setup SIGINT handler to enter mon\n\tsigemptyset(&sigint_sa.sa_mask);\n\tsigint_sa.sa_handler = (void (*)(int))sigint_handler;\n\tsigint_sa.sa_flags = 0;\n\tsigaction(SIGINT, &sigint_sa, NULL);\n#endif\n\tprintf(\"services\\n\");\n\n#ifndef USE_CPU_EMUL_SERVICES\n#if defined(HAVE_PTHREADS)\n\n\t// POSIX threads available, start 60Hz thread\n\tSet_pthread_attr(&tick_thread_attr, 0);\n\ttick_thread_active = (pthread_create(&tick_thread, &tick_thread_attr, tick_func, NULL) == 0);\n\tif (!tick_thread_active) {\n\t\tsprintf(str, GetString(STR_TICK_THREAD_ERR), strerror(errno));\n\t\tErrorAlert(str);\n\t\tQuitEmulator();\n\t}\n\tD(bug(\"60Hz thread started\\n\"));\n\n#elif defined(HAVE_TIMER_CREATE) && defined(_POSIX_REALTIME_SIGNALS)\n\n\t// POSIX.4 timers and real-time signals available, start 60Hz timer\n\tsigemptyset(&timer_sa.sa_mask);\n\ttimer_sa.sa_sigaction = (void (*)(int, siginfo_t *, void *))one_tick;\n\ttimer_sa.sa_flags = SA_SIGINFO | SA_RESTART;\n\tif (sigaction(SIG_TIMER, &timer_sa, NULL) < 0) {\n\t\tsprintf(str, GetString(STR_SIG_INSTALL_ERR), \"SIG_TIMER\", strerror(errno));\n\t\tErrorAlert(str);\n\t\tQuitEmulator();\n\t}\n\tstruct sigevent timer_event;\n\ttimer_event.sigev_notify = SIGEV_SIGNAL;\n\ttimer_event.sigev_signo = SIG_TIMER;\n\tif (timer_create(CLOCK_REALTIME, &timer_event, &timer) < 0) {\n\t\tsprintf(str, GetString(STR_TIMER_CREATE_ERR), strerror(errno));\n\t\tErrorAlert(str);\n\t\tQuitEmulator();\n\t}\n\tstruct itimerspec req;\n\treq.it_value.tv_sec = 0;\n\treq.it_value.tv_nsec = 16625000;\n\treq.it_interval.tv_sec = 0;\n\treq.it_interval.tv_nsec = 16625000;\n\tif (timer_settime(timer, 0, &req, NULL) < 0) {\n\t\tsprintf(str, GetString(STR_TIMER_SETTIME_ERR), strerror(errno));\n\t\tErrorAlert(str);\n\t\tQuitEmulator();\n\t}\n\tD(bug(\"60Hz timer started\\n\"));\n\n#else\n\n\t// Start 60Hz timer\n\tsigemptyset(&timer_sa.sa_mask);\t\t// Block virtual 68k interrupts during SIGARLM handling\n#if !EMULATED_68K\n\tsigaddset(&timer_sa.sa_mask, SIG_IRQ);\n#endif // defined(HAVE_PTHREADS)\n\ttimer_sa.sa_handler = one_tick;\n\ttimer_sa.sa_flags = SA_ONSTACK | SA_RESTART;\n\tif (sigaction(SIGALRM, &timer_sa, NULL) < 0) {\n\t\tsprintf(str, GetString(STR_SIG_INSTALL_ERR), \"SIGALRM\", strerror(errno));\n\t\tErrorAlert(str);\n\t\tQuitEmulator();\n\t}\n\tstruct itimerval req;\n\treq.it_interval.tv_sec = req.it_value.tv_sec = 0;\n\treq.it_interval.tv_usec = req.it_value.tv_usec = 16625;\n\tsetitimer(ITIMER_REAL, &req, NULL);\n\n#endif\n#endif\n\n#ifdef USE_PTHREADS_SERVICES\n\t// Start XPRAM watchdog thread\n\tmemcpy(last_xpram, XPRAM, XPRAM_SIZE);\n\txpram_thread_active = (pthread_create(&xpram_thread, NULL, xpram_func, NULL) == 0);\n\tD(bug(\"XPRAM thread started\\n\"));\n#endif\n\n\t// Start 68k and jump to ROM boot routine\n\tD(bug(\"Starting emulation...\\n\"));\n\tprintf(\"Starting emulation\\n\");\n\tStart680x0();\n\n\tprintf(\"Quit\\n\");\n\tQuitEmulator();\n\treturn 0;\n}\n\n\n/*\n *  Quit emulator\n */\n\nvoid QuitEmulator(void)\n{\n\tD(bug(\"QuitEmulator\\n\"));\n\n#if EMULATED_68K\n\t// Exit 680x0 emulation\n\tExit680x0();\n#endif\n\n#if defined(USE_CPU_EMUL_SERVICES)\n\t// Show statistics\n\tuint64 emulated_ticks_end = GetTicks_usec();\n\tD(bug(\"%ld ticks in %ld usec = %f ticks/sec [%ld tick checks]\\n\",\n\t\t  (long)emulated_ticks_count, (long)(emulated_ticks_end - emulated_ticks_start),\n\t\t  emulated_ticks_count * 1000000.0 / (emulated_ticks_end - emulated_ticks_start), (long)n_check_ticks));\n#elif defined(USE_PTHREADS_SERVICES)\n\t// Stop 60Hz thread\n\tif (tick_thread_active) {\n\t\ttick_thread_cancel = true;\n#ifdef HAVE_PTHREAD_CANCEL\n\t\tpthread_cancel(tick_thread);\n#endif\n\t\tpthread_join(tick_thread, NULL);\n\t}\n#elif defined(HAVE_TIMER_CREATE) && defined(_POSIX_REALTIME_SIGNALS)\n\t// Stop 60Hz timer\n\ttimer_delete(timer);\n#else\n\tstruct itimerval req;\n\treq.it_interval.tv_sec = req.it_value.tv_sec = 0;\n\treq.it_interval.tv_usec = req.it_value.tv_usec = 0;\n\tsetitimer(ITIMER_REAL, &req, NULL);\n#endif\n\n#ifdef USE_PTHREADS_SERVICES\n\t// Stop XPRAM watchdog thread\n\tif (xpram_thread_active) {\n\t\txpram_thread_cancel = true;\n#ifdef HAVE_PTHREAD_CANCEL\n\t\tpthread_cancel(xpram_thread);\n#endif\n\t\tpthread_join(xpram_thread, NULL);\n\t}\n#endif\n\n\t// Deinitialize everything\n\tExitAll();\n\n\t// Free ROM/RAM areas\n\tif (RAMBaseHost != VM_MAP_FAILED) {\n\t\tvm_release(RAMBaseHost, RAMSize + 0x100000);\n\t\tRAMBaseHost = NULL;\n\t\tROMBaseHost = NULL;\n\t}\n\n#if USE_SCRATCHMEM_SUBTERFUGE\n\t// Delete scratch memory area\n\tif (ScratchMem != (uint8 *)VM_MAP_FAILED) {\n\t\tvm_release((void *)(ScratchMem - SCRATCH_MEM_SIZE/2), SCRATCH_MEM_SIZE);\n\t\tScratchMem = NULL;\n\t}\n#endif\n\n#if REAL_ADDRESSING\n\t// Delete Low Memory area\n\tif (lm_area_mapped)\n\t\tvm_release(0, 0x2000);\n#endif\n\t\n\t// Exit VM wrappers\n\tvm_exit();\n\n\t// Exit system routines\n\tSysExit();\n\n\t// Exit preferences\n\tPrefsExit();\n\n\t// Close X11 server connection\n#ifndef USE_SDL_VIDEO\n\tif (x_display)\n\t\tXCloseDisplay(x_display);\n#endif\n\n\t// Notify GUI we are about to leave\n\tif (gui_connection) {\n\t\tif (rpc_method_invoke(gui_connection, RPC_METHOD_EXIT, RPC_TYPE_INVALID) == RPC_ERROR_NO_ERROR)\n\t\t\trpc_method_wait_for_reply(gui_connection, RPC_TYPE_INVALID);\n\t}\n\n\texit(0);\n}\n\n\n/*\n *  Code was patched, flush caches if neccessary (i.e. when using a real 680x0\n *  or a dynamically recompiling emulator)\n */\n\nvoid FlushCodeCache(void *start, uint32 size)\n{\n#if USE_JIT\n    if (UseJIT)\n\t\tflush_icache_range((uint8 *)start, size);\n#endif\n#if !EMULATED_68K && defined(__NetBSD__)\n\tm68k_sync_icache(start, size);\n#endif\n}\n\n\n/*\n *  SIGINT handler, enters mon\n */\n\n#ifdef ENABLE_MON\nstatic void sigint_handler(...)\n{\n#if EMULATED_68K\n\tuaecptr nextpc;\n\textern void m68k_dumpstate(uaecptr *nextpc);\n\tm68k_dumpstate(&nextpc);\n#endif\n\tVideoQuitFullScreen();\n\tconst char *arg[4] = {\"mon\", \"-m\", \"-r\", NULL};\n\tmon(3, arg);\n\tQuitEmulator();\n}\n#endif\n\n\n#ifdef HAVE_PTHREADS\n/*\n *  Pthread configuration\n */\n\nvoid Set_pthread_attr(pthread_attr_t *attr, int priority)\n{\n\tpthread_attr_init(attr);\n#ifndef EMSCRIPTEN\n#if defined(_POSIX_THREAD_PRIORITY_SCHEDULING)\n\t// Some of these only work for superuser\n\tif (geteuid() == 0) {\n\t\tpthread_attr_setinheritsched(attr, PTHREAD_EXPLICIT_SCHED);\n\t\tpthread_attr_setschedpolicy(attr, SCHED_FIFO);\n\t\tstruct sched_param fifo_param;\n\t\tfifo_param.sched_priority = ((sched_get_priority_min(SCHED_FIFO) + \n\t\t\t\t\t      sched_get_priority_max(SCHED_FIFO)) / 2 +\n\t\t\t\t\t     priority);\n\t\tpthread_attr_setschedparam(attr, &fifo_param);\n\t}\n\tif (pthread_attr_setscope(attr, PTHREAD_SCOPE_SYSTEM) != 0) {\n#ifdef PTHREAD_SCOPE_BOUND_NP\n\t    // If system scope is not available (eg. we're not running\n\t    // with CAP_SCHED_MGT capability on an SGI box), try bound\n\t    // scope.  It exposes pthread scheduling to the kernel,\n\t    // without setting realtime priority.\n\t    pthread_attr_setscope(attr, PTHREAD_SCOPE_BOUND_NP);\n#endif\n\t}\n#endif\n#endif // ifndef EMSCRIPTEN\n}\n#endif // HAVE_PTHREADS\n\n\n/*\n *  Mutexes\n */\n\n#ifdef HAVE_PTHREADS\n\nstruct B2_mutex {\n\tB2_mutex() { \n\t    pthread_mutexattr_t attr;\n\t    pthread_mutexattr_init(&attr);\n\t    // Initialize the mutex for priority inheritance --\n\t    // required for accurate timing.\n#if defined(HAVE_PTHREAD_MUTEXATTR_SETPROTOCOL) && !defined(__CYGWIN__)\n\t    pthread_mutexattr_setprotocol(&attr, PTHREAD_PRIO_INHERIT);\n#endif\n#if defined(HAVE_PTHREAD_MUTEXATTR_SETTYPE) && defined(PTHREAD_MUTEX_NORMAL)\n\t    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL);\n#endif\n#ifdef HAVE_PTHREAD_MUTEXATTR_SETPSHARED\n\t    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_PRIVATE);\n#endif\n\t    pthread_mutex_init(&m, &attr);\n\t    pthread_mutexattr_destroy(&attr);\n\t}\n\t~B2_mutex() { \n\t    pthread_mutex_trylock(&m); // Make sure it's locked before\n\t    pthread_mutex_unlock(&m);  // unlocking it.\n\t    pthread_mutex_destroy(&m);\n\t}\n\tpthread_mutex_t m;\n};\n\nB2_mutex *B2_create_mutex(void)\n{\n\treturn new B2_mutex;\n}\n\nvoid B2_lock_mutex(B2_mutex *mutex)\n{\n\tpthread_mutex_lock(&mutex->m);\n}\n\nvoid B2_unlock_mutex(B2_mutex *mutex)\n{\n\tpthread_mutex_unlock(&mutex->m);\n}\n\nvoid B2_delete_mutex(B2_mutex *mutex)\n{\n\tdelete mutex;\n}\n\n#else\n\nstruct B2_mutex {\n\tint dummy;\n};\n\nB2_mutex *B2_create_mutex(void)\n{\n\treturn new B2_mutex;\n}\n\nvoid B2_lock_mutex(B2_mutex *mutex)\n{\n}\n\nvoid B2_unlock_mutex(B2_mutex *mutex)\n{\n}\n\nvoid B2_delete_mutex(B2_mutex *mutex)\n{\n\tdelete mutex;\n}\n\n#endif\n\n\n/*\n *  Interrupt flags (must be handled atomically!)\n */\n\nuint32 InterruptFlags = 0;\n\n#if EMULATED_68K\nvoid SetInterruptFlag(uint32 flag)\n{\n\tLOCK_INTFLAGS;\n\tInterruptFlags |= flag;\n\tUNLOCK_INTFLAGS;\n}\n\nvoid ClearInterruptFlag(uint32 flag)\n{\n\tLOCK_INTFLAGS;\n\tInterruptFlags &= ~flag;\n\tUNLOCK_INTFLAGS;\n}\n#endif\n\n#if !EMULATED_68K\nvoid TriggerInterrupt(void)\n{\n#if defined(HAVE_PTHREADS)\n\tpthread_kill(emul_thread, SIG_IRQ);\n#else\n\traise(SIG_IRQ);\n#endif\n}\n\nvoid TriggerNMI(void)\n{\n\t// not yet supported\n}\n#endif\n\n\n/*\n *  XPRAM watchdog thread (saves XPRAM every minute)\n */\n\nstatic void xpram_watchdog(void)\n{\n\tif (memcmp(last_xpram, XPRAM, XPRAM_SIZE)) {\n\t\tmemcpy(last_xpram, XPRAM, XPRAM_SIZE);\n\t\tSaveXPRAM();\n\t}\n}\n\n#ifdef USE_PTHREADS_SERVICES\nstatic void *xpram_func(void *arg)\n{\n\twhile (!xpram_thread_cancel) {\n\t\tfor (int i=0; i<60 && !xpram_thread_cancel; i++)\n\t\t\tDelay_usec(999999);\t\t// Only wait 1 second so we quit promptly when xpram_thread_cancel becomes true\n\t\txpram_watchdog();\n\t}\n\treturn NULL;\n}\n#endif\n\n\n/*\n *  60Hz thread (really 60.15Hz)\n */\n\nstatic void one_second(void)\n{\n\t// Pseudo Mac 1Hz interrupt, update local time\n\tWriteMacInt32(0x20c, TimerDateTime());\n\n\tSetInterruptFlag(INTFLAG_1HZ);\n\tTriggerInterrupt();\n\n#ifndef USE_PTHREADS_SERVICES\n\tstatic int second_counter = 0;\n\tif (++second_counter > 60) {\n\t\tsecond_counter = 0;\n\t\txpram_watchdog();\n\t}\n#endif\n}\n\nstatic void one_tick(...)\n{\n\tstatic int tick_counter = 0;\n\tif (++tick_counter > 60) {\n\t\ttick_counter = 0;\n\t\tone_second();\n\t}\n\n#ifndef USE_PTHREADS_SERVICES\n\t// Threads not used to trigger interrupts, perform video refresh from here\n\t// printf(\"VideoRefresh\\n\");\n\tVideoRefresh();\n#else\n\tprintf(\"USE_PTHREADS_SERVICES\\n\");\n#endif\n\n#if defined(EMSCRIPTEN) && !defined(__EMSCRIPTEN_PTHREADS__)\n\t// tuned (badly) for sr=22050 blocksize=4096\n\tif ((tick_counter) % 11 == 0) {\n\t\taudio_write_blocks(1);\n\t}\n#endif\n\n#ifndef HAVE_PTHREADS\n\t// No threads available, perform networking from here\n\tSetInterruptFlag(INTFLAG_ETHER);\n#endif\n\n\t// Trigger 60Hz interrupt\n\tif (ROMVersion != ROM_VERSION_CLASSIC || HasMacStarted()) {\n\t\tSetInterruptFlag(INTFLAG_60HZ);\n\t\tTriggerInterrupt();\n\t}\n}\n\n#ifdef USE_PTHREADS_SERVICES\nstatic void *tick_func(void *arg)\n{\n\tuint64 start = GetTicks_usec();\n\tint64 ticks = 0;\n\tuint64 next = GetTicks_usec();\n\twhile (!tick_thread_cancel) {\n\t\tone_tick();\n\t\tnext += 16625;\n\t\tint64 delay = next - GetTicks_usec();\n\t\tif (delay > 0)\n\t\t\tDelay_usec(delay);\n\t\telse if (delay < -16625)\n\t\t\tnext = GetTicks_usec();\n\t\tticks++;\n\t}\n\tuint64 end = GetTicks_usec();\n\tD(bug(\"%lld ticks in %lld usec = %f ticks/sec\\n\", ticks, end - start, ticks * 1000000.0 / (end - start)));\n\treturn NULL;\n}\n#endif\n\n\n#if !EMULATED_68K\n/*\n *  Virtual 68k interrupt handler\n */\n\nstatic void sigirq_handler(int sig, int code, struct sigcontext *scp)\n{\n\t// Interrupts disabled? Then do nothing\n\tif (EmulatedSR & 0x0700)\n\t\treturn;\n\n\tstruct sigstate *state = (struct sigstate *)scp->sc_ap;\n\tM68kRegisters *regs = (M68kRegisters *)&state->ss_frame;\n\n\t// Set up interrupt frame on stack\n\tuint32 a7 = regs->a[7];\n\ta7 -= 2;\n\tWriteMacInt16(a7, 0x64);\n\ta7 -= 4;\n\tWriteMacInt32(a7, scp->sc_pc);\n\ta7 -= 2;\n\tWriteMacInt16(a7, scp->sc_ps | EmulatedSR);\n\tscp->sc_sp = regs->a[7] = a7;\n\n\t// Set interrupt level\n\tEmulatedSR |= 0x2100;\n\n\t// Jump to MacOS interrupt handler on return\n\tscp->sc_pc = ReadMacInt32(0x64);\n}\n\n\n/*\n *  SIGILL handler, for emulation of privileged instructions and executing\n *  A-Trap and EMUL_OP opcodes\n */\n\nstatic void sigill_handler(int sig, int code, struct sigcontext *scp)\n{\n\tstruct sigstate *state = (struct sigstate *)scp->sc_ap;\n\tuint16 *pc = (uint16 *)scp->sc_pc;\n\tuint16 opcode = *pc;\n\tM68kRegisters *regs = (M68kRegisters *)&state->ss_frame;\n\n#define INC_PC(n) scp->sc_pc += (n)\n\n#define GET_SR (scp->sc_ps | EmulatedSR)\n\n#define STORE_SR(v) \\\n\tscp->sc_ps = (v) & 0xff; \\\n\tEmulatedSR = (v) & 0xe700; \\\n\tif (((v) & 0x0700) == 0 && InterruptFlags) \\\n\t\tTriggerInterrupt();\n\n//printf(\"opcode %04x at %p, sr %04x, emul_sr %04x\\n\", opcode, pc, scp->sc_ps, EmulatedSR);\n\n\tif ((opcode & 0xf000) == 0xa000) {\n\n\t\t// A-Line instruction, set up A-Line trap frame on stack\n\t\tuint32 a7 = regs->a[7];\n\t\ta7 -= 2;\n\t\tWriteMacInt16(a7, 0x28);\n\t\ta7 -= 4;\n\t\tWriteMacInt32(a7, (uint32)pc);\n\t\ta7 -= 2;\n\t\tWriteMacInt16(a7, GET_SR);\n\t\tscp->sc_sp = regs->a[7] = a7;\n\n\t\t// Jump to MacOS A-Line handler on return\n\t\tscp->sc_pc = ReadMacInt32(0x28);\n\n\t} else if ((opcode & 0xff00) == 0x7100) {\n\n\t\t// Extended opcode, push registers on user stack\n\t\tuint32 a7 = regs->a[7];\n\t\ta7 -= 4;\n\t\tWriteMacInt32(a7, (uint32)pc);\n\t\ta7 -= 2;\n\t\tWriteMacInt16(a7, scp->sc_ps);\n\t\tfor (int i=7; i>=0; i--) {\n\t\t\ta7 -= 4;\n\t\t\tWriteMacInt32(a7, regs->a[i]);\n\t\t}\n\t\tfor (int i=7; i>=0; i--) {\n\t\t\ta7 -= 4;\n\t\t\tWriteMacInt32(a7, regs->d[i]);\n\t\t}\n\t\tscp->sc_sp = regs->a[7] = a7;\n\n\t\t// Jump to EmulOp trampoline code on return\n\t\tscp->sc_pc = (uint32)EmulOpTrampoline;\n\t\t\n\t} else switch (opcode) {\t// Emulate privileged instructions\n\n\t\tcase 0x40e7:\t// move sr,-(sp)\n\t\t\tregs->a[7] -= 2;\n\t\t\tWriteMacInt16(regs->a[7], GET_SR);\n\t\t\tscp->sc_sp = regs->a[7];\n\t\t\tINC_PC(2);\n\t\t\tbreak;\n\n\t\tcase 0x46df: {\t// move (sp)+,sr\n\t\t\tuint16 sr = ReadMacInt16(regs->a[7]);\n\t\t\tSTORE_SR(sr);\n\t\t\tregs->a[7] += 2;\n\t\t\tscp->sc_sp = regs->a[7];\n\t\t\tINC_PC(2);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 0x007c: {\t// ori #xxxx,sr\n\t\t\tuint16 sr = GET_SR | pc[1];\n\t\t\tscp->sc_ps = sr & 0xff;\t\t// oring bits into the sr can't enable interrupts, so we don't need to call STORE_SR\n\t\t\tEmulatedSR = sr & 0xe700;\n\t\t\tINC_PC(4);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 0x027c: {\t// andi #xxxx,sr\n\t\t\tuint16 sr = GET_SR & pc[1];\n\t\t\tSTORE_SR(sr);\n\t\t\tINC_PC(4);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 0x46fc:\t// move #xxxx,sr\n\t\t\tSTORE_SR(pc[1]);\n\t\t\tINC_PC(4);\n\t\t\tbreak;\n\n\t\tcase 0x46ef: {\t// move (xxxx,sp),sr\n\t\t\tuint16 sr = ReadMacInt16(regs->a[7] + (int32)(int16)pc[1]);\n\t\t\tSTORE_SR(sr);\n\t\t\tINC_PC(4);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 0x46d8:\t// move (a0)+,sr\n\t\tcase 0x46d9: {\t// move (a1)+,sr\n\t\t\tuint16 sr = ReadMacInt16(regs->a[opcode & 7]);\n\t\t\tSTORE_SR(sr);\n\t\t\tregs->a[opcode & 7] += 2;\n\t\t\tINC_PC(2);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 0x40f8:\t// move sr,xxxx.w\n\t\t\tWriteMacInt16(pc[1], GET_SR);\n\t\t\tINC_PC(4);\n\t\t\tbreak;\n\n\t\tcase 0x40d0:\t// move sr,(a0)\n\t\tcase 0x40d1:\t// move sr,(a1)\n\t\tcase 0x40d2:\t// move sr,(a2)\n\t\tcase 0x40d3:\t// move sr,(a3)\n\t\tcase 0x40d4:\t// move sr,(a4)\n\t\tcase 0x40d5:\t// move sr,(a5)\n\t\tcase 0x40d6:\t// move sr,(a6)\n\t\tcase 0x40d7:\t// move sr,(sp)\n\t\t\tWriteMacInt16(regs->a[opcode & 7], GET_SR);\n\t\t\tINC_PC(2);\n\t\t\tbreak;\n\n\t\tcase 0x40c0:\t// move sr,d0\n\t\tcase 0x40c1:\t// move sr,d1\n\t\tcase 0x40c2:\t// move sr,d2\n\t\tcase 0x40c3:\t// move sr,d3\n\t\tcase 0x40c4:\t// move sr,d4\n\t\tcase 0x40c5:\t// move sr,d5\n\t\tcase 0x40c6:\t// move sr,d6\n\t\tcase 0x40c7:\t// move sr,d7\n\t\t\tregs->d[opcode & 7] = GET_SR;\n\t\t\tINC_PC(2);\n\t\t\tbreak;\n\n\t\tcase 0x46c0:\t// move d0,sr\n\t\tcase 0x46c1:\t// move d1,sr\n\t\tcase 0x46c2:\t// move d2,sr\n\t\tcase 0x46c3:\t// move d3,sr\n\t\tcase 0x46c4:\t// move d4,sr\n\t\tcase 0x46c5:\t// move d5,sr\n\t\tcase 0x46c6:\t// move d6,sr\n\t\tcase 0x46c7: {\t// move d7,sr\n\t\t\tuint16 sr = regs->d[opcode & 7];\n\t\t\tSTORE_SR(sr);\n\t\t\tINC_PC(2);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 0xf327:\t// fsave -(sp)\n\t\t\tregs->a[7] -= 4;\n\t\t\tWriteMacInt32(regs->a[7], 0x41000000);\t// Idle frame\n\t\t\tscp->sc_sp = regs->a[7];\n\t\t\tINC_PC(2);\n\t\t\tbreak;\n\n\t\tcase 0xf35f:\t// frestore (sp)+\n\t\t\tregs->a[7] += 4;\n\t\t\tscp->sc_sp = regs->a[7];\n\t\t\tINC_PC(2);\n\t\t\tbreak;\n\n\t\tcase 0x4e73: {\t// rte\n\t\t\tuint32 a7 = regs->a[7];\n\t\t\tuint16 sr = ReadMacInt16(a7);\n\t\t\ta7 += 2;\n\t\t\tscp->sc_ps = sr & 0xff;\n\t\t\tEmulatedSR = sr & 0xe700;\n\t\t\tscp->sc_pc = ReadMacInt32(a7);\n\t\t\ta7 += 4;\n\t\t\tuint16 format = ReadMacInt16(a7) >> 12;\n\t\t\ta7 += 2;\n\t\t\tstatic const int frame_adj[16] = {\n\t\t\t\t0, 0, 4, 4, 8, 0, 0, 52, 50, 12, 24, 84, 16, 0, 0, 0\n\t\t\t};\n\t\t\tscp->sc_sp = regs->a[7] = a7 + frame_adj[format];\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 0x4e7a:\t// movec cr,x\n\t\t\tswitch (pc[1]) {\n\t\t\t\tcase 0x0002:\t// movec cacr,d0\n\t\t\t\t\tregs->d[0] = 0x3111;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x1002:\t// movec cacr,d1\n\t\t\t\t\tregs->d[1] = 0x3111;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x0003:\t// movec tc,d0\n\t\t\t\tcase 0x0004:\t// movec itt0,d0\n\t\t\t\tcase 0x0005:\t// movec itt1,d0\n\t\t\t\tcase 0x0006:\t// movec dtt0,d0\n\t\t\t\tcase 0x0007:\t// movec dtt1,d0\n\t\t\t\tcase 0x0806:\t// movec urp,d0\n\t\t\t\tcase 0x0807:\t// movec srp,d0\n\t\t\t\t\tregs->d[0] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x1000:\t// movec sfc,d1\n\t\t\t\tcase 0x1001:\t// movec dfc,d1\n\t\t\t\tcase 0x1003:\t// movec tc,d1\n\t\t\t\tcase 0x1801:\t// movec vbr,d1\n\t\t\t\t\tregs->d[1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x8801:\t// movec vbr,a0\n\t\t\t\t\tregs->a[0] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x9801:\t// movec vbr,a1\n\t\t\t\t\tregs->a[1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tgoto ill;\n\t\t\t}\n\t\t\tINC_PC(4);\n\t\t\tbreak;\n\n\t\tcase 0x4e7b:\t// movec x,cr\n\t\t\tswitch (pc[1]) {\n\t\t\t\tcase 0x1000:\t// movec d1,sfc\n\t\t\t\tcase 0x1001:\t// movec d1,dfc\n\t\t\t\tcase 0x0801:\t// movec d0,vbr\n\t\t\t\tcase 0x1801:\t// movec d1,vbr\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x0002:\t// movec d0,cacr\n\t\t\t\tcase 0x1002:\t// movec d1,cacr\n\t\t\t\t\tFlushCodeCache(NULL, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tgoto ill;\n\t\t\t}\n\t\t\tINC_PC(4);\n\t\t\tbreak;\n\n\t\tcase 0xf478:\t// cpusha dc\n\t\tcase 0xf4f8:\t// cpusha dc/ic\n\t\t\tFlushCodeCache(NULL, 0);\n\t\t\tINC_PC(2);\n\t\t\tbreak;\n\n\t\tdefault:\nill:\t\tprintf(\"SIGILL num %d, code %d\\n\", sig, code);\n\t\t\tprintf(\" context %p:\\n\", scp);\n\t\t\tprintf(\"  onstack %08x\\n\", scp->sc_onstack);\n\t\t\tprintf(\"  sp %08x\\n\", scp->sc_sp);\n\t\t\tprintf(\"  fp %08x\\n\", scp->sc_fp);\n\t\t\tprintf(\"  pc %08x\\n\", scp->sc_pc);\n\t\t\tprintf(\"   opcode %04x\\n\", opcode);\n\t\t\tprintf(\"  sr %08x\\n\", scp->sc_ps);\n\t\t\tprintf(\" state %p:\\n\", state);\n\t\t\tprintf(\"  flags %d\\n\", state->ss_flags);\n\t\t\tfor (int i=0; i<8; i++)\n\t\t\t\tprintf(\"  d%d %08x\\n\", i, state->ss_frame.f_regs[i]);\n\t\t\tfor (int i=0; i<8; i++)\n\t\t\t\tprintf(\"  a%d %08x\\n\", i, state->ss_frame.f_regs[i+8]);\n\n\t\t\tVideoQuitFullScreen();\n#ifdef ENABLE_MON\n\t\t\tchar *arg[4] = {\"mon\", \"-m\", \"-r\", NULL};\n\t\t\tmon(3, arg);\n#endif\n\t\t\tQuitEmulator();\n\t\t\tbreak;\n\t}\n}\n#endif\n\n\n/*\n *  Display alert\n */\n\n#ifdef ENABLE_GTK\nstatic void dl_destroyed(void)\n{\n\tgtk_main_quit();\n}\n\nstatic void dl_quit(GtkWidget *dialog)\n{\n\tgtk_widget_destroy(dialog);\n}\n\nvoid display_alert(int title_id, int prefix_id, int button_id, const char *text)\n{\n\tchar str[256];\n\tsprintf(str, GetString(prefix_id), text);\n\n\tGtkWidget *dialog = gtk_dialog_new();\n\tgtk_window_set_title(GTK_WINDOW(dialog), GetString(title_id));\n\tgtk_container_border_width(GTK_CONTAINER(dialog), 5);\n\tgtk_widget_set_uposition(GTK_WIDGET(dialog), 100, 150);\n\tgtk_signal_connect(GTK_OBJECT(dialog), \"destroy\", GTK_SIGNAL_FUNC(dl_destroyed), NULL);\n\n\tGtkWidget *label = gtk_label_new(str);\n\tgtk_widget_show(label);\n\tgtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->vbox), label, TRUE, TRUE, 0);\n\n\tGtkWidget *button = gtk_button_new_with_label(GetString(button_id));\n\tgtk_widget_show(button);\n\tgtk_signal_connect_object(GTK_OBJECT(button), \"clicked\", GTK_SIGNAL_FUNC(dl_quit), GTK_OBJECT(dialog));\n\tgtk_box_pack_start(GTK_BOX(GTK_DIALOG(dialog)->action_area), button, FALSE, FALSE, 0);\n\tGTK_WIDGET_SET_FLAGS(button, GTK_CAN_DEFAULT);\n\tgtk_widget_grab_default(button);\n\tgtk_widget_show(dialog);\n\n\tgtk_main();\n}\n#endif\n\n\n/*\n *  Display error alert\n */\n\nvoid ErrorAlert(const char *text)\n{\n\tif (gui_connection) {\n\t\tif (rpc_method_invoke(gui_connection, RPC_METHOD_ERROR_ALERT, RPC_TYPE_STRING, text, RPC_TYPE_INVALID) == RPC_ERROR_NO_ERROR &&\n\t\t\trpc_method_wait_for_reply(gui_connection, RPC_TYPE_INVALID) == RPC_ERROR_NO_ERROR)\n\t\t\treturn;\n\t}\n#if defined(ENABLE_GTK) && !defined(USE_SDL_VIDEO)\n\tif (PrefsFindBool(\"nogui\") || x_display == NULL) {\n\t\tprintf(GetString(STR_SHELL_ERROR_PREFIX), text);\n\t\treturn;\n\t}\n\tVideoQuitFullScreen();\n\tdisplay_alert(STR_ERROR_ALERT_TITLE, STR_GUI_ERROR_PREFIX, STR_QUIT_BUTTON, text);\n#else\n\tprintf(GetString(STR_SHELL_ERROR_PREFIX), text);\n#endif\n}\n\n\n/*\n *  Display warning alert\n */\n\nvoid WarningAlert(const char *text)\n{\n\tif (gui_connection) {\n\t\tif (rpc_method_invoke(gui_connection, RPC_METHOD_WARNING_ALERT, RPC_TYPE_STRING, text, RPC_TYPE_INVALID) == RPC_ERROR_NO_ERROR &&\n\t\t\trpc_method_wait_for_reply(gui_connection, RPC_TYPE_INVALID) == RPC_ERROR_NO_ERROR)\n\t\t\treturn;\n\t}\n#if defined(ENABLE_GTK) && !defined(USE_SDL_VIDEO)\n\tif (PrefsFindBool(\"nogui\") || x_display == NULL) {\n\t\tprintf(GetString(STR_SHELL_WARNING_PREFIX), text);\n\t\treturn;\n\t}\n\tdisplay_alert(STR_WARNING_ALERT_TITLE, STR_GUI_WARNING_PREFIX, STR_OK_BUTTON, text);\n#else\n\tprintf(GetString(STR_SHELL_WARNING_PREFIX), text);\n#endif\n}\n\n\n/*\n *  Display choice alert\n */\n\nbool ChoiceAlert(const char *text, const char *pos, const char *neg)\n{\n\tprintf(GetString(STR_SHELL_WARNING_PREFIX), text);\n\treturn false;\t//!!\n}\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const basic_string& str, size_type pos, size_type n,\n                 const Allocator& a = Allocator());\n    template<class T>\n        basic_string(const T& t, size_type pos, size_type n, const Allocator& a = Allocator()); // C++17\n    explicit basic_string(const basic_string_view<charT, traits> sv, const Allocator& a = Allocator());\n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    operator basic_string_view<charT, traits>() const noexcept;\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string_view<charT, traits> sv);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value ||\n             allocator_type::is_always_equal::value ); // C++17\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(basic_string_view<charT, traits> sv);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(basic_string_view<charT, traits> sv);\n    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14\n    template <class T>\n        basic_string& append(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string_view<charT, traits> sv);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14\n    template <class T>\n        basic_string& assign(const T& t, size_type pos, size_type n=npos); // C++17\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, basic_string_view<charT, traits> sv);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    template <class T>\n        basic_string& insert(size_type pos1, const T& t, size_type pos2, size_type n); // C++17\n    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, basic_string_view<charT, traits> sv);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2=npos); // C++14\n    template <class T>\n        basic_string& replace(size_type pos1, size_type n1, const T& t,\n                              size_type pos2, size_type n); // C++17\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, basic_string_view<charT, traits> sv);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(allocator_traits<allocator_type>::propagate_on_container_swap::value ||\n                 allocator_traits<allocator_type>::is_always_equal::value);  // C++17\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n          value_type* data()       noexcept;   // C++17\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type ffind(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(basic_string_view<charT, traits> sv, size_type pos = 0) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(basic_string_view<charT, traits> sv) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, basic_string_view<charT, traits> sv) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2=npos) const; // C++14\n    template <class T>\n        int compare(size_type pos1, size_type n1, const T& t,\n                    size_type pos2, size_type n2=npos) const; // C++17\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <string_view>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TEMPLATE_VIS fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\ntemplate <bool>\nclass _LIBCPP_TEMPLATE_VIS __basic_string_common\n{\nprotected:\n    _LIBCPP_NORETURN void __throw_length_error() const;\n    _LIBCPP_NORETURN void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n    _VSTD::__throw_length_error(\"basic_string\");\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n    _VSTD::__throw_out_of_range(\"basic_string\");\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __basic_string_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\n#ifdef _LIBCPP_NO_EXCEPTIONS\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public true_type {};\n#elif defined(_LIBCPP_HAS_NO_NOEXCEPT)\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public false_type {};\n#else\ntemplate <class _Iter, bool = __is_forward_iterator<_Iter>::value>\nstruct __libcpp_string_gets_noexcept_iterator_impl : public _LIBCPP_BOOL_CONSTANT((\n    noexcept(++(declval<_Iter&>())) && \n    is_nothrow_assignable<_Iter&, _Iter>::value && \n    noexcept(declval<_Iter>() == declval<_Iter>()) && \n    noexcept(*declval<_Iter>())\n)) {};\n\ntemplate <class _Iter> \nstruct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false> : public false_type {};\n#endif\n\n\ntemplate <class _Iter>\nstruct __libcpp_string_gets_noexcept_iterator\n    : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value) {};\n\ntemplate <class _CharT, class _Traits, class _Tp>\nstruct __can_be_converted_to_string_view : public _LIBCPP_BOOL_CONSTANT(\n\t( is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&\n     !is_convertible<const _Tp&, const _CharT*>::value)) {};\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TEMPLATE_VIS basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef basic_string_view<_CharT, _Traits>           __self_view;\n    typedef _Traits                                      traits_type;\n    typedef typename traits_type::char_type              value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert(is_pod<value_type>::value, \"Character type of basic_string must be a POD\");\n    static_assert((is_same<_CharT, value_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n#else\n        _NOEXCEPT;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c, const allocator_type& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                 const allocator_type& __a = allocator_type());\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const basic_string& __str, size_type __pos,\n                 const allocator_type& __a = allocator_type());\n    template<class _Tp>\n        basic_string(const _Tp& __t, size_type __pos, size_type __n, \n                     const allocator_type& __a = allocator_type(),\n                     typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type* = 0);\n    _LIBCPP_INLINE_VISIBILITY explicit\n    basic_string(__self_view __sv);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(__self_view __sv, const allocator_type& __a);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    inline ~basic_string();\n\n    _LIBCPP_INLINE_VISIBILITY\n    operator __self_view() const _NOEXCEPT { return __self_view(data(), size()); }\n\n    basic_string& operator=(const basic_string& __str);\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class = void>\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(__self_view __sv)  {return assign(__sv);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap()\n                             : static_cast<size_type>(__min_cap)) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos)       _NOEXCEPT;\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(__self_view __sv)          {return append(__sv);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)     {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(__self_view __sv) { return append(__sv.data(), __sv.size()); }\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  append(const _Tp& __t, size_type __pos, size_type __n=npos);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template <class _ForwardIterator>\n    inline basic_string& __append_forward_unsafe(_ForwardIterator, _ForwardIterator);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_InputIterator __first, _InputIterator __last) {\n      const basic_string __temp (__first, __last, __alloc());\n      append(__temp.data(), __temp.size());\n      return *this;\n    }\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n    _LIBCPP_INLINE_VISIBILITY\n    append(_ForwardIterator __first, _ForwardIterator __last) {\n      return __append_forward_unsafe(__first, __last);\n    }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(__self_view __sv) { return assign(__sv.data(), __sv.size()); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str) { return *this = __str; }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& str)\n        _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n        {*this = _VSTD::move(str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  assign(const _Tp & __t, size_type pos, size_type n=npos);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, __self_view __sv) { return insert(__pos1, __sv.data(), __sv.size()); }\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n           __is_exactly_input_iterator<_InputIterator>::value\n                || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value\n                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, __self_view __sv) { return replace(__pos1, __n1, __sv.data(), __sv.size()); }\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);\n    template <class _Tp>\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            basic_string&\n        >::type\n                  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, __self_view __sv) { return replace(__i1 - begin(), __i2 - __i1, __sv); }\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG;\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#if _LIBCPP_STD_VER > 14\n    _LIBCPP_INLINE_VISIBILITY\n    value_type* data()             _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(__self_view __sv, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(__self_view __sv) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, __self_view __sv) const;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;\n    template <class _Tp>\n    inline _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n            int\n        >::type\n        compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return (__s + (__a-1)) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? static_cast<size_type>(__min_cap) :\n                 __align_it<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(const value_type* __s, size_type __sz);\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    typename enable_if\n    <\n        __is_exactly_input_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() != __str.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __alloc() = __str.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type)\n        _NOEXCEPT_(__alloc_traits::is_always_equal::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n        _NOEXCEPT;\n#else\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n: __r_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,\n                                                       size_type __sz,\n                                                       size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n#if _LIBCPP_STD_VER <= 14\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n#else\n        _NOEXCEPT\n#endif\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    else\n    {\n        __r_.first().__r = __str.__r_.first().__r;\n        __str.__zero();\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, __str_sz - __pos);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(\n             const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a,\n\t\t\t typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type *)\n    : __r_(__a)\n{\n\t__self_view __sv = __self_view(__t).substr(__pos, __n);\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\t\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv)\n{\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__sv.data(), __sv.size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_exactly_input_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, (void) ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign received nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str.data(), __str.size());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n    _NOEXCEPT_(__alloc_traits::is_always_equal::value)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n#if _LIBCPP_STD_VER > 14\n    _NOEXCEPT\n#else\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n#endif\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_exactly_input_iterator <_InputIterator>::value\n          || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    const basic_string __temp(__first, __last, __alloc());\n    assign(__temp.data(), __temp.size());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign received nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append received nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _Tp>\nbool __ptr_in_range (const _Tp* __p, const _Tp* __first, const _Tp* __last)\n{\n    return __first <= __p && __p < __last;\n}\n\ntemplate <class _Tp1, class _Tp2>\nbool __ptr_in_range (const _Tp1*, const _Tp2*, const _Tp2*)\n{\n    return false;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::__append_forward_unsafe(\n    _ForwardIterator __first, _ForwardIterator __last)\n{\n    static_assert(__is_forward_iterator<_ForwardIterator>::value,\n                  \"function requires a ForwardIterator\");\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_ref = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_ref), data(), data() + size()))\n        {\n            const basic_string __temp (__first, __last, __alloc());\n            append(__temp.data(), __temp.size());\n        }\n        else \n        {\n            if (__cap - __sz < __n)\n                __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n            pointer __p = __get_pointer() + __sz;\n            for (; __first != __last; ++__p, ++__first)\n                traits_type::assign(*__p, *__first);\n            traits_type::assign(*__p, value_type());\n            __set_size(__sz + __n);\n        }\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\n    typename enable_if\n    <\n        __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n        basic_string<_CharT, _Traits, _Allocator>&\n    >::type\nbasic_string<_CharT, _Traits, _Allocator>::append(const _Tp & __t, size_type __pos, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __sz = __sv.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__sv.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n   __is_exactly_input_iterator<_InputIterator>::value\n        || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,\n   typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    const basic_string __temp(__first, __last, __alloc());\n    return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value\n        && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;\n        _CharRef __tmp_char = *__first;\n        if (__ptr_in_range(_VSTD::addressof(__tmp_char), data(), data() + size()))\n        {\n            const basic_string __temp(__first, __last, __alloc());\n            return insert(__pos, __temp.data(), __temp.data() + __temp.size());\n        }\n\n        size_type __sz = size();\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t,\n                                                  size_type __pos2, size_type __n)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __sv.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert received nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    const basic_string __temp(__j1, __j2, __alloc());\n    return this->replace(__i1, __i2, __temp);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n\t__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tbasic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const _Tp& __t,\n                                                   size_type __pos2, size_type __n2)\n{\n    __self_view __sv = __t;\n    size_type __str_sz = __sv.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __sv.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace received nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#if _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n#if _LIBCPP_STD_VER >= 14\n        _NOEXCEPT_DEBUG\n#else\n        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||\n                    __is_nothrow_swappable<allocator_type>::value)\n#endif\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _LIBCPP_ASSERT(\n        __alloc_traits::propagate_on_container_swap::value ||\n        __alloc_traits::is_always_equal::value ||\n        __alloc() == __str.__alloc(), \"swapping non-equal allocators\");\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_allocator(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): received nullptr\");\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): received nullptr\");\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return __str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): received nullptr\");\n    return __str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): received nullptr\");\n    return __str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return __str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(__self_view __sv,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __sv.data(), __pos, __sv.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return __str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(__self_view __sv) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __sv.size();\n    int __result = traits_type::compare(data(), __sv.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    return compare(__self_view(__str));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): received nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   __self_view __sv) const\n{\n    return compare(__pos1, __n1, __sv.data(), __sv.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _Tp>\ntypename enable_if\n<\n\t__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,\n\tint\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const _Tp& __t,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    __self_view __sv = __t;\n    return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n        return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__lhs != nullptr, \"operator==(char*, basic_string): received nullptr\");\n    size_t __lhs_len = _Traits::length(__lhs);\n    if (__lhs_len != __rhs.size()) return false;\n    return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    typedef basic_string<_CharT, _Traits, _Allocator> _String;\n    _LIBCPP_ASSERT(__rhs != nullptr, \"operator==(basic_string, char*): received nullptr\");\n    size_t __rhs_len = _Traits::length(__rhs);\n    if (__rhs_len != __lhs.size()) return false;\n    return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TEMPLATE_VIS hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_string<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STRING\n","/*\n *  prefs_unix.cpp - Preferences handling, Unix specific stuff\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"sysdeps.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <string>\nusing std::string;\n\n#include \"prefs.h\"\n\n\n// Platform-specific preferences items\nprefs_desc platform_prefs_items[] = {\n\t{\"keycodes\", TYPE_BOOLEAN, false,      \"use keycodes rather than keysyms to decode keyboard\"},\n\t{\"keycodefile\", TYPE_STRING, false,    \"path of keycode translation file\"},\n\t{\"fbdevicefile\", TYPE_STRING, false,   \"path of frame buffer device specification file\"},\n\t{\"mousewheelmode\", TYPE_INT32, false,  \"mouse wheel support mode (0=page up/down, 1=cursor up/down)\"},\n\t{\"mousewheellines\", TYPE_INT32, false, \"number of lines to scroll in mouse wheel mode 1\"},\n\t{\"dsp\", TYPE_STRING, false,            \"audio output (dsp) device name\"},\n\t{\"mixer\", TYPE_STRING, false,          \"audio mixer device name\"},\n#ifdef HAVE_SIGSEGV_SKIP_INSTRUCTION\n\t{\"ignoresegv\", TYPE_BOOLEAN, false,    \"ignore illegal memory accesses\"},\n#endif\n\t{\"idlewait\", TYPE_BOOLEAN, false,      \"sleep when idle\"},\n\t{NULL, TYPE_END, false, NULL} // End of list\n};\n\n\n// Prefs file name and path\nconst char PREFS_FILE_NAME[] = \".basilisk_ii_prefs\";\nstring UserPrefsPath;\nstatic string prefs_path;\n\n\n/*\n *  Load preferences from settings file\n */\n\nvoid LoadPrefs(const char *vmdir)\n{\n\tif (vmdir) {\n\t\tprefs_path = string(vmdir) + '/' + string(\"prefs\");\n\t\tFILE *prefs = fopen(prefs_path.c_str(), \"r\");\n\t\tif (!prefs) {\n\t\t\tprintf(\"No file at %s found.\\n\", prefs_path.c_str());\n\t\t\texit(1);\n\t\t}\n\t\tLoadPrefsFromStream(prefs);\n\t\tfclose(prefs);\n\t\treturn;\n\t}\n\n\t// Construct prefs path\n\tif (UserPrefsPath.empty()) {\n\t\tchar *home = getenv(\"HOME\");\n\t\tif (home)\n\t\t\tprefs_path = string(home) + '/';\n\t\tprefs_path += PREFS_FILE_NAME;\n\t} else\n\t\tprefs_path = UserPrefsPath;\n\n\t// Read preferences from settings file\n\tFILE *f = fopen(prefs_path.c_str(), \"r\");\n\tif (f != NULL) {\n\n\t\t// Prefs file found, load settings\n\t\tLoadPrefsFromStream(f);\n\t\tfclose(f);\n\n\t} else {\n\n\t\t// No prefs file, save defaults\n\t\tSavePrefs();\n\t}\n}\n\n\n/*\n *  Save preferences to settings file\n */\n\nvoid SavePrefs(void)\n{\n\tFILE *f;\n\tif ((f = fopen(prefs_path.c_str(), \"w\")) != NULL) {\n\t\tSavePrefsToStream(f);\n\t\tfclose(f);\n\t}\n}\n\n\n/*\n *  Add defaults of platform-specific prefs items\n *  You may also override the defaults set in PrefsInit()\n */\n\nvoid AddPlatformPrefsDefaults(void)\n{\n\tPrefsAddBool(\"keycodes\", false);\n\tPrefsReplaceString(\"extfs\", \"/\");\n\tPrefsReplaceInt32(\"mousewheelmode\", 1);\n\tPrefsReplaceInt32(\"mousewheellines\", 3);\n#ifdef __linux__\n\tif (access(\"/dev/sound/dsp\", F_OK) == 0) {\n\t\tPrefsReplaceString(\"dsp\", \"/dev/sound/dsp\");\n\t} else {\n\t\tPrefsReplaceString(\"dsp\", \"/dev/dsp\");\n\t}\n\tif (access(\"/dev/sound/mixer\", F_OK) == 0) {\n\t\tPrefsReplaceString(\"mixer\", \"/dev/sound/mixer\");\n\t} else {\n\t\tPrefsReplaceString(\"mixer\", \"/dev/mixer\");\n\t}\n#else\n\tPrefsReplaceString(\"dsp\", \"/dev/dsp\");\n\tPrefsReplaceString(\"mixer\", \"/dev/mixer\");\n#endif\n#ifdef HAVE_SIGSEGV_SKIP_INSTRUCTION\n\tPrefsAddBool(\"ignoresegv\", false);\n#endif\n\tPrefsAddBool(\"idlewait\", true);\n}\n","// -*- C++ -*-\n//===-------------------------- __string ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___STRING\n#define _LIBCPP___STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static constexpr void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static constexpr int    compare(const char_type* s1, const char_type* s2, size_t n);\n    static constexpr size_t length(const char_type* s);\n    static constexpr const char_type* \n                            find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <algorithm>  // for search and min\n#include <cstdio>     // For EOF.\n#include <memory>     // for __murmur2_or_cityhash\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TEMPLATE_VIS char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void _LIBCPP_CONSTEXPR_AFTER_CXX14\n        assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\n_LIBCPP_CONSTEXPR_AFTER_CXX14 int\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 size_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline\n_LIBCPP_CONSTEXPR_AFTER_CXX14 const _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static inline size_t _LIBCPP_CONSTEXPR_AFTER_CXX14\n    length(const char_type* __s)  _NOEXCEPT {return __builtin_strlen(__s);}\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*) memmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)memcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_memcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return memcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char*\nchar_traits<char>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return NULL;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_char_memchr(__s, to_int_type(__a), __n);\n#elif _LIBCPP_STD_VER <= 14\n    return (const char_type*) memchr(__s, to_int_type(__a), __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return NULL;\n#endif\n}\n\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t length(const char_type* __s) _NOEXCEPT;\n    static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {return __n == 0 ? __s1 : (char_type*)wmemmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return __n == 0 ? __s1 : (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n        {return __n == 0 ? __s : (char_type*)wmemset(__s, __a, __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<wchar_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    if (__n == 0)\n        return 0;\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wmemcmp(__s1, __s2, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemcmp(__s1, __s2, __n);\n#else\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<wchar_t>::length(const char_type* __s) _NOEXCEPT\n{\n#if __has_feature(cxx_constexpr_string_builtins)\n    return __builtin_wcslen(__s);\n#elif _LIBCPP_STD_VER <= 14\n    return wcslen(__s);\n#else\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n#endif\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst wchar_t*\nchar_traits<wchar_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    if (__n == 0)\n        return NULL;\n#if __has_feature(cxx_constexpr_string_builtins)\n        return __builtin_wmemchr(__s, __a, __n);\n#elif _LIBCPP_STD_VER <= 14\n    return wmemchr(__s, __a, __n);\n#else\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return NULL;\n#endif\n}\n\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char16_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TEMPLATE_VIS char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline _LIBCPP_CONSTEXPR_AFTER_CXX14\n    void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    size_t           length(const char_type* __s) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14\n    const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nsize_t\nchar_traits<char32_t>::length(const char_type* __s) _NOEXCEPT\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// helper fns for basic_string and string_view\n\n// __str_find\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n             _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos >= __sz)\n        return __npos;\n    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 const _CharT *\n__search_substring(const _CharT *__first1, const _CharT *__last1,\n                   const _CharT *__first2, const _CharT *__last2) {\n  // Take advantage of knowing source and pattern lengths.\n  // Stop short when source is smaller than pattern.\n  const ptrdiff_t __len2 = __last2 - __first2;\n  if (__len2 == 0)\n    return __first1;\n\n  ptrdiff_t __len1 = __last1 - __first1;\n  if (__len1 < __len2)\n    return __last1;\n\n  // First element of __first2 is loop invariant.\n  _CharT __f2 = *__first2;\n  while (true) {\n    __len1 = __last1 - __first1;\n    // Check whether __first1 still has at least __len2 bytes.\n    if (__len1 < __len2)\n      return __last1;\n\n    // Find __f2 the first byte matching in __first1.\n    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);\n    if (__first1 == 0)\n      return __last1;\n\n    // It is faster to compare from the first byte of __first1 even if we\n    // already know that it matches the first byte of __first2: this is because\n    // __first2 is most likely aligned, as it is user's \"pattern\" string, and\n    // __first1 + 1 is most likely not aligned, as the match is in the middle of\n    // the string.\n    if (_Traits::compare(__first1, __first2, __len2) == 0)\n      return __first1;\n\n    ++__first1;\n  }\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n       const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos > __sz)\n        return __npos;\n\n    if (__n == 0) // There is nothing to search, just return __pos.\n        return __pos;\n\n    const _CharT *__r = __search_substring<_CharT, _Traits>(\n        __p + __pos, __p + __sz, __s, __s + __n);\n\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_rfind\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n              _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__sz < 1)\n        return __npos;\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n    {\n        if (_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n        const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const _CharT* __r = _VSTD::__find_end(\n                  __p, __p + __pos, __s, __s + __n, _Traits::eq, \n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__n > 0 && __r == __p + __pos)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n// __str_find_first_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_of(const _CharT *__p, _SizeT __sz,\n                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos >= __sz || __n == 0)\n        return __npos;\n    const _CharT* __r = _VSTD::__find_first_of_ce\n        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_find_last_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_of(const _CharT *__p, _SizeT __sz,\n               const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n    {\n    if (__n != 0)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        {\n            const _CharT* __r = _Traits::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<_SizeT>(__ps - __p);\n        }\n    }\n    return __npos;\n}\n\n\n// __str_find_first_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (_Traits::find(__s, __n, *__ps) == 0)\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                          _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!_Traits::eq(*__ps, __c))\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\n// __str_find_last_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                   const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (_Traits::find(__s, __n, *--__ps) == 0)\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\ninline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                         _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (!_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\ntemplate<class _Ptr>\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\ntemplate <class _CharT, class _Iter, class _Traits=char_traits<_CharT> >\nstruct __quoted_output_proxy\n{\n    _Iter  __first;\n    _Iter  __last;\n    _CharT  __delim;\n    _CharT  __escape;\n\n    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)\n    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}\n    //  This would be a nice place for a string_ref \n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___STRING\n","/*\n *  disk.cpp - Generic disk driver\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/*\n *  SEE ALSO\n *    Inside Macintosh: Devices, chapter 1 \"Device Manager\"\n *    Technote DV 05: \"Drive Queue Elements\"\n *    Technote DV 23: \"Driver Education\"\n *    Technote FL 24: \"Don't Look at ioPosOffset for Devices\"\n */\n\n#include \"sysdeps.h\"\n\n#include <string.h>\n#include <vector>\n\n#ifndef NO_STD_NAMESPACE\nusing std::vector;\n#endif\n\n#include \"cpu_emulation.h\"\n#include \"main.h\"\n#include \"macos_util.h\"\n#include \"sys.h\"\n#include \"prefs.h\"\n#include \"disk.h\"\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n// .Disk Disk/drive icon\nconst uint8 DiskIcon[258] = {\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xfe,\n\t0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01,\n\t0x80, 0x00, 0x00, 0x01, 0x8c, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01,\n\t0x7f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xfe,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0x7f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\n\t0, 0\n};\n\n\n// Struct for each drive\nstruct disk_drive_info {\n\tdisk_drive_info() : num(0), fh(NULL), start_byte(0), read_only(false), status(0) {}\n\tdisk_drive_info(void *fh_, bool ro) : num(0), fh(fh_), read_only(ro), status(0) {}\n\n\tvoid close_fh(void) { Sys_close(fh); }\n\n\tint num;\t\t\t// Drive number\n\tvoid *fh;\t\t\t// File handle\n\tloff_t start_byte;\t// Start of HFS partition on disk\n\tuint32 num_blocks;\t// Size in 512-byte blocks\n\tbool to_be_mounted;\t// Flag: drive must be mounted in accRun\n\tbool read_only;\t\t// Flag: force write protection\n\tuint32 status;\t\t// Mac address of drive status record\n};\n\n// List of drives handled by this driver\ntypedef vector<disk_drive_info> drive_vec;\nstatic drive_vec drives;\n\n// Icon address (Mac address space, set by PatchROM())\nuint32 DiskIconAddr;\n\n// Flag: Control(accRun) has been called, interrupt routine is now active\nstatic bool acc_run_called = false;\n\n\n/*\n *  Get pointer to drive info or drives.end() if not found\n */\n\nstatic drive_vec::iterator get_drive_info(int num)\n{\n\tdrive_vec::iterator info, end = drives.end();\n\tfor (info = drives.begin(); info != end; ++info) {\n\t\tif (info->num == num)\n\t\t\treturn info;\n\t}\n\treturn info;\n}\n\n\n/*\n *  Find HFS partition, set info->start_byte and info->num_blocks\n *  (0 = no partition map or HFS partition found, assume flat disk image)\n */\n\nstatic void find_hfs_partition(disk_drive_info &info)\n{\n\tinfo.start_byte = 0;\n\tinfo.num_blocks = 0;\n\tuint8 *map = new uint8[512];\n\n\t// Search first 64 blocks for HFS partition\n\tfor (int i=0; i<64; i++) {\n\t\tif (Sys_read(info.fh, map, i * 512, 512) != 512)\n\t\t\tbreak;\n\n\t\t// Not a partition map block? Then look at next block\n\t\tuint16 sig = (map[0] << 8) | map[1];\n\t\tif (sig != 0x504d)\n\t\t\tcontinue;\n\n\t\t// Partition map block found, Apple HFS partition?\n\t\tif (strcmp((char *)(map + 48), \"Apple_HFS\") == 0) {\n\t\t\tinfo.start_byte = (loff_t)((map[8] << 24) | (map[9] << 16) | (map[10] << 8) | map[11]) << 9;\n\t\t\tinfo.num_blocks = (map[12] << 24) | (map[13] << 16) | (map[14] << 8) | map[15];\n\t\t\tD(bug(\" HFS partition found at %d, %d blocks\\n\", info.start_byte, info.num_blocks));\n\t\t\tbreak;\n\t\t}\n\t}\n\tdelete[] map;\n}\n\n\n/*\n *  Initialization\n */\n\nvoid DiskInit(void)\n{\n\t// No drives specified in prefs? Then add defaults\n\tif (PrefsFindString(\"disk\", 0) == NULL)\n\t\tSysAddDiskPrefs();\n\n\t// Add drives specified in preferences\n\tint index = 0;\n\tconst char *str;\n\twhile ((str = PrefsFindString(\"disk\", index++)) != NULL) {\n\t\tbool read_only = false;\n\t\tif (str[0] == '*') {\n\t\t\tread_only = true;\n\t\t\tstr++;\n\t\t}\n\t\tvoid *fh = Sys_open(str, read_only);\n\t\tif (fh)\n\t\t\tdrives.push_back(disk_drive_info(fh, SysIsReadOnly(fh)));\n\t}\n}\n\n\n/*\n *  Deinitialization\n */\n\nvoid DiskExit(void)\n{\n\tdrive_vec::iterator info, end = drives.end();\n\tfor (info = drives.begin(); info != end; ++info)\n\t\tinfo->close_fh();\n\tdrives.clear();\n}\n\n\n/*\n *  Disk was inserted, flag for mounting\n */\n\nbool DiskMountVolume(void *fh)\n{\n\tdrive_vec::iterator info = drives.begin(), end = drives.end();\n\twhile (info != end && info->fh != fh)\n\t\t++info;\n\tif (info != end) {\n\t\tif (SysIsDiskInserted(info->fh)) {\n\t\t\tinfo->read_only = SysIsReadOnly(info->fh);\n\t\t\tWriteMacInt8(info->status + dsDiskInPlace, 1);\t// Inserted removable disk\n\t\t\tWriteMacInt8(info->status + dsWriteProt, info->read_only ? 0xff : 0);\n\t\t\tfind_hfs_partition(*info);\n\t\t\tif (info->start_byte == 0)\n\t\t\t\tinfo->num_blocks = SysGetFileSize(info->fh) / 512;\n\t\t\tWriteMacInt16(info->status + dsDriveSize, info->num_blocks & 0xffff);\n\t\t\tWriteMacInt16(info->status + dsDriveS1, info->num_blocks >> 16);\n\t\t\tinfo->to_be_mounted = true;\n\t\t}\n\t\treturn true;\n\t} else\n\t\treturn false;\n}\n\n\n/*\n *  Mount volumes for which the to_be_mounted flag is set\n *  (called during interrupt time)\n */\n\nstatic void mount_mountable_volumes(void)\n{\n\tdrive_vec::iterator info, end = drives.end();\n\tfor (info = drives.begin(); info != end; ++info) {\n\n\t\t// Disk in drive?\n\t\tif (!ReadMacInt8(info->status + dsDiskInPlace)) {\n\n\t\t\t// No, check if disk was inserted\n\t\t\tif (SysIsDiskInserted(info->fh))\n\t\t\t\tDiskMountVolume(info->fh);\n\t\t}\n\n\t\t// Mount disk if flagged\n\t\tif (info->to_be_mounted) {\n\t\t\tD(bug(\" mounting drive %d\\n\", info->num));\n\t\t\tM68kRegisters r;\n\t\t\tr.d[0] = info->num;\n\t\t\tr.a[0] = 7;\t// diskEvent\n\t\t\tExecute68kTrap(0xa02f, &r);\t\t// PostEvent()\n\t\t\tinfo->to_be_mounted = false;\n\t\t}\n\t}\n}\n\n\n/*\n *  Driver Open() routine\n */\n\nint16 DiskOpen(uint32 pb, uint32 dce)\n{\n\tD(bug(\"DiskOpen\\n\"));\n\n\t// Set up DCE\n\tWriteMacInt32(dce + dCtlPosition, 0);\n\tacc_run_called = false;\n\n\t// Install drives\n\tdrive_vec::iterator info, end = drives.end();\n\tfor (info = drives.begin(); info != end; ++info) {\n\n\t\tinfo->num = FindFreeDriveNumber(1);\n\t\tinfo->to_be_mounted = false;\n\n\t\tif (info->fh) {\n\n\t\t\t// Allocate drive status record\n\t\t\tM68kRegisters r;\n\t\t\tr.d[0] = SIZEOF_DrvSts;\n\t\t\tExecute68kTrap(0xa71e, &r);\t\t// NewPtrSysClear()\n\t\t\tif (r.a[0] == 0)\n\t\t\t\tcontinue;\n\t\t\tinfo->status = r.a[0];\n\t\t\tD(bug(\" DrvSts at %08lx\\n\", info->status));\n\n\t\t\t// Set up drive status\n\t\t\tWriteMacInt16(info->status + dsQType, hard20);\n\t\t\tWriteMacInt8(info->status + dsInstalled, 1);\n\t\t\tbool disk_in_place = false;\n\t\t\tif (SysIsFixedDisk(info->fh)) {\n\t\t\t\tWriteMacInt8(info->status + dsDiskInPlace, 8);\t// Fixed disk\n\t\t\t\tdisk_in_place = true;\n\t\t\t} else if (SysIsDiskInserted(info->fh)) {\n\t\t\t\tWriteMacInt8(info->status + dsDiskInPlace, 1);\t// Inserted removable disk\n\t\t\t\tdisk_in_place = true;\n\t\t\t}\n\t\t\tif (disk_in_place) {\n\t\t\t\tD(bug(\" disk inserted\\n\"));\n\t\t\t\tWriteMacInt8(info->status + dsWriteProt, info->read_only ? 0x80 : 0);\n\t\t\t\tfind_hfs_partition(*info);\n\t\t\t\tif (info->start_byte == 0)\n\t\t\t\t\tinfo->num_blocks = SysGetFileSize(info->fh) / 512;\n\t\t\t\tinfo->to_be_mounted = true;\n\t\t\t}\n\t\t\tD(bug(\" %d blocks\\n\", info->num_blocks));\n\t\t\tWriteMacInt16(info->status + dsDriveSize, info->num_blocks & 0xffff);\n\t\t\tWriteMacInt16(info->status + dsDriveS1, info->num_blocks >> 16);\n\n\t\t\t// Add drive to drive queue\n\t\t\tD(bug(\" adding drive %d\\n\", info->num));\n\t\t\tr.d[0] = (info->num << 16) | (DiskRefNum & 0xffff);\n\t\t\tr.a[0] = info->status + dsQLink;\n\t\t\tExecute68kTrap(0xa04e, &r);\t// AddDrive()\n\t\t}\n\t}\n\treturn noErr;\n}\n\n\n/*\n *  Driver Prime() routine\n */\n\nint16 DiskPrime(uint32 pb, uint32 dce)\n{\n\tWriteMacInt32(pb + ioActCount, 0);\n\n\t// Drive valid and disk inserted?\n\tdrive_vec::iterator info = get_drive_info(ReadMacInt16(pb + ioVRefNum));\n\tif (info == drives.end())\n\t\treturn nsDrvErr;\n\tif (!ReadMacInt8(info->status + dsDiskInPlace))\n\t\treturn offLinErr;\n\n\t// Get parameters\n\tvoid *buffer = Mac2HostAddr(ReadMacInt32(pb + ioBuffer));\n\tsize_t length = ReadMacInt32(pb + ioReqCount);\n\tloff_t position = ReadMacInt32(dce + dCtlPosition);\n\tif (ReadMacInt16(pb + ioPosMode) & 0x100)\t// 64 bit positioning\n\t\tposition = ((loff_t)ReadMacInt32(pb + ioWPosOffset) << 32) | ReadMacInt32(pb + ioWPosOffset + 4);\n\tif ((length & 0x1ff) || (position & 0x1ff))\n\t\treturn paramErr;\n\n\tsize_t actual = 0;\n\tif ((ReadMacInt16(pb + ioTrap) & 0xff) == aRdCmd) {\n\n\t\t// Read\n\t\tactual = Sys_read(info->fh, buffer, position + info->start_byte, length);\n\t\tif (actual != length)\n\t\t\treturn readErr;\n\n\t} else {\n\n\t\t// Write\n\t\tif (info->read_only)\n\t\t\treturn wPrErr;\n\t\tactual = Sys_write(info->fh, buffer, position + info->start_byte, length);\n\t\tif (actual != length)\n\t\t\treturn writErr;\n\t}\n\n\t// Update ParamBlock and DCE\n\tWriteMacInt32(pb + ioActCount, actual);\n\tWriteMacInt32(dce + dCtlPosition, ReadMacInt32(dce + dCtlPosition) + actual);\n\treturn noErr;\n}\n\n\n/*\n *  Driver Control() routine\n */\n\nint16 DiskControl(uint32 pb, uint32 dce)\n{\n\tuint16 code = ReadMacInt16(pb + csCode);\n\tD(bug(\"DiskControl %d\\n\", code));\n\n\t// General codes\n\tswitch (code) {\n\t\tcase 1:\t\t// KillIO\n\t\t\treturn noErr;\n\n\t\tcase 65: {\t// Periodic action (accRun, \"insert\" disks on startup)\n\t\t\tmount_mountable_volumes();\n\t\t\tWriteMacInt16(dce + dCtlFlags, ReadMacInt16(dce + dCtlFlags) & ~0x2000);\t// Disable periodic action\n\t\t\tacc_run_called = true;\n\t\t\treturn noErr;\n\t\t}\n\t}\n\n\t// Drive valid?\n\tdrive_vec::iterator info = get_drive_info(ReadMacInt16(pb + ioVRefNum));\n\tif (info == drives.end())\n\t\treturn nsDrvErr;\n\n\t// Drive-specific codes\n\tswitch (code) {\n\t\tcase 5:\t\t// Verify disk\n\t\t\tif (ReadMacInt8(info->status + dsDiskInPlace) > 0)\n\t\t\t\treturn noErr;\n\t\t\telse\n\t\t\t\treturn offLinErr;\n\n\t\tcase 6:\t\t// Format disk\n\t\t\tif (info->read_only)\n\t\t\t\treturn wPrErr;\n\t\t\telse if (ReadMacInt8(info->status + dsDiskInPlace) > 0)\n\t\t\t\treturn noErr;\n\t\t\telse\n\t\t\t\treturn offLinErr;\n\n\t\tcase 7:\t\t// Eject disk\n\t\t\tif (ReadMacInt8(info->status + dsDiskInPlace) == 8) {\n\t\t\t\t// Fixed disk, re-insert\n\t\t\t\tM68kRegisters r;\n\t\t\t\tr.d[0] = info->num;\n\t\t\t\tr.a[0] = 7;\t// diskEvent\n\t\t\t\tExecute68kTrap(0xa02f, &r);\t\t// PostEvent()\n\t\t\t} else if (ReadMacInt8(info->status + dsDiskInPlace) > 0) {\n\t\t\t\tSysEject(info->fh);\n\t\t\t\tWriteMacInt8(info->status + dsDiskInPlace, 0);\n\t\t\t}\n\t\t\treturn noErr;\n\n\t\tcase 21:\t// Get drive icon\n\t\tcase 22:\t// Get disk icon\n\t\t\tWriteMacInt32(pb + csParam, DiskIconAddr);\n\t\t\treturn noErr;\n\n\t\tcase 23:\t// Get drive info\n\t\t\tif (ReadMacInt8(info->status + dsDiskInPlace) == 8)\n\t\t\t\tWriteMacInt32(pb + csParam, 0x0601);\t// Unspecified fixed SCSI disk\n\t\t\telse\n\t\t\t\tWriteMacInt32(pb + csParam, 0x0201);\t// Unspecified SCSI disk\n\t\t\treturn noErr;\n\n\t\tcase 24:\t// Get partition size\n\t\t\tif (ReadMacInt8(info->status + dsDiskInPlace) > 0) {\n\t\t\t\tWriteMacInt32(pb + csParam, info->num_blocks);\n\t\t\t\treturn noErr;\n\t\t\t} else\n\t\t\t\treturn offLinErr;\n\n\t\tdefault:\n\t\t\tprintf(\"WARNING: Unknown DiskControl(%d)\\n\", code);\n\t\t\treturn controlErr;\n\t}\n}\n\n\n/*\n *  Driver Status() routine\n */\n\nint16 DiskStatus(uint32 pb, uint32 dce)\n{\n\tdrive_vec::iterator info = get_drive_info(ReadMacInt16(pb + ioVRefNum));\n\tuint16 code = ReadMacInt16(pb + csCode);\n\tD(bug(\"DiskStatus %d\\n\", code));\n\n\t// General codes (we can get these even if the drive was invalid)\n\tswitch (code) {\n\t\tcase 43: {\t// Driver gestalt\n\t\t\tuint32 sel = ReadMacInt32(pb + csParam);\n\t\t\tD(bug(\" driver gestalt %c%c%c%c\\n\", sel >> 24, sel >> 16,  sel >> 8, sel));\n\t\t\tswitch (sel) {\n\t\t\t\tcase FOURCC('v','e','r','s'):\t// Version\n\t\t\t\t\tWriteMacInt32(pb + csParam + 4, 0x01008000);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOURCC('d','e','v','t'):\t// Device type\n\t\t\t\t\tif (info != drives.end()) {\n\t\t\t\t\t\tif (ReadMacInt8(info->status + dsDiskInPlace) == 8)\n\t\t\t\t\t\t\tWriteMacInt32(pb + csParam + 4, FOURCC('d','i','s','k'));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tWriteMacInt32(pb + csParam + 4, FOURCC('r','d','s','k'));\n\t\t\t\t\t} else\n\t\t\t\t\t\tWriteMacInt32(pb + csParam + 4, FOURCC('d','i','s','k'));\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOURCC('i','n','t','f'):\t// Interface type\n\t\t\t\t\tWriteMacInt32(pb + csParam + 4, EMULATOR_ID_4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOURCC('s','y','n','c'):\t// Only synchronous operation?\n\t\t\t\t\tWriteMacInt32(pb + csParam + 4, 0x01000000);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOURCC('b','o','o','t'):\t// Boot ID\n\t\t\t\t\tif (info != drives.end())\n\t\t\t\t\t\tWriteMacInt16(pb + csParam + 4, info->num);\n\t\t\t\t\telse\n\t\t\t\t\t\tWriteMacInt16(pb + csParam + 4, 0);\n\t\t\t\t\tWriteMacInt16(pb + csParam + 6, (uint16)DiskRefNum);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOURCC('w','i','d','e'):\t// 64-bit access supported?\n\t\t\t\t\tWriteMacInt16(pb + csParam + 4, 0x0100);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOURCC('p','u','r','g'):\t// Purge flags\n\t\t\t\t\tWriteMacInt32(pb + csParam + 4, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOURCC('e','j','e','c'):\t// Eject flags\n\t\t\t\t\tWriteMacInt32(pb + csParam + 4, 0x00030003);\t// Don't eject on shutdown/restart\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOURCC('f','l','u','s'):\t// Flush flags\n\t\t\t\t\tWriteMacInt16(pb + csParam + 4, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOURCC('v','m','o','p'):\t// Virtual memory attributes\n\t\t\t\t\tWriteMacInt32(pb + csParam + 4, 0);\t// Drive not available for VM\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn statusErr;\n\t\t\t}\n\t\t\treturn noErr;\n\t\t}\n\t}\n\n\t// Drive valid?\n\tif (info == drives.end())\n\t\treturn nsDrvErr;\n\n\t// Drive-specific codes\n\tswitch (code) {\n\t\tcase 8:\t\t// Get drive status\n\t\t\tMac2Mac_memcpy(pb + csParam, info->status, 22);\n\t\t\treturn noErr;\n\n\t\tcase 44: // get startup partition status: http://developer.apple.com/documentation/Hardware/DeviceManagers/ata/ata_ref/ATA.21.html\n\t\t\tprintf(\"WARNING: DiskStatus(44:'get startup partition status') Not Implemented\\n\");\n\t\t\treturn statusErr;\n\n\t\tcase 45: // get partition write protect status: http://developer.apple.com/documentation/Hardware/DeviceManagers/ata/ata_ref/ATA.23.html\n\t\t\tprintf(\"WARNING: DiskStatus(45:'get partition write protect status') Not Implemented\\n\");\n\t\t\treturn statusErr;\n\n\t\tcase 46: // get partition mount status: http://developer.apple.com/documentation/Hardware/DeviceManagers/ata/ata_ref/ATA.22.html\n\t\t\tprintf(\"WARNING: DiskStatus(46:'get partition mount status') Not Implemented\\n\");\n\t\t\treturn statusErr;\n\n\t\tcase 70: // get power mode status: http://developer.apple.com/documentation/Hardware/DeviceManagers/ata/ata_ref/ATA.24.html\n\t\t\tprintf(\"WARNING: DiskStatus(70:'get power mode status') Not Implemented\\n\");\n\t\t\treturn statusErr;\n\n\t\tdefault:\n\t\t\tprintf(\"WARNING: Unknown DiskStatus(%d)\\n\", code);\n\t\t\treturn statusErr;\n\t}\n}\n\n\n/*\n *  Driver interrupt routine (1Hz) - check for volumes to be mounted\n */\n\nvoid DiskInterrupt(void)\n{\n\tif (!acc_run_called)\n\t\treturn;\n\n\tmount_mountable_volumes();\n}\n","/*\n *  sony.cpp - Replacement .Sony driver (floppy drives)\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/*\n *  SEE ALSO\n *    Inside Macintosh: Devices, chapter 1 \"Device Manager\"\n *    Technote DV 05: \"Drive Queue Elements\"\n *    Technote DV 07: \"Forcing Floppy Disk Size to be Either 400K or 800K\"\n *    Technote DV 17: \"Sony Driver: What Your Sony Drives For You\"\n *    Technote DV 23: \"Driver Education\"\n *    Technote FL 24: \"Don't Look at ioPosOffset for Devices\"\n */\n\n#include \"sysdeps.h\"\n\n#include <string.h>\n#include <vector>\n\n#ifndef NO_STD_NAMESPACE\nusing std::vector;\n#endif\n\n#include \"cpu_emulation.h\"\n#include \"main.h\"\n#include \"macos_util.h\"\n#include \"rom_patches.h\"\n#include \"sys.h\"\n#include \"prefs.h\"\n#include \"sony.h\"\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n// Check for inserted disks by polling?\n#ifdef AMIGA\n#define DISK_INSERT_CHECK 1\n#else\n#define DISK_INSERT_CHECK 0\n#endif\n\n\n// Floppy disk icon\nconst uint8 SonyDiskIcon[258] = {\n\t0x7f, 0xff, 0xff, 0xf8, 0x81, 0x00, 0x01, 0x04, 0x81, 0x00, 0x71, 0x02, 0x81, 0x00, 0x89, 0x01,\n\t0x81, 0x00, 0x89, 0x01, 0x81, 0x00, 0x89, 0x01, 0x81, 0x00, 0x89, 0x01, 0x81, 0x00, 0x89, 0x01,\n\t0x81, 0x00, 0x71, 0x01, 0x81, 0x00, 0x01, 0x01, 0x80, 0xff, 0xfe, 0x01, 0x80, 0x00, 0x00, 0x01,\n\t0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01,\n\t0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x87, 0xff, 0xff, 0xe1, 0x88, 0x00, 0x00, 0x11,\n\t0x88, 0x00, 0x00, 0x11, 0x88, 0x00, 0x00, 0x11, 0x88, 0x00, 0x00, 0x11, 0x88, 0x00, 0x00, 0x11,\n\t0x88, 0x00, 0x00, 0x11, 0x88, 0x00, 0x00, 0x11, 0x88, 0x00, 0x00, 0x11, 0x88, 0x00, 0x00, 0x11,\n\t0x88, 0x00, 0x00, 0x11, 0x88, 0x00, 0x00, 0x11, 0x88, 0x00, 0x00, 0x11, 0x7f, 0xff, 0xff, 0xfe,\n\n\t0x7f, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xfe,\n\n\t0, 0\n};\n\n// Floppy drive icon\nconst uint8 SonyDriveIcon[258] = {\n\t0x7f, 0xff, 0xff, 0xf8, 0x81, 0x00, 0x01, 0x04, 0x81, 0x00, 0x71, 0x02, 0x81, 0x00, 0x89, 0x01,\n\t0x81, 0x00, 0x89, 0x01, 0x81, 0x00, 0x89, 0x01, 0x81, 0x00, 0x89, 0x01, 0x81, 0x00, 0x89, 0x01,\n\t0x81, 0x00, 0x71, 0x01, 0x81, 0x00, 0x01, 0x01, 0x80, 0xff, 0xfe, 0x01, 0x80, 0x00, 0x00, 0x01,\n\t0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01,\n\t0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x87, 0xff, 0xff, 0xe1, 0x88, 0x00, 0x00, 0x11,\n\t0x88, 0x00, 0x00, 0x11, 0x88, 0x00, 0x00, 0x11, 0x88, 0x00, 0x00, 0x11, 0x88, 0x00, 0x00, 0x11,\n\t0x88, 0x00, 0x00, 0x11, 0x88, 0x00, 0x00, 0x11, 0x88, 0x00, 0x00, 0x11, 0x88, 0x00, 0x00, 0x11,\n\t0x88, 0x00, 0x00, 0x11, 0x88, 0x00, 0x00, 0x11, 0x88, 0x00, 0x00, 0x11, 0x7f, 0xff, 0xff, 0xfe,\n\n\t0x7f, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xfe,\n\n\t0, 0\n};\n\n\n// Struct for each drive\nstruct sony_drive_info {\n\tsony_drive_info() : num(0), fh(NULL), read_only(false), status(0) {}\n\tsony_drive_info(void *fh_, bool ro) : num(0), fh(fh_), read_only(ro), status(0) {}\n\n\tvoid close_fh(void) { Sys_close(fh); }\n\n\tint num;\t\t\t// Drive number\n\tvoid *fh;\t\t\t// Floppy driver file handle\n\tbool to_be_mounted;\t// Flag: drive must be mounted in accRun\n\tbool read_only;\t\t// Flag: force write protection\n\tuint32 status;\t\t// Mac address of drive status record\n};\n\n// List of drives handled by this driver\ntypedef vector<sony_drive_info> drive_vec;\nstatic drive_vec drives;\n\n// Icon addresses (Mac address space, set by PatchROM())\nuint32 SonyDiskIconAddr;\nuint32 SonyDriveIconAddr;\n\n// Flag: Control(accRun) has been called, interrupt routine is now active\nstatic bool acc_run_called = false;\n\n\n/*\n *  Get reference to drive info or drives.end() if not found\n */\n\nstatic drive_vec::iterator get_drive_info(int num)\n{\n\tdrive_vec::iterator info, end = drives.end();\n\tfor (info = drives.begin(); info != end; ++info) {\n\t\tif (info->num == num)\n\t\t\treturn info;\n\t}\n\treturn info;\n}\n\n\n/*\n *  Initialization\n */\n\nvoid SonyInit(void)\n{\n\t// No drives specified in prefs? Then add defaults\n\tif (PrefsFindString(\"floppy\", 0) == NULL)\n\t\tSysAddFloppyPrefs();\n\n\t// Add drives specified in preferences\n\tint index = 0;\n\tconst char *str;\n\twhile ((str = PrefsFindString(\"floppy\", index++)) != NULL) {\n\t\tbool read_only = false;\n\t\tif (str[0] == '*') {\n\t\t\tread_only = true;\n\t\t\tstr++;\n\t\t}\n\t\tvoid *fh = Sys_open(str, read_only);\n\t\tif (fh)\n\t\t\tdrives.push_back(sony_drive_info(fh, SysIsReadOnly(fh)));\n\t}\n}\n\n\n/*\n *  Deinitialization\n */\n\nvoid SonyExit(void)\n{\n\tdrive_vec::iterator info, end = drives.end();\n\tfor (info = drives.begin(); info != end; ++info)\n\t\tinfo->close_fh();\n\tdrives.clear();\n}\n\n\n/*\n *  Disk was inserted, flag for mounting\n */\n\nbool SonyMountVolume(void *fh)\n{\n\tdrive_vec::iterator info = drives.begin(), end = drives.end();\n\twhile (info != end && info->fh != fh)\n\t\t++info;\n\tif (info != end) {\n\t\tD(bug(\"Looking for disk in drive %d\\n\", info->num));\n\t\tif (SysIsDiskInserted(info->fh)) {\n\t\t\tinfo->read_only = SysIsReadOnly(info->fh);\n\t\t\tWriteMacInt8(info->status + dsDiskInPlace, 1);\t// Inserted removable disk\n\t\t\tWriteMacInt8(info->status + dsWriteProt, info->read_only ? 0xff : 0);\n\t\t\tD(bug(\" disk inserted, mounting\\n\"));\n\t\t\tinfo->to_be_mounted = true;\n\t\t}\n\t\treturn true;\n\t} else\n\t\treturn false;\n}\n\n\n/*\n *  Mount volumes for which the to_be_mounted flag is set\n *  (called during interrupt time)\n */\n\nstatic void mount_mountable_volumes(void)\n{\n\tdrive_vec::iterator info, end = drives.end();\n\tfor (info = drives.begin(); info != end; ++info) {\n\n#if DISK_INSERT_CHECK\n\t\t// Disk in drive?\n\t\tif (ReadMacInt8(info->status + dsDiskInPlace) == 0) {\n\n\t\t\t// No, check if disk was inserted\n\t\t\tif (SysIsDiskInserted(info->fh))\n\t\t\t\tSonyMountVolume(info->fh);\n\t\t}\n#endif\n\n\t\t// Mount disk if flagged\n\t\tif (info->to_be_mounted) {\n\t\t\tD(bug(\" mounting drive %d\\n\", info->num));\n\t\t\tM68kRegisters r;\n\t\t\tr.d[0] = info->num;\n\t\t\tr.a[0] = 7;\t// diskEvent\n\t\t\tExecute68kTrap(0xa02f, &r);\t\t// PostEvent()\n\t\t\tinfo->to_be_mounted = false;\n\t\t}\n\t}\n}\n\n\n/*\n *  Set error code in DskErr\n */\n\nstatic int16 set_dsk_err(int16 err)\n{\n\tD(bug(\"set_dsk_err(%d)\\n\", err));\n\tWriteMacInt16(0x142, err);\n\treturn err;\n}\n\n\n/*\n *  Driver Open() routine\n */\n\nint16 SonyOpen(uint32 pb, uint32 dce)\n{\n\tD(bug(\"SonyOpen\\n\"));\n\n\t// Set up DCE\n\tWriteMacInt32(dce + dCtlPosition, 0);\n\tWriteMacInt16(dce + dCtlQHdr + qFlags, ReadMacInt16(dce + dCtlQHdr + qFlags) & 0xff00 | 3);\t// Version number, must be >=3 or System 8 will replace us\n\tacc_run_called = false;\n\n\t// Install driver again with refnum -2 (HD20)\n\tuint32 utab = ReadMacInt32(0x11c);\n\tWriteMacInt32(utab + 4, ReadMacInt32(utab + 16));\n\n\t// Set up fake SonyVars\n\tWriteMacInt32(0x134, 0xdeadbeef);\n\n\t// Clear DskErr\n\tset_dsk_err(0);\n\n\t// Install drives\n\tdrive_vec::iterator info, end = drives.end();\n\tfor (info = drives.begin(); info != end; ++info) {\n\n\t\tinfo->num = FindFreeDriveNumber(1);\n\t\tinfo->to_be_mounted = false;\n\n\t\tif (info->fh) {\n\n\t\t\t// Allocate drive status record\n\t\t\tM68kRegisters r;\n\t\t\tr.d[0] = SIZEOF_DrvSts;\n\t\t\tExecute68kTrap(0xa71e, &r);\t\t// NewPtrSysClear()\n\t\t\tif (r.a[0] == 0)\n\t\t\t\tcontinue;\n\t\t\tinfo->status = r.a[0];\n\t\t\tD(bug(\" DrvSts at %08lx\\n\", info->status));\n\n\t\t\t// Set up drive status\n\t\t\tWriteMacInt16(info->status + dsQType, sony);\n\t\t\tWriteMacInt8(info->status + dsInstalled, 1);\n\t\t\tWriteMacInt8(info->status + dsSides, 0xff);\n\t\t\tWriteMacInt8(info->status + dsTwoSideFmt, 0xff);\n\t\t\tWriteMacInt8(info->status + dsNewIntf, 0xff);\n\t\t\tWriteMacInt8(info->status + dsMFMDrive, 0xff);\t// SuperDrive (0 = 400/800K GCR drive)\n\t\t\tWriteMacInt8(info->status + dsMFMDisk, 0xff);\t// MFM (0 = GCR)\n\t\t\tWriteMacInt8(info->status + dsTwoMegFmt, 0xff);\t// 1.44MB (0 = 720K)\n\n\t\t\t// Disk in drive?\n\t\t\tif (SysIsDiskInserted(info->fh)) {\n\t\t\t\tWriteMacInt8(info->status + dsDiskInPlace, 1);\t// Inserted removable disk\n\t\t\t\tWriteMacInt8(info->status + dsWriteProt, info->read_only ? 0xff : 0);\n\t\t\t\tD(bug(\" disk inserted, flagging for mount\\n\"));\n\t\t\t\tinfo->to_be_mounted = true;\n\t\t\t}\n\n\t\t\t// Add drive to drive queue\n\t\t\tD(bug(\" adding drive %d\\n\", info->num));\n\t\t\tr.d[0] = (info->num << 16) | (SonyRefNum & 0xffff);\n\t\t\tr.a[0] = info->status + dsQLink;\n\t\t\tExecute68kTrap(0xa04e, &r);\t// AddDrive()\n\t\t}\n\t}\n\treturn noErr;\n}\n\n\n/*\n *  Driver Prime() routine\n */\n\nint16 SonyPrime(uint32 pb, uint32 dce)\n{\n\tWriteMacInt32(pb + ioActCount, 0);\n\n\t// Drive valid and disk inserted?\n\tdrive_vec::iterator info = get_drive_info(ReadMacInt16(pb + ioVRefNum));\n\tif (info == drives.end())\n\t\treturn set_dsk_err(nsDrvErr);\n\tif (!ReadMacInt8(info->status + dsDiskInPlace))\n\t\treturn set_dsk_err(offLinErr);\n\tWriteMacInt8(info->status + dsDiskInPlace, 2);\t// Disk accessed\n\n\t// Get parameters\n\tvoid *buffer = Mac2HostAddr(ReadMacInt32(pb + ioBuffer));\n\tsize_t length = ReadMacInt32(pb + ioReqCount);\n\tloff_t position = ReadMacInt32(dce + dCtlPosition);\n\tif ((length & 0x1ff) || (position & 0x1ff))\n\t\treturn set_dsk_err(paramErr);\n\n\tsize_t actual = 0;\n\tif ((ReadMacInt16(pb + ioTrap) & 0xff) == aRdCmd) {\n\n\t\t// Read\n\t\tactual = Sys_read(info->fh, buffer, position, length);\n\t\tif (actual != length)\n\t\t\treturn set_dsk_err(readErr);\n\n\t\t// Clear TagBuf\n\t\tWriteMacInt32(0x2fc, 0);\n\t\tWriteMacInt32(0x300, 0);\n\t\tWriteMacInt32(0x304, 0);\n\n\t} else {\n\n\t\t// Write\n\t\tif (info->read_only)\n\t\t\treturn set_dsk_err(wPrErr);\n\t\tactual = Sys_write(info->fh, buffer, position, length);\n\t\tif (actual != length)\n\t\t\treturn set_dsk_err(writErr);\n\t}\n\n\t// Update ParamBlock and DCE\n\tWriteMacInt32(pb + ioActCount, actual);\n\tWriteMacInt32(dce + dCtlPosition, ReadMacInt32(dce + dCtlPosition) + actual);\n\treturn set_dsk_err(noErr);\n}\n\n\n/*\n *  Driver Control() routine\n */\n\nint16 SonyControl(uint32 pb, uint32 dce)\n{\n\tuint16 code = ReadMacInt16(pb + csCode);\n\tD(bug(\"SonyControl %d\\n\", code));\n\n\t// General codes\n\tswitch (code) {\n\t\tcase 1:\t\t// KillIO (not supported)\n\t\t\treturn set_dsk_err(-1);\n\n\t\tcase 9:\t\t// Track cache control (ignore, assume that host OS does the caching)\n\t\t\treturn set_dsk_err(noErr);\n\n\t\tcase 65:\t// Periodic action (accRun, \"insert\" disks on startup)\n\t\t\tmount_mountable_volumes();\n\t\t\tPatchAfterStartup();\t\t// Install patches after system startup\n\t\t\tWriteMacInt16(dce + dCtlFlags, ReadMacInt16(dce + dCtlFlags) & ~0x2000);\t// Disable periodic action\n\t\t\tacc_run_called = true;\n\t\t\treturn noErr;\n\t}\n\n\t// Drive valid?\n\tdrive_vec::iterator info = get_drive_info(ReadMacInt16(pb + ioVRefNum));\n\tif (info == drives.end())\n\t\treturn set_dsk_err(nsDrvErr);\n\n\t// Drive-specific codes\n\tint16 err = noErr;\n\tswitch (code) {\n\t\tcase 5:\t\t\t// Verify disk\n\t\t\tif (ReadMacInt8(info->status + dsDiskInPlace) <= 0) {\n\t\t\t\terr = offLinErr;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 6:\t\t\t// Format disk\n\t\t\tif (info->read_only) {\n\t\t\t\terr = wPrErr;\n\t\t\t} else if (ReadMacInt8(info->status + dsDiskInPlace) > 0) {\n\t\t\t\tif (!SysFormat(info->fh))\n\t\t\t\t\terr = writErr;\n\t\t\t} else\n\t\t\t\terr = offLinErr;\n\t\t\tbreak;\n\n\t\tcase 7:\t\t\t// Eject\n\t\t\tif (ReadMacInt8(info->status + dsDiskInPlace) > 0) {\n\t\t\t\tSysEject(info->fh);\n\t\t\t\tWriteMacInt8(info->status + dsDiskInPlace, 0);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 8:\t\t\t// Set tag buffer (ignore, not supported)\n\t\t\tbreak;\n\n\t\tcase 21:\t\t// Get drive icon\n\t\t\tWriteMacInt32(pb + csParam, SonyDriveIconAddr);\n\t\t\tbreak;\n\n\t\tcase 22:\t\t// Get disk icon\n\t\t\tWriteMacInt32(pb + csParam, SonyDiskIconAddr);\n\t\t\tbreak;\n\n\t\tcase 23:\t\t// Get drive info\n\t\t\tif (info->num == 1) {\n\t\t\t\tWriteMacInt32(pb + csParam, 0x0004);\t// Internal SuperDrive\n\t\t\t} else {\n\t\t\t\tWriteMacInt32(pb + csParam, 0x0104);\t// External SuperDrive\n\t\t\t}\n\t\t\tbreak;\n\n//\t\tcase 0x4350:\t// Enable/disable retries ('CP') (not supported)\n//\t\t\tbreak;\n\n//\t\tcase 0x4744:\t// Get raw track data ('GD') (not supported)\n//\t\t\tbreak;\n\n\t\tcase 0x5343:\t// Format and write to disk ('SC') in one pass, used by DiskCopy to speed things up\n\t\t\tif (!ReadMacInt8(info->status + dsDiskInPlace)) {\n\t\t\t\terr = offLinErr;\n\t\t\t} else if (info->read_only) {\n\t\t\t\terr = wPrErr;\n\t\t\t} else {\n\t\t\t\t// Assume that the disk is already formatted and only write the data\n\t\t\t\tvoid *data = Mac2HostAddr(ReadMacInt32(pb + csParam + 2));\n\t\t\t\tsize_t actual = Sys_write(info->fh, data, 0, 2880*512);\n\t\t\t\tif (actual != 2880*512)\n\t\t\t\t\terr = writErr;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"WARNING: Unknown SonyControl(%d)\\n\", code);\n\t\t\terr = controlErr;\n\t\t\tbreak;\n\t}\n\n\treturn set_dsk_err(err);\n}\n\n\n/*\n *  Driver Status() routine\n */\n\nint16 SonyStatus(uint32 pb, uint32 dce)\n{\n\tuint16 code = ReadMacInt16(pb + csCode);\n\tD(bug(\"SonyStatus %d\\n\", code));\n\n\t// Drive valid?\n\tdrive_vec::iterator info = get_drive_info(ReadMacInt16(pb + ioVRefNum));\n\tif (info == drives.end())\n\t\treturn set_dsk_err(nsDrvErr);\n\n\tint16 err = noErr;\n\tswitch (code) {\n\t\tcase 6:\t\t\t// Return list of supported disk formats\n\t\t\tif (ReadMacInt16(pb + csParam) > 0) {\t// At least one entry requested?\n\t\t\t\tuint32 adr = ReadMacInt32(pb + csParam + 2);\n\t\t\t\tWriteMacInt16(pb + csParam, 1);\t\t// 1 format supported\n\t\t\t\tWriteMacInt32(adr, 2880);\t\t\t// 2880 sectors\n\t\t\t\tWriteMacInt32(adr + 4, 0xd2120050);\t// DD, 2 heads, 18 secs/track, 80 tracks\n\n\t\t\t\t// Upper byte of format flags:\n\t\t\t\t//  bit #7: number of tracks, sectors, and heads is valid\n\t\t\t\t//  bit #6: current disk has this format\n\t\t\t\t//  bit #5: <unused>\n\t\t\t\t//  bit #4: double density\n\t\t\t\t//  bits #3..#0: number of heads\n\t\t\t} else {\n\t\t\t\terr = paramErr;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 8:\t\t\t// Get drive status\n\t\t\tMac2Mac_memcpy(pb + csParam, info->status, 22);\n\t\t\tbreak;\n\n\t\tcase 10:\t\t// Get disk type and MFM info\n\t\t\tWriteMacInt32(pb + csParam, ReadMacInt32(info->status + dsMFMDrive) & 0xffffff00 | 0xfe);\t// 0xfe = SWIM2 controller\n\t\t\tbreak;\n\n//\t\tcase 0x4350:\t// Measure disk speed at a given track ('CP') (not supported)\n//\t\t\tbreak;\n\n\t\tcase 0x4456:\t// Duplicator (DiskCopy) version supported ('DV'), enables the 'SC' control code above\n\t\t\tWriteMacInt16(pb + csParam, 0x0410);\t// Version 4.1 and later\n\t\t\tbreak;\n\n//\t\tcase 0x5250:\t// Get floppy info record ('RP') (not supported)\n//\t\t\tbreak;\n\n\t\tcase 0x5343:\t// Get address header format byte ('SC')\n\t\t\tWriteMacInt8(pb + csParam, 0x02);\t// 500 kbit/s (HD) MFM\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"WARNING: Unknown SonyStatus(%d)\\n\", code);\n\t\t\terr = statusErr;\n\t\t\tbreak;\n\t}\n\n\treturn set_dsk_err(err);\n}\n\n\n/*\n *  Driver interrupt routine (1Hz) - check for volumes to be mounted\n */\n\nvoid SonyInterrupt(void)\n{\n\tif (!acc_run_called)\n\t\treturn;\n\n\tmount_mountable_volumes();\n}\n","/*\n *  adb.cpp - ADB emulation (mouse/keyboard)\n *\n *  Basilisk II (C) Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/*\n *  SEE ALSO\n *    Inside Macintosh: Devices, chapter 5 \"ADB Manager\"\n *    Technote HW 01: \"ADB - The Untold Story: Space Aliens Ate My Mouse\"\n */\n\n#include <stdlib.h>\n\n#include \"sysdeps.h\"\n#include \"cpu_emulation.h\"\n#include \"emul_op.h\"\n#include \"main.h\"\n#include \"prefs.h\"\n#include \"video.h\"\n#include \"adb.h\"\n\n#ifdef POWERPC_ROM\n#include \"thunks.h\"\n#endif\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n// Global variables\nstatic int mouse_x = 0, mouse_y = 0;\t\t\t\t\t\t\t// Mouse position\nstatic int old_mouse_x = 0, old_mouse_y = 0;\nstatic bool mouse_button[3] = {false, false, false};\t\t\t// Mouse button states\nstatic bool old_mouse_button[3] = {false, false, false};\nstatic bool relative_mouse = false;\n\nstatic uint8 key_states[16];\t\t\t\t// Key states (Mac keycodes)\n#define MATRIX(code) (key_states[code >> 3] & (1 << (~code & 7)))\n\n// Keyboard event buffer (Mac keycodes with up/down flag)\nconst int KEY_BUFFER_SIZE = 16;\nstatic uint8 key_buffer[KEY_BUFFER_SIZE];\nstatic unsigned int key_read_ptr = 0, key_write_ptr = 0;\n\nstatic uint8 mouse_reg_3[2] = {0x63, 0x01};\t// Mouse ADB register 3\n\nstatic uint8 key_reg_2[2] = {0xff, 0xff};\t// Keyboard ADB register 2\nstatic uint8 key_reg_3[2] = {0x62, 0x05};\t// Keyboard ADB register 3\n\nstatic uint8 m_keyboard_type = 0x05;\n\n// ADB mouse motion lock (for platforms that use separate input thread)\nstatic B2_mutex *mouse_lock;\n\n\n/*\n *  Initialize ADB emulation\n */\n\nvoid ADBInit(void)\n{\n\tmouse_lock = B2_create_mutex();\n\tm_keyboard_type = (uint8)PrefsFindInt32(\"keyboardtype\");\n\tkey_reg_3[1] = m_keyboard_type;\n}\n\n\n/*\n *  Exit ADB emulation\n */\n\nvoid ADBExit(void)\n{\n\tif (mouse_lock) {\n\t\tB2_delete_mutex(mouse_lock);\n\t\tmouse_lock = NULL;\n\t}\n}\n\n\n/*\n *  ADBOp() replacement\n */\n\nvoid ADBOp(uint8 op, uint8 *data)\n{\n\tD(bug(\"ADBOp op %02x, data %02x %02x %02x\\n\", op, data[0], data[1], data[2]));\n\n\t// ADB reset?\n\tif ((op & 0x0f) == 0) {\n\t\tmouse_reg_3[0] = 0x63;\n\t\tmouse_reg_3[1] = 0x01;\n\t\tkey_reg_2[0] = 0xff;\n\t\tkey_reg_2[1] = 0xff;\n\t\tkey_reg_3[0] = 0x62;\n\t\tkey_reg_3[1] = m_keyboard_type;\n\t\treturn;\n\t}\n\n\t// Cut op into fields\n\tuint8 adr = op >> 4;\n\tuint8 cmd = (op >> 2) & 3;\n\tuint8 reg = op & 3;\n\n\t// Check which device was addressed and act accordingly\n\tif (adr == (mouse_reg_3[0] & 0x0f)) {\n\n\t\t// Mouse\n\t\tif (cmd == 2) {\n\n\t\t\t// Listen\n\t\t\tswitch (reg) {\n\t\t\t\tcase 3:\t\t// Address/HandlerID\n\t\t\t\t\tif (data[2] == 0xfe)\t\t\t// Change address\n\t\t\t\t\t\tmouse_reg_3[0] = (mouse_reg_3[0] & 0xf0) | (data[1] & 0x0f);\n\t\t\t\t\telse if (data[2] == 1 || data[2] == 2 || data[2] == 4)\t// Change device handler ID\n\t\t\t\t\t\tmouse_reg_3[1] = data[2];\n\t\t\t\t\telse if (data[2] == 0x00)\t\t// Change address and enable bit\n\t\t\t\t\t\tmouse_reg_3[0] = (mouse_reg_3[0] & 0xd0) | (data[1] & 0x2f);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else if (cmd == 3) {\n\n\t\t\t// Talk\n\t\t\tswitch (reg) {\n\t\t\t\tcase 1:\t\t// Extended mouse protocol\n\t\t\t\t\tdata[0] = 8;\n\t\t\t\t\tdata[1] = 'a';\t\t\t\t// Identifier\n\t\t\t\t\tdata[2] = 'p';\n\t\t\t\t\tdata[3] = 'p';\n\t\t\t\t\tdata[4] = 'l';\n\t\t\t\t\tdata[5] = 300 >> 8;\t\t\t// Resolution (dpi)\n\t\t\t\t\tdata[6] = 300 & 0xff;\n\t\t\t\t\tdata[7] = 1;\t\t\t\t// Class (mouse)\n\t\t\t\t\tdata[8] = 3;\t\t\t\t// Number of buttons\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\t\t// Address/HandlerID\n\t\t\t\t\tdata[0] = 2;\n\t\t\t\t\tdata[1] = mouse_reg_3[0] & 0xf0 | (rand() & 0x0f);\n\t\t\t\t\tdata[2] = mouse_reg_3[1];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdata[0] = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tD(bug(\" mouse reg 3 %02x%02x\\n\", mouse_reg_3[0], mouse_reg_3[1]));\n\n\t} else if (adr == (key_reg_3[0] & 0x0f)) {\n\n\t\t// Keyboard\n\t\tif (cmd == 2) {\n\n\t\t\t// Listen\n\t\t\tswitch (reg) {\n\t\t\t\tcase 2:\t\t// LEDs/Modifiers\n\t\t\t\t\tkey_reg_2[0] = data[1];\n\t\t\t\t\tkey_reg_2[1] = data[2];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\t\t// Address/HandlerID\n\t\t\t\t\tif (data[2] == 0xfe)\t\t\t// Change address\n\t\t\t\t\t\t\tkey_reg_3[0] = (key_reg_3[0] & 0xf0) | (data[1] & 0x0f);\n\t\t\t\t\telse if (data[2] == 0x00)\t\t// Change address and enable bit\n\t\t\t\t\t\tkey_reg_3[0] = (key_reg_3[0] & 0xd0) | (data[1] & 0x2f);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else if (cmd == 3) {\n\n\t\t\t// Talk\n\t\t\tswitch (reg) {\n\t\t\t\tcase 2: {\t// LEDs/Modifiers\n\t\t\t\t\tuint8 reg2hi = 0xff;\n\t\t\t\t\tuint8 reg2lo = key_reg_2[1] | 0xf8;\n\t\t\t\t\tif (MATRIX(0x6b))\t// Scroll Lock\n\t\t\t\t\t\treg2lo &= ~0x40;\n\t\t\t\t\tif (MATRIX(0x47))\t// Num Lock\n\t\t\t\t\t\treg2lo &= ~0x80;\n\t\t\t\t\tif (MATRIX(0x37))\t// Command\n\t\t\t\t\t\treg2hi &= ~0x01;\n\t\t\t\t\tif (MATRIX(0x3a))\t// Option\n\t\t\t\t\t\treg2hi &= ~0x02;\n\t\t\t\t\tif (MATRIX(0x38))\t// Shift\n\t\t\t\t\t\treg2hi &= ~0x04;\n\t\t\t\t\tif (MATRIX(0x36))\t// Control\n\t\t\t\t\t\treg2hi &= ~0x08;\n\t\t\t\t\tif (MATRIX(0x39))\t// Caps Lock\n\t\t\t\t\t\treg2hi &= ~0x20;\n\t\t\t\t\tif (MATRIX(0x75))\t// Delete\n\t\t\t\t\t\treg2hi &= ~0x40;\n\t\t\t\t\tdata[0] = 2;\n\t\t\t\t\tdata[1] = reg2hi;\n\t\t\t\t\tdata[2] = reg2lo;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3:\t\t// Address/HandlerID\n\t\t\t\t\tdata[0] = 2;\n\t\t\t\t\tdata[1] = key_reg_3[0] & 0xf0 | (rand() & 0x0f);\n\t\t\t\t\tdata[2] = key_reg_3[1];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdata[0] = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tD(bug(\" keyboard reg 3 %02x%02x\\n\", key_reg_3[0], key_reg_3[1]));\n\n\t} else\t\t\t\t\t\t\t\t\t\t\t\t// Unknown address\n\t\tif (cmd == 3)\n\t\t\tdata[0] = 0;\t\t\t\t\t\t\t\t// Talk: 0 bytes of data\n}\n\n\n/*\n *  Mouse was moved (x/y are absolute or relative, depending on ADBSetRelMouseMode())\n */\n\nvoid ADBMouseMoved(int x, int y)\n{\n\tB2_lock_mutex(mouse_lock);\n\tif (relative_mouse) {\n\t\tmouse_x += x; mouse_y += y;\n\t} else {\n\t\tmouse_x = x; mouse_y = y;\n\t}\n\tB2_unlock_mutex(mouse_lock);\n\tSetInterruptFlag(INTFLAG_ADB);\n\tTriggerInterrupt();\n}\n\n\n/* \n *  Mouse button pressed\n */\n\nvoid ADBMouseDown(int button)\n{\n\tmouse_button[button] = true;\n\tSetInterruptFlag(INTFLAG_ADB);\n\tTriggerInterrupt();\n}\n\n\n/*\n *  Mouse button released\n */\n\nvoid ADBMouseUp(int button)\n{\n\tmouse_button[button] = false;\n\tSetInterruptFlag(INTFLAG_ADB);\n\tTriggerInterrupt();\n}\n\n\n/*\n *  Set mouse mode (absolute or relative)\n */\n\nvoid ADBSetRelMouseMode(bool relative)\n{\n\tif (relative_mouse != relative) {\n\t\trelative_mouse = relative;\n\t\tmouse_x = mouse_y = 0;\n\t}\n}\n\n\n/*\n *  Key pressed (\"code\" is the Mac key code)\n */\n\nvoid ADBKeyDown(int code)\n{\n\t// Add keycode to buffer\n\tkey_buffer[key_write_ptr] = code;\n\tkey_write_ptr = (key_write_ptr + 1) % KEY_BUFFER_SIZE;\n\n\t// Set key in matrix\n\tkey_states[code >> 3] |= (1 << (~code & 7));\n\n\t// Trigger interrupt\n\tSetInterruptFlag(INTFLAG_ADB);\n\tTriggerInterrupt();\n}\n\n\n/*\n *  Key released (\"code\" is the Mac key code)\n */\n\nvoid ADBKeyUp(int code)\n{\n\t// Add keycode to buffer\n\tkey_buffer[key_write_ptr] = code | 0x80;\t// Key-up flag\n\tkey_write_ptr = (key_write_ptr + 1) % KEY_BUFFER_SIZE;\n\n\t// Clear key in matrix\n\tkey_states[code >> 3] &= ~(1 << (~code & 7));\n\n\t// Trigger interrupt\n\tSetInterruptFlag(INTFLAG_ADB);\n\tTriggerInterrupt();\n}\n\n\n/*\n *  ADB interrupt function (executed as part of 60Hz interrupt)\n */\n\nvoid ADBInterrupt(void)\n{\n\tM68kRegisters r;\n\n\t// Return if ADB is not initialized\n\tuint32 adb_base = ReadMacInt32(0xcf8);\n\tif (!adb_base || adb_base == 0xffffffff)\n\t\treturn;\n\tuint32 tmp_data = adb_base + 0x163;\t// Temporary storage for faked ADB data\n\n\t// Get mouse state\n\tB2_lock_mutex(mouse_lock);\n\tint mx = mouse_x;\n\tint my = mouse_y;\n\tif (relative_mouse)\n\t\tmouse_x = mouse_y = 0;\n\tint mb[3] = {mouse_button[0], mouse_button[1], mouse_button[2]};\n\tB2_unlock_mutex(mouse_lock);\n\n\tuint32 key_base = adb_base + 4;\n\tuint32 mouse_base = adb_base + 16;\n\n\tif (relative_mouse) {\n\n\t\t// Mouse movement (relative) and buttons\n\t\tif (mx != 0 || my != 0 || mb[0] != old_mouse_button[0] || mb[1] != old_mouse_button[1] || mb[2] != old_mouse_button[2]) {\n\n\t\t\t// Call mouse ADB handler\n\t\t\tif (mouse_reg_3[1] == 4) {\n\t\t\t\t// Extended mouse protocol\n\t\t\t\tWriteMacInt8(tmp_data, 3);\n\t\t\t\tWriteMacInt8(tmp_data + 1, (my & 0x7f) | (mb[0] ? 0 : 0x80));\n\t\t\t\tWriteMacInt8(tmp_data + 2, (mx & 0x7f) | (mb[1] ? 0 : 0x80));\n\t\t\t\tWriteMacInt8(tmp_data + 3, ((my >> 3) & 0x70) | ((mx >> 7) & 0x07) | (mb[2] ? 0x08 : 0x88));\n\t\t\t} else {\n\t\t\t\t// 100/200 dpi mode\n\t\t\t\tWriteMacInt8(tmp_data, 2);\n\t\t\t\tWriteMacInt8(tmp_data + 1, (my & 0x7f) | (mb[0] ? 0 : 0x80));\n\t\t\t\tWriteMacInt8(tmp_data + 2, (mx & 0x7f) | (mb[1] ? 0 : 0x80));\n\t\t\t}\t\n\t\t\tr.a[0] = tmp_data;\n\t\t\tr.a[1] = ReadMacInt32(mouse_base);\n\t\t\tr.a[2] = ReadMacInt32(mouse_base + 4);\n\t\t\tr.a[3] = adb_base;\n\t\t\tr.d[0] = (mouse_reg_3[0] << 4) | 0x0c;\t// Talk 0\n\t\t\tExecute68k(r.a[1], &r);\n\n\t\t\told_mouse_button[0] = mb[0];\n\t\t\told_mouse_button[1] = mb[1];\n\t\t\told_mouse_button[2] = mb[2];\n\t\t}\n\n\t} else {\n\n\t\t// Update mouse position (absolute)\n\t\tif (mx != old_mouse_x || my != old_mouse_y) {\n#ifdef POWERPC_ROM\n\t\t\tstatic const uint8 proc_template[] = {\n\t\t\t\t0x2f, 0x08,\t\t// move.l a0,-(sp)\n\t\t\t\t0x2f, 0x00,\t\t// move.l d0,-(sp)\n\t\t\t\t0x2f, 0x01,\t\t// move.l d1,-(sp)\n\t\t\t\t0x70, 0x01,\t\t// moveq #1,d0 (MoveTo)\n\t\t\t\t0xaa, 0xdb,\t\t// CursorDeviceDispatch\n\t\t\t\tM68K_RTS >> 8, M68K_RTS & 0xff\n\t\t\t};\n\t\t\tBUILD_SHEEPSHAVER_PROCEDURE(proc);\n\t\t\tr.a[0] = ReadMacInt32(mouse_base + 4);\n\t\t\tr.d[0] = mx;\n\t\t\tr.d[1] = my;\n\t\t\tExecute68k(proc, &r);\n#else\n\t\t\tWriteMacInt16(0x82a, mx);\n\t\t\tWriteMacInt16(0x828, my);\n\t\t\tWriteMacInt16(0x82e, mx);\n\t\t\tWriteMacInt16(0x82c, my);\n\t\t\tWriteMacInt8(0x8ce, ReadMacInt8(0x8cf));\t// CrsrCouple -> CrsrNew\n#endif\n\t\t\told_mouse_x = mx;\n\t\t\told_mouse_y = my;\n\t\t}\n\n\t\t// Send mouse button events\n\t\tif (mb[0] != old_mouse_button[0] || mb[1] != old_mouse_button[1] || mb[2] != old_mouse_button[2]) {\n\t\t\tuint32 mouse_base = adb_base + 16;\n\n\t\t\t// Call mouse ADB handler\n\t\t\tif (mouse_reg_3[1] == 4) {\n\t\t\t\t// Extended mouse protocol\n\t\t\t\tWriteMacInt8(tmp_data, 3);\n\t\t\t\tWriteMacInt8(tmp_data + 1, mb[0] ? 0 : 0x80);\n\t\t\t\tWriteMacInt8(tmp_data + 2, mb[1] ? 0 : 0x80);\n\t\t\t\tWriteMacInt8(tmp_data + 3, mb[2] ? 0x08 : 0x88);\n\t\t\t} else {\n\t\t\t\t// 100/200 dpi mode\n\t\t\t\tWriteMacInt8(tmp_data, 2);\n\t\t\t\tWriteMacInt8(tmp_data + 1, mb[0] ? 0 : 0x80);\n\t\t\t\tWriteMacInt8(tmp_data + 2, mb[1] ? 0 : 0x80);\n\t\t\t}\n\t\t\tr.a[0] = tmp_data;\n\t\t\tr.a[1] = ReadMacInt32(mouse_base);\n\t\t\tr.a[2] = ReadMacInt32(mouse_base + 4);\n\t\t\tr.a[3] = adb_base;\n\t\t\tr.d[0] = (mouse_reg_3[0] << 4) | 0x0c;\t// Talk 0\n\t\t\tExecute68k(r.a[1], &r);\n\n\t\t\told_mouse_button[0] = mb[0];\n\t\t\told_mouse_button[1] = mb[1];\n\t\t\told_mouse_button[2] = mb[2];\n\t\t}\n\t}\n\n\t// Process accumulated keyboard events\n\twhile (key_read_ptr != key_write_ptr) {\n\n\t\t// Read keyboard event\n\t\tuint8 mac_code = key_buffer[key_read_ptr];\n\t\tkey_read_ptr = (key_read_ptr + 1) % KEY_BUFFER_SIZE;\n\n\t\t// Call keyboard ADB handler\n\t\tWriteMacInt8(tmp_data, 2);\n\t\tWriteMacInt8(tmp_data + 1, mac_code);\n\t\tWriteMacInt8(tmp_data + 2, mac_code == 0x7f ? 0x7f : 0xff);\t// Power key is special\n\t\tr.a[0] = tmp_data;\n\t\tr.a[1] = ReadMacInt32(key_base);\n\t\tr.a[2] = ReadMacInt32(key_base + 4);\n\t\tr.a[3] = adb_base;\n\t\tr.d[0] = (key_reg_3[0] << 4) | 0x0c;\t// Talk 0\n\t\tExecute68k(r.a[1], &r);\n\t}\n\n\t// Clear temporary data\n\tWriteMacInt32(tmp_data, 0);\n\tWriteMacInt32(tmp_data + 4, 0);\n}\n","/*\n *  extfs_unix.cpp - MacOS file system for access native file system access, Unix specific stuff\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <errno.h>\n\n#include \"sysdeps.h\"\n#include \"extfs.h\"\n#include \"extfs_defs.h\"\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n// Default Finder flags\nconst uint16 DEFAULT_FINDER_FLAGS = kHasBeenInited;\n\n\n/*\n *  Initialization\n */\n\nvoid extfs_init(void)\n{\n}\n\n\n/*\n *  Deinitialization\n */\n\nvoid extfs_exit(void)\n{\n}\n\n\n/*\n *  Add component to path name\n */\n\nvoid add_path_component(char *path, const char *component)\n{\n\tint l = strlen(path);\n\tif (l < MAX_PATH_LENGTH-1 && path[l-1] != '/') {\n\t\tpath[l] = '/';\n\t\tpath[l+1] = 0;\n\t}\n\tstrncat(path, component, MAX_PATH_LENGTH-1);\n}\n\n\n/*\n *  Finder info and resource forks are kept in helper files\n *\n *  Finder info:\n *    /path/.finf/file\n *  Resource fork:\n *    /path/.rsrc/file\n *\n *  The .finf files store a FInfo/DInfo, followed by a FXInfo/DXInfo\n *  (16+16 bytes)\n */\n\nstatic void make_helper_path(const char *src, char *dest, const char *add, bool only_dir = false)\n{\n\tdest[0] = 0;\n\n\t// Get pointer to last component of path\n\tconst char *last_part = strrchr(src, '/');\n\tif (last_part)\n\t\tlast_part++;\n\telse\n\t\tlast_part = src;\n\n\t// Copy everything before\n\tstrncpy(dest, src, last_part-src);\n\tdest[last_part-src] = 0;\n\n\t// Add additional component\n\tstrncat(dest, add, MAX_PATH_LENGTH-1);\n\n\t// Add last component\n\tif (!only_dir)\n\t\tstrncat(dest, last_part, MAX_PATH_LENGTH-1);\n}\n\nstatic int create_helper_dir(const char *path, const char *add)\n{\n\tchar helper_dir[MAX_PATH_LENGTH];\n\tmake_helper_path(path, helper_dir, add, true);\n\tif (helper_dir[strlen(helper_dir) - 1] == '/')\t// Remove trailing \"/\"\n\t\thelper_dir[strlen(helper_dir) - 1] = 0;\n\treturn mkdir(helper_dir, 0777);\n}\n\nstatic int open_helper(const char *path, const char *add, int flag)\n{\n\tchar helper_path[MAX_PATH_LENGTH];\n\tmake_helper_path(path, helper_path, add);\n\n\tif ((flag & O_ACCMODE) == O_RDWR || (flag & O_ACCMODE) == O_WRONLY)\n\t\tflag |= O_CREAT;\n\tint fd = open(helper_path, flag, 0666);\n\tif (fd < 0) {\n\t\tif (errno == ENOENT && (flag & O_CREAT)) {\n\t\t\t// One path component was missing, probably the helper\n\t\t\t// directory. Try to create it and re-open the file.\n\t\t\tint ret = create_helper_dir(path, add);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tfd = open(helper_path, flag, 0666);\n\t\t}\n\t}\n\treturn fd;\n}\n\nstatic int open_finf(const char *path, int flag)\n{\n\treturn open_helper(path, \".finf/\", flag);\n}\n\nstatic int open_rsrc(const char *path, int flag)\n{\n\treturn open_helper(path, \".rsrc/\", flag);\n}\n\n\n/*\n *  Get/set finder info for file/directory specified by full path\n */\n\nstruct ext2type {\n\tconst char *ext;\n\tuint32 type;\n\tuint32 creator;\n};\n\nstatic const ext2type e2t_translation[] = {\n\t{\".Z\", FOURCC('Z','I','V','M'), FOURCC('L','Z','I','V')},\n\t{\".gz\", FOURCC('G','z','i','p'), FOURCC('G','z','i','p')},\n\t{\".hqx\", FOURCC('T','E','X','T'), FOURCC('S','I','T','x')},\n\t{\".bin\", FOURCC('T','E','X','T'), FOURCC('S','I','T','x')},\n\t{\".pdf\", FOURCC('P','D','F',' '), FOURCC('C','A','R','O')},\n\t{\".ps\", FOURCC('T','E','X','T'), FOURCC('t','t','x','t')},\n\t{\".sit\", FOURCC('S','I','T','!'), FOURCC('S','I','T','x')},\n\t{\".tar\", FOURCC('T','A','R','F'), FOURCC('T','A','R',' ')},\n\t{\".uu\", FOURCC('T','E','X','T'), FOURCC('S','I','T','x')},\n\t{\".uue\", FOURCC('T','E','X','T'), FOURCC('S','I','T','x')},\n\t{\".zip\", FOURCC('Z','I','P',' '), FOURCC('Z','I','P',' ')},\n\t{\".8svx\", FOURCC('8','S','V','X'), FOURCC('S','N','D','M')},\n\t{\".aifc\", FOURCC('A','I','F','C'), FOURCC('T','V','O','D')},\n\t{\".aiff\", FOURCC('A','I','F','F'), FOURCC('T','V','O','D')},\n\t{\".au\", FOURCC('U','L','A','W'), FOURCC('T','V','O','D')},\n\t{\".mid\", FOURCC('M','I','D','I'), FOURCC('T','V','O','D')},\n\t{\".midi\", FOURCC('M','I','D','I'), FOURCC('T','V','O','D')},\n\t{\".mp2\", FOURCC('M','P','G',' '), FOURCC('T','V','O','D')},\n\t{\".mp3\", FOURCC('M','P','G',' '), FOURCC('T','V','O','D')},\n\t{\".wav\", FOURCC('W','A','V','E'), FOURCC('T','V','O','D')},\n\t{\".bmp\", FOURCC('B','M','P','f'), FOURCC('o','g','l','e')},\n\t{\".gif\", FOURCC('G','I','F','f'), FOURCC('o','g','l','e')},\n\t{\".lbm\", FOURCC('I','L','B','M'), FOURCC('G','K','O','N')},\n\t{\".ilbm\", FOURCC('I','L','B','M'), FOURCC('G','K','O','N')},\n\t{\".jpg\", FOURCC('J','P','E','G'), FOURCC('o','g','l','e')},\n\t{\".jpeg\", FOURCC('J','P','E','G'), FOURCC('o','g','l','e')},\n\t{\".pict\", FOURCC('P','I','C','T'), FOURCC('o','g','l','e')},\n\t{\".png\", FOURCC('P','N','G','f'), FOURCC('o','g','l','e')},\n\t{\".sgi\", FOURCC('.','S','G','I'), FOURCC('o','g','l','e')},\n\t{\".tga\", FOURCC('T','P','I','C'), FOURCC('o','g','l','e')},\n\t{\".tif\", FOURCC('T','I','F','F'), FOURCC('o','g','l','e')},\n\t{\".tiff\", FOURCC('T','I','F','F'), FOURCC('o','g','l','e')},\n\t{\".htm\", FOURCC('T','E','X','T'), FOURCC('M','O','S','S')},\n\t{\".html\", FOURCC('T','E','X','T'), FOURCC('M','O','S','S')},\n\t{\".txt\", FOURCC('T','E','X','T'), FOURCC('t','t','x','t')},\n\t{\".rtf\", FOURCC('T','E','X','T'), FOURCC('M','S','W','D')},\n\t{\".c\", FOURCC('T','E','X','T'), FOURCC('R','*','c','h')},\n\t{\".C\", FOURCC('T','E','X','T'), FOURCC('R','*','c','h')},\n\t{\".cc\", FOURCC('T','E','X','T'), FOURCC('R','*','c','h')},\n\t{\".cpp\", FOURCC('T','E','X','T'), FOURCC('R','*','c','h')},\n\t{\".cxx\", FOURCC('T','E','X','T'), FOURCC('R','*','c','h')},\n\t{\".h\", FOURCC('T','E','X','T'), FOURCC('R','*','c','h')},\n\t{\".hh\", FOURCC('T','E','X','T'), FOURCC('R','*','c','h')},\n\t{\".hpp\", FOURCC('T','E','X','T'), FOURCC('R','*','c','h')},\n\t{\".hxx\", FOURCC('T','E','X','T'), FOURCC('R','*','c','h')},\n\t{\".s\", FOURCC('T','E','X','T'), FOURCC('R','*','c','h')},\n\t{\".S\", FOURCC('T','E','X','T'), FOURCC('R','*','c','h')},\n\t{\".i\", FOURCC('T','E','X','T'), FOURCC('R','*','c','h')},\n\t{\".mpg\", FOURCC('M','P','E','G'), FOURCC('T','V','O','D')},\n\t{\".mpeg\", FOURCC('M','P','E','G'), FOURCC('T','V','O','D')},\n\t{\".mov\", FOURCC('M','o','o','V'), FOURCC('T','V','O','D')},\n\t{\".fli\", FOURCC('F','L','I',' '), FOURCC('T','V','O','D')},\n\t{\".avi\", FOURCC('V','f','W',' '), FOURCC('T','V','O','D')},\n\t{\".qxd\", FOURCC('X','D','O','C'), FOURCC('X','P','R','3')},\n\t{\".hfv\", FOURCC('D','D','i','m'), FOURCC('d','d','s','k')},\n\t{\".dsk\", FOURCC('D','D','i','m'), FOURCC('d','d','s','k')},\n\t{\".img\", FOURCC('r','o','h','d'), FOURCC('d','d','s','k')},\n\t{NULL, 0, 0}\t// End marker\n};\n\nvoid get_finfo(const char *path, uint32 finfo, uint32 fxinfo, bool is_dir)\n{\n\t// Set default finder info\n\tMac_memset(finfo, 0, SIZEOF_FInfo);\n\tif (fxinfo)\n\t\tMac_memset(fxinfo, 0, SIZEOF_FXInfo);\n\tWriteMacInt16(finfo + fdFlags, DEFAULT_FINDER_FLAGS);\n\tWriteMacInt32(finfo + fdLocation, (uint32)-1);\n\n\t// Read Finder info file\n\tint fd = open_finf(path, O_RDONLY);\n\tif (fd >= 0) {\n\t\tssize_t actual = read(fd, Mac2HostAddr(finfo), SIZEOF_FInfo);\n\t\tif (fxinfo)\n\t\t\tactual += read(fd, Mac2HostAddr(fxinfo), SIZEOF_FXInfo);\n\t\tclose(fd);\n\t\tif (actual >= SIZEOF_FInfo)\n\t\t\treturn;\n\t}\n\n\t// No Finder info file, translate file name extension to MacOS type/creator\n\tif (!is_dir) {\n\t\tint path_len = strlen(path);\n\t\tfor (int i=0; e2t_translation[i].ext; i++) {\n\t\t\tint ext_len = strlen(e2t_translation[i].ext);\n\t\t\tif (path_len < ext_len)\n\t\t\t\tcontinue;\n\t\t\tif (!strcmp(path + path_len - ext_len, e2t_translation[i].ext)) {\n\t\t\t\tWriteMacInt32(finfo + fdType, e2t_translation[i].type);\n\t\t\t\tWriteMacInt32(finfo + fdCreator, e2t_translation[i].creator);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid set_finfo(const char *path, uint32 finfo, uint32 fxinfo, bool is_dir)\n{\n\t// Open Finder info file\n\tint fd = open_finf(path, O_RDWR);\n\tif (fd < 0)\n\t\treturn;\n\n\t// Write file\n\twrite(fd, Mac2HostAddr(finfo), SIZEOF_FInfo);\n\tif (fxinfo)\n\t\twrite(fd, Mac2HostAddr(fxinfo), SIZEOF_FXInfo);\n\tclose(fd);\n}\n\n\n/*\n *  Resource fork emulation functions\n */\n\nuint32 get_rfork_size(const char *path)\n{\n\t// Open resource file\n\tint fd = open_rsrc(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\t// Get size\n\toff_t size = lseek(fd, 0, SEEK_END);\n\t\n\t// Close file and return size\n\tclose(fd);\n\treturn size < 0 ? 0 : size;\n}\n\nint open_rfork(const char *path, int flag)\n{\n\treturn open_rsrc(path, flag);\n}\n\nvoid close_rfork(const char *path, int fd)\n{\n\tclose(fd);\n}\n\n\n/*\n *  Read \"length\" bytes from file to \"buffer\",\n *  returns number of bytes read (or -1 on error)\n */\n\nssize_t extfs_read(int fd, void *buffer, size_t length)\n{\n\treturn read(fd, buffer, length);\n}\n\n\n/*\n *  Write \"length\" bytes from \"buffer\" to file,\n *  returns number of bytes written (or -1 on error)\n */\n\nssize_t extfs_write(int fd, void *buffer, size_t length)\n{\n\treturn write(fd, buffer, length);\n}\n\n\n/*\n *  Remove file/directory (and associated helper files),\n *  returns false on error (and sets errno)\n */\n\nbool extfs_remove(const char *path)\n{\n\t// Remove helpers first, don't complain if this fails\n\tchar helper_path[MAX_PATH_LENGTH];\n\tmake_helper_path(path, helper_path, \".finf/\", false);\n\tremove(helper_path);\n\tmake_helper_path(path, helper_path, \".rsrc/\", false);\n\tremove(helper_path);\n\n\t// Now remove file or directory (and helper directories in the directory)\n\tif (remove(path) < 0) {\n\t\tif (errno == EISDIR || errno == ENOTEMPTY) {\n\t\t\thelper_path[0] = 0;\n\t\t\tstrncpy(helper_path, path, MAX_PATH_LENGTH-1);\n\t\t\tadd_path_component(helper_path, \".finf\");\n\t\t\trmdir(helper_path);\n\t\t\thelper_path[0] = 0;\n\t\t\tstrncpy(helper_path, path, MAX_PATH_LENGTH-1);\n\t\t\tadd_path_component(helper_path, \".rsrc\");\n\t\t\trmdir(helper_path);\n\t\t\treturn rmdir(path) == 0;\n\t\t} else\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n\n/*\n *  Rename/move file/directory (and associated helper files),\n *  returns false on error (and sets errno)\n */\n\nbool extfs_rename(const char *old_path, const char *new_path)\n{\n\t// Rename helpers first, don't complain if this fails\n\tchar old_helper_path[MAX_PATH_LENGTH], new_helper_path[MAX_PATH_LENGTH];\n\tmake_helper_path(old_path, old_helper_path, \".finf/\", false);\n\tmake_helper_path(new_path, new_helper_path, \".finf/\", false);\n\tcreate_helper_dir(new_path, \".finf/\");\n\trename(old_helper_path, new_helper_path);\n\tmake_helper_path(old_path, old_helper_path, \".rsrc/\", false);\n\tmake_helper_path(new_path, new_helper_path, \".rsrc/\", false);\n\tcreate_helper_dir(new_path, \".rsrc/\");\n\trename(old_helper_path, new_helper_path);\n\n\t// Now rename file\n\treturn rename(old_path, new_path) == 0;\n}\n\n\n// Convert from the host OS filename encoding to MacRoman\nconst char *host_encoding_to_macroman(const char *filename)\n{\n\treturn filename;\n}\n\n// Convert from MacRoman to host OS filename encoding\nconst char *macroman_to_host_encoding(const char *filename)\n{\n\treturn filename;\n}\n","// -*- C++ -*-\n//===--------------------------- string.h ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING_H\n#define _LIBCPP_STRING_H\n\n/*\n    string.h synopsis\n\nMacros:\n\n    NULL\n\nTypes:\n\n    size_t\n\nvoid* memcpy(void* restrict s1, const void* restrict s2, size_t n);\nvoid* memmove(void* s1, const void* s2, size_t n);\nchar* strcpy (char* restrict s1, const char* restrict s2);\nchar* strncpy(char* restrict s1, const char* restrict s2, size_t n);\nchar* strcat (char* restrict s1, const char* restrict s2);\nchar* strncat(char* restrict s1, const char* restrict s2, size_t n);\nint memcmp(const void* s1, const void* s2, size_t n);\nint strcmp (const char* s1, const char* s2);\nint strncmp(const char* s1, const char* s2, size_t n);\nint strcoll(const char* s1, const char* s2);\nsize_t strxfrm(char* restrict s1, const char* restrict s2, size_t n);\nconst void* memchr(const void* s, int c, size_t n);\n      void* memchr(      void* s, int c, size_t n);\nconst char* strchr(const char* s, int c);\n      char* strchr(      char* s, int c);\nsize_t strcspn(const char* s1, const char* s2);\nconst char* strpbrk(const char* s1, const char* s2);\n      char* strpbrk(      char* s1, const char* s2);\nconst char* strrchr(const char* s, int c);\n      char* strrchr(      char* s, int c);\nsize_t strspn(const char* s1, const char* s2);\nconst char* strstr(const char* s1, const char* s2);\n      char* strstr(      char* s1, const char* s2);\nchar* strtok(char* restrict s1, const char* restrict s2);\nvoid* memset(void* s, int c, size_t n);\nchar* strerror(int errnum);\nsize_t strlen(const char* s);\n\n*/\n\n#include <__config>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#include_next <string.h>\n\n// MSVCRT, GNU libc and its derivates may already have the correct prototype in\n// <string.h>. This macro can be defined by users if their C library provides\n// the right signature.\n#if defined(__CORRECT_ISO_CPP_STRING_H_PROTO) || defined(_LIBCPP_MSVCRT) || \\\n    defined(__sun__) || defined(_STRING_H_CPLUSPLUS_98_CONFORMANCE_)\n#define _LIBCPP_STRING_H_HAS_CONST_OVERLOADS\n#endif\n\n#if defined(__cplusplus) && !defined(_LIBCPP_STRING_H_HAS_CONST_OVERLOADS) && defined(_LIBCPP_PREFERRED_OVERLOAD)\nextern \"C++\" {\ninline _LIBCPP_INLINE_VISIBILITY\nchar* __libcpp_strchr(const char* __s, int __c) {return (char*)strchr(__s, __c);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst char* strchr(const char* __s, int __c) {return __libcpp_strchr(__s, __c);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      char* strchr(      char* __s, int __c) {return __libcpp_strchr(__s, __c);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar* __libcpp_strpbrk(const char* __s1, const char* __s2) {return (char*)strpbrk(__s1, __s2);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst char* strpbrk(const char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      char* strpbrk(      char* __s1, const char* __s2) {return __libcpp_strpbrk(__s1, __s2);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar* __libcpp_strrchr(const char* __s, int __c) {return (char*)strrchr(__s, __c);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst char* strrchr(const char* __s, int __c) {return __libcpp_strrchr(__s, __c);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      char* strrchr(      char* __s, int __c) {return __libcpp_strrchr(__s, __c);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid* __libcpp_memchr(const void* __s, int __c, size_t __n) {return (void*)memchr(__s, __c, __n);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst void* memchr(const void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      void* memchr(      void* __s, int __c, size_t __n) {return __libcpp_memchr(__s, __c, __n);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar* __libcpp_strstr(const char* __s1, const char* __s2) {return (char*)strstr(__s1, __s2);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\nconst char* strstr(const char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD\n      char* strstr(      char* __s1, const char* __s2) {return __libcpp_strstr(__s1, __s2);}\n}\n#endif\n\n#endif  // _LIBCPP_STRING_H\n","/*\n *  disk_sparsebundle.cpp - Apple sparse bundle implementation\n *\n *  Basilisk II (C) Dave Vasilevsky\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"disk_unix.h\"\n#include \"tinyxml2.h\"\n\n#include <errno.h>\n#include <limits.h>\n#include <algorithm>\n\n#if defined __APPLE__ && defined __MACH__\n#define __MACOSX__ 1\n#endif\n\nstruct disk_sparsebundle : disk_generic {\n\tdisk_sparsebundle(const char *bands, int fd, bool read_only,\n\t\tloff_t band_size, loff_t total_size)\n\t: token_fd(fd), read_only(read_only), band_size(band_size),\n\t\ttotal_size(total_size), band_dir(strdup(bands)),\n\t\tband_cur(-1), band_fd(-1), band_alloc(-1) {\n\t}\n\t\n\tvirtual ~disk_sparsebundle() {\n\t\tif (band_fd != -1)\n\t\t\tclose(band_fd);\n\t\tclose(token_fd);\n\t\tfree(band_dir);\n\t}\n\t\n\tvirtual bool is_read_only() { return read_only; }\n\tvirtual loff_t size() { return total_size; }\n\t\n\tvirtual size_t read(void *buf, loff_t offset, size_t length) {\n\t\treturn band_do(&disk_sparsebundle::band_read, buf, offset, length);\n\t}\n\t\n\tvirtual size_t write(void *buf, loff_t offset, size_t length) {\n\t\treturn band_do(&disk_sparsebundle::band_write, buf, offset, length);\n\t}\n\t\nprotected:\n\tint token_fd;\t\t\t// lockfile\n\tbool read_only;\n\tloff_t band_size, total_size;\n\tchar *band_dir;\t\t\t// directory containing band files\n\t\n\t// Currently open band\n\tloff_t band_cur;\t\t// index of the band\n\tint band_fd;\t\t\t// -1 if not open\n\tloff_t band_alloc;\t\t// how much space is already used?\n\t\n\ttypedef ssize_t (disk_sparsebundle::*band_func)(char *buf, loff_t band,\n\t\tsize_t offset, size_t len);\n\t\n\t// Split an (offset, length) operation into bands.\n\tsize_t band_do(band_func func, void *buf, loff_t offset, size_t length) {\n\t\tchar *b = (char*)buf;\n\t\tloff_t band = offset / band_size;\n\t\tsize_t done = 0;\n\t\twhile (length) {\n\t\t\tif (offset >= total_size)\n\t\t\t\tbreak;\n\t\t\tsize_t start = offset % band_size;\n\t\t\tsize_t segment = std::min((size_t)band_size - start, length);\n\t\t\t\n\t\t\tssize_t err = (this->*func)(b, band, start, segment);\n\t\t\tif (err > 0)\n\t\t\t\tdone += err;\n\t\t\tif (err < segment)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tb += segment;\n\t\t\toffset += segment;\n\t\t\tlength -= segment;\n\t\t\t++band;\n\t\t}\n\t\treturn done;\n\t}\n\t\t\n\t// Open a band by index. It's ok if the band is already open.\n\tenum open_ret {\n\t\tOPEN_FAILED = 0,\n\t\tOPEN_NOENT,\t\t// Band doesn't exist yet\n\t\tOPEN_OK,\n\t};\n\topen_ret open_band(loff_t band, bool create) {\n\t\tif (band_cur == band)\n\t\t\treturn OPEN_OK;\n\t\t\n\t\tchar path[PATH_MAX + 1];\n\t\tif (snprintf(path, PATH_MAX, \"%s/%lx\", band_dir,\n\t\t\t\t(unsigned long)band) >= PATH_MAX) {\n\t\t\treturn OPEN_FAILED;\n\t\t}\n\t\t\n\t\tif (band_fd != -1)\n\t\t\tclose(band_fd);\n\t\tband_alloc = -1;\n\t\tband_cur = -1;\n\t\t\n\t\tint oflags = read_only ? O_RDONLY : O_RDWR;\n\t\tif (create)\n\t\t\toflags |= O_CREAT;\n\t\tband_fd = open(path, oflags, 0644);\n\t\tif (band_fd == -1) {\n\t\t\treturn (!create && errno == ENOENT) ? OPEN_NOENT : OPEN_FAILED;\n\t\t}\n\t\t\n\t\t// Get the allocated size\n\t\tif (!read_only) {\n\t\t\tband_alloc = lseek(band_fd, 0, SEEK_END);\n\t\t\tif (band_alloc == -1)\n\t\t\t\tband_alloc = band_size;\n\t\t}\n\t\tband_cur = band;\n\t\treturn OPEN_OK;\n\t}\n\t\n\tssize_t band_read(char *buf, loff_t band, size_t off, size_t len) {\n\t\topen_ret st = open_band(band, false);\n\t\tif (st == OPEN_FAILED)\n\t\t\treturn -1;\n\t\t\n\t\t// Unallocated bytes \n\t\tsize_t want = (st == OPEN_NOENT || off >= band_alloc) ? 0\n\t\t\t: std::min(len, (size_t)band_alloc - off);\n\t\tif (want) {\n\t\t\tif (lseek(band_fd, off, SEEK_SET) == -1)\n\t\t\t\treturn -1;\n\t\t\tssize_t err = ::read(band_fd, buf, want);\n\t\t\tif (err < want)\n\t\t\t\treturn err;\n\t\t}\n\t\tmemset(buf + want, 0, len - want);\n\t\treturn len;\n\t}\n\n\tssize_t band_write(char *buf, loff_t band, size_t off, size_t len) {\n\t\t// If space is unused, don't needlessly fill it with zeros\n\t\t\n\t\t// Find min length such that all trailing chars are zero:\n\t\tsize_t nz = len;\n\t\tfor (; nz > 0 && !buf[nz-1]; --nz)\n\t\t\t; // pass\n\t\t\n\t\topen_ret st = open_band(band, nz);\n\t\tif (st != OPEN_OK)\n\t\t\treturn st == OPEN_NOENT ? len : -1;\n\n\t\tif (lseek(band_fd, off, SEEK_SET) == -1)\n\t\t\treturn -1;\n\t\t\n\t\tsize_t space = (off >= band_alloc ? 0 : band_alloc - off);\n\t\tsize_t want = std::max(nz, std::min(space, len));\n\t\tssize_t err = ::write(band_fd, buf, want);\n\t\tif (err >= 0)\n\t\t\tband_alloc = std::max(band_alloc, loff_t(off + err));\n\t\tif (err < want)\n\t\t\treturn err;\n\t\treturn len;\n\t}\n};\n\n\n\nusing tinyxml2::XML_NO_ERROR;\nusing tinyxml2::XMLElement;\n\n// Simplistic plist parser\nstruct plist {\n\tplist() : doc(true, tinyxml2::COLLAPSE_WHITESPACE) { }\n\t\n\tbool open(const char *path) {\n\t\tif (doc.LoadFile(path) != XML_NO_ERROR)\n\t\t\treturn false;\n\t\ttinyxml2::XMLHandle hnd(&doc);\n\t\tdict = hnd.FirstChildElement(\"plist\").FirstChildElement(\"dict\")\n\t\t\t.ToElement();\n\t\treturn dict;\n\t}\n\t\n\tconst char *str_val(const char *key) {\n\t\treturn value(key, \"string\");\n\t}\n\n\tbool int_val(const char *key, loff_t *i) {\n\t\tconst char *v = value(key, \"integer\");\n\t\tif (!v || !*v)\n\t\t\treturn false;\n\t\t\n\t\tchar *endp;\n\t\tlong long ll = strtoll(v, &endp, 10);\n\t\tif (*endp)\n\t\t\treturn false;\n\t\t*i = ll;\n\t\treturn true;\n\t}\n\t\nprotected:\n\ttinyxml2::XMLDocument doc;\n\tXMLElement *dict;\n\t\n\tconst char *value(const char *key, const char *type) {\n\t\t// Assume it's a flat plist\n\t\tXMLElement *cur = dict->FirstChildElement();\n\t\tbool found_key = false;\n\t\twhile (cur) {\n\t\t\tif (found_key) {\n\t\t\t\tif (strcmp(cur->Name(), type) != 0)\n\t\t\t\t\treturn NULL;\n\t\t\t\treturn cur->GetText();\n\t\t\t}\n\t\t\tfound_key = strcmp(cur->Name(), \"key\") == 0\n\t\t\t\t&& strcmp(cur->GetText(), key) == 0;\n\t\t\tcur = cur->NextSiblingElement();\n\t\t}\n\t\treturn NULL;\n\t}\n};\n\n\nstatic int try_open(const char *path, bool read_only, bool *locked) {\n\tint oflags = (read_only ? O_RDONLY : O_RDWR);\n\tint lockflags = 0;\n#if defined(__MACOSX__)\n\tlockflags = O_NONBLOCK | (read_only ? O_SHLOCK : O_EXLOCK);\n#endif\n\tint fd = open(path, oflags | lockflags);\n#if defined(__MACOSX__)\n\tif (fd == -1) {\n\t\tif (errno == EOPNOTSUPP) { // no locking support, try again\n\t\t\tfd = open(path, oflags);\n\t\t} else if (errno == EAGAIN) { // locked\n\t\t\t*locked = true;\n\t\t}\n\t}\n#endif\n\treturn fd;\n}\n\ndisk_generic::status disk_sparsebundle_factory(const char *path,\n\t\tbool read_only, disk_generic **disk) {\n\t// Does it look like a sparsebundle?\n\tchar buf[PATH_MAX + 1];\n\tif (snprintf(buf, PATH_MAX, \"%s/%s\", path, \"Info.plist\") >= PATH_MAX)\n\t\treturn disk_generic::DISK_UNKNOWN;\n\t\n\tplist pl;\n\tif (!pl.open(buf))\n\t\treturn disk_generic::DISK_UNKNOWN;\n\t\n\tconst char *type;\n\tif (!(type = pl.str_val(\"diskimage-bundle-type\")))\n\t\treturn disk_generic::DISK_UNKNOWN;\n\tif (strcmp(type, \"com.apple.diskimage.sparsebundle\") != 0)\n\t\treturn disk_generic::DISK_UNKNOWN;\n\t\n\t\n\t// Find the sparsebundle parameters\n\tloff_t version, band_size, total_size;\n\tif (!pl.int_val(\"bundle-backingstore-version\", &version) || version != 1) {\n\t\tfprintf(stderr, \"sparsebundle: Bad version\\n\");\n\t\treturn disk_generic::DISK_UNKNOWN;\n\t}\n\tif (!pl.int_val(\"band-size\", &band_size)\n\t\t\t|| !pl.int_val(\"size\", &total_size)) {\n\t\tfprintf(stderr, \"sparsebundle: Can't find size\\n\");\n\t\treturn disk_generic::DISK_INVALID;\n\t}\n\t\n\t\n\t// Check if we can open it\n\tif (snprintf(buf, PATH_MAX, \"%s/%s\", path, \"token\") >= PATH_MAX)\n\t\treturn disk_generic::DISK_INVALID;\n\tbool locked = false;\n\tint token = try_open(buf, read_only, &locked);\n\tif (token == -1 && !read_only) { // try again, read-only\n\t\ttoken = try_open(buf, true, &locked);\n\t\tif (token != -1 && !read_only)\n\t\t\tfprintf(stderr, \"sparsebundle: Can only mount read-only\\n\");\n\t\tread_only = true;\n\t}\n\tif (token == -1) {\n\t\tif (locked)\n\t\t\tfprintf(stderr, \"sparsebundle: Refusing to double-mount\\n\");\n\t\telse\n\t\t\tperror(\"sparsebundle: open failed:\");\n\t\treturn disk_generic::DISK_INVALID;\n\t}\n\t\n\t\n\t// We're good to go!\n\tif (snprintf(buf, PATH_MAX, \"%s/%s\", path, \"bands\") >= PATH_MAX)\n\t\treturn disk_generic::DISK_INVALID;\n\t*disk = new disk_sparsebundle(buf, token, read_only, band_size,\n\t\ttotal_size);\n\treturn disk_generic::DISK_VALID;\n}\n","/*\n *  timer.cpp - Time Manager emulation\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/*\n *  SEE ALSO\n *    Inside Macintosh: Processes, chapter 3 \"Time Manager\"\n *    Technote 1063: \"Inside Macintosh: Processes: Time Manager Addenda\"\n */\n\n#include <stdio.h>\n\n#include \"sysdeps.h\"\n#include \"cpu_emulation.h\"\n#include \"main.h\"\n#include \"macos_util.h\"\n#include \"timer.h\"\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n// Set this to 1 to enable TMQueue management (doesn't work)\n#define TM_QUEUE 0\n\n\n// Definitions for Time Manager\nenum {\t// TMTask struct\n\ttmAddr = 6,\n\ttmCount = 10,\n\ttmWakeUp = 14,\n\ttmReserved = 18\n};\n\n\n// Array of additional info for each installed TMTask\nstruct TMDesc {\n\tuint32 task;\t\t// Mac address of associated TMTask\n\ttm_time_t wakeup;\t// Time this task is scheduled for execution\n\tbool in_use;\t\t// Flag: descriptor in use\n};\n\nconst int NUM_DESCS = 64;\t\t// Maximum number of descriptors\nstatic TMDesc desc[NUM_DESCS];\n\n\n/*\n *  Allocate descriptor for given TMTask in list\n */\n\nstatic int alloc_desc(uint32 tm)\n{\n\t// Search for first free descriptor\n\tfor (int i=0; i<NUM_DESCS; i++)\n\t\tif (!desc[i].in_use) {\n\t\t\tdesc[i].task = tm;\n\t\t\tdesc[i].in_use = true;\n\t\t\treturn i;\n\t\t}\n\treturn -1;\n}\n\n\n/*\n *  Free descriptor in list\n */\n\ninline static void free_desc(int i)\n{\n\tdesc[i].in_use = false;\n}\n\n\n/*\n *  Find descriptor associated with given TMTask\n */\n\ninline static int find_desc(uint32 tm)\n{\n\tfor (int i=0; i<NUM_DESCS; i++)\n\t\tif (desc[i].in_use && desc[i].task == tm)\n\t\t\treturn i;\n\treturn -1;\n}\n\n\n/*\n *  Enqueue task in Time Manager queue\n */\n\nstatic void enqueue_tm(uint32 tm)\n{\n#if TM_QUEUE\n\tuint32 tm_var = ReadMacInt32(0xb30);\n\tWriteMacInt32(tm + qLink, ReadMacInt32(tm_var));\n\tWriteMacInt32(tm_var, tm);\n#endif\n}\n\n\n/*\n *  Remove task from Time Manager queue\n */\n\nstatic void dequeue_tm(uint32 tm)\n{\n#if TM_QUEUE\n\tuint32 p = ReadMacInt32(0xb30);\n\twhile (p) {\n\t\tuint32 next = ReadMacInt32(p + qLink);\n\t\tif (next == tm) {\n\t\t\tWriteMacInt32(p + qLink, ReadMacInt32(next + qLink));\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n}\n\n\n/*\n *  Initialize Time Manager\n */\n\nvoid TimerInit(void)\n{\n\t// Mark all descriptors as inactive\n\tfor (int i=0; i<NUM_DESCS; i++)\n\t\tfree_desc(i);\n}\n\n\n/*\n *  Exit Time Manager\n */\n\nvoid TimerExit(void)\n{\n}\n\n\n/*\n *  Emulator reset, remove all timer tasks\n */\n\nvoid TimerReset(void)\n{\n\t// Mark all descriptors as inactive\n\tfor (int i=0; i<NUM_DESCS; i++)\n\t\tfree_desc(i);\n}\n\n\n/*\n *  Insert timer task\n */\n\nint16 InsTime(uint32 tm, uint16 trap)\n{\n\tD(bug(\"InsTime %08lx, trap %04x\\n\", tm, trap));\n\tWriteMacInt16(tm + qType, ReadMacInt16(tm + qType) & 0x1fff | (trap << 4) & 0x6000);\n\tif (find_desc(tm) >= 0)\n\t\tprintf(\"WARNING: InsTime(): Task re-inserted\\n\");\n\telse {\n\t\tint i = alloc_desc(tm);\n\t\tif (i < 0)\n\t\t\tprintf(\"FATAL: InsTime(): No free Time Manager descriptor\\n\");\n\t}\n\treturn 0;\n}\n\n\n/*\n *  Remove timer task\n */\n\nint16 RmvTime(uint32 tm)\n{\n\tD(bug(\"RmvTime %08lx\\n\", tm));\n\n\t// Find descriptor\n\tint i = find_desc(tm);\n\tif (i < 0) {\n\t\tprintf(\"WARNING: RmvTime(%08x): Descriptor not found\\n\", tm);\n\t\treturn 0;\n\t}\n\n\t// Task active?\n\tif (ReadMacInt16(tm + qType) & 0x8000) {\n\n\t\t// Yes, make task inactive and remove it from the Time Manager queue\n\t\tWriteMacInt16(tm + qType, ReadMacInt16(tm + qType) & 0x7fff);\n\t\tdequeue_tm(tm);\n\n\t\t// Compute remaining time\n\t\ttm_time_t remaining, current;\n\t\ttimer_current_time(current);\n\t\ttimer_sub_time(remaining, desc[i].wakeup, current);\n\t\tWriteMacInt32(tm + tmCount, timer_host2mac_time(remaining));\n\t} else\n\t\tWriteMacInt32(tm + tmCount, 0);\n\tD(bug(\" tmCount %d\\n\", ReadMacInt32(tm + tmCount)));\n\n\t// Free descriptor\n\tfree_desc(i);\n\treturn 0;\n}\n\n\n/*\n *  Start timer task\n */\n\nint16 PrimeTime(uint32 tm, int32 time)\n{\n\tD(bug(\"PrimeTime %08x, time %d\\n\", tm, time));\n\n\t// Find descriptor\n\tint i = find_desc(tm);\n\tif (i < 0) {\n\t\tprintf(\"FATAL: PrimeTime(): Descriptor not found\\n\");\n\t\treturn 0;\n\t}\n\n\t// Extended task?\n\tif (ReadMacInt16(tm + qType) & 0x4000) {\n\n\t\t// Convert delay time\n\t\ttm_time_t delay;\n\t\ttimer_mac2host_time(delay, time);\n\n\t\t// Yes, tmWakeUp set?\n\t\tif (ReadMacInt32(tm + tmWakeUp)) {\n\n\t\t\t//!! PrimeTime(0) means continue previous delay\n\t\t\t// (save wakeup time in RmvTime?)\n\t\t\tif (time == 0)\n\t\t\t\tprintf(\"WARNING: Unsupported PrimeTime(0)\\n\");\n\n\t\t\t// Yes, calculate wakeup time relative to last scheduled time\n\t\t\ttm_time_t wakeup;\n\t\t\ttimer_add_time(wakeup, desc[i].wakeup, delay);\n\t\t\tdesc[i].wakeup = wakeup;\n\n\t\t} else {\n\n\t\t\t// No, calculate wakeup time relative to current time\n\t\t\ttm_time_t now;\n\t\t\ttimer_current_time(now);\n\t\t\ttimer_add_time(desc[i].wakeup, now, delay);\n\t\t}\n\n\t\t// Set tmWakeUp to indicate that task was scheduled\n\t\tWriteMacInt32(tm + tmWakeUp, 0x12345678);\n\n\t} else {\n\n\t\t// Not extended task, calculate wakeup time relative to current time\n\t\ttm_time_t delay;\n\t\ttimer_mac2host_time(delay, time);\n\t\ttimer_current_time(desc[i].wakeup);\n\t\ttimer_add_time(desc[i].wakeup, desc[i].wakeup, delay);\n\t}\n\n\t// Make task active and enqueue it in the Time Manager queue\n\tWriteMacInt16(tm + qType, ReadMacInt16(tm + qType) | 0x8000);\n\tenqueue_tm(tm);\n\treturn 0;\n}\n\n\n/*\n *  Timer interrupt function (executed as part of 60Hz interrupt)\n */\n\nvoid TimerInterrupt(void)\n{\n\t// Look for active TMTasks that have expired\n\ttm_time_t now;\n\ttimer_current_time(now);\n\tfor (int i=0; i<NUM_DESCS; i++)\n\t\tif (desc[i].in_use) {\n\t\t\tuint32 tm = desc[i].task;\n\t\t\tif ((ReadMacInt16(tm + qType) & 0x8000) && timer_cmp_time(desc[i].wakeup, now) < 0) {\n\n\t\t\t\t// Found one, mark as inactive and remove it from the Time Manager queue\n\t\t\t\tWriteMacInt16(tm + qType, ReadMacInt16(tm + qType) & 0x7fff);\n\t\t\t\tdequeue_tm(tm);\n\n\t\t\t\t// Call timer function\n\t\t\t\tuint32 addr = ReadMacInt32(tm + tmAddr);\n\t\t\t\tif (addr) {\n\t\t\t\t\tD(bug(\"Calling TimeTask %08lx, addr %08lx\\n\", tm, addr));\n\t\t\t\t\tM68kRegisters r;\n\t\t\t\t\tr.a[0] = addr;\n\t\t\t\t\tr.a[1] = tm;\n\t\t\t\t\tExecute68k(addr, &r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\n","/*\n *  audio_oss_esd.cpp - Audio support, implementation for OSS and ESD (Linux and FreeBSD)\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"sysdeps.h\"\n\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <pthread.h>\n#include <semaphore.h>\n\n#ifdef __linux__\n#include <linux/soundcard.h>\n#endif\n\n#ifdef __FreeBSD__\n#include <sys/soundcard.h>\n#endif\n\n#include \"cpu_emulation.h\"\n#include \"main.h\"\n#include \"prefs.h\"\n#include \"user_strings.h\"\n#include \"audio.h\"\n#include \"audio_defs.h\"\n\n#ifdef ENABLE_ESD\n#include <esd.h>\n#endif\n\n#ifdef EMSCRIPTEN\n#include <emscripten.h>\n#endif\n\n#define BROWSER_AUDIO 1\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n// The currently selected audio parameters (indices in audio_sample_rates[] etc. vectors)\nstatic int audio_sample_rate_index = 0;\nstatic int audio_sample_size_index = 0;\nstatic int audio_channel_count_index = 0;\n\n// Global variables\nstatic bool is_dsp_audio = false;\t\t\t\t\t// Flag: is DSP audio\nstatic int audio_fd = -1;\t\t\t\t\t\t\t// fd of dsp or ESD\nstatic int mixer_fd = -1;\t\t\t\t\t\t\t// fd of mixer\nstatic sem_t audio_irq_done_sem;\t\t\t\t\t// Signal from interrupt to streaming thread: data block read\nstatic bool sem_inited = false;\t\t\t\t\t\t// Flag: audio_irq_done_sem initialized\nstatic int sound_buffer_size;\t\t\t\t\t\t// Size of sound buffer in bytes\nstatic bool little_endian = false;\t\t\t\t\t// Flag: DSP accepts only little-endian 16-bit sound data\nstatic uint8 silence_byte;\t\t\t\t\t\t\t// Byte value to use to fill sound buffers with silence\nstatic pthread_t stream_thread;\t\t\t\t\t\t// Audio streaming thread\nstatic pthread_attr_t stream_thread_attr;\t\t\t// Streaming thread attributes\nstatic bool stream_thread_active = false;\t\t\t// Flag: streaming thread installed\nstatic volatile bool stream_thread_cancel = false;\t// Flag: cancel streaming thread\n\n// Prototypes\nstatic void *stream_func(void *arg);\nstatic ssize_t audio_write(int audio_fd, const void *buf, size_t buf_nbytes);\n\n\n/*\n *  Initialization\n */\n\n// Set AudioStatus to reflect current audio stream format\nstatic void set_audio_status_format(void)\n{\n\tAudioStatus.sample_rate = audio_sample_rates[audio_sample_rate_index];\n\tAudioStatus.sample_size = audio_sample_sizes[audio_sample_size_index];\n\tAudioStatus.channels = audio_channel_counts[audio_channel_count_index];\n}\n\n// Init using the dsp device, returns false on error\nstatic bool open_dsp(void)\n{\n\t#ifndef BROWSER_AUDIO\n\t// Open the device\n\tconst char *dsp = PrefsFindString(\"dsp\");\n\taudio_fd = open(dsp, O_WRONLY);\n\tif (audio_fd < 0) {\n\t\tfprintf(stderr, \"WARNING: Cannot open %s (%s)\\n\", dsp, strerror(errno));\n\t\treturn false;\n\t}\n\n\tprintf(\"Using %s audio output\\n\", dsp);\n\tis_dsp_audio = true;\n\n\t// Get supported sample formats\n\tif (audio_sample_sizes.empty()) {\n\t\tunsigned long format;\n\t\tioctl(audio_fd, SNDCTL_DSP_GETFMTS, &format);\n\t\tif (format & AFMT_U8)\n\t\t\taudio_sample_sizes.push_back(8);\n\t\tif (format & (AFMT_S16_BE | AFMT_S16_LE))\n\t\t\taudio_sample_sizes.push_back(16);\n\n\t\tint stereo = 0;\n\t\tif (ioctl(audio_fd, SNDCTL_DSP_STEREO, &stereo) == 0 && stereo == 0)\n\t\t\taudio_channel_counts.push_back(1);\n\t\tstereo = 1;\n\t\tif (ioctl(audio_fd, SNDCTL_DSP_STEREO, &stereo) == 0 && stereo == 1)\n\t\t\taudio_channel_counts.push_back(2);\n\n\t\tif (audio_sample_sizes.empty() || audio_channel_counts.empty()) {\n\t\t\tWarningAlert(GetString(STR_AUDIO_FORMAT_WARN));\n\t\t\tclose(audio_fd);\n\t\t\taudio_fd = -1;\n\t\t\treturn false;\n\t\t}\n\n\t\taudio_sample_rates.push_back(11025 << 16);\n\t\taudio_sample_rates.push_back(22050 << 16);\n\t\tint rate = 44100;\n\t\tioctl(audio_fd, SNDCTL_DSP_SPEED, &rate);\n\t\tif (rate > 22050)\n\t\t\taudio_sample_rates.push_back(rate << 16);\n\n\t\t// Default to highest supported values\n\t\taudio_sample_rate_index = audio_sample_rates.size() - 1;\n\t\taudio_sample_size_index = audio_sample_sizes.size() - 1;\n\t\taudio_channel_count_index = audio_channel_counts.size() - 1;\n\t}\n\n\t// Set DSP parameters\n\tunsigned long format;\n\tif (audio_sample_sizes[audio_sample_size_index] == 8) {\n\t\tformat = AFMT_U8;\n\t\tlittle_endian = false;\n\t\tsilence_byte = 0x80;\n\t} else {\n\t\tunsigned long sup_format;\n\t\tioctl(audio_fd, SNDCTL_DSP_GETFMTS, &sup_format);\n\t\tif (sup_format & AFMT_S16_BE) {\n\t\t\tlittle_endian = false;\n\t\t\tformat = AFMT_S16_BE;\n\t\t} else {\n\t\t\tlittle_endian = true;\n\t\t\tformat = AFMT_S16_LE;\n\t\t}\n\t\tsilence_byte = 0;\n\t}\n\tioctl(audio_fd, SNDCTL_DSP_SETFMT, &format);\n\tint frag = 0x0004000c;\t\t// Block size: 4096 frames\n\tioctl(audio_fd, SNDCTL_DSP_SETFRAGMENT, &frag);\n\tint stereo = (audio_channel_counts[audio_channel_count_index] == 2);\n\tioctl(audio_fd, SNDCTL_DSP_STEREO, &stereo);\n\tint rate = audio_sample_rates[audio_sample_rate_index] >> 16;\n\tioctl(audio_fd, SNDCTL_DSP_SPEED, &rate);\n\n\t// Get sound buffer size\n\tioctl(audio_fd, SNDCTL_DSP_GETBLKSIZE, &audio_frames_per_block);\n\tD(bug(\"DSP_GETBLKSIZE %d\\n\", audio_frames_per_block));\n\t#endif\n\treturn true;\n}\n\n\n// Init using the js device, returns false on error\nstatic bool open_js(void)\n{\n\n#if WORDS_BIGENDIAN\n\tlittle_endian = false;\n#else\n\tlittle_endian = true;\n#endif\n\tsilence_byte = 0;\t// Is this correct for 8-bit mode?\n\n\t// fake some stuff\n\taudio_fd = 69;\n\n\tprintf(\"Using JS audio output\\n\");\n\n\t// JS supports a variety of twisted little audio formats, all different\n\tif (audio_sample_sizes.empty()) {\n\n\t\t// The reason we do this here is that we don't want to add sample\n\t\t// rates etc. unless the JS connection could be opened\n\t\t// (if JS fails, dsp might be tried next)\n\t\t// audio_sample_rates.push_back(11025 << 16);\n\t\taudio_sample_rates.push_back(22050 << 16);\n\t\t// audio_sample_rates.push_back(44100 << 16);\n\t\t// audio_sample_sizes.push_back(8);\n\t\taudio_sample_sizes.push_back(16);\n\t\taudio_channel_counts.push_back(1);\n\t\t// audio_channel_counts.push_back(2);\n\n\t\t// Default to highest supported values\n\t\taudio_sample_rate_index = audio_sample_rates.size() - 1;\n\t\taudio_sample_size_index = audio_sample_sizes.size() - 1;\n\t\taudio_channel_count_index = audio_channel_counts.size() - 1;\n\t}\n\n\t// Sound buffer size = 4096 frames\n\taudio_frames_per_block = 4096;\n\n\n\tint opt_sr = (audio_sample_rates[audio_sample_rate_index] >> 16);\n\tint opt_ss = audio_sample_sizes[audio_sample_size_index];\n\tint opt_ch = audio_channel_counts[audio_channel_count_index];\n\n#if defined(EMSCRIPTEN) && !defined(__EMSCRIPTEN_PTHREADS__)\n\tEM_ASM_({\n\n  \tModule.openAudio($0, $1, $2, $3);\n\n\t}, opt_sr, opt_ss, opt_ch, audio_frames_per_block);\n#endif\n\n\treturn true;\n}\n\n// Init using ESD, returns false on error\nstatic bool open_esd(void)\n{\n#ifdef ENABLE_ESD\n\tint rate;\n\tesd_format_t format = ESD_STREAM | ESD_PLAY;\n\n\tif (audio_sample_sizes.empty()) {\n\n\t\t// Default values\n\t\trate = 44100;\n\t\tformat |= (ESD_BITS16 | ESD_STEREO);\n\n\t} else {\n\n\t\trate = audio_sample_rates[audio_sample_rate_index] >> 16;\n\t\tif (audio_sample_sizes[audio_sample_size_index] == 8)\n\t\t\tformat |= ESD_BITS8;\n\t\telse\n\t\t\tformat |= ESD_BITS16;\n\t\tif (audio_channel_counts[audio_channel_count_index] == 1)\n\t\t\tformat |= ESD_MONO;\n\t\telse\n\t\t\tformat |= ESD_STEREO;\n\t}\n\n#if WORDS_BIGENDIAN\n\tlittle_endian = false;\n#else\n\tlittle_endian = true;\n#endif\n\tsilence_byte = 0;\t// Is this correct for 8-bit mode?\n\n\t// Open connection to ESD server\n\taudio_fd = esd_play_stream(format, rate, NULL, NULL);\n\tif (audio_fd < 0) {\n\t\tfprintf(stderr, \"WARNING: Cannot open ESD connection\\n\");\n\t\treturn false;\n\t}\n\n\tprintf(\"Using ESD audio output\\n\");\n\n\t// ESD supports a variety of twisted little audio formats, all different\n\tif (audio_sample_sizes.empty()) {\n\n\t\t// The reason we do this here is that we don't want to add sample\n\t\t// rates etc. unless the ESD server connection could be opened\n\t\t// (if ESD fails, dsp might be tried next)\n\t\taudio_sample_rates.push_back(11025 << 16);\n\t\taudio_sample_rates.push_back(22050 << 16);\n\t\taudio_sample_rates.push_back(44100 << 16);\n\t\taudio_sample_sizes.push_back(8);\n\t\taudio_sample_sizes.push_back(16);\n\t\taudio_channel_counts.push_back(1);\n\t\taudio_channel_counts.push_back(2);\n\n\t\t// Default to highest supported values\n\t\taudio_sample_rate_index = audio_sample_rates.size() - 1;\n\t\taudio_sample_size_index = audio_sample_sizes.size() - 1;\n\t\taudio_channel_count_index = audio_channel_counts.size() - 1;\n\t}\n\n\t// Sound buffer size = 4096 frames\n\taudio_frames_per_block = 4096;\n\treturn true;\n#else\n\t// ESD is not enabled, shut up the compiler\n\treturn false;\n#endif\n}\n\nstatic bool open_audio(void)\n{\n\tprintf(\"open_audio\\n\");\n#ifdef BROWSER_AUDIO\n\t\tif (open_js())\n\t\t\tgoto dev_opened;\n\treturn false;\n#endif\n\n#ifdef ENABLE_ESD\n\t// If ESPEAKER is set, the user probably wants to use ESD, so try that first\n\tif (getenv(\"ESPEAKER\"))\n\t\tif (open_esd())\n\t\t\tgoto dev_opened;\n#endif\n\n\t// Try to open dsp\n\tif (open_dsp())\n\t\tgoto dev_opened;\n\n#ifdef ENABLE_ESD\n\t// Hm, dsp failed so we try ESD again if ESPEAKER wasn't set\n\tif (!getenv(\"ESPEAKER\"))\n\t\tif (open_esd())\n\t\t\tgoto dev_opened;\n#endif\n\n\t// No audio device succeeded\n\tWarningAlert(GetString(STR_NO_AUDIO_WARN));\n\treturn false;\n\n\t// Device opened, set AudioStatus\ndev_opened:\n\tsound_buffer_size = (audio_sample_sizes[audio_sample_size_index] >> 3) * audio_channel_counts[audio_channel_count_index] * audio_frames_per_block;\n\tset_audio_status_format();\n\n\t#if defined(BROWSER_AUDIO) && !defined(__EMSCRIPTEN_PTHREADS__)\n\t\t// ???\n\t\tprintf(\"audio would be happening now\\n\");\n\t#else\n\tprintf(\"starting stream_thread\\n\");\n\t// Start streaming thread\n\tSet_pthread_attr(&stream_thread_attr, 0);\n\tstream_thread_active = (pthread_create(&stream_thread, &stream_thread_attr, stream_func, NULL) == 0);\n\tprintf(\"stream_thread_active %d\\n\", stream_thread_active);\n\t#endif\n\n\t// Everything went fine\n\taudio_open = true;\n\treturn true;\n}\n\nvoid AudioInit(void)\n{\n\tprintf(\"AudioInit\\n\");\n\t// Init audio status (reasonable defaults) and feature flags\n\tAudioStatus.sample_rate = 44100 << 16;\n\tAudioStatus.sample_size = 16;\n\tAudioStatus.channels = 2;\n\tAudioStatus.mixer = 0;\n\tAudioStatus.num_sources = 0;\n\taudio_component_flags = cmpWantsRegisterMessage | kStereoOut | k16BitOut;\n\n\t// Sound disabled in prefs? Then do nothing\n\tif (PrefsFindBool(\"nosound\"))\n\t\treturn;\n\n\t// Init semaphore\n\tif (sem_init(&audio_irq_done_sem, 0, 0) < 0)\n\t\treturn;\n\tsem_inited = true;\n\n\t// Try to open the mixer device\n\tconst char *mixer = PrefsFindString(\"mixer\");\n\tmixer_fd = open(mixer, O_RDWR);\n\tif (mixer_fd < 0)\n\t\tprintf(\"WARNING: Cannot open %s (%s)\\n\", mixer, strerror(errno));\n\n\t// Open and initialize audio device\n\topen_audio();\n}\n\n\n/*\n *  Deinitialization\n */\n\nstatic void close_audio(void)\n{\n\tprintf(\"close_audio\\n\");\n\t// Stop stream and delete semaphore\n\tif (stream_thread_active) {\n\t\tstream_thread_cancel = true;\n#ifdef HAVE_PTHREAD_CANCEL\n\t\tpthread_cancel(stream_thread);\n#endif\n\t\tpthread_join(stream_thread, NULL);\n\t\tstream_thread_active = false;\n\t}\n\n\t// Close dsp or ESD socket\n\tif (audio_fd >= 0) {\n\t\tclose(audio_fd);\n\t\taudio_fd = -1;\n\t}\n\n\taudio_open = false;\n}\n\nvoid AudioExit(void)\n{\n\tprintf(\"AudioExit\\n\");\n\t// Stop the device immediately. Otherwise, close() sends\n\t// SNDCTL_DSP_SYNC, which may hang\n\t#ifndef BROWSER_AUDIO\n\tif (is_dsp_audio)\n\t\tioctl(audio_fd, SNDCTL_DSP_RESET, 0);\n\t#endif\n\n\t// Close audio device\n\tclose_audio();\n\n\t// Delete semaphore\n\tif (sem_inited) {\n\t\tsem_destroy(&audio_irq_done_sem);\n\t\tsem_inited = false;\n\t}\n\n\t// Close mixer device\n\tif (mixer_fd >= 0) {\n\t\tclose(mixer_fd);\n\t\tmixer_fd = -1;\n\t}\n}\n\n\n/*\n *  First source added, start audio stream\n */\n\nvoid audio_enter_stream()\n{\n\t// Streaming thread is always running to avoid clicking noises\n}\n\n\n/*\n *  Last source removed, stop audio stream\n */\n\nvoid audio_exit_stream()\n{\n\t// Streaming thread is always running to avoid clicking noises\n}\n\nstatic int blocks_to_skip = 0;\n\nvoid audio_write_blocks(int blocks_to_write)\n{\n\n\twhile (blocks_to_skip > 0 && blocks_to_write > 0) {\n\t\tblocks_to_write--;\n\t\tblocks_to_skip--;\n\t}\n\tif (blocks_to_write == 0) {\n\t\tprintf(\"audio_write_blocks early return\\n\");\n\t\treturn;\n\t}\n\t\n\tint failed_to_write = false;\n\tsize_t bytes_written = 0;\n\tint blocks_written = 0;\n\n\t// printf(\"stream_func\\n\");\n\tint16 *silent_buffer = new int16[sound_buffer_size / 2];\n\tint16 *last_buffer = new int16[sound_buffer_size / 2];\n\tmemset(silent_buffer, silence_byte, sound_buffer_size);\n\n\twhile (blocks_written < blocks_to_write) {\n\t\tif (AudioStatus.num_sources) {\n\t#ifdef EMSCRIPTEN\n\t\taudio_fd = 99;\n\t#endif\n\n\t\t\t// Trigger audio interrupt to get new buffer\n\t\t\tD(bug(\"stream: triggering irq\\n\"));\n\t\t\tSetInterruptFlag(INTFLAG_AUDIO);\n\t\t\tTriggerInterrupt();\n\t\t\tD(bug(\"stream: waiting for ack\\n\"));\n\t\t\tsem_wait(&audio_irq_done_sem);\n\t\t\tD(bug(\"stream: ack received\\n\"));\n\n\t\t\t// Get size of audio data\n\t\t\tuint32 apple_stream_info = ReadMacInt32(audio_data + adatStreamInfo);\n\t\t\tif (apple_stream_info) {\n\t\t\t\tint work_size = ReadMacInt32(apple_stream_info + scd_sampleCount) * (AudioStatus.sample_size >> 3) * AudioStatus.channels;\n\t\t\t\tD(bug(\"stream: work_size %d\\n\", work_size));\n\t\t\t\tif (work_size > sound_buffer_size)\n\t\t\t\t\twork_size = sound_buffer_size;\n\t\t\t\tif (work_size == 0)\n\t\t\t\t\tgoto silence;\n\n\t\t\t\t// Send data to DSP\n\t\t\t\tif (work_size == sound_buffer_size && !little_endian)\n\t\t\t\t\tbytes_written = audio_write(audio_fd, Mac2HostAddr(ReadMacInt32(apple_stream_info + scd_buffer)), sound_buffer_size);\n\t\t\t\telse {\n\t\t\t\t\t// Last buffer or little-endian DSP\n\t\t\t\t\tif (little_endian) {\n\t\t\t\t\t\tint16 *p = (int16 *)Mac2HostAddr(ReadMacInt32(apple_stream_info + scd_buffer));\n\t\t\t\t\t\tfor (int i=0; i<work_size/2; i++)\n\t\t\t\t\t\t\tlast_buffer[i] = ntohs(p[i]);\n\t\t\t\t\t} else\n\t\t\t\t\t\tMac2Host_memcpy(last_buffer, ReadMacInt32(apple_stream_info + scd_buffer), work_size);\n\t\t\t\t\tmemset((uint8 *)last_buffer + work_size, silence_byte, sound_buffer_size - work_size);\n\t\t\t\t\tbytes_written = audio_write(audio_fd, last_buffer, sound_buffer_size);\n\t\t\t\t}\n\t\t\t\tD(bug(\"stream: data written\\n\"));\n\t\t\t} else\n\t\t\t\tgoto silence;\n\n\t\t} else {\n\n\t\t\t// Audio not active, play silence\nsilence:\n\t#ifdef EMSCRIPTEN\n\t\taudio_fd = 1;\n\t#endif\n\tbytes_written = audio_write(audio_fd, silent_buffer, sound_buffer_size);\n\n\n\t\t\t\tD(bug(\"stream: silence written\\n\"));\n\t\t}\n\t\tif (bytes_written == 0) {\n\t\t\tfailed_to_write = true;\n\t\t\tbreak;\n\t\t}\n\t\tblocks_written++;\n\t}\n\tdelete[] silent_buffer;\n\tdelete[] last_buffer;\n\n\tif (failed_to_write) {\n\t\tblocks_to_skip = 3;\n\t\tprintf(\"blocks_to_skip=%d\\n\", blocks_to_skip);\n\t}\n}\n\n/*\n *  Streaming function\n */\n\nstatic void *stream_func(void *arg)\n{\n\tprintf(\"stream_func\\n\");\n\tint16 *silent_buffer = new int16[sound_buffer_size / 2];\n\tint16 *last_buffer = new int16[sound_buffer_size / 2];\n\tmemset(silent_buffer, silence_byte, sound_buffer_size);\n\n\twhile (!stream_thread_cancel) {\n\t\tif (AudioStatus.num_sources) {\n\n\t\t\t// Trigger audio interrupt to get new buffer\n\t\t\tD(bug(\"stream: triggering irq\\n\"));\n\t\t\tSetInterruptFlag(INTFLAG_AUDIO);\n\t\t\tTriggerInterrupt();\n\t\t\tD(bug(\"stream: waiting for ack\\n\"));\n\t\t\tsem_wait(&audio_irq_done_sem);\n\t\t\tD(bug(\"stream: ack received\\n\"));\n\n\t\t\t// Get size of audio data\n\t\t\tuint32 apple_stream_info = ReadMacInt32(audio_data + adatStreamInfo);\n\t\t\tif (apple_stream_info) {\n\t\t\t\tint work_size = ReadMacInt32(apple_stream_info + scd_sampleCount) * (AudioStatus.sample_size >> 3) * AudioStatus.channels;\n\t\t\t\tD(bug(\"stream: work_size %d\\n\", work_size));\n\t\t\t\tif (work_size > sound_buffer_size)\n\t\t\t\t\twork_size = sound_buffer_size;\n\t\t\t\tif (work_size == 0)\n\t\t\t\t\tgoto silence;\n\n\t\t\t\t// Send data to DSP\n\t\t\t\tif (work_size == sound_buffer_size && !little_endian)\n\t\t\t\t\taudio_write(audio_fd, Mac2HostAddr(ReadMacInt32(apple_stream_info + scd_buffer)), sound_buffer_size);\n\t\t\t\telse {\n\t\t\t\t\t// Last buffer or little-endian DSP\n\t\t\t\t\tif (little_endian) {\n\t\t\t\t\t\tint16 *p = (int16 *)Mac2HostAddr(ReadMacInt32(apple_stream_info + scd_buffer));\n\t\t\t\t\t\tfor (int i=0; i<work_size/2; i++)\n\t\t\t\t\t\t\tlast_buffer[i] = ntohs(p[i]);\n\t\t\t\t\t} else\n\t\t\t\t\t\tMac2Host_memcpy(last_buffer, ReadMacInt32(apple_stream_info + scd_buffer), work_size);\n\t\t\t\t\tmemset((uint8 *)last_buffer + work_size, silence_byte, sound_buffer_size - work_size);\n\t\t\t\t\taudio_write(audio_fd, last_buffer, sound_buffer_size);\n\t\t\t\t}\n\t\t\t\tD(bug(\"stream: data written\\n\"));\n\t\t\t} else\n\t\t\t\tgoto silence;\n\n\t\t} else {\n\n\t\t\t// Audio not active, play silence\nsilence:\taudio_write(audio_fd, silent_buffer, sound_buffer_size);\n\t\t}\n\t}\n\tdelete[] silent_buffer;\n\tdelete[] last_buffer;\n\treturn NULL;\n}\n\nstatic ssize_t audio_write(int audio_fd, const void *buf, size_t buf_nbytes) {\n\t#ifdef BROWSER_AUDIO\n\t\t#ifdef EMSCRIPTEN\n\t\t\treturn EM_ASM_INT({\n\t\t\t\treturn Module.enqueueAudio($0, $1, $2);\n\t\t\t}, buf, buf_nbytes, audio_fd);\n\t\t#endif\n\n\t\treturn 0;\n\t#else\n\n\treturn write(audio_fd, buf, buf_nbytes);\n\t#endif\n}\n\n\n/*\n *  MacOS audio interrupt, read next data block\n */\n\nvoid AudioInterrupt(void)\n{\n\tD(bug(\"AudioInterrupt\\n\"));\n\n\t// Get data from apple mixer\n\tif (AudioStatus.mixer) {\n\t\tM68kRegisters r;\n\t\tr.a[0] = audio_data + adatStreamInfo;\n\t\tr.a[1] = AudioStatus.mixer;\n\t\tExecute68k(audio_data + adatGetSourceData, &r);\n\t\tD(bug(\" GetSourceData() returns %08lx\\n\", r.d[0]));\n\t} else\n\t\tWriteMacInt32(audio_data + adatStreamInfo, 0);\n\n\t// Signal stream function\n\tsem_post(&audio_irq_done_sem);\n\tD(bug(\"AudioInterrupt done\\n\"));\n}\n\n\n/*\n *  Set sampling parameters\n *  \"index\" is an index into the audio_sample_rates[] etc. vectors\n *  It is guaranteed that AudioStatus.num_sources == 0\n */\n\nbool audio_set_sample_rate(int index)\n{\n\tclose_audio();\n\taudio_sample_rate_index = index;\n\treturn open_audio();\n}\n\nbool audio_set_sample_size(int index)\n{\n\tclose_audio();\n\taudio_sample_size_index = index;\n\treturn open_audio();\n}\n\nbool audio_set_channels(int index)\n{\n\tclose_audio();\n\taudio_channel_count_index = index;\n\treturn open_audio();\n}\n\n\n/*\n *  Get/set volume controls (volume values received/returned have the left channel\n *  volume in the upper 16 bits and the right channel volume in the lower 16 bits;\n *  both volumes are 8.8 fixed point values with 0x0100 meaning \"maximum volume\"))\n */\n\nbool audio_get_main_mute(void)\n{\n\treturn false;\n}\n\nuint32 audio_get_main_volume(void)\n{\n\t#ifndef BROWSER_AUDIO\n\tif (mixer_fd >= 0) {\n\t\tint vol;\n\t\tif (ioctl(mixer_fd, SOUND_MIXER_READ_PCM, &vol) == 0) {\n\t\t\tint left = vol >> 8;\n\t\t\tint right = vol & 0xff;\n\t\t\treturn ((left * 256 / 100) << 16) | (right * 256 / 100);\n\t\t}\n\t}\n\t#endif\n\treturn 0x01000100;\n}\n\nbool audio_get_speaker_mute(void)\n{\n\treturn false;\n}\n\nuint32 audio_get_speaker_volume(void)\n{\n\t#ifndef BROWSER_AUDIO\n\tif (mixer_fd >= 0) {\n\t\tint vol;\n\t\tif (ioctl(mixer_fd, SOUND_MIXER_READ_VOLUME, &vol) == 0) {\n\t\t\tint left = vol >> 8;\n\t\t\tint right = vol & 0xff;\n\t\t\treturn ((left * 256 / 100) << 16) | (right * 256 / 100);\n\t\t}\n\t}\n\t#endif\n\treturn 0x01000100;\n}\n\nvoid audio_set_main_mute(bool mute)\n{\n}\n\nvoid audio_set_main_volume(uint32 vol)\n{\n\t#ifndef BROWSER_AUDIO\n\tif (mixer_fd >= 0) {\n\t\tint left = vol >> 16;\n\t\tint right = vol & 0xffff;\n\t\tint p = ((left * 100 / 256) << 8) | (right * 100 / 256);\n\t\tioctl(mixer_fd, SOUND_MIXER_WRITE_PCM, &p);\n\t}\n\t#endif\n}\n\nvoid audio_set_speaker_mute(bool mute)\n{\n}\n\nvoid audio_set_speaker_volume(uint32 vol)\n{\n\t#ifndef BROWSER_AUDIO\n\tif (mixer_fd >= 0) {\n\t\tint left = vol >> 16;\n\t\tint right = vol & 0xffff;\n\t\tint p = ((left * 100 / 256) << 8) | (right * 100 / 256);\n\t\tioctl(mixer_fd, SOUND_MIXER_WRITE_VOLUME, &p);\n\t}\n\t#endif\n}\n","/*\n *  scsi.cpp - SCSI Manager\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/*\n *  SEE ALSO\n *    Inside Macintosh: Devices, chapter 3 \"SCSI Manager\"\n *    Technote DV 24: \"Fear No SCSI\"\n */\n\n#include <stdio.h>\n#include <string.h>\n\n#include \"sysdeps.h\"\n#include \"cpu_emulation.h\"\n#include \"main.h\"\n#include \"user_strings.h\"\n#include \"scsi.h\"\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n// Error codes\nenum {\n\tscCommErr = 2,\n\tscArbNBErr,\n\tscBadParmsErr,\n\tscPhaseErr,\n\tscCompareErr,\n\tscMgrBusyErr,\n\tscSequenceErr,\n\tscBusTOErr,\n\tscComplPhaseErr\n};\n\n// TIB opcodes\nenum {\n\tscInc = 1,\n\tscNoInc,\n\tscAdd,\n\tscMove,\n\tscLoop,\n\tscNop,\n\tscStop,\n\tscComp\n};\n\n// Logical SCSI phases\nenum {\n\tPH_FREE,\t\t// Bus free\n\tPH_ARBITRATED,\t// Bus arbitrated (after SCSIGet())\n\tPH_SELECTED,\t// Target selected (after SCSISelect())\n\tPH_TRANSFER\t\t// Command sent (after SCSICmd())\n};\n\n// Global variables\nstatic int target_id;\t\t\t\t\t// ID of active target\nstatic int phase;\t\t\t\t\t\t// Logical SCSI phase\nstatic uint16 fake_status;\t\t\t\t// Faked 5830 status word\nstatic bool reading;\t\t\t\t\t// Flag: reading from device\n\nconst int SG_TABLE_SIZE = 1024;\nstatic int sg_index;\t\t\t\t\t// Index of first unused entry in S/G table\nstatic uint8 *sg_ptr[SG_TABLE_SIZE];\t// Scatter/gather table data pointer (host address space)\nstatic uint32 sg_len[SG_TABLE_SIZE];\t// Scatter/gather table data length\nstatic uint32 sg_total_length;\t\t\t// Total data length\n\n\n/*\n *  Execute TIB, constructing S/G table\n */\n\nstatic int16 exec_tib(uint32 tib)\n{\n\tfor (;;) {\n\n\t\t// Read next opcode and parameters\n\t\tuint16 cmd = ReadMacInt16(tib); tib += 2;\n\t\tuint32 ptr = ReadMacInt32(tib); tib += 4;\n\t\tuint32 len = ReadMacInt32(tib); tib += 4;\n\n#if DEBUG\n\t\tconst char *cmd_str;\n\t\tswitch (cmd) {\n\t\t\tcase scInc:   cmd_str = \"INC  \"; break;\n\t\t\tcase scNoInc: cmd_str = \"NOINC\"; break;\n\t\t\tcase scAdd:   cmd_str = \"ADD  \"; break;\n\t\t\tcase scMove:  cmd_str = \"MOVE \"; break;\n\t\t\tcase scLoop:  cmd_str = \"LOOP \"; break;\n\t\t\tcase scNop:   cmd_str = \"NOP  \"; break;\n\t\t\tcase scStop:  cmd_str = \"STOP \"; break;\n\t\t\tcase scComp:  cmd_str = \"COMP \"; break;\n\t\t\tdefault:      cmd_str = \"???  \"; break;\n\t\t}\n\t\tD(bug(\" %s(%d) %08x %d\\n\", cmd_str, cmd, ptr, len));\n#endif\n\n\t\tswitch (cmd) {\n\t\t\tcase scInc:\n\t\t\t\tWriteMacInt32(tib - 8, ptr + len);\n\t\t\t\t// fall through to scNoInc\n\t\t\tcase scNoInc:\n\t\t\t\tif ((sg_index > 0) && (Mac2HostAddr(ptr) == sg_ptr[sg_index-1] + sg_len[sg_index-1])) {\n\t\t\t\t\tsg_len[sg_index-1] += len;\t\t\t\t// Merge to previous entry\n\t\t\t\t} else {\n\t\t\t\t\tif (sg_index == SG_TABLE_SIZE) {\n\t\t\t\t\t\tErrorAlert(GetString(STR_SCSI_SG_FULL_ERR));\n\t\t\t\t\t\treturn -108;\n\t\t\t\t\t}\n\t\t\t\t\tsg_ptr[sg_index] = Mac2HostAddr(ptr);\t// Create new entry\n\t\t\t\t\tsg_len[sg_index] = len;\n\t\t\t\t\tsg_index++;\n\t\t\t\t}\n\t\t\t\tsg_total_length += len;\n\t\t\t\tbreak;\n\n\t\t\tcase scAdd:\n\t\t\t\tWriteMacInt32(ptr, ReadMacInt32(ptr) + len);\n\t\t\t\tbreak;\n\n\t\t\tcase scMove:\n\t\t\t\tWriteMacInt32(len, ReadMacInt32(ptr));\n\t\t\t\tbreak;\n\n\t\t\tcase scLoop:\n\t\t\t\tWriteMacInt32(tib - 4, len - 1);\n\t\t\t\tif (len - 1 > 0)\n\t\t\t\t\ttib += (int32)ptr - 10;\n\t\t\t\tbreak;\n\n\t\t\tcase scNop:\n\t\t\t\tbreak;\n\n\t\t\tcase scStop:\n\t\t\t\treturn 0;\n\n\t\t\tcase scComp:\n\t\t\t\tprintf(\"WARNING: Unimplemented scComp opcode\\n\");\n\t\t\t\treturn scCompareErr;\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"FATAL: Unrecognized TIB opcode %d\\n\", cmd);\n\t\t\t\treturn scBadParmsErr;\n\t\t}\n\t}\n}\n\n\n/*\n *  Reset SCSI bus\n */\n\nint16 SCSIReset(void)\n{\n\tD(bug(\"SCSIReset\\n\"));\n\n\tphase = PH_FREE;\n\tfake_status = 0x0000;\t// Bus free\n\tsg_index = 0;\n\ttarget_id = 8;\n\treturn 0;\n}\n\n\n/*\n *  Arbitrate bus\n */\n\nint16 SCSIGet(void)\n{\n\tD(bug(\"SCSIGet\\n\"));\n\tif (phase != PH_FREE)\n\t\treturn scMgrBusyErr;\n\n\tphase = PH_ARBITRATED;\n\tfake_status = 0x0040;\t// Bus busy\n\treading = false;\n\tsg_index = 0;\t\t\t// Flush S/G table\n\tsg_total_length = 0;\n\treturn 0;\n}\n\n\n/*\n *  Select SCSI device\n */\n\nint16 SCSISelect(int id)\n{\n\tD(bug(\"SCSISelect %d\\n\", id));\n\tif (phase != PH_ARBITRATED)\n\t\treturn scSequenceErr;\n\n\t// ID valid?\n\tif (id < 0 || id > 7)\n\t\treturn scBadParmsErr;\n\n\t// Target present?\n\ttarget_id = id;\n\tif (!scsi_is_target_present(target_id)) {\n\t\tphase = PH_FREE;\n\t\tfake_status = 0x0000;\t// Bus free\n\t\treturn scCommErr;\n\t}\n\n\tphase = PH_SELECTED;\n\tfake_status = 0x006a;\t\t// Target selected, command phase\n\treturn 0;\n}\n\n\n/*\n *  Send SCSI command\n */\n\nint16 SCSICmd(int cmd_length, uint8 *cmd)\n{\n#if DEBUG\n\tswitch (cmd_length) {\n\t\tcase 6:\n\t\t\tD(bug(\"SCSICmd len 6, cmd %02x %02x %02x %02x %02x %02x\\n\", cmd[0], cmd[1], cmd[2], cmd[3], cmd[4], cmd[5]));\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tD(bug(\"SCSICmd len 10, cmd %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\\n\", cmd[0], cmd[1], cmd[2], cmd[3], cmd[4], cmd[5], cmd[6], cmd[7], cmd[8], cmd[9]));\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tD(bug(\"SCSICmd len 12, cmd %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\\n\", cmd[0], cmd[1], cmd[2], cmd[3], cmd[4], cmd[5], cmd[6], cmd[7], cmd[8], cmd[9], cmd[10], cmd[11]));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tD(bug(\"SCSICmd bogus length %d\\n\", cmd_length));\n\t\t\tbreak;\n\t}\n#endif\n\n\tif (phase != PH_SELECTED)\n\t\treturn scPhaseErr;\n\n\t// Commdn length valid?\n\tif (cmd_length != 6 && cmd_length != 10 && cmd_length != 12)\n\t\treturn scBadParmsErr;\n\n\t// Set command, extract LUN\n\tscsi_set_cmd(cmd_length, cmd);\n\n\t// Extract LUN, set target\n\tif (!scsi_set_target(target_id, (cmd[1] >> 5) & 7)) {\n\t\tphase = PH_FREE;\n\t\tfake_status = 0x0000;\t// Bus free\n\t\treturn scCommErr;\n\t}\n\n\tphase = PH_TRANSFER;\n\tfake_status = 0x006e;\t\t// Target selected, data phase\n\treturn 0;\n}\n\n\n/*\n *  Read data\n */\n\nint16 SCSIRead(uint32 tib)\n{\n\tD(bug(\"SCSIRead TIB %08lx\\n\", tib));\n\tif (phase != PH_TRANSFER)\n\t\treturn scPhaseErr;\n\n\t// Execute TIB, fill S/G table\n\treading = true;\n\treturn exec_tib(tib);\n}\n\n\n/*\n *  Write data\n */\n\nint16 SCSIWrite(uint32 tib)\n{\n\tD(bug(\"SCSIWrite TIB %08lx\\n\", tib));\n\tif (phase != PH_TRANSFER)\n\t\treturn scPhaseErr;\n\n\t// Execute TIB, fill S/G table\n\treturn exec_tib(tib);\n}\n\n\n/*\n *  Wait for command completion (we're actually doing everything in here...)\n */\n\nint16 SCSIComplete(uint32 timeout, uint32 message, uint32 stat)\n{\n\tD(bug(\"SCSIComplete wait %d, msg %08lx, stat %08lx\\n\", timeout, message, stat));\n\tWriteMacInt16(message, 0);\n\tif (phase != PH_TRANSFER)\n\t\treturn scPhaseErr;\n\n\t// Send command, process S/G table\n\tuint16 scsi_stat = 0;\n\tbool success = scsi_send_cmd(sg_total_length, reading, sg_index, sg_ptr, sg_len, &scsi_stat, timeout);\n\tWriteMacInt16(stat, scsi_stat);\n\n\t// Complete command\n\tphase = PH_FREE;\n\tfake_status = 0x0000;\t// Bus free\n\treturn success ? 0 : scCommErr;\n}\n\n\n/*\n *  Get bus status\n */\n\nuint16 SCSIStat(void)\n{\n\tD(bug(\"SCSIStat returns %04x\\n\", fake_status));\n\treturn fake_status;\n}\n\n\n/*\n *  SCSI Manager busy?\n */\n\nint16 SCSIMgrBusy(void)\n{\n//\tD(bug(\"SCSIMgrBusy\\n\"));\n\treturn phase != PH_FREE;\n}\n","/*\n *  serial.cpp - Serial device driver\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/*\n *  SEE ALSO\n *    Inside Macintosh: Devices, chapter 7 \"Serial Driver\"\n *    Technote HW 04: \"Break/CTS Device Driver Event Structure\"\n *    Technote 1018: \"Understanding the SerialDMA Driver\"\n */\n\n#include <stdio.h>\n\n#include \"sysdeps.h\"\n#include \"cpu_emulation.h\"\n#include \"main.h\"\n#include \"macos_util.h\"\n#include \"serial.h\"\n#include \"serial_defs.h\"\n\n#include \"emul_op.h\"\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n// Global variables\nSERDPort *the_serd_port[2];\n\n\n/*\n *  Driver Open() routine\n */\n\nint16 SerialOpen(uint32 pb, uint32 dce, int port)\n{\n\tD(bug(\"SerialOpen port %d, pb %08lx, dce %08lx\\n\", port, pb, dce));\n\n\tif (port == 0 || port == 2) {\n\n\t\t// Do nothing for input side\n\t\treturn noErr;\n\n\t} else {\n\n\t\t// Do nothing if port is already open\n\t\tSERDPort *the_port = the_serd_port[port >> 1];\n\t\tif (the_port->is_open)\n\t\t\treturn noErr;\n\n\t\t// Init variables\n\t\tthe_port->read_pending = the_port->write_pending = false;\n\t\tthe_port->read_done = the_port->write_done = false;\n\t\tthe_port->cum_errors = 0;\n\n\t\t// Open port\n\t\tint16 res = the_port->open(ReadMacInt16(0x1fc + (port & 2)));\n\t\tif (res)\n\t\t\treturn res;\n\n\t\t// Allocate Deferred Task structures\n\t\tM68kRegisters r;\n\t\tr.d[0] = SIZEOF_serdt * 2;\n\t\tExecute68kTrap(0xa71e, &r);\t\t// NewPtrSysClear()\n\t\tif (r.a[0] == 0) {\n\t\t\tthe_port->close();\n\t\t\treturn openErr;\n\t\t}\n\t\tuint32 input_dt = the_port->input_dt = r.a[0];\n\t\tuint32 output_dt = the_port->output_dt = r.a[0] + SIZEOF_serdt;\n\t\tD(bug(\" input_dt %08lx, output_dt %08lx\\n\", input_dt, output_dt));\n\n\t\tWriteMacInt16(input_dt + qType, dtQType);\n\t\tWriteMacInt32(input_dt + dtAddr, input_dt + serdtCode);\n\t\tWriteMacInt32(input_dt + dtParam, input_dt + serdtResult);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Deferred function for signalling that Prime is complete (pointer to mydtResult in a1)\n\t\tWriteMacInt16(input_dt + serdtCode, 0x2019);\t\t\t// move.l\t(a1)+,d0\t(result)\n\t\tWriteMacInt16(input_dt + serdtCode + 2, 0x2251);\t\t// move.l\t(a1),a1\t\t(dce)\n\t\tWriteMacInt32(input_dt + serdtCode + 4, 0x207808fc);\t// move.l\tJIODone,a0\n\t\tWriteMacInt16(input_dt + serdtCode + 8, 0x4ed0);\t\t// jmp\t\t(a0)\n\n\t\tWriteMacInt16(output_dt + qType, dtQType);\n\t\tWriteMacInt32(output_dt + dtAddr, output_dt + serdtCode);\n\t\tWriteMacInt32(output_dt + dtParam, output_dt + serdtResult);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Deferred function for signalling that Prime is complete (pointer to mydtResult in a1)\n\t\tWriteMacInt16(output_dt + serdtCode, 0x2019);\t\t\t// move.l\t(a1)+,d0\t(result)\n\t\tWriteMacInt16(output_dt + serdtCode + 2, 0x2251);\t\t// move.l\t(a1),a1\t\t(dce)\n\t\tWriteMacInt32(output_dt + serdtCode + 4, 0x207808fc);\t// move.l\tJIODone,a0\n\t\tWriteMacInt16(output_dt + serdtCode + 8, 0x4ed0);\t\t// jmp\t\t(a0)\n\n\t\tthe_port->is_open = true;\n\t\treturn noErr;\n\t}\n}\n\n\n/*\n *  Driver Prime() routine\n */\n\nint16 SerialPrime(uint32 pb, uint32 dce, int port)\n{\n\tD(bug(\"SerialPrime port %d, pb %08lx, dce %08lx\\n\", port, pb, dce));\n\n\t// Error if port is not open\n\tSERDPort *the_port = the_serd_port[port >> 1];\n\tif (!the_port->is_open)\n\t\treturn notOpenErr;\n\n\tif (port == 0 || port == 2) {\n\t\tif (the_port->read_pending) {\n\t\t\tprintf(\"FATAL: SerialPrimeIn() called while request is pending\\n\");\n\t\t\treturn readErr;\n\t\t} else\n\t\t\treturn the_port->prime_in(pb, dce);\n\t} else {\n\t\tif (the_port->write_pending) {\n\t\t\tprintf(\"FATAL: SerialPrimeOut() called while request is pending\\n\");\n\t\t\treturn readErr;\n\t\t} else\n\t\t\treturn the_port->prime_out(pb, dce);\n\t}\n}\n\n\n/*\n *  Driver Control() routine\n */\n\nint16 SerialControl(uint32 pb, uint32 dce, int port)\n{\n\tuint16 code = ReadMacInt16(pb + csCode);\n\tD(bug(\"SerialControl %d, port %d, pb %08lx, dce %08lx\\n\", code, port, pb, dce));\n\n\t// Error if port is not open\n\tSERDPort *the_port = the_serd_port[port >> 1];\n\tif (!the_port->is_open)\n\t\treturn notOpenErr;\n\n\tswitch (code) {\n\t\tcase kSERDSetPollWrite:\n\t\t\treturn noErr;\n\n\t\tdefault:\n\t\t\treturn the_port->control(pb, dce, code);\n\t}\n}\n\n\n/*\n *  Driver Status() routine\n */\n\nint16 SerialStatus(uint32 pb, uint32 dce, int port)\n{\n\tuint16 code = ReadMacInt16(pb + csCode);\n\tD(bug(\"SerialStatus %d, port %d, pb %08lx, dce %08lx\\n\", code, port, pb, dce));\n\n\t// Error if port is not open\n\tSERDPort *the_port = the_serd_port[port >> 1];\n\tif (!the_port->is_open)\n\t\treturn notOpenErr;\n\n\tswitch (code) {\n\t\tcase kSERDVersion:\n\t\t\tWriteMacInt8(pb + csParam, 9);\t\t// Second-generation SerialDMA driver\n\t\t\treturn noErr;\n\n\t\tcase 0x8000:\n\t\t\tWriteMacInt8(pb + csParam, 9);\t\t// Second-generation SerialDMA driver\n\t\t\tWriteMacInt16(pb + csParam + 4, 0x1997);\t// Date of serial driver\n\t\t\tWriteMacInt16(pb + csParam + 6, 0x0616);\n\t\t\treturn noErr;\n\n\t\tdefault:\n\t\t\treturn the_port->status(pb, dce, code);\n\t}\n}\n\n\n/*\n *  Driver Close() routine\n */\n\nint16 SerialClose(uint32 pb, uint32 dce, int port)\n{\n\tD(bug(\"SerialClose port %d, pb %08lx, dce %08lx\\n\", port, pb, dce));\n\n\tif (port == 0 || port == 2) {\n\n\t\t// Do nothing for input side\n\t\treturn noErr;\n\n\t} else {\n\n\t\t// Close port if open\n\t\tSERDPort *the_port = the_serd_port[port >> 1];\n\t\tif (the_port->is_open) {\n\t\t\tint16 res = the_port->close();\n\t\t\tM68kRegisters r;\t\t\t\t// Free Deferred Task structures\n\t\t\tr.a[0] = the_port->input_dt;\n\t\t\tExecute68kTrap(0xa01f, &r);\t\t// DisposePtr()\n\t\t\tthe_port->is_open = false;\n\t\t\treturn res;\n\t\t} else\n\t\t\treturn noErr;\n\t}\n}\n\n\n/*\n *  Serial interrupt - Prime command completed, activate deferred tasks to call IODone\n */\n\nstatic void serial_irq(SERDPort *p)\n{\n\tif (p->is_open) {\n\t\tif (p->read_pending && p->read_done) {\n\t\t\tEnqueueMac(p->input_dt, 0xd92);\n\t\t\tp->read_pending = p->read_done = false;\n\t\t}\n\t\tif (p->write_pending && p->write_done) {\n\t\t\tEnqueueMac(p->output_dt, 0xd92);\n\t\t\tp->write_pending = p->write_done = false;\n\t\t}\n\t}\n}\n\nvoid SerialInterrupt(void)\n{\n\tD(bug(\"SerialIRQ\\n\"));\n\n\tserial_irq(the_serd_port[0]);\n\tserial_irq(the_serd_port[1]);\n}\n","/*\n *  basilisk_glue.cpp - Glue UAE CPU to Basilisk II CPU engine interface\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"sysdeps.h\"\n\n#include \"cpu_emulation.h\"\n#include \"main.h\"\n#include \"prefs.h\"\n#include \"emul_op.h\"\n#include \"rom_patches.h\"\n#include \"timer.h\"\n#include \"m68k.h\"\n#include \"memory.h\"\n#include \"readcpu.h\"\n#include \"newcpu.h\"\n#include \"compiler/compemu.h\"\n\n\n// RAM and ROM pointers\nuint32 RAMBaseMac = 0;\t\t// RAM base (Mac address space) gb-- initializer is important\nuint8 *RAMBaseHost;\t\t\t// RAM base (host address space)\nuint32 RAMSize;\t\t\t\t// Size of RAM\nuint32 ROMBaseMac;\t\t\t// ROM base (Mac address space)\nuint8 *ROMBaseHost;\t\t\t// ROM base (host address space)\nuint32 ROMSize;\t\t\t\t// Size of ROM\n\n#if !REAL_ADDRESSING\n// Mac frame buffer\nuint8 *MacFrameBaseHost;\t// Frame buffer base (host address space)\nuint32 MacFrameSize;\t\t// Size of frame buffer\nint MacFrameLayout;\t\t\t// Frame buffer layout\n#endif\n\n#if DIRECT_ADDRESSING\nuintptr MEMBaseDiff;\t\t// Global offset between a Mac address and its Host equivalent\n#endif\n\n#if USE_JIT\nbool UseJIT = false;\n#endif\n\n// From newcpu.cpp\nextern bool quit_program;\n\n\n/*\n *  Initialize 680x0 emulation, CheckROM() must have been called first\n */\n\nbool Init680x0(void)\n{\n#if REAL_ADDRESSING\n\t// Mac address space = host address space\n\tRAMBaseMac = (uintptr)RAMBaseHost;\n\tROMBaseMac = (uintptr)ROMBaseHost;\n#elif DIRECT_ADDRESSING\n\t// Mac address space = host address space minus constant offset (MEMBaseDiff)\n\t// NOTE: MEMBaseDiff is set up in main_unix.cpp/main()\n\tRAMBaseMac = 0;\n\tROMBaseMac = Host2MacAddr(ROMBaseHost);\n#else\n\t// Initialize UAE memory banks\n\tRAMBaseMac = 0;\n\tswitch (ROMVersion) {\n\t\tcase ROM_VERSION_64K:\n\t\tcase ROM_VERSION_PLUS:\n\t\tcase ROM_VERSION_CLASSIC:\n\t\t\tROMBaseMac = 0x00400000;\n\t\t\tbreak;\n\t\tcase ROM_VERSION_II:\n\t\t\tROMBaseMac = 0x00a00000;\n\t\t\tbreak;\n\t\tcase ROM_VERSION_32:\n\t\t\tROMBaseMac = 0x40800000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n\tmemory_init();\n#endif\n\n\tinit_m68k();\n#if USE_JIT\n\tUseJIT = compiler_use_jit();\n\tif (UseJIT)\n\t    compiler_init();\n#endif\n\treturn true;\n}\n\n\n/*\n *  Deinitialize 680x0 emulation\n */\n\nvoid Exit680x0(void)\n{\n#if USE_JIT\n    if (UseJIT)\n\tcompiler_exit();\n#endif\n\texit_m68k();\n}\n\n\n/*\n *  Initialize memory mapping of frame buffer (called upon video mode change)\n */\n\nvoid InitFrameBufferMapping(void)\n{\n#if !REAL_ADDRESSING && !DIRECT_ADDRESSING\n\tmemory_init();\n#endif\n}\n\n/*\n *  Reset and start 680x0 emulation (doesn't return)\n */\n\nvoid Start680x0(void)\n{\n\tm68k_reset();\n#if USE_JIT\n    if (UseJIT)\n\tm68k_compile_execute();\n    else\n#endif\n\tm68k_execute();\n}\n\n\n/*\n *  Trigger interrupt\n */\n\nvoid TriggerInterrupt(void)\n{\n\tidle_resume();\n\tSPCFLAGS_SET( SPCFLAG_INT );\n}\n\nvoid TriggerNMI(void)\n{\n\t//!! not implemented yet\n}\n\n\n/*\n *  Get 68k interrupt level\n */\n\nint intlev(void)\n{\n\treturn InterruptFlags ? 1 : 0;\n}\n\n\n/*\n *  Execute MacOS 68k trap\n *  r->a[7] and r->sr are unused!\n */\n\nvoid Execute68kTrap(uint16 trap, struct M68kRegisters *r)\n{\n\tint i;\n\n\t// Save old PC\n\tuaecptr oldpc = m68k_getpc();\n\n\t// Set registers\n\tfor (i=0; i<8; i++)\n\t\tm68k_dreg(regs, i) = r->d[i];\n\tfor (i=0; i<7; i++)\n\t\tm68k_areg(regs, i) = r->a[i];\n\n\t// Push trap and EXEC_RETURN on stack\n\tm68k_areg(regs, 7) -= 2;\n\tput_word(m68k_areg(regs, 7), M68K_EXEC_RETURN);\n\tm68k_areg(regs, 7) -= 2;\n\tput_word(m68k_areg(regs, 7), trap);\n\n\t// Execute trap\n\tm68k_setpc(m68k_areg(regs, 7));\n\tfill_prefetch_0();\n\tquit_program = false;\n\tm68k_execute();\n\n\t// Clean up stack\n\tm68k_areg(regs, 7) += 4;\n\n\t// Restore old PC\n\tm68k_setpc(oldpc);\n\tfill_prefetch_0();\n\n\t// Get registers\n\tfor (i=0; i<8; i++)\n\t\tr->d[i] = m68k_dreg(regs, i);\n\tfor (i=0; i<7; i++)\n\t\tr->a[i] = m68k_areg(regs, i);\n\tquit_program = false;\n}\n\n\n/*\n *  Execute 68k subroutine\n *  The executed routine must reside in UAE memory!\n *  r->a[7] and r->sr are unused!\n */\n\nvoid Execute68k(uint32 addr, struct M68kRegisters *r)\n{\n\tint i;\n\n\t// Save old PC\n\tuaecptr oldpc = m68k_getpc();\n\n\t// Set registers\n\tfor (i=0; i<8; i++)\n\t\tm68k_dreg(regs, i) = r->d[i];\n\tfor (i=0; i<7; i++)\n\t\tm68k_areg(regs, i) = r->a[i];\n\n\t// Push EXEC_RETURN and faked return address (points to EXEC_RETURN) on stack\n\tm68k_areg(regs, 7) -= 2;\n\tput_word(m68k_areg(regs, 7), M68K_EXEC_RETURN);\n\tm68k_areg(regs, 7) -= 4;\n\tput_long(m68k_areg(regs, 7), m68k_areg(regs, 7) + 4);\n\n\t// Execute routine\n\tm68k_setpc(addr);\n\tfill_prefetch_0();\n\tquit_program = false;\n\tm68k_execute();\n\n\t// Clean up stack\n\tm68k_areg(regs, 7) += 2;\n\n\t// Restore old PC\n\tm68k_setpc(oldpc);\n\tfill_prefetch_0();\n\n\t// Get registers\n\tfor (i=0; i<8; i++)\n\t\tr->d[i] = m68k_dreg(regs, i);\n\tfor (i=0; i<7; i++)\n\t\tr->a[i] = m68k_areg(regs, i);\n\tquit_program = false;\n}\n","// -*- C++ -*-\n#ifndef _LIBCPP_SPLIT_BUFFER\n#define _LIBCPP_SPLIT_BUFFER\n\n#include <__config>\n#include <type_traits>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __split_buffer_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nstruct __split_buffer\n    : private __split_buffer_common<true>\n{\nprivate:\n    __split_buffer(const __split_buffer&);\n    __split_buffer& operator=(const __split_buffer&);\npublic:\n    typedef _Tp                                             value_type;\n    typedef _Allocator                                      allocator_type;\n    typedef typename remove_reference<allocator_type>::type __alloc_rr;\n    typedef allocator_traits<__alloc_rr>                    __alloc_traits;\n    typedef value_type&                                     reference;\n    typedef const value_type&                               const_reference;\n    typedef typename __alloc_traits::size_type              size_type;\n    typedef typename __alloc_traits::difference_type        difference_type;\n    typedef typename __alloc_traits::pointer                pointer;\n    typedef typename __alloc_traits::const_pointer          const_pointer;\n    typedef pointer                                         iterator;\n    typedef const_pointer                                   const_iterator;\n\n    pointer                                         __first_;\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;\n\n    _LIBCPP_INLINE_VISIBILITY __alloc_rr&           __alloc() _NOEXCEPT         {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY const __alloc_rr&     __alloc() const _NOEXCEPT   {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY pointer&              __end_cap() _NOEXCEPT       {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY const pointer&        __end_cap() const _NOEXCEPT {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __split_buffer()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __split_buffer(__alloc_rr& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __split_buffer(const __alloc_rr& __a);\n    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);\n    ~__split_buffer();\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __split_buffer(__split_buffer&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);\n    __split_buffer& operator=(__split_buffer&& __c)\n        _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY       iterator begin() _NOEXCEPT       {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator begin() const _NOEXCEPT {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY       iterator end() _NOEXCEPT         {return __end_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator end() const _NOEXCEPT   {return __end_;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n        {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY size_type size() const {return static_cast<size_type>(__end_ - __begin_);}\n    _LIBCPP_INLINE_VISIBILITY bool empty()     const {return __end_ == __begin_;}\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}\n\n    _LIBCPP_INLINE_VISIBILITY       reference front()       {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY       reference back()        {return *(__end_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const  {return *(__end_ - 1);}\n\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n    void push_front(const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n#if !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // !defined(_LIBCPP_HAS_NO_VARIADICS)\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY void pop_front() {__destruct_at_begin(__begin_+1);}\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {__destruct_at_end(__end_-1);}\n\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _InputIter>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIter>::value &&\n           !__is_forward_iterator<_InputIter>::value,\n            void\n        >::type\n        __construct_at_end(_InputIter __first, _InputIter __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY void __destruct_at_begin(pointer __new_begin)\n        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}\n        _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_begin(pointer __new_begin, false_type);\n        _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_begin(pointer __new_begin, true_type);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n        {__destruct_at_end(__new_last, false_type());}\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, false_type) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, true_type) _NOEXCEPT;\n\n    void swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value);\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer&, false_type) _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\nbool\n__split_buffer<_Tp, _Allocator>::__invariants() const\n{\n    if (__first_ == nullptr)\n    {\n        if (__begin_ != nullptr)\n            return false;\n        if (__end_ != nullptr)\n            return false;\n        if (__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (__begin_ < __first_)\n            return false;\n        if (__end_ < __begin_)\n            return false;\n        if (__end_cap() < __end_)\n            return false;\n    }\n    return true;\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ntypename enable_if\n<\n     __is_input_iterator<_InputIter>::value &&\n    !__is_forward_iterator<_InputIter>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        if (__end_ == __end_cap())\n        {\n            size_type __old_cap = __end_cap() - __first_;\n            size_type __new_cap = _VSTD::max<size_type>(2 * __old_cap, 8);\n            __split_buffer __buf(__new_cap, 0, __a);\n            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)\n                __alloc_traits::construct(__buf.__alloc(),\n                        _VSTD::__to_raw_pointer(__buf.__end_), _VSTD::move(*__p));\n            swap(__buf);\n        }\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)\n{\n    while (__begin_ != __new_begin)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(__begin_++));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)\n{\n    __begin_ = __new_begin;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) _NOEXCEPT\n{\n    __end_ = __new_last;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)\n    : __end_cap_(nullptr, __a)\n{\n    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;\n    __begin_ = __end_ = __first_ + __start;\n    __end_cap() = __first_ + __cap;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline\n__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::~__split_buffer()\n{\n    clear();\n    if (__first_)\n        __alloc_traits::deallocate(__alloc(), __first_, capacity());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __first_(_VSTD::move(__c.__first_)),\n      __begin_(_VSTD::move(__c.__begin_)),\n      __end_(_VSTD::move(__c.__end_)),\n      __end_cap_(_VSTD::move(__c.__end_cap_))\n{\n    __c.__first_ = nullptr;\n    __c.__begin_ = nullptr;\n    __c.__end_ = nullptr;\n    __c.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)\n    : __end_cap_(__a)\n{\n    if (__a == __c.__alloc())\n    {\n        __first_ = __c.__first_;\n        __begin_ = __c.__begin_;\n        __end_ = __c.__end_;\n        __end_cap() = __c.__end_cap();\n        __c.__first_ = nullptr;\n        __c.__begin_ = nullptr;\n        __c.__end_ = nullptr;\n        __c.__end_cap() = nullptr;\n    }\n    else\n    {\n        size_type __cap = __c.size();\n        __first_ = __alloc_traits::allocate(__alloc(), __cap);\n        __begin_ = __end_ = __first_;\n        __end_cap() = __first_ + __cap;\n        typedef move_iterator<iterator> _Ip;\n        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>&\n__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)\n    _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value)\n{\n    clear();\n    shrink_to_fit();\n    __first_ = __c.__first_;\n    __begin_ = __c.__begin_;\n    __end_ = __c.__end_;\n    __end_cap() = __c.__end_cap();\n    __move_assign_alloc(__c,\n        integral_constant<bool,\n                          __alloc_traits::propagate_on_container_move_assignment::value>());\n    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n{\n    _VSTD::swap(__first_, __x.__first_);\n    _VSTD::swap(__begin_, __x.__begin_);\n    _VSTD::swap(__end_, __x.__end_);\n    _VSTD::swap(__end_cap(), __x.__end_cap());\n    __swap_allocator(__alloc(), __x.__alloc());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n < capacity())\n    {\n        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());\n        __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                               move_iterator<pointer>(__end_));\n        _VSTD::swap(__first_, __t.__first_);\n        _VSTD::swap(__begin_, __t.__begin_);\n        _VSTD::swap(__end_, __t.__end_);\n        _VSTD::swap(__end_cap(), __t.__end_cap());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            __t.__end_ = __t.__begin_ + (__end_ - __begin_);\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1), __x);\n    --__begin_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1),\n            _VSTD::move(__x));\n    --__begin_;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_), __x);\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n            _VSTD::move(__x));\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\n__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n                              _VSTD::forward<_Args>(__args)...);\n    ++__end_;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)\n        _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SPLIT_BUFFER\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;   // C++11\n    typedef integral_constant<bool, false> false_type;  // C++11\n    \n    template <bool B>                                   // C++14\n    using bool_constant = integral_constant<bool, B>;   // C++14\n    typedef bool_constant<true> true_type;              // C++14\n    typedef bool_constant<false> false_type;            // C++14\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n    template <class T> struct is_final; // C++14\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T, class U>       struct is_swappable_with;       // C++17\n    template <class T>                struct is_swappable;            // C++17\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T, class U>       struct is_nothrow_swappable_with; // C++17\n    template <class T>                struct is_nothrow_swappable;      // C++17\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    template <class, class R = void> struct is_callable; // not defined\n    template <class Fn, class... ArgTypes, class R>\n      struct is_callable<Fn(ArgTypes...), R>;\n\n    template <class, class R = void> struct is_nothrow_callable; // not defined\n    template <class Fn, class... ArgTypes, class R>\n      struct is_nothrow_callable<Fn(ArgTypes...), R>;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n  \n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n  \n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n  \n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class F, class... ArgTypes>\n      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14\n\n    template <class...>\n      using void_t = void;   // C++17\n      \n      // See C++14 20.10.4.1, primary type categories\n      template <class T> constexpr bool is_void_v\n        = is_void<T>::value;                                             // C++17\n      template <class T> constexpr bool is_null_pointer_v\n        = is_null_pointer<T>::value;                                     // C++17\n      template <class T> constexpr bool is_integral_v\n        = is_integral<T>::value;                                         // C++17\n      template <class T> constexpr bool is_floating_point_v\n        = is_floating_point<T>::value;                                   // C++17\n      template <class T> constexpr bool is_array_v\n        = is_array<T>::value;                                            // C++17\n      template <class T> constexpr bool is_pointer_v\n        = is_pointer<T>::value;                                          // C++17\n      template <class T> constexpr bool is_lvalue_reference_v\n        = is_lvalue_reference<T>::value;                                 // C++17\n      template <class T> constexpr bool is_rvalue_reference_v\n        = is_rvalue_reference<T>::value;                                 // C++17\n      template <class T> constexpr bool is_member_object_pointer_v\n        = is_member_object_pointer<T>::value;                            // C++17\n      template <class T> constexpr bool is_member_function_pointer_v\n        = is_member_function_pointer<T>::value;                          // C++17\n      template <class T> constexpr bool is_enum_v\n        = is_enum<T>::value;                                             // C++17\n      template <class T> constexpr bool is_union_v\n        = is_union<T>::value;                                            // C++17\n      template <class T> constexpr bool is_class_v\n        = is_class<T>::value;                                            // C++17\n      template <class T> constexpr bool is_function_v\n        = is_function<T>::value;                                         // C++17\n\n      // See C++14 20.10.4.2, composite type categories\n      template <class T> constexpr bool is_reference_v\n        = is_reference<T>::value;                                        // C++17\n      template <class T> constexpr bool is_arithmetic_v\n        = is_arithmetic<T>::value;                                       // C++17\n      template <class T> constexpr bool is_fundamental_v\n        = is_fundamental<T>::value;                                      // C++17\n      template <class T> constexpr bool is_object_v\n        = is_object<T>::value;                                           // C++17\n      template <class T> constexpr bool is_scalar_v\n        = is_scalar<T>::value;                                           // C++17\n      template <class T> constexpr bool is_compound_v\n        = is_compound<T>::value;                                         // C++17\n      template <class T> constexpr bool is_member_pointer_v\n        = is_member_pointer<T>::value;                                   // C++17\n\n      // See C++14 20.10.4.3, type properties\n      template <class T> constexpr bool is_const_v\n        = is_const<T>::value;                                            // C++17\n      template <class T> constexpr bool is_volatile_v\n        = is_volatile<T>::value;                                         // C++17\n      template <class T> constexpr bool is_trivial_v\n        = is_trivial<T>::value;                                          // C++17\n      template <class T> constexpr bool is_trivially_copyable_v\n        = is_trivially_copyable<T>::value;                               // C++17\n      template <class T> constexpr bool is_standard_layout_v\n        = is_standard_layout<T>::value;                                  // C++17\n      template <class T> constexpr bool is_pod_v\n        = is_pod<T>::value;                                              // C++17\n      template <class T> constexpr bool is_literal_type_v\n        = is_literal_type<T>::value;                                     // C++17\n      template <class T> constexpr bool is_empty_v\n        = is_empty<T>::value;                                            // C++17\n      template <class T> constexpr bool is_polymorphic_v\n        = is_polymorphic<T>::value;                                      // C++17\n      template <class T> constexpr bool is_abstract_v\n        = is_abstract<T>::value;                                         // C++17\n      template <class T> constexpr bool is_final_v\n        = is_final<T>::value;                                            // C++17\n      template <class T> constexpr bool is_signed_v\n        = is_signed<T>::value;                                           // C++17\n      template <class T> constexpr bool is_unsigned_v\n        = is_unsigned<T>::value;                                         // C++17\n      template <class T, class... Args> constexpr bool is_constructible_v\n        = is_constructible<T, Args...>::value;                           // C++17\n      template <class T> constexpr bool is_default_constructible_v\n        = is_default_constructible<T>::value;                            // C++17\n      template <class T> constexpr bool is_copy_constructible_v\n        = is_copy_constructible<T>::value;                               // C++17\n      template <class T> constexpr bool is_move_constructible_v\n        = is_move_constructible<T>::value;                               // C++17\n      template <class T, class U> constexpr bool is_assignable_v\n        = is_assignable<T, U>::value;                                    // C++17\n      template <class T> constexpr bool is_copy_assignable_v\n        = is_copy_assignable<T>::value;                                  // C++17\n      template <class T> constexpr bool is_move_assignable_v\n        = is_move_assignable<T>::value;                                  // C++17\n      template <class T, class U> constexpr bool is_swappable_with_v\n        = is_swappable_with<T, U>::value;                                // C++17\n      template <class T> constexpr bool is_swappable_v\n        = is_swappable<T>::value;                                        // C++17\n      template <class T> constexpr bool is_destructible_v\n        = is_destructible<T>::value;                                     // C++17\n      template <class T, class... Args> constexpr bool is_trivially_constructible_v\n        = is_trivially_constructible<T, Args...>::value;                 // C++17\n      template <class T> constexpr bool is_trivially_default_constructible_v\n        = is_trivially_default_constructible<T>::value;                  // C++17\n      template <class T> constexpr bool is_trivially_copy_constructible_v\n        = is_trivially_copy_constructible<T>::value;                     // C++17\n      template <class T> constexpr bool is_trivially_move_constructible_v\n        = is_trivially_move_constructible<T>::value;                     // C++17\n      template <class T, class U> constexpr bool is_trivially_assignable_v\n        = is_trivially_assignable<T, U>::value;                          // C++17\n      template <class T> constexpr bool is_trivially_copy_assignable_v\n        = is_trivially_copy_assignable<T>::value;                        // C++17\n      template <class T> constexpr bool is_trivially_move_assignable_v\n        = is_trivially_move_assignable<T>::value;                        // C++17\n      template <class T> constexpr bool is_trivially_destructible_v\n        = is_trivially_destructible<T>::value;                           // C++17\n      template <class T, class... Args> constexpr bool is_nothrow_constructible_v\n        = is_nothrow_constructible<T, Args...>::value;                   // C++17\n      template <class T> constexpr bool is_nothrow_default_constructible_v\n        = is_nothrow_default_constructible<T>::value;                    // C++17\n      template <class T> constexpr bool is_nothrow_copy_constructible_v\n        = is_nothrow_copy_constructible<T>::value;                       // C++17\n      template <class T> constexpr bool is_nothrow_move_constructible_v\n        = is_nothrow_move_constructible<T>::value;                       // C++17\n      template <class T, class U> constexpr bool is_nothrow_assignable_v\n        = is_nothrow_assignable<T, U>::value;                            // C++17\n      template <class T> constexpr bool is_nothrow_copy_assignable_v\n        = is_nothrow_copy_assignable<T>::value;                          // C++17\n      template <class T> constexpr bool is_nothrow_move_assignable_v\n        = is_nothrow_move_assignable<T>::value;                          // C++17\n      template <class T, class U> constexpr bool is_nothrow_swappable_with_v\n        = is_nothrow_swappable_with<T, U>::value;                       // C++17\n      template <class T> constexpr bool is_nothrow_swappable_v\n        = is_nothrow_swappable<T>::value;                               // C++17\n      template <class T> constexpr bool is_nothrow_destructible_v\n        = is_nothrow_destructible<T>::value;                             // C++17\n      template <class T> constexpr bool has_virtual_destructor_v\n        = has_virtual_destructor<T>::value;                              // C++17\n\n      // See C++14 20.10.5, type property queries\n      template <class T> constexpr size_t alignment_of_v\n        = alignment_of<T>::value;                                        // C++17\n      template <class T> constexpr size_t rank_v\n        = rank<T>::value;                                                // C++17\n      template <class T, unsigned I = 0> constexpr size_t extent_v\n        = extent<T, I>::value;                                           // C++17\n\n      // See C++14 20.10.6, type relations\n      template <class T, class U> constexpr bool is_same_v\n        = is_same<T, U>::value;                                          // C++17\n      template <class Base, class Derived> constexpr bool is_base_of_v\n        = is_base_of<Base, Derived>::value;                              // C++17\n      template <class From, class To> constexpr bool is_convertible_v\n        = is_convertible<From, To>::value;                               // C++17\n      template <class T, class R = void> constexpr bool is_callable_v\n        = is_callable<T, R>::value;                                      // C++17\n      template <class T, class R = void> constexpr bool is_nothrow_callable_v\n        = is_nothrow_callable<T, R>::value;                              // C++17\n\n      // [meta.logical], logical operator traits:\n      template<class... B> struct conjunction;                           // C++17\n      template<class... B> \n        constexpr bool conjunction_v = conjunction<B...>::value;         // C++17\n      template<class... B> struct disjunction;                           // C++17\n      template<class... B>\n        constexpr bool disjunction_v = disjunction<B...>::value;         // C++17\n      template<class B> struct negation;                                 // C++17\n      template<class B> \n        constexpr bool negation_v = negation<B>::value;                  // C++17\n\n}\n\n*/\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair;\ntemplate <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper;\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash;\n\ntemplate <class>\nstruct __void_t { typedef void type; };\n\ntemplate <class _Tp>\nstruct __identity { typedef _Tp type; };\n\ntemplate <class _Tp, bool>\nstruct _LIBCPP_TEMPLATE_VIS __dependent_type : public _Tp {};\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TEMPLATE_VIS conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TEMPLATE_VIS conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TEMPLATE_VIS enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n// addressof\n#ifndef _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n\ntemplate <class _Tp>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX14\n_LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return __builtin_addressof(__x);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n  return reinterpret_cast<_Tp *>(\n      const_cast<char *>(&reinterpret_cast<const volatile char &>(__x)));\n}\n\n#endif // _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\n#if !defined(_LIBCPP_CXX03_LANG)\ntemplate <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;\n#endif\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TEMPLATE_VIS integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const _NOEXCEPT {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\n#if _LIBCPP_STD_VER > 14\ntemplate <bool __b>\nusing bool_constant = integral_constant<bool, __b>;\n#define _LIBCPP_BOOL_CONSTANT(__b) bool_constant<(__b)>\n#else\n#define _LIBCPP_BOOL_CONSTANT(__b) integral_constant<bool,(__b)>\n#endif\n\ntypedef _LIBCPP_BOOL_CONSTANT(true)  true_type;\ntypedef _LIBCPP_BOOL_CONSTANT(false) false_type;\n\n#if !defined(_LIBCPP_CXX03_LANG)\n\n// __lazy_and\n\ntemplate <bool _Last, class ..._Preds>\nstruct __lazy_and_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_and_impl<false, _Preds...> : false_type {};\n\ntemplate <>\nstruct __lazy_and_impl<true> : true_type {};\n\ntemplate <class _Pred>\nstruct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_or\n\ntemplate <bool _List, class ..._Preds>\nstruct __lazy_or_impl;\n\ntemplate <class ..._Preds>\nstruct __lazy_or_impl<true, _Preds...> : true_type {};\n\ntemplate <>\nstruct __lazy_or_impl<false> : false_type {};\n\ntemplate <class _Hp, class ..._Tp>\nstruct __lazy_or_impl<false, _Hp, _Tp...>\n        : __lazy_or_impl<_Hp::type::value, _Tp...> {};\n\ntemplate <class _P1, class ..._Pr>\nstruct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};\n\n// __lazy_not\n\ntemplate <class _Pred>\nstruct __lazy_not : integral_constant<bool, !_Pred::type::value> {};\n\n// __and_\ntemplate<class...> struct __and_;\ntemplate<> struct __and_<> : true_type {};\n\ntemplate<class _B0> struct __and_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __and_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};\n\n// __or_\ntemplate<class...> struct __or_;\ntemplate<> struct __or_<> : false_type {};\n\ntemplate<class _B0> struct __or_<_B0> : _B0 {};\n\ntemplate<class _B0, class _B1>\nstruct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};\n\ntemplate<class _B0, class _B1, class _B2, class... _Bn>\nstruct __or_<_B0, _B1, _B2, _Bn...> \n        : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};\n\n// __not_\ntemplate<class _Tp> \nstruct __not_ : conditional<_Tp::value, false_type, true_type>::type {};\n\n#endif // !defined(_LIBCPP_CXX03_LANG)\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const<_Tp const> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_const_v\n    = is_const<_Tp>::value;\n#endif\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile<_Tp volatile> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_volatile_v\n    = is_volatile<_Tp>::value;\n#endif\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};\ntemplate <>          struct __libcpp_is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_void\n    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_void_v\n    = is_void<_Tp>::value;\n#endif\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};\ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS __is_nullptr_t\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_null_pointer\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_null_pointer_v\n    = is_null_pointer<_Tp>::value;\n#endif\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};\ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};\ntemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_integral\n    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_integral_v\n    = is_integral<_Tp>::value;\n#endif\n\n// is_floating_point\n\ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};\ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_floating_point\n    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_floating_point_v\n    = is_floating_point<_Tp>::value;\n#endif\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[_Np]>\n    : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_array_v\n    = is_array<_Tp>::value;\n#endif\n\n// is_pointer\n\ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};\ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pointer\n    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pointer_v\n    = is_pointer<_Tp>::value;\n#endif\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&&> : public true_type {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_reference_v\n    = is_reference<_Tp>::value;\n\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_lvalue_reference_v\n    = is_lvalue_reference<_Tp>::value;\n\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_rvalue_reference_v\n    = is_rvalue_reference<_Tp>::value;\n#endif\n// is_union\n\n#if __has_feature(is_union) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_union_v\n    = is_union<_Tp>::value;\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_class_v\n    = is_class<_Tp>::value;\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TEMPLATE_VIS is_same<_Tp, _Tp> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Up> _LIBCPP_CONSTEXPR bool is_same_v\n    = is_same<_Tp, _Up>::value;\n#endif\n\n// is_function\n\nnamespace __libcpp_is_function_imp\n{\nstruct __dummy_type {};\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> char __test(__dummy_type);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source(int);\ntemplate <class _Tp> __dummy_type __source(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __libcpp_is_function\n    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>\n    {};\ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_function\n    : public __libcpp_is_function<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_function_v\n    = is_function<_Tp>::value;\n#endif\n\n// is_member_function_pointer\n\n// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};\n// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n// \n\ntemplate <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{  // forward declaration; specializations later\n};\n\n\ntemplate <class _Tp> struct __libcpp_is_member_function_pointer\n    : public false_type {};\n\ntemplate <class _Ret, class _Class>\nstruct __libcpp_is_member_function_pointer<_Ret _Class::*>\n    : public is_function<_Ret> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_function_pointer\n    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_function_pointer_v\n    = is_member_function_pointer<_Tp>::value;\n#endif\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_pointer\n    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_pointer_v\n    = is_member_pointer<_Tp>::value;\n#endif\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_member_object_pointer_v\n    = is_member_object_pointer<_Tp>::value;\n#endif\n\n// is_enum\n\n#if __has_feature(is_enum) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_enum_v\n    = is_enum<_Tp>::value;\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_arithmetic_v\n    = is_arithmetic<_Tp>::value;\n#endif\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_fundamental_v\n    = is_fundamental<_Tp>::value;\n#endif\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TEMPLATE_VIS is_scalar<nullptr_t> : public true_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_scalar_v\n    = is_scalar<_Tp>::value;\n#endif\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_object_v\n    = is_object<_Tp>::value;\n#endif\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_compound_v\n    = is_compound<_Tp>::value;\n#endif\n\n\n// __is_referenceable  [defns.referenceable]\n\nstruct __is_referenceable_impl {\n    template <class _Tp> static _Tp& __test(int);\n    template <class _Tp> static __two __test(...);\n};\n\ntemplate <class _Tp>\nstruct __is_referenceable : integral_constant<bool,\n    !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};\n\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl            { typedef _Tp  type; };\ntemplate <class _Tp                                       > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_lvalue_reference\n{typedef typename __add_lvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl            { typedef _Tp   type; };\ntemplate <class _Tp                                       > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_rvalue_reference\n{typedef typename __add_rvalue_reference_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> _Tp&& __declval(int);\ntemplate <class _Tp> _Tp   __declval(long);\n\ntemplate <class _Tp>\ndecltype(_VSTD::__declval<_Tp>(0))\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// __uncvref\n\ntemplate <class _Tp>\nstruct __uncvref  {\n    typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __unconstref {\n    typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;\n};\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Tp>\nusing __uncvref_t = typename __uncvref<_Tp>::type;\n#endif\n\n// __is_same_uncvref\n\ntemplate <class _Tp, class _Up>\nstruct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,\n                                   typename __uncvref<_Up>::type> {};\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp, \n        bool = __is_referenceable<_Tp>::value || \n                is_same<typename remove_cv<_Tp>::type, void>::value>\nstruct __add_pointer_impl\n    {typedef typename remove_reference<_Tp>::type* type;};\ntemplate <class _Tp> struct __add_pointer_impl<_Tp, false> \n    {typedef _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_pointer\n    {typedef typename __add_pointer_impl<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_signed_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(-1) < _Tp(0)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_signed : public __libcpp_is_signed<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_signed_v\n    = is_signed<_Tp>::value;\n#endif\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_unsigned_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(0) < _Tp(-1)) {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_unsigned : public __libcpp_is_unsigned<_Tp> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_unsigned_v\n    = is_unsigned<_Tp>::value;\n#endif\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR size_t rank_v\n    = rank<_Tp>::value;\n#endif\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TEMPLATE_VIS extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, unsigned _Ip = 0> _LIBCPP_CONSTEXPR size_t extent_v\n    = extent<_Tp, _Ip>::value;\n#endif\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_abstract\n    : public integral_constant<bool, __is_abstract(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_abstract_v\n    = is_abstract<_Tp>::value;\n#endif\n\n// is_final\n\n#if defined(_LIBCPP_HAS_IS_FINAL)\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\n__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};\n#else\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\n__libcpp_is_final : public false_type {};\n#endif\n\n#if defined(_LIBCPP_HAS_IS_FINAL) && _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS\nis_final : public integral_constant<bool, __is_final(_Tp)> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_final_v\n    = is_final<_Tp>::value;\n#endif\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // _LIBCPP_HAS_IS_BASE_OF\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TEMPLATE_VIS is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // _LIBCPP_HAS_IS_BASE_OF\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Bp, class _Dp> _LIBCPP_CONSTEXPR bool is_base_of_v\n    = is_base_of<_Bp, _Dp>::value;\n#endif\n\n// is_convertible\n\n#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> void  __test_convert(_Tp);\n\ntemplate <class _From, class _To, class = void>\nstruct __is_convertible_test : public false_type {};\n\ntemplate <class _From, class _To>\nstruct __is_convertible_test<_From, _To,\n    decltype(_VSTD::__is_convertible_imp::__test_convert<_To>(_VSTD::declval<_From>()))> : public true_type\n{};\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n        __is_convertible_imp::__is_convertible_test<_T1, _T2>::value\n#if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _From, class _To> _LIBCPP_CONSTEXPR bool is_convertible_v\n    = is_convertible<_From, _To>::value;\n#endif\n\n// is_empty\n\n#if __has_feature(is_empty) || (_GNUC_VER >= 407)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_empty_v\n    = is_empty<_Tp>::value;\n#endif\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic) || defined(_LIBCPP_COMPILER_MSVC)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_polymorphic_v\n    = is_polymorphic<_Tp>::value;\n#endif\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool has_virtual_destructor_v\n    = has_virtual_destructor<_Tp>::value;\n#endif\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS alignment_of\n    : public integral_constant<size_t, __alignof__(_Tp)> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR size_t alignment_of_v\n    = alignment_of<_Tp>::value;\n#endif\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_CXX03_LANG\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = alignment_of<_Tp>::value;\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TEMPLATE_VIS aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TEMPLATE_VIS aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[(_Len + n - 1)/n * n];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// PE/COFF does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<__alignof__(_Type0),\n                                                       __alignof__(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __numeric_type\n{\n   static void __test(...);\n   static float __test(float);\n   static double __test(char);\n   static double __test(int);\n   static double __test(unsigned);\n   static double __test(long);\n   static double __test(unsigned long);\n   static double __test(long long);\n   static double __test(unsigned long long);\n   static double __test(double);\n   static long double __test(long double);\n\n   typedef decltype(__test(declval<_Tp>())) type;\n   static const bool value = !is_same<type, void>::value;\n};\n\ntemplate <>\nstruct __numeric_type<void>\n{\n   static const bool value = true;\n};\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = __numeric_type<_A1>::value &&\n                 __numeric_type<_A2>::value &&\n                 __numeric_type<_A3>::value>\nclass __promote_imp\n{\npublic:\n    static const bool value = false;\n};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote_imp<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\n    typedef typename __promote_imp<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote_imp<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote_imp<_A1>::type __type1;\n    typedef typename __promote_imp<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1>\nclass __promote_imp<_A1, void, void, true>\n{\npublic:\n    typedef typename __numeric_type<_A1>::type type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2 = void, class _A3 = void>\nclass __promote : public __promote_imp<_A1, _A2, _A3> {};\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__int128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__uint128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};\ntemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};\ntemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class _Vp = void>\nstruct _LIBCPP_TEMPLATE_VIS common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp>::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, void, void>\n{\npublic:\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, void>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n      )>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// bullet 1 - sizeof...(Tp) == 0\n\ntemplate <class ..._Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type {};\n\n// bullet 2 - sizeof...(Tp) == 1\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp>\n{\n    typedef typename decay<_Tp>::type type;\n};\n\n// bullet 3 - sizeof...(Tp) == 2\n\ntemplate <class _Tp, class _Up, class = void>\nstruct __common_type2_imp {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type2_imp<_Tp, _Up,\n    typename __void_t<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type>\n{\n    typedef typename decay<decltype(\n        true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()\n    )>::type type;\n};\n\ntemplate <class _Tp, class _Up,\n          class _DTp = typename decay<_Tp>::type,\n          class _DUp = typename decay<_Up>::type>\nusing __common_type2 =\n  typename conditional<\n    is_same<_Tp, _DTp>::value && is_same<_Up, _DUp>::value,\n    __common_type2_imp<_Tp, _Up>,\n    common_type<_DTp, _DUp>\n  >::type;\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up>\n    : __common_type2<_Tp, _Up> {};\n\n// bullet 4 - sizeof...(Tp) > 2\n\ntemplate <class ...Tp> struct __common_types;\n\ntemplate <class, class = void>\nstruct __common_type_impl {};\n\ntemplate <class _Tp, class _Up>\nstruct __common_type_impl<\n    __common_types<_Tp, _Up>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n{\n  typedef typename common_type<_Tp, _Up>::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,\n    typename __void_t<typename common_type<_Tp, _Up>::type>::type>\n  : __common_type_impl<\n      __common_types<typename common_type<_Tp, _Up>::type, _Vp...> >\n{\n\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, _Vp...>\n    : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n__is_assignable_test(int);\n\ntemplate <class, class>\nfalse_type __is_assignable_test(...);\n\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public decltype((_VSTD::__is_assignable_test<_Tp, _Arg>(0))) {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_assignable_v\n    = is_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_assignable_v\n    = is_copy_assignable<_Tp>::value;\n#endif\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                           typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_assignable_v\n    = is_move_assignable<_Tp>::value;\n#endif\n\n// is_destructible\n\n//  if it's a reference, return true\n//  if it's a function, return false\n//  if it's   void,     return false\n//  if it's an array of unknown bound, return false\n//  Otherwise, return \"std::declval<_Up&>().~_Up()\" is well-formed\n//    where _Up is remove_all_extents<_Tp>::type\n\ntemplate <class>\nstruct __is_destructible_apply { typedef int type; };\n\ntemplate <typename _Tp>\nstruct __is_destructor_wellformed {\n    template <typename _Tp1>\n    static char  __test (\n        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type\n    );\n\n    template <typename _Tp1>\n    static __two __test (...);\n    \n    static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);\n};\n\ntemplate <class _Tp, bool>\nstruct __destructible_imp;\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, false> \n   : public _VSTD::integral_constant<bool, \n        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public _VSTD::true_type {};\n\ntemplate <class _Tp, bool>\nstruct __destructible_false;\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public _VSTD::false_type {};\n\ntemplate <>\nstruct is_destructible<void>\n    : public _VSTD::false_type {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_destructible_v\n    = is_destructible<_Tp>::value;\n#endif\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp&&\nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n_Tp&&\nforward(typename remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!is_lvalue_reference<_Tp>::value,\n                  \"can not forward an rvalue as an lvalue\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#if __has_feature(cxx_reference_qualified_functions) || \\\n    (defined(_GNUC_VER) && _GNUC_VER >= 409)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions) || _GNUC_VER >= 409\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n//     typedef ... _FnType;\n};\n\n\ntemplate <class _DecayedFp>\nstruct __member_pointer_class_type {};\n\ntemplate <class _Ret, class _ClassType>\nstruct __member_pointer_class_type<_Ret _ClassType::*> {\n  typedef _ClassType type;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public __identity<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\nnamespace __is_construct\n{\nstruct __nat {};\n}\n\n#if !defined(_LIBCPP_CXX03_LANG) && (!__has_feature(is_constructible) || \\\n    defined(_LIBCPP_TESTING_FALLBACK_IS_CONSTRUCTIBLE))\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_constructible;\n\ntemplate <class _To, class _From>\nstruct __is_invalid_base_to_derived_cast {\n  static_assert(is_reference<_To>::value, \"Wrong specialization\");\n  using _RawFrom = __uncvref_t<_From>;\n  using _RawTo = __uncvref_t<_To>;\n  static const bool value = __lazy_and<\n        __lazy_not<is_same<_RawFrom, _RawTo>>,\n        is_base_of<_RawFrom, _RawTo>,\n        __lazy_not<__libcpp_is_constructible<_RawTo, _From>>\n  >::value;\n};\n\ntemplate <class _To, class _From>\nstruct __is_invalid_lvalue_to_rvalue_cast : false_type {\n  static_assert(is_reference<_To>::value, \"Wrong specialization\");\n};\n\ntemplate <class _ToRef, class _FromRef>\nstruct __is_invalid_lvalue_to_rvalue_cast<_ToRef&&, _FromRef&> {\n  using _RawFrom = __uncvref_t<_FromRef>;\n  using _RawTo = __uncvref_t<_ToRef>;\n  static const bool value = __lazy_and<\n      __lazy_not<is_function<_RawTo>>,\n      __lazy_or<\n        is_same<_RawFrom, _RawTo>,\n        is_base_of<_RawTo, _RawFrom>>\n    >::value;\n};\n\nstruct __is_constructible_helper\n{\n    template <class _To>\n    static void __eat(_To);\n\n    // This overload is needed to work around a Clang bug that disallows\n    // static_cast<T&&>(e) for non-reference-compatible types.\n    // Example: static_cast<int&&>(declval<double>());\n    // NOTE: The static_cast implementation below is required to support\n    //  classes with explicit conversion operators.\n    template <class _To, class _From,\n              class = decltype(__eat<_To>(_VSTD::declval<_From>()))>\n    static true_type __test_cast(int);\n\n    template <class _To, class _From,\n              class = decltype(static_cast<_To>(_VSTD::declval<_From>()))>\n    static integral_constant<bool,\n        !__is_invalid_base_to_derived_cast<_To, _From>::value &&\n        !__is_invalid_lvalue_to_rvalue_cast<_To, _From>::value\n    > __test_cast(long);\n\n    template <class, class>\n    static false_type __test_cast(...);\n\n    template <class _Tp, class ..._Args,\n        class = decltype(_Tp(_VSTD::declval<_Args>()...))>\n    static true_type __test_nary(int);\n    template <class _Tp, class...>\n    static false_type __test_nary(...);\n\n    template <class _Tp, class _A0, class = decltype(::new _Tp(_VSTD::declval<_A0>()))>\n    static is_destructible<_Tp> __test_unary(int);\n    template <class, class>\n    static false_type __test_unary(...);\n};\n\ntemplate <class _Tp, bool = is_void<_Tp>::value>\nstruct __is_default_constructible\n    : decltype(__is_constructible_helper::__test_nary<_Tp>(0))\n{};\n\ntemplate <class _Tp>\nstruct __is_default_constructible<_Tp, true> : false_type {};\n\ntemplate <class _Tp>\nstruct __is_default_constructible<_Tp[], false> : false_type {};\n\ntemplate <class _Tp, size_t _Nx>\nstruct __is_default_constructible<_Tp[_Nx], false>\n    : __is_default_constructible<typename remove_all_extents<_Tp>::type>  {};\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_constructible\n{\n  static_assert(sizeof...(_Args) > 1, \"Wrong specialization\");\n  typedef decltype(__is_constructible_helper::__test_nary<_Tp, _Args...>(0))\n      type;\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_constructible<_Tp> : __is_default_constructible<_Tp> {};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp, _A0>\n    : public decltype(__is_constructible_helper::__test_unary<_Tp, _A0>(0))\n{};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp&, _A0>\n    : public decltype(__is_constructible_helper::\n    __test_cast<_Tp&, _A0>(0))\n{};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<_Tp&&, _A0>\n    : public decltype(__is_constructible_helper::\n    __test_cast<_Tp&&, _A0>(0))\n{};\n\n#endif\n\n#if __has_feature(is_constructible)\ntemplate <class _Tp, class ..._Args>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>\n    {};\n#elif !defined(_LIBCPP_CXX03_LANG)\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public __libcpp_is_constructible<_Tp, _Args...>::type {};\n#else\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TEMPLATE_VIS is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\n#endif // __has_feature(is_constructible)\n\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_constructible_v\n    = is_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_default_constructible_v\n    = is_default_constructible<_Tp>::value;\n#endif\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_copy_constructible\n    : public is_constructible<_Tp, \n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_constructible_v\n    = is_copy_constructible<_Tp>::value;\n#endif\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_move_constructible_v\n    = is_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class... _Args> _LIBCPP_CONSTEXPR bool is_trivially_constructible_v\n    = is_trivially_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_default_constructible_v\n    = is_trivially_default_constructible<_Tp>::value;\n#endif\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_constructible_v\n    = is_trivially_copy_constructible<_Tp>::value;\n#endif\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_constructible_v\n    = is_trivially_move_constructible<_Tp>::value;\n#endif\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_assignable)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_trivially_assignable_v\n    = is_trivially_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_assignable_v\n    = is_trivially_copy_assignable<_Tp>::value;\n#endif\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v\n    = is_trivially_move_assignable<_Tp>::value;\n#endif\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible\n    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_destructible_v\n    = is_trivially_destructible<_Tp>::value;\n#endif\n\n// is_nothrow_constructible\n\n#if 0\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>\n{\n};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp>\nvoid __implicit_conversion_to(_Tp) noexcept { }\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))>\n{\n};\n\ntemplate <class _Tp, bool _IsReference, class... _Args>\nstruct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp[_Ns]>\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_nothrow_constructible)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\ntemplate <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_nothrow_constructible_v\n    = is_nothrow_constructible<_Tp, _Args...>::value;\n#endif\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_default_constructible_v\n    = is_nothrow_default_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_constructible_v\n    = is_nothrow_copy_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_constructible_v\n    = is_nothrow_move_constructible<_Tp>::value;\n#endif\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable\n    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_nothrow_assignable_v\n    = is_nothrow_assignable<_Tp, _Arg>::value;\n#endif\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_assignable_v\n    = is_nothrow_copy_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_assignable_v\n    = is_nothrow_move_assignable<_Tp>::value;\n#endif\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible\n    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[]>\n    : public false_type {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_destructible_v\n    = is_nothrow_destructible<_Tp>::value;\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_pod_v\n    = is_pod<_Tp>::value;\n#endif\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_literal_type\n#ifdef _LIBCPP_IS_LITERAL\n    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_literal_type_v\n    = is_literal_type<_Tp>::value;\n#endif\n\n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_standard_layout\n#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_standard_layout_v\n    = is_standard_layout<_Tp>::value;\n#endif\n\n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#elif _GNUC_VER >= 501\n    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copyable_v\n    = is_trivially_copyable<_Tp>::value;\n#endif\n\n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivial\n#if __has_feature(is_trivial) || _GNUC_VER >= 407\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)\ntemplate <class _Tp> _LIBCPP_CONSTEXPR bool is_trivial_v\n    = is_trivial<_Tp>::value;\n#endif\n\ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};\ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};\n\n#ifndef _LIBCPP_CXX03_LANG\n\n// Check for complete types\n\ntemplate <class ..._Tp> struct __check_complete;\n\ntemplate <>\nstruct __check_complete<>\n{\n};\n\ntemplate <class _Hp, class _T0, class ..._Tp>\nstruct __check_complete<_Hp, _T0, _Tp...>\n    : private __check_complete<_Hp>,\n      private __check_complete<_T0, _Tp...>\n{\n};\n\ntemplate <class _Hp>\nstruct __check_complete<_Hp, _Hp>\n    : private __check_complete<_Hp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp>\n{\n    static_assert(sizeof(_Tp) > 0, \"Type must be complete.\");\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (*)(_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (*)(_Param...)>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (_Param...)>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...)>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class>\nstruct __check_complete<_Rp _Class::*>\n    : private __check_complete<_Class>\n{\n};\n\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet1 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet2 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet3 = typename enable_if\n    <\n        is_member_function_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet4 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && is_base_of<_ClassT, _DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type>\nusing __enable_if_bullet5 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && __is_reference_wrapper<_DecayA0>::value\n    >::type;\n\ntemplate <class _Fp, class _A0,\n         class _DecayFp = typename decay<_Fp>::type,\n         class _DecayA0 = typename decay<_A0>::type,\n         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>\nusing __enable_if_bullet6 = typename enable_if\n    <\n        is_member_object_pointer<_DecayFp>::value\n        && !is_base_of<_ClassT, _DecayA0>::value\n        && !__is_reference_wrapper<_DecayA0>::value\n    >::type;\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\n#define _LIBCPP_INVOKE_RETURN(...) \\\n    noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) \\\n    { return __VA_ARGS__; }\n\ntemplate <class ..._Args>\nauto __invoke(__any, _Args&& ...__args) -> __nat;\n\ntemplate <class ..._Args>\nauto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;\n\n// bullets 1, 2 and 3\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet1<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet2<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class _A0, class ..._Args,\n          class = __enable_if_bullet3<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n\n// bullets 4, 5 and 6\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet4<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet5<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN(__a0.get().*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\ntemplate <class _Fp, class _A0,\n          class = __enable_if_bullet6<_Fp, _A0>>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _A0&& __a0)\n_LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)\n\n// bullet 7\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR auto\n__invoke_constexpr(_Fp&& __f, _Args&& ...__args)\n_LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n\n#undef _LIBCPP_INVOKE_RETURN\n\n// __invokable\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __invokable_r\n    : private __check_complete<_Fp>\n{\n    using _Result = decltype(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n\n    static const bool value =\n        conditional<\n            !is_same<_Result, __nat>::value,\n            typename conditional<\n                is_void<_Ret>::value,\n                true_type,\n                is_convertible<_Result, _Ret>\n            >::type,\n            false_type\n        >::type::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nusing __invokable = __invokable_r<void, _Fp, _Args...>;\n\ntemplate <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp {\n  static const bool value = false;\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>\n{\n    typedef __nothrow_invokable_r_imp _ThisT;\n\n    template <class _Tp>\n    static void __test_noexcept(_Tp) noexcept;\n\n    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nstruct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>\n{\n    static const bool value = noexcept(\n        _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));\n};\n\ntemplate <class _Ret, class _Fp, class ..._Args>\nusing __nothrow_invokable_r =\n    __nothrow_invokable_r_imp<\n            __invokable_r<_Ret, _Fp, _Args...>::value,\n            is_void<_Ret>::value,\n            _Ret, _Fp, _Args...\n    >;\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public enable_if<\n        __invokable<_Fp, _Args...>::value,\n        typename __invokable_r<void, _Fp, _Args...>::_Result>\n{\n};\n\n// result_of\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TEMPLATE_VIS result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#if _LIBCPP_STD_VER > 14\n\n// is_callable\n\ntemplate <class _Fn, class _Ret = void>\nstruct _LIBCPP_TEMPLATE_VIS is_callable;\n\ntemplate <class _Fn, class ..._Args, class _Ret>\nstruct _LIBCPP_TEMPLATE_VIS is_callable<_Fn(_Args...), _Ret>\n    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};\n\ntemplate <class _Fn, class _Ret = void>\nconstexpr bool is_callable_v = is_callable<_Fn, _Ret>::value;\n\n// is_nothrow_callable\n\ntemplate <class _Fn, class _Ret = void>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_callable;\n\ntemplate <class _Fn, class ..._Args, class _Ret>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_callable<_Fn(_Args...), _Ret>\n    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value>\n{};\n\ntemplate <class _Fn, class _Ret = void>\nconstexpr bool is_nothrow_callable_v = is_nothrow_callable<_Fn, _Ret>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#endif  // !defined(_LIBCPP_CXX03_LANG)\n\ntemplate <class _Tp> struct __is_swappable;\ntemplate <class _Tp> struct __is_nothrow_swappable;\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_CXX03_LANG\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<\n    __is_swappable<_Tp>::value\n>::type\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value);\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n// ALL generic swap overloads MUST already have a declaration available at this point.\n\ntemplate <class _Tp, class _Up = _Tp,\n          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>\nstruct __swappable_with\n{\n    template <class _LHS, class _RHS>\n    static decltype(swap(_VSTD::declval<_LHS>(), _VSTD::declval<_RHS>()))\n    __test_swap(int);\n    template <class, class>\n    static __nat __test_swap(long);\n\n    // Extra parens are needed for the C++03 definition of decltype.\n    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;\n    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;\n\n    static const bool value = !is_same<__swap1, __nat>::value\n                           && !is_same<__swap2, __nat>::value;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __swappable_with<_Tp, _Up,  false> : false_type {};\n\ntemplate <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>\nstruct __nothrow_swappable_with {\n  static const bool value =\n#ifndef _LIBCPP_HAS_NO_NOEXCEPT\n      noexcept(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>()))\n  &&  noexcept(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>()));\n#else\n      false;\n#endif\n};\n\ntemplate <class _Tp, class _Up>\nstruct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>\n{\n};\n\n#if _LIBCPP_STD_VER > 14\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS is_swappable_with\n    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable_with\n    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable\n    : public conditional<\n        __is_referenceable<_Tp>::value,\n        is_nothrow_swappable_with<\n            typename add_lvalue_reference<_Tp>::type,\n            typename add_lvalue_reference<_Tp>::type>,\n        false_type\n    >::type\n{\n};\n\ntemplate <class _Tp, class _Up>\nconstexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\nconstexpr bool is_swappable_v = is_swappable<_Tp>::value;\n\ntemplate <class _Tp, class _Up>\nconstexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;\n\ntemplate <class _Tp>\nconstexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;\n\n#endif // _LIBCPP_STD_VER > 14\n\n#ifdef _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCPP_UNDERLYING_TYPE\n\n\ntemplate <class _Tp, bool = is_enum<_Tp>::value>\nstruct __sfinae_underlying_type\n{\n    typedef typename underlying_type<_Tp>::type type;\n    typedef decltype(((type)1) + 0) __promoted_type;\n};\n\ntemplate <class _Tp>\nstruct __sfinae_underlying_type<_Tp, false> {};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint __convert_to_integral(int __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned __convert_to_integral(unsigned __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong __convert_to_integral(long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long __convert_to_integral(unsigned long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong long __convert_to_integral(long long __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long __convert_to_integral(unsigned long long __val) {return __val; }\n\n#ifndef _LIBCPP_HAS_NO_INT128\ninline _LIBCPP_INLINE_VISIBILITY\n__int128_t __convert_to_integral(__int128_t __val) { return __val; }\n\ninline _LIBCPP_INLINE_VISIBILITY\n__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __sfinae_underlying_type<_Tp>::__promoted_type\n__convert_to_integral(_Tp __val) { return __val; }\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_member_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(_VSTD::declval<_Up>().operator&()), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_free_imp\n{\n    template <class _Up>\n        static auto __test(int)\n            -> typename __select_2nd<decltype(operator&(_VSTD::declval<_Up>())), true_type>::type;\n    template <class>\n        static auto __test(long) -> false_type;\n\n    static const bool value = decltype(__test<_Tp>(0))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_member_imp<_Tp>::value\n                                  || __has_operator_addressof_free_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_CXX03_LANG\n\n#if _LIBCPP_STD_VER > 14\n\n#define __cpp_lib_void_t 201411\ntemplate <class...> using void_t = void;\n\n# ifndef _LIBCPP_HAS_NO_VARIADICS\ntemplate <class... _Args>\nstruct conjunction : __and_<_Args...> {};\ntemplate<class... _Args> constexpr bool conjunction_v = conjunction<_Args...>::value;\n\ntemplate <class... _Args>\nstruct disjunction : __or_<_Args...> {};\ntemplate<class... _Args> constexpr bool disjunction_v = disjunction<_Args...>::value;\n\ntemplate <class _Tp>\nstruct negation : __not_<_Tp> {};\ntemplate<class _Tp> constexpr bool negation_v = negation<_Tp>::value;\n# endif // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_STD_VER > 14\n\n// These traits are used in __tree and __hash_table\n#ifndef _LIBCPP_CXX03_LANG\nstruct __extract_key_fail_tag {};\nstruct __extract_key_self_tag {};\nstruct __extract_key_first_tag {};\n\ntemplate <class _ValTy, class _Key,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_key\n    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,\n                  __extract_key_fail_tag>::type {};\n\ntemplate <class _Pair, class _Key, class _First, class _Second>\nstruct __can_extract_key<_Pair, _Key, pair<_First, _Second>>\n    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,\n                  __extract_key_first_tag, __extract_key_fail_tag>::type {};\n\n// __can_extract_map_key uses true_type/false_type instead of the tags.\n// It returns true if _Key != _ContainerValueTy (the container is a map not a set)\n// and _ValTy == _Key.\ntemplate <class _ValTy, class _Key, class _ContainerValueTy,\n          class _RawValTy = typename __unconstref<_ValTy>::type>\nstruct __can_extract_map_key\n    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};\n\n// This specialization returns __extract_key_fail_tag for non-map containers\n// because _Key == _ContainerValueTy\ntemplate <class _ValTy, class _Key, class _RawValTy>\nstruct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>\n    : false_type {};\n\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TYPE_TRAITS\n","/*\n *  ether_dummy.cpp - Ethernet device driver, dummy implementation\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"sysdeps.h\"\n\n#if SUPPORTS_UDP_TUNNEL\n#include <netinet/in.h>\n#include <sys/socket.h>\n#endif\n\n#include \"cpu_emulation.h\"\n#include \"main.h\"\n#include \"macos_util.h\"\n#include \"prefs.h\"\n#include \"user_strings.h\"\n#include \"ether.h\"\n#include \"ether_defs.h\"\n\n#define DEBUG 0\n#include \"debug.h\"\n\n#define MONITOR 0\n\n\n// Global variables\n#if SUPPORTS_UDP_TUNNEL\nstatic int fd = -1;\t\t\t\t\t\t// UDP tunnel socket fd\nstatic bool udp_tunnel_active = false;\n#endif\n\n\n/*\n *  Initialization\n */\n\nbool ether_init(void)\n{\n\treturn true;\n}\n\n\n/*\n *  Deinitialization\n */\n\nvoid ether_exit(void)\n{\n}\n\n\n/*\n *  Reset\n */\n\nvoid ether_reset(void)\n{\n}\n\n\n/*\n *  Add multicast address\n */\n\nint16 ether_add_multicast(uint32 pb)\n{\n\treturn noErr;\n}\n\n\n/*\n *  Delete multicast address\n */\n\nint16 ether_del_multicast(uint32 pb)\n{\n\treturn noErr;\n}\n\n\n/*\n *  Attach protocol handler\n */\n\nint16 ether_attach_ph(uint16 type, uint32 handler)\n{\n\treturn noErr;\n}\n\n\n/*\n *  Detach protocol handler\n */\n\nint16 ether_detach_ph(uint16 type)\n{\n\treturn noErr;\n}\n\n\n/*\n *  Transmit raw ethernet packet\n */\n\nint16 ether_write(uint32 wds)\n{\n\t// Set source address\n\tuint32 hdr = ReadMacInt32(wds + 2);\n\tmemcpy(Mac2HostAddr(hdr + 6), ether_addr, 6);\n\treturn noErr;\n}\n\n\n/*\n *  Start UDP packet reception thread\n */\n\nbool ether_start_udp_thread(int socket_fd)\n{\n#if SUPPORTS_UDP_TUNNEL\n\tfd = socket_fd;\n\tudp_tunnel_active = true;\n\treturn true;\n#else\n\treturn false;\n#endif\n}\n\n\n/*\n *  Stop UDP packet reception thread\n */\n\nvoid ether_stop_udp_thread(void)\n{\n#if SUPPORTS_UDP_TUNNEL\n\tudp_tunnel_active = false;\n#endif\n}\n\n\n/*\n *  Ethernet interrupt - activate deferred tasks to call IODone or protocol handlers\n */\n\nvoid EtherInterrupt(void)\n{\n#if SUPPORTS_UDP_TUNNEL\n\tif (udp_tunnel_active) {\n\t\tEthernetPacket ether_packet;\n\t\tuint32 packet = ether_packet.addr();\n\t\tssize_t length;\n\n\t\t// Read packets from socket and hand to ether_udp_read() for processing\n\t\twhile (true) {\n\t\t\tstruct sockaddr_in from;\n\t\t\tsocklen_t from_len = sizeof(from);\n\t\t\tlength = recvfrom(fd, Mac2HostAddr(packet), 1514, 0, (struct sockaddr *)&from, &from_len);\n\t\t\tif (length < 14)\n\t\t\t\tbreak;\n\t\t\tether_udp_read(packet, length, &from);\n\t\t}\n\t}\n#endif\n}\n","/*\n *  scsi_dummy.cpp - SCSI Manager, dummy implementation\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"sysdeps.h\"\n#include \"scsi.h\"\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n/*\n *  Initialization\n */\n\nvoid SCSIInit(void)\n{\n\t// Reset SCSI bus\n\tSCSIReset();\n}\n\n\n/*\n *  Deinitialization\n */\n\nvoid SCSIExit(void)\n{\n}\n\n\n/*\n *  Set SCSI command to be sent by scsi_send_cmd()\n */\n\nvoid scsi_set_cmd(int cmd_length, uint8 *cmd)\n{\n}\n\n\n/*\n *  Check for presence of SCSI target\n */\n\nbool scsi_is_target_present(int id)\n{\n\treturn false;\n}\n\n\n/*\n *  Set SCSI target (returns false on error)\n */\n\nbool scsi_set_target(int id, int lun)\n{\n\treturn false;\n}\n\n\n/*\n *  Send SCSI command to active target (scsi_set_command() must have been called),\n *  read/write data according to S/G table (returns false on error)\n */\n\nbool scsi_send_cmd(size_t data_length, bool reading, int sg_size, uint8 **sg_ptr, uint32 *sg_len, uint16 *stat, uint32 timeout)\n{\n\treturn false;\n}\n\n","/*\n *  serial.h - Serial device driver\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef SERIAL_H\n#define SERIAL_H\n\n/*\n *  port:\n *    0 - .AIn\n *    1 - .AOut\n *    2 - .BIn\n *    3 - .BOut\n */\n\n#ifdef POWERPC_ROM\nextern int16 SerialOpen(uint32 pb, uint32 dce);\nextern int16 SerialPrimeIn(uint32 pb, uint32 dce);\nextern int16 SerialPrimeOut(uint32 pb, uint32 dce);\nextern int16 SerialControl(uint32 pb, uint32 dce);\nextern int16 SerialStatus(uint32 pb, uint32 dce);\nextern int16 SerialClose(uint32 pb, uint32 dce);\nextern int16 SerialNothing(uint32 pb, uint32 dce);\n#else\nextern int16 SerialOpen(uint32 pb, uint32 dce, int port);\nextern int16 SerialPrime(uint32 pb, uint32 dce, int port);\nextern int16 SerialControl(uint32 pb, uint32 dce, int port);\nextern int16 SerialStatus(uint32 pb, uint32 dce, int port);\nextern int16 SerialClose(uint32 pb, uint32 dce, int port);\n#endif\n\nextern void SerialInterrupt(void);\n\n// System specific and internal functions/data\nextern void SerialInit(void);\nextern void SerialExit(void);\n\n// Serial driver Deferred Task structure\nenum {\n\tserdtCode = 20,\t\t// DT code is stored here\n\tserdtResult = 30,\n\tserdtDCE = 34,\n\tSIZEOF_serdt = 38\n};\n\n// Variables for one (In/Out combined) serial port\n// To implement a serial driver, you create a subclass of SERDPort\nclass SERDPort {\npublic:\n\tSERDPort()\n\t{\n\t\tis_open = false;\n\t\tinput_dt = output_dt = 0;\n\t}\n\n\tvirtual ~SERDPort() {}\n\n\tvirtual int16 open(uint16 config) = 0;\n\tvirtual int16 prime_in(uint32 pb, uint32 dce) = 0;\n\tvirtual int16 prime_out(uint32 pb, uint32 dce) = 0;\n\tvirtual int16 control(uint32 pb, uint32 dce, uint16 code) = 0;\n\tvirtual int16 status(uint32 pb, uint32 dce, uint16 code) = 0;\n\tvirtual int16 close(void) = 0;\n\n\tbool is_open;\t\t// Port has been opened\n\tuint8 cum_errors;\t// Cumulative errors\n\n\tbool read_pending;\t// Read operation pending\n\tbool read_done;\t\t// Read operation complete\n\tuint32 input_dt;\t// Mac address of Deferred Task for reading\n\n\tbool write_pending;\t// Write operation pending\n\tbool write_done;\t// Write operation complete\n\tuint32 output_dt;\t// Mac address of Deferred Task for writing\n\n#ifdef POWERPC_ROM\n\tuint32 dt_store;\n#endif\n};\n\nextern SERDPort *the_serd_port[2];\n\n#endif\n","/*\n *  serial_dummy.cpp - Serial device driver, dummy implementation\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"sysdeps.h\"\n#include \"cpu_emulation.h\"\n#include \"main.h\"\n#include \"macos_util.h\"\n#include \"prefs.h\"\n#include \"serial.h\"\n#include \"serial_defs.h\"\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n// Driver private variables\nclass DSERDPort : public SERDPort {\npublic:\n\tDSERDPort(const char *dev)\n\t{\n\t\tdevice_name = (char *)dev;\n\t}\n\n\tvirtual ~DSERDPort()\n\t{\n\t}\n\n\tvirtual int16 open(uint16 config);\n\tvirtual int16 prime_in(uint32 pb, uint32 dce);\n\tvirtual int16 prime_out(uint32 pb, uint32 dce);\n\tvirtual int16 control(uint32 pb, uint32 dce, uint16 code);\n\tvirtual int16 status(uint32 pb, uint32 dce, uint16 code);\n\tvirtual int16 close(void);\n\nprivate:\n\tchar *device_name;\t\t\t// Device name\n};\n\n\n/*\n *  Initialization\n */\n\nvoid SerialInit(void)\n{\n\t// Read serial preferences and create structs for both ports\n\tthe_serd_port[0] = new DSERDPort(PrefsFindString(\"seriala\"));\n\tthe_serd_port[1] = new DSERDPort(PrefsFindString(\"serialb\"));\n}\n\n\n/*\n *  Deinitialization\n */\n\nvoid SerialExit(void)\n{\n\tdelete (DSERDPort *)the_serd_port[0];\n\tdelete (DSERDPort *)the_serd_port[1];\n}\n\n\n/*\n *  Open serial port\n */\n\nint16 DSERDPort::open(uint16 config)\n{\n\treturn openErr;\n}\n\n\n/*\n *  Read data from port\n */\n\nint16 DSERDPort::prime_in(uint32 pb, uint32 dce)\n{\n\treturn readErr;\n}\n\n\n/*\n *  Write data to port\n */\n\nint16 DSERDPort::prime_out(uint32 pb, uint32 dce)\n{\n\treturn writErr;\n}\n\n\n/*\n *\tControl calls\n */\n \nint16 DSERDPort::control(uint32 pb, uint32 dce, uint16 code)\n{\n\treturn controlErr;\n}\n\n\n/*\n *\tStatus calls\n */\n\nint16 DSERDPort::status(uint32 pb, uint32 dce, uint16 code)\n{\n\treturn statusErr;\n}\n\n\n/*\n *\tClose serial port\n */\n\nint16 DSERDPort::close()\n{\n\treturn noErr;\n}\n","// -*- C++ -*-\n//===--------------------------- stdexcept --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STDEXCEPT\n#define _LIBCPP_STDEXCEPT\n\n/*\n    stdexcept synopsis\n\nnamespace std\n{\n\nclass logic_error;\n    class domain_error;\n    class invalid_argument;\n    class length_error;\n    class out_of_range;\nclass runtime_error;\n    class range_error;\n    class overflow_error;\n    class underflow_error;\n\nfor each class xxx_error:\n\nclass xxx_error : public exception // at least indirectly\n{\npublic:\n    explicit xxx_error(const string& what_arg);\n    explicit xxx_error(const char*   what_arg);\n\n    virtual const char* what() const noexcept // returns what_arg\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <iosfwd>  // for string forward decl\n#ifdef _LIBCPP_NO_EXCEPTIONS\n#include <cstdlib>\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_HIDDEN __libcpp_refstring\n{\n    const char* __imp_;\n\n    bool __uses_refcount() const;\npublic:\n    explicit __libcpp_refstring(const char* msg);\n    __libcpp_refstring(const __libcpp_refstring& s) _NOEXCEPT;\n    __libcpp_refstring& operator=(const __libcpp_refstring& s) _NOEXCEPT;\n    ~__libcpp_refstring();\n\n    const char* c_str() const _NOEXCEPT {return __imp_;}\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI logic_error\n    : public exception\n{\nprivate:\n    _VSTD::__libcpp_refstring __imp_;\npublic:\n    explicit logic_error(const string&);\n    explicit logic_error(const char*);\n\n    logic_error(const logic_error&) _NOEXCEPT;\n    logic_error& operator=(const logic_error&) _NOEXCEPT;\n\n    virtual ~logic_error() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI runtime_error\n    : public exception\n{\nprivate:\n    _VSTD::__libcpp_refstring __imp_;\npublic:\n    explicit runtime_error(const string&);\n    explicit runtime_error(const char*);\n\n    runtime_error(const runtime_error&) _NOEXCEPT;\n    runtime_error& operator=(const runtime_error&) _NOEXCEPT;\n\n    virtual ~runtime_error() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI domain_error\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const char* __s)   : logic_error(__s) {}\n\n    virtual ~domain_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI invalid_argument\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const char* __s)   : logic_error(__s) {}\n\n    virtual ~invalid_argument() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI length_error\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit length_error(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit length_error(const char* __s)   : logic_error(__s) {}\n\n    virtual ~length_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI out_of_range\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const char* __s)   : logic_error(__s) {}\n\n    virtual ~out_of_range() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI range_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit range_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit range_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~range_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI overflow_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~overflow_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI underflow_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~underflow_error() _NOEXCEPT;\n};\n\n}  // std\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// in the dylib\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_logic_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw logic_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_domain_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw domain_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_invalid_argument(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw invalid_argument(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_length_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_out_of_range(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_range_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw range_error(__msg);\n#else\n    ((void)__msg);\n\t  _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_overflow_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw overflow_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE\nvoid __throw_underflow_error(const char*__msg)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw underflow_error(__msg);\n#else\n    ((void)__msg);\n    _VSTD::abort();\n#endif\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STDEXCEPT\n","/*\n *  timer_unix.cpp - Time Manager emulation, Unix specific stuff\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"sysdeps.h\"\n#include \"macos_util.h\"\n#include \"timer.h\"\n\n#include <errno.h>\n\n#define DEBUG 0\n#include \"debug.h\"\n\n// For NetBSD with broken pthreads headers\n#ifndef CLOCK_REALTIME\n#define CLOCK_REALTIME 0\n#endif\n\n#if defined(__MACH__)\n#include <mach/mach.h>\n#include <mach/clock.h>\n\nstatic clock_serv_t host_clock;\nstatic bool host_clock_inited = false;\n\nstatic inline void mach_current_time(tm_time_t &t) {\n\tif(!host_clock_inited) {\n\t\thost_get_clock_service(mach_host_self(), SYSTEM_CLOCK, &host_clock);\n\t\thost_clock_inited = true;\n\t}\n\t\n\tclock_get_time(host_clock, &t);\n}\n#endif\n\n\n#include <time.h>\n/*\n *  Return microseconds since boot (64 bit)\n */\n\nvoid Microseconds(uint32 &hi, uint32 &lo)\n{\n\tD(bug(\"Microseconds\\n\"));\n#if HAVE_CLOCK_GETTIME\n\tstruct timespec t;\n\tclock_gettime(CLOCK_REALTIME, &t);\n\tuint64 tl = (uint64)t.tv_sec * 1000000 + t.tv_nsec / 1000;\n#elif defined(__MACH__)\n\ttm_time_t t;\n\tmach_current_time(t);\n\tuint64 tl = (uint64)t.tv_sec * 1000000 + t.tv_nsec / 1000;\n#else\n\tstruct timeval t;\n\tgettimeofday(&t, NULL);\n\tuint64 tl = (uint64)t.tv_sec * 1000000 + t.tv_usec;\n#endif\n\thi = tl >> 32;\n\tlo = tl;\n}\n\n\n/*\n *  Return local date/time in Mac format (seconds since 1.1.1904)\n */\n\nuint32 TimerDateTime(void)\n{\n\treturn TimeToMacTime(time(NULL));\n}\n\n\n/*\n *  Get current time\n */\n\nvoid timer_current_time(tm_time_t &t)\n{\n#ifdef HAVE_CLOCK_GETTIME\n\tclock_gettime(CLOCK_REALTIME, &t);\n#elif defined(__MACH__)\n\tmach_current_time(t);\n#else\n\tgettimeofday(&t, NULL);\n#endif\n}\n\n\n/*\n *  Add times\n */\n\nvoid timer_add_time(tm_time_t &res, tm_time_t a, tm_time_t b)\n{\n#if defined(HAVE_CLOCK_GETTIME) || defined(__MACH__)\n\tres.tv_sec = a.tv_sec + b.tv_sec;\n\tres.tv_nsec = a.tv_nsec + b.tv_nsec;\n\tif (res.tv_nsec >= 1000000000) {\n\t\tres.tv_sec++;\n\t\tres.tv_nsec -= 1000000000;\n\t}\n#else\n\tres.tv_sec = a.tv_sec + b.tv_sec;\n\tres.tv_usec = a.tv_usec + b.tv_usec;\n\tif (res.tv_usec >= 1000000) {\n\t\tres.tv_sec++;\n\t\tres.tv_usec -= 1000000;\n\t}\n#endif\n}\n\n\n/*\n *  Subtract times\n */\n\nvoid timer_sub_time(tm_time_t &res, tm_time_t a, tm_time_t b)\n{\n#if defined(HAVE_CLOCK_GETTIME) || defined(__MACH__)\n\tres.tv_sec = a.tv_sec - b.tv_sec;\n\tres.tv_nsec = a.tv_nsec - b.tv_nsec;\n\tif (res.tv_nsec < 0) {\n\t\tres.tv_sec--;\n\t\tres.tv_nsec += 1000000000;\n\t}\n#else\n\tres.tv_sec = a.tv_sec - b.tv_sec;\n\tres.tv_usec = a.tv_usec - b.tv_usec;\n\tif (res.tv_usec < 0) {\n\t\tres.tv_sec--;\n\t\tres.tv_usec += 1000000;\n\t}\n#endif\n}\n\n\n/*\n *  Compare times (<0: a < b, =0: a = b, >0: a > b)\n */\n\nint timer_cmp_time(tm_time_t a, tm_time_t b)\n{\n#if defined(HAVE_CLOCK_GETTIME) || defined(__MACH__)\n\tif (a.tv_sec == b.tv_sec)\n\t\treturn a.tv_nsec - b.tv_nsec;\n\telse\n\t\treturn a.tv_sec - b.tv_sec;\n#else\n\tif (a.tv_sec == b.tv_sec)\n\t\treturn a.tv_usec - b.tv_usec;\n\telse\n\t\treturn a.tv_sec - b.tv_sec;\n#endif\n}\n\n\n/*\n *  Convert Mac time value (>0: microseconds, <0: microseconds) to tm_time_t\n */\n\nvoid timer_mac2host_time(tm_time_t &res, int32 mactime)\n{\n#if defined(HAVE_CLOCK_GETTIME) || defined(__MACH__)\n\tif (mactime > 0) {\n\t\t// Time in milliseconds\n\t\tres.tv_sec = mactime / 1000;\n\t\tres.tv_nsec = (mactime % 1000) * 1000000;\n\t} else {\n\t\t// Time in negative microseconds\n\t\tres.tv_sec = -mactime / 1000000;\n\t\tres.tv_nsec = (-mactime % 1000000) * 1000;\n\t}\n#else\n\tif (mactime > 0) {\n\t\t// Time in milliseconds\n\t\tres.tv_sec = mactime / 1000;\n\t\tres.tv_usec = (mactime % 1000) * 1000;\n\t} else {\n\t\t// Time in negative microseconds\n\t\tres.tv_sec = -mactime / 1000000;\n\t\tres.tv_usec = -mactime % 1000000;\n\t}\n#endif\n}\n\n\n/*\n *  Convert positive tm_time_t to Mac time value (>0: microseconds, <0: microseconds)\n *  A negative input value for hosttime results in a zero return value\n *  As long as the microseconds value fits in 32 bit, it must not be converted to milliseconds!\n */\n\nint32 timer_host2mac_time(tm_time_t hosttime)\n{\n\tif (hosttime.tv_sec < 0)\n\t\treturn 0;\n\telse {\n#if defined(HAVE_CLOCK_GETTIME) || defined(__MACH__)\n\t\tuint64 t = (uint64)hosttime.tv_sec * 1000000 + hosttime.tv_nsec / 1000;\n#else\n\t\tuint64 t = (uint64)hosttime.tv_sec * 1000000 + hosttime.tv_usec;\n#endif\n\t\tif (t > 0x7fffffff)\n\t\t\treturn t / 1000;\t// Time in milliseconds\n\t\telse\n\t\t\treturn -t;\t\t\t// Time in negative microseconds\n\t}\n}\n\n\n/*\n *  Get current value of microsecond timer\n */\n\nuint64 GetTicks_usec(void)\n{\n#ifdef HAVE_CLOCK_GETTIME\n\tstruct timespec t;\n\tclock_gettime(CLOCK_REALTIME, &t);\n\treturn (uint64)t.tv_sec * 1000000 + t.tv_nsec / 1000;\n#elif defined(__MACH__)\n\ttm_time_t t;\n\tmach_current_time(t);\n\treturn (uint64)t.tv_sec * 1000000 + t.tv_nsec / 1000;\n#else\n\tstruct timeval t;\n\tgettimeofday(&t, NULL);\n\treturn (uint64)t.tv_sec * 1000000 + t.tv_usec;\n#endif\n}\n\n\n/*\n *  Delay by specified number of microseconds (<1 second)\n *  (adapted from SDL_Delay() source; this function is designed to provide\n *  the highest accuracy possible)\n */\n\n#if defined(linux)\n// Linux select() changes its timeout parameter upon return to contain\n// the remaining time. Most other unixen leave it unchanged or undefined.\n#define SELECT_SETS_REMAINING\n#elif defined(__FreeBSD__) || defined(__sun__) || (defined(__MACH__) && defined(__APPLE__))\n#define USE_NANOSLEEP\n#elif defined(HAVE_PTHREADS) && defined(sgi)\n// SGI pthreads has a bug when using pthreads+signals+nanosleep,\n// so instead of using nanosleep, wait on a CV which is never signalled.\n#include <pthread.h>\n#define USE_COND_TIMEDWAIT\n#endif\n\nvoid Delay_usec(uint32 usec)\n{\n\tint was_error;\n\n#if defined(USE_NANOSLEEP)\n\tstruct timespec elapsed, tv;\n#elif defined(USE_COND_TIMEDWAIT)\n\t// Use a local mutex and cv, so threads remain independent\n\tpthread_cond_t delay_cond = PTHREAD_COND_INITIALIZER;\n\tpthread_mutex_t delay_mutex = PTHREAD_MUTEX_INITIALIZER;\n\tstruct timespec elapsed;\n\tuint64 future;\n#else\n\tstruct timeval tv;\n#ifndef SELECT_SETS_REMAINING\n\tuint64 then, now, elapsed;\n#endif\n#endif\n\n\t// Set the timeout interval - Linux only needs to do this once\n#if defined(SELECT_SETS_REMAINING)\n    tv.tv_sec = 0;\n    tv.tv_usec = usec;\n#elif defined(USE_NANOSLEEP)\n    elapsed.tv_sec = 0;\n    elapsed.tv_nsec = usec * 1000;\n#elif defined(USE_COND_TIMEDWAIT)\n\tfuture = GetTicks_usec() + usec;\n\telapsed.tv_sec = future / 1000000;\n\telapsed.tv_nsec = (future % 1000000) * 1000;\n#else\n    then = GetTicks_usec();\n#endif\n\n\tdo {\n\t\terrno = 0;\n#if defined(USE_NANOSLEEP)\n\t\ttv.tv_sec = elapsed.tv_sec;\n\t\ttv.tv_nsec = elapsed.tv_nsec;\n\t\twas_error = nanosleep(&tv, &elapsed);\n#elif defined(USE_COND_TIMEDWAIT)\n\t\twas_error = pthread_mutex_lock(&delay_mutex);\n\t\twas_error = pthread_cond_timedwait(&delay_cond, &delay_mutex, &elapsed);\n\t\twas_error = pthread_mutex_unlock(&delay_mutex);\n#else\n#ifndef SELECT_SETS_REMAINING\n\t\t// Calculate the time interval left (in case of interrupt)\n\t\tnow = GetTicks_usec();\n\t\telapsed = now - then;\n\t\tthen = now;\n\t\tif (elapsed >= usec)\n\t\t\tbreak;\n\t\tusec -= elapsed;\n\t\ttv.tv_sec = 0;\n\t\ttv.tv_usec = usec;\n#endif\n\t\twas_error = select(0, NULL, NULL, NULL, &tv);\n#endif\n\t} while (was_error && (errno == EINTR));\n}\n\n\n/*\n *  Suspend emulator thread, virtual CPU in idle mode\n */\n\n#ifdef HAVE_PTHREADS\n#if defined(HAVE_PTHREAD_COND_INIT)\n#define IDLE_USES_COND_WAIT 1\nstatic pthread_mutex_t idle_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t idle_cond = PTHREAD_COND_INITIALIZER;\n#elif defined(HAVE_SEM_INIT)\n#define IDLE_USES_SEMAPHORE 1\n#include <semaphore.h>\n#ifdef HAVE_SPINLOCKS\nstatic spinlock_t idle_lock = SPIN_LOCK_UNLOCKED;\n#define LOCK_IDLE spin_lock(&idle_lock)\n#define UNLOCK_IDLE spin_unlock(&idle_lock)\n#else\nstatic pthread_mutex_t idle_lock = PTHREAD_MUTEX_INITIALIZER;\n#define LOCK_IDLE pthread_mutex_lock(&idle_lock)\n#define UNLOCK_IDLE pthread_mutex_unlock(&idle_lock)\n#endif\nstatic sem_t idle_sem;\nstatic int idle_sem_ok = -1;\n#endif\n#endif\n\nvoid idle_wait(void)\n{\n#ifdef IDLE_USES_COND_WAIT\n\tpthread_mutex_lock(&idle_lock);\n\tpthread_cond_wait(&idle_cond, &idle_lock);\n\tpthread_mutex_unlock(&idle_lock);\n#else\n#ifdef IDLE_USES_SEMAPHORE\n\tLOCK_IDLE;\n\tif (idle_sem_ok < 0)\n\t\tidle_sem_ok = (sem_init(&idle_sem, 0, 0) == 0);\n\tif (idle_sem_ok > 0) {\n\t\tidle_sem_ok++;\n\t\tUNLOCK_IDLE;\n\t\tsem_wait(&idle_sem);\n\t\treturn;\n\t}\n\tUNLOCK_IDLE;\n#endif\n\n\t// Fallback: sleep 10 ms\n\tDelay_usec(10000);\n#endif\n}\n\n\n/*\n *  Resume execution of emulator thread, events just arrived\n */\n\nvoid idle_resume(void)\n{\n#ifdef IDLE_USES_COND_WAIT\n\tpthread_cond_signal(&idle_cond);\n#else\n#ifdef IDLE_USES_SEMAPHORE\n\tLOCK_IDLE;\n\tif (idle_sem_ok > 1) {\n\t\tidle_sem_ok--;\n\t\tUNLOCK_IDLE;\n\t\tsem_post(&idle_sem);\n\t\treturn;\n\t}\n\tUNLOCK_IDLE;\n#endif\n#endif\n}\n","// -*- C++ -*-\n//===-------------------------- algorithm ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ALGORITHM\n#define _LIBCPP_ALGORITHM\n\n/*\n    algorithm synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    all_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    any_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    none_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Function>\n    Function\n    for_each(InputIterator first, InputIterator last, Function f);\n\ntemplate <class InputIterator, class T>\n    InputIterator\n    find(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    InputIterator\n    find_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate<class InputIterator, class Predicate>\n    InputIterator\n    find_if_not(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class T>\n    typename iterator_traits<InputIterator>::difference_type\n    count(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    typename iterator_traits<InputIterator>::difference_type\n    count_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2,\n             BinaryPredicate pred); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2,\n          BinaryPredicate pred); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, BinaryPredicate pred);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2,\n                   BinaryPredicate pred);  // **C++14**\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator, class Size, class T>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);\n\ntemplate <class ForwardIterator, class Size, class T, class BinaryPredicate>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last,\n             Size count, const T& value, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate<class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    copy_if(InputIterator first, InputIterator last,\n            OutputIterator result, Predicate pred);\n\ntemplate<class InputIterator, class Size, class OutputIterator>\n    OutputIterator\n    copy_n(InputIterator first, Size n, OutputIterator result);\n\ntemplate <class BidirectionalIterator1, class BidirectionalIterator2>\n    BidirectionalIterator2\n    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,\n                  BidirectionalIterator2 result);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator2\n    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    void\n    iter_swap(ForwardIterator1 a, ForwardIterator2 b);\n\ntemplate <class InputIterator, class OutputIterator, class UnaryOperation>\n    OutputIterator\n    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,\n              OutputIterator result, BinaryOperation binary_op);\n\ntemplate <class ForwardIterator, class T>\n    void\n    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);\n\ntemplate <class ForwardIterator, class Predicate, class T>\n    void\n    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    replace_copy(InputIterator first, InputIterator last, OutputIterator result,\n                 const T& old_value, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate, class T>\n    OutputIterator\n    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);\n\ntemplate <class ForwardIterator, class T>\n    void\n    fill(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class OutputIterator, class Size, class T>\n    OutputIterator\n    fill_n(OutputIterator first, Size n, const T& value);\n\ntemplate <class ForwardIterator, class Generator>\n    void\n    generate(ForwardIterator first, ForwardIterator last, Generator gen);\n\ntemplate <class OutputIterator, class Size, class Generator>\n    OutputIterator\n    generate_n(OutputIterator first, Size n, Generator gen);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    remove(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryPredicate>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);\n\ntemplate <class BidirectionalIterator>\n    void\n    reverse(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class OutputIterator>\n    OutputIterator\n    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\n\ntemplate <class ForwardIterator, class OutputIterator>\n    OutputIterator\n    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);\n\ntemplate <class RandomAccessIterator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last); // deprecated in C++14\n\ntemplate <class RandomAccessIterator, class RandomNumberGenerator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                   RandomNumberGenerator& rand);  // deprecated in C++14\n\ntemplate<class PopulationIterator, class SampleIterator,\n         class Distance, class UniformRandomBitGenerator>\n    SampleIterator sample(PopulationIterator first, PopulationIterator last,\n                          SampleIterator out, Distance n,\n                          UniformRandomBitGenerator&& g); // C++17\n\ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>\n    void shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                 UniformRandomNumberGenerator&& g);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    is_partitioned(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator1,\n          class OutputIterator2, class Predicate>\n    pair<OutputIterator1, OutputIterator2>\n    partition_copy(InputIterator first, InputIterator last,\n                   OutputIterator1 out_true, OutputIterator2 out_false,\n                   Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate<class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class ForwardIterator>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class ForwardIterator>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);\n\ntemplate <class InputIterator, class RandomAccessIterator>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last);\n\ntemplate <class InputIterator, class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    min(const T& a, const T& b);  // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    min(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    min(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    min(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi );               // C++17\n\ntemplate<class T, class Compare>\n    constexpr const T& clamp( const T& v, const T& lo, const T& hi, Compare comp ); // C++17\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last);  // constexpr in C++14\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last, Compare comp);  // constexpr in C++14\n\ntemplate <class T>\n    const T&\n    max(const T& a, const T& b); // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    max(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    max(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    max(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class ForwardIterator>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last);   // constexpr in C++14\n\ntemplate<class ForwardIterator, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);   // constexpr in C++14\n\ntemplate<class T>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    pair<T, T>\n    minmax(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<T, T>\n    minmax(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n                            InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <initializer_list>\n#include <type_traits>\n#include <cstring>\n#include <utility> // needed to provide swap_ranges.\n#include <memory>\n#include <iterator>\n#include <cstddef>\n\n#if defined(__IBMCPP__)\n#include \"support/ibm/support.h\"\n#endif\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include \"support/win32/support.h\"\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// I'd like to replace these with _VSTD::equal_to<void>, but can't because:\n//   * That only works with C++14 and later, and\n//   * We haven't included <functional> here.\ntemplate <class _T1, class _T2 = _T1>\nstruct __equal_to\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __less\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _Predicate>\nclass __negate\n{\nprivate:\n    _Predicate __p_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __negate() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __negate(_Predicate __p) : __p_(__p) {}\n\n    template <class _T1>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x) {return !__p_(__x);}\n\n    template <class _T1, class _T2>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}\n};\n\n#ifdef _LIBCPP_DEBUG\n\ntemplate <class _Compare>\nstruct __debug_less\n{\n    _Compare __comp_;\n    __debug_less(_Compare& __c) : __comp_(__c) {}\n\n    template <class _Tp, class _Up>\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        bool __r = __comp_(__x, __y);\n        if (__r)\n            __do_compare_assert(0, __y, __x);\n        return __r;\n    }\n\n    template <class _LHS, class _RHS>\n    inline _LIBCPP_INLINE_VISIBILITY\n    decltype((void)_VSTD::declval<_Compare&>()(\n        _VSTD::declval<_LHS const&>(), _VSTD::declval<_RHS const&>()))\n    __do_compare_assert(int, _LHS const& __l, _RHS const& __r) {\n        _LIBCPP_ASSERT(!__comp_(__l, __r),\n            \"Comparator does not induce a strict weak ordering\");\n    }\n\n    template <class _LHS, class _RHS>\n    inline _LIBCPP_INLINE_VISIBILITY\n    void __do_compare_assert(long, _LHS const&, _RHS const&) {}\n};\n\n#endif  // _LIBCPP_DEBUG\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__ctz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_ctz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__ctz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_ctzl(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__ctz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_ctzll(__x));\n}\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__clz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_clz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__clz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_clzl (__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__clz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_clzll(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned           __x) {return __builtin_popcount  (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned      long __x) {return __builtin_popcountl (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}\n\n// all_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nall_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            return false;\n    return true;\n}\n\n// any_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nany_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return true;\n    return false;\n}\n\n// none_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnone_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// for_each\n\ntemplate <class _InputIterator, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n    for (; __first != __last; ++__first)\n        __f(*__first);\n    return __f;\n}\n\n// find\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            break;\n    return __first;\n}\n\n// find_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_if_not\n\ntemplate<class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_end\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n           forward_iterator_tag, forward_iterator_tag)\n{\n    // modeled after search algorithm\n    _ForwardIterator1 __r = __last1;  // __last1 is the \"default\" answer\n    if (__first2 == __last2)\n        return __r;\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __last1)         // if source exhausted return last correct answer\n                return __r;                  //    (or __last1 if never found)\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)\n            {                         // Pattern exhaused, record answer and search for another one\n                __r = __first1;\n                ++__first1;\n                break;\n            }\n            if (++__m1 == __last1)     // Source exhausted, return last answer\n                return __r;\n            if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>\n_BidirectionalIterator1\n__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,\n           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,\n           bidirectional_iterator_tag, bidirectional_iterator_tag)\n{\n    // modeled after search algorithm (in reverse)\n    if (__first2 == __last2)\n        return __last1;  // Everything matches an empty sequence\n    _BidirectionalIterator1 __l1 = __last1;\n    _BidirectionalIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __l1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        // *__l1 matches *__l2, now match elements before here\n        _BidirectionalIterator1 __m1 = __l1;\n        _BidirectionalIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)  // If pattern exhausted, __m1 is the answer (works for 1 element pattern)\n                return __m1;\n            if (__m1 == __first1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*--__m1, *--__m2))  // if there is a mismatch, restart with a new __l1\n            {\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1\n__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __last1;\n    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);  // End of pattern match can't go before here\n    _RandomAccessIterator1 __l1 = __last1;\n    _RandomAccessIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        while (true)\n        {\n            if (__s == __l1)\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        _RandomAccessIterator1 __m1 = __l1;\n        _RandomAccessIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)\n                return __m1;\n                                 // no need to check range on __m1 because __s guarantees we have enough source\n            if (!__pred(*--__m1, *--__m2))\n            {\n                break;\n            }\n        }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// find_first_of\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator1\n__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1)\n        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n            if (__pred(*__first1, *__j))\n                return __first1;\n    return __last1;\n}\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// adjacent_find\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__first, *__i))\n                return __first;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());\n}\n\n// count\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            ++__r;\n    return __r;\n}\n\n// count_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            ++__r;\n    return __r;\n}\n\n// mismatch\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2,\n         _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n#endif\n\n// equal\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,\n        input_iterator_tag, input_iterator_tag )\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return __first1 == __last1 && __first2 == __last2;\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n      random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,\n                        typename add_lvalue_reference<_BinaryPredicate>::type>\n                       (__first1, __last1, __first2, __pred );\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )\n{\n    return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n#endif\n\n// is_permutation\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _BinaryPredicate __pred)\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return true;\n__not_done:\n    // __first1 != __last1 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n    if (__l1 == _D1(1))\n        return false;\n    _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\nbool\n__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                 _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n                 _BinaryPredicate __pred,\n                 forward_iterator_tag, forward_iterator_tag )\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return __first1 == __last1 && __first2 == __last2;\n__not_done:\n    // __first1 != __last1 && __first2 != __last2 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n\n    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;\n    _D2 __l2 = _VSTD::distance(__first2, __last2);\n    if (__l1 != __l2)\n        return false;\n\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\nbool\n__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,\n               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2,\n               _BinaryPredicate __pred,\n               random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,\n                                 typename add_lvalue_reference<_BinaryPredicate>::type>\n                                (__first1, __last1, __first2, __pred );\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n               _BinaryPredicate __pred )\n{\n    return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,\n        __equal_to<__v1, __v2>(),\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n#endif\n\n// search\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\npair<_ForwardIterator1, _ForwardIterator1>\n__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n         forward_iterator_tag, forward_iterator_tag)\n{\n    if (__first2 == __last2)\n        return make_pair(__first1, __first1);  // Everything matches an empty sequence\n    while (true)\n    {\n        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __last1)  // return __last1 if no element matches *__first2\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)\n                return make_pair(__first1, __m1);\n            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found\n                return make_pair(__last1, __last1);\n            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_RandomAccessIterator1, _RandomAccessIterator1>\n__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;\n    typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    const _D2 __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return make_pair(__first1, __first1);\n    const _D1 __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return make_pair(__last1, __last1);\n    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here\n\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __s)\n                return make_pair(__last1, __last1);\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n\n        _RandomAccessIterator1 __m1 = __first1;\n        _RandomAccessIterator2 __m2 = __first2;\n         while (true)\n         {\n             if (++__m2 == __last2)\n                 return make_pair(__first1, __first1 + __len2);\n             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source\n             if (!__pred(*__m1, *__m2))\n             {\n                 ++__first1;\n                 break;\n             }\n         }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category())\n            .first;\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// search_n\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\n__search_n(_ForwardIterator __first, _ForwardIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first == __last)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _ForwardIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n            if (++__m == __last)  // Otherwise if source exhaused, pattern not found\n                return __last;\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>\n_RandomAccessIterator\n__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    _Size __len = static_cast<_Size>(__last - __first);\n    if (__len < __count)\n        return __last;\n    const _RandomAccessIterator __s = __last - (__count - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first >= __s)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _RandomAccessIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n             ++__m;          // no need to check range on __m because __s guarantees we have enough source\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last,\n         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)\n{\n    return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>\n           (__first, __last, __convert_to_integral(__count), __value_, __pred,\n           typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::search_n(__first, __last, __convert_to_integral(__count),\n                           __value_, __equal_to<__v, _Tp>());\n}\n\n// copy\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n_Iter\n__unwrap_iter(_Iter __i)\n{\n    return __i;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(move_iterator<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    __wrap_iter<_Tp*>\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = *__first;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_backward\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = *--__last;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\ncopy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__copy_backward(__unwrap_iter(__first),\n                                  __unwrap_iter(__last),\n                                  __unwrap_iter(__result));\n}\n\n// copy_if\n\ntemplate<class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy_if(_InputIterator __first, _InputIterator __last,\n        _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// copy_n\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    if (__n > 0)\n    {\n        *__result = *__first;\n        ++__result;\n        for (--__n; __n > 0; --__n)\n        {\n            ++__first;\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    return _VSTD::copy(__first, __first + __n, __result);\n}\n\n// move\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = _VSTD::move(*__first);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmove(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// move_backward\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = _VSTD::move(*--__last);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    if (__n > 0)\n    {\n        __result -= __n;\n        _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    }\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\nmove_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// iter_swap\n\n// moved to <type_traits> for better swap / noexcept support\n\n// transform\n\ntemplate <class _InputIterator, class _OutputIterator, class _UnaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        *__result = __op(*__first);\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,\n          _OutputIterator __result, _BinaryOperation __binary_op)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)\n        *__result = __binary_op(*__first1, *__first2);\n    return __result;\n}\n\n// replace\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __old_value)\n            *__first = __new_value;\n}\n\n// replace_if\n\ntemplate <class _ForwardIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            *__first = __new_value;\n}\n\n// replace_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n             const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (*__first == __old_value)\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// replace_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n                _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, (void) ++__result)\n        if (__pred(*__first))\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// fill_n\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __value_;\n    return __first;\n}\n\ntemplate <class _Tp, class _Size, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&\n    !is_same<_Tp, bool>::value &&\n    is_integral<_Up>::value && sizeof(_Up) == 1,\n    _Tp*\n>::type\n__fill_n(_Tp* __first, _Size __n,_Up __value_)\n{\n    if (__n > 0)\n        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));\n    return __first + __n;\n}\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nfill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n   return _VSTD::__fill_n(__first, __convert_to_integral(__n), __value_);\n}\n\n// fill\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)\n{\n    for (; __first != __last; ++__first)\n        *__first = __value_;\n}\n\ntemplate <class _RandomAccessIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)\n{\n    _VSTD::fill_n(__first, __last - __first, __value_);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    _VSTD::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// generate\n\ntemplate <class _ForwardIterator, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ngenerate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)\n{\n    for (; __first != __last; ++__first)\n        *__first = __gen();\n}\n\n// generate_n\n\ntemplate <class _OutputIterator, class _Size, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ngenerate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)\n{\n    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;\n    _IntegralSize __n = __orig_n;\n    for (; __n > 0; ++__first, (void) --__n)\n        *__first = __gen();\n    return __first;\n}\n\n// remove\n\ntemplate <class _ForwardIterator, class _Tp>\n_ForwardIterator\nremove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    __first = _VSTD::find(__first, __last, __value_);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!(*__i == __value_))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_if\n\ntemplate <class _ForwardIterator, class _Predicate>\n_ForwardIterator\nremove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    __first = _VSTD::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>\n                           (__first, __last, __pred);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!(*__first == __value_))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// remove_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// unique\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>\n                                 (__first, __last, __pred);\n    if (__first != __last)\n    {\n        // ...  a  a  ?  ...\n        //      f     i\n        _ForwardIterator __i = __first;\n        for (++__i; ++__i != __last;)\n            if (!__pred(*__first, *__i))\n                *++__first = _VSTD::move(*__i);\n        ++__first;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::unique(__first, __last, __equal_to<__v>());\n}\n\n// unique_copy\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(__t, *__first))\n            {\n                __t = *__first;\n                *__result = __t;\n                ++__result;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              forward_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        *__result = *__i;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(*__i, *__first))\n            {\n                *__result = *__first;\n                ++__result;\n                __i = __first;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>\n_ForwardIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, forward_iterator_tag)\n{\n    if (__first != __last)\n    {\n        *__result = *__first;\n        while (++__first != __last)\n            if (!__pred(*__result, *__first))\n                *++__result = *__first;\n        ++__result;\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)\n{\n    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>\n                              (__first, __last, __result, __pred,\n                               typename iterator_traits<_InputIterator>::iterator_category(),\n                               typename iterator_traits<_OutputIterator>::iterator_category());\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type __v;\n    return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());\n}\n\n// reverse\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)\n{\n    while (__first != __last)\n    {\n        if (__first == --__last)\n            break;\n        _VSTD::iter_swap(__first, __last);\n        ++__first;\n    }\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)\n{\n    if (__first != __last)\n        for (; __first < --__last; ++__first)\n            _VSTD::iter_swap(__first, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());\n}\n\n// reverse_copy\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__result)\n        *__result = *--__last;\n    return __result;\n}\n\n// rotate\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_left(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    value_type __tmp = _VSTD::move(*__first);\n    _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);\n    *__lm1 = _VSTD::move(__tmp);\n    return __lm1;\n}\n\ntemplate <class _BidirectionalIterator>\n_BidirectionalIterator\n__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    _BidirectionalIterator __lm1 = _VSTD::prev(__last);\n    value_type __tmp = _VSTD::move(*__lm1);\n    _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);\n    *__first = _VSTD::move(__tmp);\n    return __fp1;\n}\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    _ForwardIterator __i = __middle;\n    while (true)\n    {\n        swap(*__first, *__i);\n        ++__first;\n        if (++__i == __last)\n            break;\n        if (__first == __middle)\n            __middle = __i;\n    }\n    _ForwardIterator __r = __first;\n    if (__first != __middle)\n    {\n        __i = __middle;\n        while (true)\n        {\n            swap(*__first, *__i);\n            ++__first;\n            if (++__i == __last)\n            {\n                if (__first == __middle)\n                    break;\n                __i = __middle;\n            }\n            else if (__first == __middle)\n                __middle = __i;\n        }\n    }\n    return __r;\n}\n\ntemplate<typename _Integral>\ninline _LIBCPP_INLINE_VISIBILITY\n_Integral\n__algo_gcd(_Integral __x, _Integral __y)\n{\n    do\n    {\n        _Integral __t = __x % __y;\n        __x = __y;\n        __y = __t;\n    } while (__y);\n    return __x;\n}\n\ntemplate<typename _RandomAccessIterator>\n_RandomAccessIterator\n__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n\n    const difference_type __m1 = __middle - __first;\n    const difference_type __m2 = __last - __middle;\n    if (__m1 == __m2)\n    {\n        _VSTD::swap_ranges(__first, __middle, __middle);\n        return __middle;\n    }\n    const difference_type __g = _VSTD::__algo_gcd(__m1, __m2);\n    for (_RandomAccessIterator __p = __first + __g; __p != __first;)\n    {\n        value_type __t(_VSTD::move(*--__p));\n        _RandomAccessIterator __p1 = __p;\n        _RandomAccessIterator __p2 = __p1 + __m1;\n        do\n        {\n            *__p1 = _VSTD::move(*__p2);\n            __p1 = __p2;\n            const difference_type __d = __last - __p2;\n            if (__m1 < __d)\n                __p2 += __m1;\n            else\n                __p2 = __first + (__m1 - __d);\n        } while (__p2 != __p);\n        *__p1 = _VSTD::move(__t);\n    }\n    return __first + __m2;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\n__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n         _VSTD::forward_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator\n__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n         _VSTD::bidirectional_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\n__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n         _VSTD::random_access_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n        return _VSTD::__rotate_gcd(__first, __middle, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nrotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    if (__first == __middle)\n        return __last;\n    if (__middle == __last)\n        return __first;\n    return _VSTD::__rotate(__first, __middle, __last,\n                           typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// rotate_copy\n\ntemplate <class _ForwardIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nrotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));\n}\n\n// min_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__i, *__first))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::min_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// min\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::min(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// max_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__first, *__i))\n                __first = __i;\n    }\n    return __first;\n}\n\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::max_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// max\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__a, __b) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::max(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_STD_VER > 14\n// clamp\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi, _Compare __comp)\n{\n    _LIBCPP_ASSERT(!__comp(__hi, __lo), \"Bad bounds passed to std::clamp\");\n    return __comp(__v, __lo) ? __lo : __comp(__hi, __v) ? __hi : __v;\n\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\nconst _Tp&\nclamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi)\n{\n    return _VSTD::clamp(__v, __lo, __hi, __less<_Tp>());\n}\n#endif\n\n// minmax_element\n\ntemplate <class _ForwardIterator, class _Compare>\n_LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);\n  if (__first != __last)\n  {\n      if (++__first != __last)\n      {\n          if (__comp(*__first, *__result.first))\n              __result.first = __first;\n          else\n              __result.second = __first;\n          while (++__first != __last)\n          {\n              _ForwardIterator __i = __first;\n              if (++__first == __last)\n              {\n                  if (__comp(*__i, *__result.first))\n                      __result.first = __i;\n                  else if (!__comp(*__i, *__result.second))\n                      __result.second = __i;\n                  break;\n              }\n              else\n              {\n                  if (__comp(*__first, *__i))\n                  {\n                      if (__comp(*__first, *__result.first))\n                          __result.first = __first;\n                      if (!__comp(*__i, *__result.second))\n                          __result.second = __i;\n                  }\n                  else\n                  {\n                      if (__comp(*__i, *__result.first))\n                          __result.first = __i;\n                      if (!__comp(*__first, *__result.second))\n                          __result.second = __first;\n                  }\n              }\n          }\n      }\n  }\n  return __result;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::minmax_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// minmax\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :\n                              pair<const _Tp&, const _Tp&>(__a, __b);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::minmax(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    typedef typename initializer_list<_Tp>::const_iterator _Iter;\n    _Iter __first = __t.begin();\n    _Iter __last  = __t.end();\n    std::pair<_Tp, _Tp> __result(*__first, *__first);\n\n    ++__first;\n    if (__t.size() % 2 == 0)\n    {\n        if (__comp(*__first,  __result.first))\n            __result.first  = *__first;\n        else\n            __result.second = *__first;\n        ++__first;\n    }\n\n    while (__first != __last)\n    {\n        _Tp __prev = *__first++;\n        if (__comp(*__first, __prev)) {\n            if ( __comp(*__first, __result.first)) __result.first  = *__first;\n            if (!__comp(__prev, __result.second))  __result.second = __prev;\n            }\n        else {\n            if ( __comp(__prev, __result.first))    __result.first  = __prev;\n            if (!__comp(*__first, __result.second)) __result.second = *__first;\n            }\n\n        __first++;\n    }\n    return __result;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t)\n{\n    return _VSTD::minmax(__t, __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// random_shuffle\n\n// __independent_bits_engine\n\ntemplate <unsigned long long _Xp, size_t _Rp>\nstruct __log2_imp\n{\n    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp\n                                           : __log2_imp<_Xp, _Rp - 1>::value;\n};\n\ntemplate <unsigned long long _Xp>\nstruct __log2_imp<_Xp, 0>\n{\n    static const size_t value = 0;\n};\n\ntemplate <size_t _Rp>\nstruct __log2_imp<0, _Rp>\n{\n    static const size_t value = _Rp + 1;\n};\n\ntemplate <class _UI, _UI _Xp>\nstruct __log2\n{\n    static const size_t value = __log2_imp<_Xp,\n                                         sizeof(_UI) * __CHAR_BIT__ - 1>::value;\n};\n\ntemplate<class _Engine, class _UIntType>\nclass __independent_bits_engine\n{\npublic:\n    // types\n    typedef _UIntType result_type;\n\nprivate:\n    typedef typename _Engine::result_type _Engine_result_type;\n    typedef typename conditional\n        <\n            sizeof(_Engine_result_type) <= sizeof(result_type),\n                result_type,\n                _Engine_result_type\n        >::type _Working_result_type;\n\n    _Engine& __e_;\n    size_t __w_;\n    size_t __w0_;\n    size_t __n_;\n    size_t __n0_;\n    _Working_result_type __y0_;\n    _Working_result_type __y1_;\n    _Engine_result_type __mask0_;\n    _Engine_result_type __mask1_;\n\n#ifdef _LIBCPP_HAS_NO_CONSTEXPR\n    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min\n                                          + _Working_result_type(1);\n#else\n    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()\n                                                      + _Working_result_type(1);\n#endif\n    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;\n    static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;\n    static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;\n\npublic:\n    // constructors and seeding functions\n    __independent_bits_engine(_Engine& __e, size_t __w);\n\n    // generating functions\n    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}\n\nprivate:\n    result_type __eval(false_type);\n    result_type __eval(true_type);\n};\n\ntemplate<class _Engine, class _UIntType>\n__independent_bits_engine<_Engine, _UIntType>\n    ::__independent_bits_engine(_Engine& __e, size_t __w)\n        : __e_(__e),\n          __w_(__w)\n{\n    __n_ = __w_ / __m + (__w_ % __m != 0);\n    __w0_ = __w_ / __n_;\n    if (_Rp == 0)\n        __y0_ = _Rp;\n    else if (__w0_ < _WDt)\n        __y0_ = (_Rp >> __w0_) << __w0_;\n    else\n        __y0_ = 0;\n    if (_Rp - __y0_ > __y0_ / __n_)\n    {\n        ++__n_;\n        __w0_ = __w_ / __n_;\n        if (__w0_ < _WDt)\n            __y0_ = (_Rp >> __w0_) << __w0_;\n        else\n            __y0_ = 0;\n    }\n    __n0_ = __n_ - __w_ % __n_;\n    if (__w0_ < _WDt - 1)\n        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);\n    else\n        __y1_ = 0;\n    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :\n                          _Engine_result_type(0);\n    __mask1_ = __w0_ < _EDt - 1 ?\n                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :\n                               _Engine_result_type(~0);\n}\n\ntemplate<class _Engine, class _UIntType>\ninline\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)\n{\n    return static_cast<result_type>(__e_() & __mask0_);\n}\n\ntemplate<class _Engine, class _UIntType>\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)\n{\n    result_type _Sp = 0;\n    for (size_t __k = 0; __k < __n0_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y0_);\n        if (__w0_ < _WDt)\n            _Sp <<= __w0_;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask0_;\n    }\n    for (size_t __k = __n0_; __k < __n_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y1_);\n        if (__w0_ < _WDt - 1)\n            _Sp <<= __w0_ + 1;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask1_;\n    }\n    return _Sp;\n}\n\n// uniform_int_distribution\n\ntemplate<class _IntType = int>\nclass uniform_int_distribution\n{\npublic:\n    // types\n    typedef _IntType result_type;\n\n    class param_type\n    {\n        result_type __a_;\n        result_type __b_;\n    public:\n        typedef uniform_int_distribution distribution_type;\n\n        explicit param_type(result_type __a = 0,\n                            result_type __b = numeric_limits<result_type>::max())\n            : __a_(__a), __b_(__b) {}\n\n        result_type a() const {return __a_;}\n        result_type b() const {return __b_;}\n\n        friend bool operator==(const param_type& __x, const param_type& __y)\n            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}\n        friend bool operator!=(const param_type& __x, const param_type& __y)\n            {return !(__x == __y);}\n    };\n\nprivate:\n    param_type __p_;\n\npublic:\n    // constructors and reset functions\n    explicit uniform_int_distribution(result_type __a = 0,\n                                      result_type __b = numeric_limits<result_type>::max())\n        : __p_(param_type(__a, __b)) {}\n    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}\n    void reset() {}\n\n    // generating functions\n    template<class _URNG> result_type operator()(_URNG& __g)\n        {return (*this)(__g, __p_);}\n    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);\n\n    // property functions\n    result_type a() const {return __p_.a();}\n    result_type b() const {return __p_.b();}\n\n    param_type param() const {return __p_;}\n    void param(const param_type& __p) {__p_ = __p;}\n\n    result_type min() const {return a();}\n    result_type max() const {return b();}\n\n    friend bool operator==(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n        {return __x.__p_ == __y.__p_;}\n    friend bool operator!=(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n            {return !(__x == __y);}\n};\n\ntemplate<class _IntType>\ntemplate<class _URNG>\ntypename uniform_int_distribution<_IntType>::result_type\nuniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)\n{\n    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),\n                                            uint32_t, uint64_t>::type _UIntType;\n    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);\n    if (_Rp == 1)\n        return __p.a();\n    const size_t _Dt = numeric_limits<_UIntType>::digits;\n    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;\n    if (_Rp == 0)\n        return static_cast<result_type>(_Eng(__g, _Dt)());\n    size_t __w = _Dt - __clz(_Rp) - 1;\n    if ((_Rp & (std::numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)\n        ++__w;\n    _Eng __e(__g, __w);\n    _UIntType __u;\n    do\n    {\n        __u = __e();\n    } while (__u >= _Rp);\n    return static_cast<result_type>(__u + __p.a());\n}\n\nclass _LIBCPP_TYPE_VIS __rs_default;\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\nclass _LIBCPP_TYPE_VIS __rs_default\n{\n    static unsigned __c_;\n\n    __rs_default();\npublic:\n    typedef uint_fast32_t result_type;\n\n    static const result_type _Min = 0;\n    static const result_type _Max = 0xFFFFFFFF;\n\n    __rs_default(const __rs_default&);\n    ~__rs_default();\n\n    result_type operator()();\n\n    static _LIBCPP_CONSTEXPR result_type min() {return _Min;}\n    static _LIBCPP_CONSTEXPR result_type max() {return _Max;}\n\n    friend _LIBCPP_FUNC_VIS __rs_default __rs_get();\n};\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\ntemplate <class _RandomAccessIterator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        __rs_default __g = __rs_get();\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _RandomNumberGenerator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n               _RandomNumberGenerator&& __rand)\n#else\n               _RandomNumberGenerator& __rand)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        for (--__last; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __rand(__d);\n            swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output,\n                         _Distance __n,\n                         _UniformRandomNumberGenerator & __g,\n                         input_iterator_tag) {\n\n  _Distance __k = 0;\n  for (; __first != __last && __k < __n; ++__first, (void)++__k)\n    __output[__k] = *__first;\n  _Distance __sz = __k;\n  for (; __first != __last; ++__first, (void)++__k) {\n    _Distance __r = _VSTD::uniform_int_distribution<_Distance>(0, __k)(__g);\n    if (__r < __sz)\n      __output[__r] = *__first;\n  }\n  return __output + _VSTD::min(__n, __k);\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output,\n                         _Distance __n,\n                         _UniformRandomNumberGenerator& __g,\n                         forward_iterator_tag) {\n  _Distance __unsampled_sz = _VSTD::distance(__first, __last);\n  for (__n = _VSTD::min(__n, __unsampled_sz); __n != 0; ++__first) {\n    _Distance __r =\n        _VSTD::uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);\n    if (__r < __n) {\n      *__output++ = *__first;\n      --__n;\n    }\n  }\n  return __output;\n}\n\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\n_LIBCPP_INLINE_VISIBILITY\n_SampleIterator __sample(_PopulationIterator __first,\n                         _PopulationIterator __last, _SampleIterator __output,\n                         _Distance __n, _UniformRandomNumberGenerator& __g) {\n  typedef typename iterator_traits<_PopulationIterator>::iterator_category\n        _PopCategory;\n  typedef typename iterator_traits<_PopulationIterator>::difference_type\n        _Difference;\n  static_assert(__is_forward_iterator<_PopulationIterator>::value ||\n                __is_random_access_iterator<_SampleIterator>::value,\n                \"SampleIterator must meet the requirements of RandomAccessIterator\");\n  typedef typename common_type<_Distance, _Difference>::type _CommonType;\n  _LIBCPP_ASSERT(__n >= 0, \"N must be a positive number.\");\n  return _VSTD::__sample(\n      __first, __last, __output, _CommonType(__n),\n      __g, _PopCategory());\n}\n\n#if _LIBCPP_STD_VER > 14\ntemplate <class _PopulationIterator, class _SampleIterator, class _Distance,\n          class _UniformRandomNumberGenerator>\ninline _LIBCPP_INLINE_VISIBILITY\n_SampleIterator sample(_PopulationIterator __first,\n                       _PopulationIterator __last, _SampleIterator __output,\n                       _Distance __n, _UniformRandomNumberGenerator&& __g) {\n    return _VSTD::__sample(__first, __last, __output, __n, __g);\n}\n#endif // _LIBCPP_STD_VER > 14\n\ntemplate<class _RandomAccessIterator, class _UniformRandomNumberGenerator>\n    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                 _UniformRandomNumberGenerator&& __g)\n#else\n                 _UniformRandomNumberGenerator& __g)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _InputIterator, class _Predicate>\nbool\nis_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    if ( __first == __last )\n        return true;\n    ++__first;\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// partition\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)\n{\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    for (_ForwardIterator __p = __first; ++__p != __last;)\n    {\n        if (__pred(*__p))\n        {\n            swap(*__first, *__p);\n            ++__first;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n            bidirectional_iterator_tag)\n{\n    while (true)\n    {\n        while (true)\n        {\n            if (__first == __last)\n                return __first;\n            if (!__pred(*__first))\n                break;\n            ++__first;\n        }\n        do\n        {\n            if (__first == --__last)\n                return __first;\n        } while (!__pred(*__last));\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\npartition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>\n                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// partition_copy\n\ntemplate <class _InputIterator, class _OutputIterator1,\n          class _OutputIterator2, class _Predicate>\npair<_OutputIterator1, _OutputIterator2>\npartition_copy(_InputIterator __first, _InputIterator __last,\n               _OutputIterator1 __out_true, _OutputIterator2 __out_false,\n               _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__out_true = *__first;\n            ++__out_true;\n        }\n        else\n        {\n            *__out_false = *__first;\n            ++__out_false;\n        }\n    }\n    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);\n}\n\n// partition_point\n\ntemplate<class _ForwardIterator, class _Predicate>\n_ForwardIterator\npartition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__pred(*__m))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\n// stable_partition\n\ntemplate <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, forward_iterator_tag __fit)\n{\n    // *__first is known to be false\n    // __len >= 1\n    if (__len == 1)\n        return __first;\n    if (__len == 2)\n    {\n        _ForwardIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            return __m;\n        }\n        return __first;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        __i = __first;\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 3\n    _ForwardIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m), *__first know to be false\n    // F?????????????????\n    // f       m         l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);\n    // TTTFFFFF??????????\n    // f  ff   m         l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    _ForwardIterator __m1 = __m;\n    _ForwardIterator __second_false = __last;\n    _Distance __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF??????\n    // f  ff   m  m1     l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf   l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\nstruct __return_temporary_buffer\n{\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const {_VSTD::return_temporary_buffer(__p);}\n};\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   forward_iterator_tag)\n{\n    const unsigned __alloc_limit = 3;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // We now have a reduced range [__first, __last)\n    // *__first is known to be false\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, forward_iterator_tag());\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)\n{\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    if (__len == 2)\n    {\n        swap(*__first, *__last);\n        return __last;\n    }\n    if (__len == 3)\n    {\n        _BidirectionalIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            swap(*__m, *__last);\n            return __last;\n        }\n        swap(*__m, *__last);\n        swap(*__first, *__m);\n        return __m;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _BidirectionalIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // move *__last, known to be true\n        *__first = _VSTD::move(*__i);\n        __i = ++__first;\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 4\n    _BidirectionalIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false\n    // F????????????????T\n    // f       m        l\n    _BidirectionalIterator __m1 = __m;\n    _BidirectionalIterator __first_false = __first;\n    _Distance __len_half = __len2;\n    while (!__pred(*--__m1))\n    {\n        if (__m1 == __first)\n            goto __first_half_done;\n        --__len_half;\n    }\n    // F???TFFF?????????T\n    // f   m1  m        l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);\n__first_half_done:\n    // TTTFFFFF?????????T\n    // f  ff   m        l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    __m1 = __m;\n    _BidirectionalIterator __second_false = __last;\n    ++__second_false;\n    __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF?????T\n    // f  ff   m  m1    l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf  l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   bidirectional_iterator_tag)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    const difference_type __alloc_limit = 4;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // __first points to first false, everything prior to __first is already set.\n    // Either prove [__first, __last) is all false and return __first, or point __last to last true\n    do\n    {\n        if (__first == --__last)\n            return __first;\n    } while (!__pred(*__last));\n    // We now have a reduced range [__first, __last]\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    difference_type __len = _VSTD::distance(__first, __last) + 1;\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nstable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// is_sorted_until\n\ntemplate <class _ForwardIterator, class _Compare>\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__comp(*__i, *__first))\n                return __i;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// is_sorted\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return _VSTD::is_sorted_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// sort\n\n// stable, 2-3 compares, 0-2 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)\n{\n    unsigned __r = 0;\n    if (!__c(*__y, *__x))          // if x <= y\n    {\n        if (!__c(*__z, *__y))      // if y <= z\n            return __r;            // x <= y && y <= z\n                                   // x <= y && y > z\n        swap(*__y, *__z);          // x <= z && y < z\n        __r = 1;\n        if (__c(*__y, *__x))       // if x > y\n        {\n            swap(*__x, *__y);      // x < y && y <= z\n            __r = 2;\n        }\n        return __r;                // x <= y && y < z\n    }\n    if (__c(*__z, *__y))           // x > y, if y > z\n    {\n        swap(*__x, *__z);          // x < y && y < z\n        __r = 1;\n        return __r;\n    }\n    swap(*__x, *__y);              // x > y && y <= z\n    __r = 1;                       // x < y && x <= z\n    if (__c(*__z, *__y))           // if y > z\n    {\n        swap(*__y, *__z);          // x <= y && y < z\n        __r = 2;\n    }\n    return __r;\n}                                  // x <= y && y <= z\n\n// stable, 3-6 compares, 0-5 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _Compare __c)\n{\n    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);\n    if (__c(*__x4, *__x3))\n    {\n        swap(*__x3, *__x4);\n        ++__r;\n        if (__c(*__x3, *__x2))\n        {\n            swap(*__x2, *__x3);\n            ++__r;\n            if (__c(*__x2, *__x1))\n            {\n                swap(*__x1, *__x2);\n                ++__r;\n            }\n        }\n    }\n    return __r;\n}\n\n// stable, 4-10 compares, 0-9 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)\n{\n    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);\n    if (__c(*__x5, *__x4))\n    {\n        swap(*__x4, *__x5);\n        ++__r;\n        if (__c(*__x4, *__x3))\n        {\n            swap(*__x3, *__x4);\n            ++__r;\n            if (__c(*__x3, *__x2))\n            {\n                swap(*__x2, *__x3);\n                ++__r;\n                if (__c(*__x2, *__x1))\n                {\n                    swap(*__x1, *__x2);\n                    ++__r;\n                }\n            }\n        }\n    }\n    return __r;\n}\n\n// Assumes size > 0\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    _BirdirectionalIterator __lm1 = __last;\n    for (--__lm1; __first != __lm1; ++__first)\n    {\n        _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,\n                                                        typename add_lvalue_reference<_Compare>::type>\n                                                       (__first, __last, __comp);\n        if (__i != __first)\n            swap(*__first, *__i);\n    }\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first != __last)\n    {\n        _BirdirectionalIterator __i = __first;\n        for (++__i; __i != __last; ++__i)\n        {\n            _BirdirectionalIterator __j = __i;\n            value_type __t(_VSTD::move(*__j));\n            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t,  *--__k); --__j)\n                *__j = _VSTD::move(*__k);\n            *__j = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n        }\n        __j = __i;\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nbool\n__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    switch (__last - __first)\n    {\n    case 0:\n    case 1:\n        return true;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return true;\n    case 3:\n        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n        return true;\n    case 4:\n        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n        return true;\n    case 5:\n        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n        return true;\n    }\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    const unsigned __limit = 8;\n    unsigned __count = 0;\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n            if (++__count == __limit)\n                return ++__i == __last;\n        }\n        __j = __i;\n    }\n    return true;\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,\n                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first1 != __last1)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);\n        value_type* __last2 = __first2;\n        ::new(__last2) value_type(_VSTD::move(*__first1));\n        __d.__incr((value_type*)0);\n        for (++__last2; ++__first1 != __last1; ++__last2)\n        {\n            value_type* __j2 = __last2;\n            value_type* __i2 = __j2;\n            if (__comp(*__first1, *--__i2))\n            {\n                ::new(__j2) value_type(_VSTD::move(*__i2));\n                __d.__incr((value_type*)0);\n                for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)\n                    *__j2 = _VSTD::move(*__i2);\n                *__j2 = _VSTD::move(*__first1);\n            }\n            else\n            {\n                ::new(__j2) value_type(_VSTD::move(*__first1));\n                __d.__incr((value_type*)0);\n            }\n        }\n        __h.release();\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&\n                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;\n    while (true)\n    {\n    __restart:\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n            return;\n        case 4:\n            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n            return;\n        case 5:\n            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n            return;\n        }\n        if (__len <= __limit)\n        {\n            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > 5\n        _RandomAccessIterator __m = __first;\n        _RandomAccessIterator __lm1 = __last;\n        --__lm1;\n        unsigned __n_swaps;\n        {\n        difference_type __delta;\n        if (__len >= 1000)\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __delta /= 2;\n            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);\n        }\n        else\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);\n        }\n        }\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted, sort the secod part\n                    // _VSTD::__sort<_Compare>(__i, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        // It is known that *__i < *__m\n        ++__i;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            // known that __i <= __m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i > __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        // If we were given a perfect partition, see if insertion sort is quick...\n        if (__n_swaps == 0)\n        {\n            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);\n            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))\n            {\n                if (__fs)\n                    return;\n                __last = __i;\n                continue;\n            }\n            else\n            {\n                if (__fs)\n                {\n                    __first = ++__i;\n                    continue;\n                }\n            }\n        }\n        // sort smaller range with recursive call and larger with tail recursion elimination\n        if (__i - __first < __last - __i)\n        {\n            _VSTD::__sort<_Compare>(__first, __i, __comp);\n            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            __first = ++__i;\n        }\n        else\n        {\n            _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            // _VSTD::__sort<_Compare>(__first, __i, __comp);\n            __last = __i;\n        }\n    }\n}\n\n// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_Tp** __first, _Tp** __last)\n{\n    _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)\n{\n    _VSTD::sort(__first.base(), __last.base());\n}\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231)\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif  // _LIBCPP_MSVC\n\n// lower_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::lower_bound(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// upper_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(__value_, *__m))\n            __len = __l2;\n        else\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::upper_bound(__first, __last, __value_,\n                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// equal_range\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\npair<_ForwardIterator, _ForwardIterator>\n__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else if (__comp(__value_, *__m))\n        {\n            __last = __m;\n            __len = __l2;\n        }\n        else\n        {\n            _ForwardIterator __mp1 = __m;\n            return pair<_ForwardIterator, _ForwardIterator>\n                   (\n                      __lower_bound<_Compare>(__first, __m, __value_, __comp),\n                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)\n                   );\n        }\n    }\n    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::equal_range(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// binary_search\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);\n    return __first != __last && !__comp(__value_, *__first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__merge(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());\n}\n\n// inplace_merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2,\n          class _OutputIterator>\nvoid __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2,\n                          _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            _VSTD::move(__first1, __last1, __result);\n            return;\n        }\n\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    // __first2 through __last2 are already in the right spot.\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n    if (__len1 <= __len2)\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        __half_inplace_merge(__buff, __p, __middle, __last, __first, __comp);\n    }\n    else\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), (void) ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        typedef reverse_iterator<_BidirectionalIterator> _RBi;\n        typedef reverse_iterator<value_type*> _Rv;\n        __half_inplace_merge(_Rv(__p), _Rv(__buff),\n                             _RBi(__middle), _RBi(__first),\n                             _RBi(__last), __negate<_Compare>(__comp));\n    }\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    while (true)\n    {\n        // if __middle == __last, we're done\n        if (__len2 == 0)\n            return;\n        if (__len1 <= __buff_size || __len2 <= __buff_size)\n            return __buffered_inplace_merge<_Compare>\n                   (__first, __middle, __last, __comp, __len1, __len2, __buff);\n        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0\n        for (; true; ++__first, (void) --__len1)\n        {\n            if (__len1 == 0)\n                return;\n            if (__comp(*__middle, *__first))\n                break;\n        }\n        // __first < __middle < __last\n        // *__first > *__middle\n        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that\n        //     all elements in:\n        //         [__first, __m1)  <= [__middle, __m2)\n        //         [__middle, __m2) <  [__m1, __middle)\n        //         [__m1, __middle) <= [__m2, __last)\n        //     and __m1 or __m2 is in the middle of its range\n        _BidirectionalIterator __m1;  // \"median\" of [__first, __middle)\n        _BidirectionalIterator __m2;  // \"median\" of [__middle, __last)\n        difference_type __len11;      // distance(__first, __m1)\n        difference_type __len21;      // distance(__middle, __m2)\n        // binary search smaller range\n        if (__len1 < __len2)\n        {   // __len >= 1, __len2 >= 2\n            __len21 = __len2 / 2;\n            __m2 = __middle;\n            _VSTD::advance(__m2, __len21);\n            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);\n            __len11 = _VSTD::distance(__first, __m1);\n        }\n        else\n        {\n            if (__len1 == 1)\n            {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1\n                // It is known *__first > *__middle\n                swap(*__first, *__middle);\n                return;\n            }\n            // __len1 >= 2, __len2 >= 1\n            __len11 = __len1 / 2;\n            __m1 = __first;\n            _VSTD::advance(__m1, __len11);\n            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);\n            __len21 = _VSTD::distance(__middle, __m2);\n        }\n        difference_type __len12 = __len1 - __len11;  // distance(__m1, __middle)\n        difference_type __len22 = __len2 - __len21;  // distance(__m2, __last)\n        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)\n        // swap middle two partitions\n        __middle = _VSTD::rotate(__m1, __middle, __m2);\n        // __len12 and __len21 now have swapped meanings\n        // merge smaller range with recurisve call and larger with tail recursion elimination\n        if (__len11 + __len21 < __len12 + __len22)\n        {\n            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n            __first = __middle;\n            __middle = __m2;\n            __len1 = __len12;\n            __len2 = __len22;\n        }\n        else\n        {\n            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n            __last = __middle;\n            __middle = __m1;\n            __len1 = __len11;\n            __len2 = __len21;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n              _Compare __comp)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    difference_type __len1 = _VSTD::distance(__first, __middle);\n    difference_type __len2 = _VSTD::distance(__middle, __last);\n    difference_type __buf_size = _VSTD::min(__len1, __len2);\n    pair<value_type*, ptrdiff_t> __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);\n    unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);\n\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,\n                                            __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,\n                                            __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)\n{\n    _VSTD::inplace_merge(__first, __middle, __last,\n                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// stable_sort\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nvoid\n__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h(__result, __d);\n    for (; true; ++__result)\n    {\n        if (__first1 == __last1)\n        {\n            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first2));\n            __h.release();\n            return;\n        }\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first1));\n            __h.release();\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            ::new (__result) value_type(_VSTD::move(*__first2));\n            __d.__incr((value_type*)0);\n            ++__first2;\n        }\n        else\n        {\n            ::new (__result) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first1;\n        }\n    }\n}\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\nvoid\n__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result)\n                *__result = _VSTD::move(*__first1);\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    for (; __first2 != __last2; ++__first2, ++__result)\n        *__result = _VSTD::move(*__first2);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,\n                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    switch (__len)\n    {\n    case 0:\n        return;\n    case 1:\n        ::new(__first2) value_type(_VSTD::move(*__first1));\n        return;\n    case 2:\n       __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);\n         if (__comp(*--__last1, *__first1))\n        {\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n        }\n        else\n        {\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n        }\n        __h2.release();\n        return;\n    }\n    if (__len <= 8)\n    {\n        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first1 + __l2;\n    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);\n    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);\n    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);\n}\n\ntemplate <class _Tp>\nstruct __stable_sort_switch\n{\n    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    switch (__len)\n    {\n    case 0:\n    case 1:\n        return;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return;\n    }\n    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __insertion_sort<_Compare>(__first, __last, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first + __l2;\n    if (__len <= __buff_size)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);\n        __d.__set(__l2, (value_type*)0);\n        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);\n        __d.__set(__len, (value_type*)0);\n        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);\n//         __merge<_Compare>(move_iterator<value_type*>(__buff),\n//                           move_iterator<value_type*>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __len),\n//                           __first, __comp);\n        return;\n    }\n    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);\n    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);\n    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap_until\n\ntemplate <class _RandomAccessIterator, class _Compare>\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    difference_type __p = 0;\n    difference_type __c = 1;\n    _RandomAccessIterator __pp = __first;\n    while (__c < __len)\n    {\n        _RandomAccessIterator __cp = __first + __c;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__c;\n        ++__cp;\n        if (__c == __len)\n            return __last;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__p;\n        ++__pp;\n        __c = 2 * __p + 1;\n    }\n    return __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    return _VSTD::is_heap_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// push_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n          typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        __len = (__len - 2) / 2;\n        _RandomAccessIterator __ptr = __first + __len;\n        if (__comp(*__ptr, *--__last))\n        {\n            value_type __t(_VSTD::move(*__last));\n            do\n            {\n                *__last = _VSTD::move(*__ptr);\n                __last = __ptr;\n                if (__len == 0)\n                    break;\n                __len = (__len - 1) / 2;\n                __ptr = __first + __len;\n            } while (__comp(*__ptr, __t));\n            *__last = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sift_up<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// pop_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_down(_RandomAccessIterator __first, _RandomAccessIterator /*__last*/,\n            _Compare __comp,\n            typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n            _RandomAccessIterator __start)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    // left-child of __start is at 2 * __start + 1\n    // right-child of __start is at 2 * __start + 2\n    difference_type __child = __start - __first;\n\n    if (__len < 2 || (__len - 2) / 2 < __child)\n        return;\n\n    __child = 2 * __child + 1;\n    _RandomAccessIterator __child_i = __first + __child;\n\n    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n        // right-child exists and is greater than left-child\n        ++__child_i;\n        ++__child;\n    }\n\n    // check if we are in heap-order\n    if (__comp(*__child_i, *__start))\n        // we are, __start is larger than it's largest child\n        return;\n\n    value_type __top(_VSTD::move(*__start));\n    do\n    {\n        // we are not in heap-order, swap the parent with it's largest child\n        *__start = _VSTD::move(*__child_i);\n        __start = __child_i;\n\n        if ((__len - 2) / 2 < __child)\n            break;\n\n        // recompute the child based off of the updated parent\n        __child = 2 * __child + 1;\n        __child_i = __first + __child;\n\n        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n            // right-child exists and is greater than left-child\n            ++__child_i;\n            ++__child;\n        }\n\n        // check if we are in heap-order\n    } while (!__comp(*__child_i, __top));\n    *__start = _VSTD::move(__top);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n           typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    if (__len > 1)\n    {\n        swap(*__first, *--__last);\n        __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// make_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __n = __last - __first;\n    if (__n > 1)\n    {\n        // start from the first parent, there is no need to consider children\n        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)\n        {\n            __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __make_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __make_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// sort_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)\n        __pop_heap<_Compare>(__first, __last, __comp, __n);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n    __make_heap<_Compare>(__first, __middle, __comp);\n    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;\n    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__first))\n        {\n            swap(*__i, *__first);\n            __sift_down<_Compare>(__first, __middle, __comp, __len, __first);\n        }\n    }\n    __sort_heap<_Compare>(__first, __middle, __comp);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    _VSTD::partial_sort(__first, __middle, __last,\n                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort_copy\n\ntemplate <class _Compare, class _InputIterator, class _RandomAccessIterator>\n_RandomAccessIterator\n__partial_sort_copy(_InputIterator __first, _InputIterator __last,\n                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n    _RandomAccessIterator __r = __result_first;\n    if (__r != __result_last)\n    {\n        for (; __first != __last && __r != __result_last; (void) ++__first, ++__r)\n            *__r = *__first;\n        __make_heap<_Compare>(__result_first, __r, __comp);\n        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;\n        for (; __first != __last; ++__first)\n            if (__comp(*__first, *__result_first))\n            {\n                *__result_first = *__first;\n                __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);\n            }\n        __sort_heap<_Compare>(__result_first, __r, __comp);\n    }\n    return __r;\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)\n{\n    return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,\n                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// nth_element\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    const difference_type __limit = 7;\n    while (true)\n    {\n    __restart:\n        if (__nth == __last)\n            return;\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            {\n            _RandomAccessIterator __m = __first;\n            _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);\n            return;\n            }\n        }\n        if (__len <= __limit)\n        {\n            __selection_sort<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > __limit >= 3\n        _RandomAccessIterator __m = __first + __len/2;\n        _RandomAccessIterator __lm1 = __last;\n        unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted,\n                    if (__nth < __i)\n                        return;\n                    // __nth_element the secod part\n                    // __nth_element<_Compare>(__i, __nth, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        ++__i;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i >= __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        if (__nth == __i)\n            return;\n        if (__n_swaps == 0)\n        {\n            // We were given a perfectly partitioned sequence.  Coincidence?\n            if (__nth < __i)\n            {\n                // Check for [__first, __i) already sorted\n                __j = __m = __first;\n                while (++__j != __i)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__first, __i) sorted\n                return;\n            }\n            else\n            {\n                // Check for [__i, __last) already sorted\n                __j = __m = __i;\n                while (++__j != __last)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__i, __last) sorted\n                return;\n            }\n        }\nnot_sorted:\n        // __nth_element on range containing __nth\n        if (__nth < __i)\n        {\n            // __nth_element<_Compare>(__first, __nth, __i, __comp);\n            __last = __i;\n        }\n        else\n        {\n            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);\n            __first = ++__i;\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __nth_element<_Comp_ref>(__first, __nth, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)\n{\n    _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// includes\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::includes(__first1, __last1, __first2, __last2,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_union\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            if (!__comp(*__first1, *__first2))\n                ++__first2;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_intersection\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1 && __first2 != __last2)\n    {\n        if (__comp(*__first1, *__first2))\n            ++__first1;\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n            {\n                *__result = *__first1;\n                ++__result;\n                ++__first1;\n            }\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,\n                                  __less<typename iterator_traits<_InputIterator1>::value_type,\n                                         typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,\n                                __less<typename iterator_traits<_InputIterator1>::value_type,\n                                       typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_symmetric_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (__comp(*__first2, *__first1))\n            {\n                *__result = *__first2;\n                ++__result;\n            }\n            else\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,\n                                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// lexicographical_compare\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1, (void) ++__first2)\n    {\n        if (__first1 == __last1 || __comp(*__first1, *__first2))\n            return true;\n        if (__comp(*__first2, *__first1))\n            return false;\n    }\n    return false;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,\n                                         __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// next_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __next_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __next_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::next_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// prev_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*__ip1, *--__i))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*--__j, *__i))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __prev_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __prev_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::prev_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ALGORITHM\n","// -*- C++ -*-\n//===----------------------------- map ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MAP\n#define _LIBCPP_MAP\n\n/*\n\n    map synopsis\n\nnamespace std\n{\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass map\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    map()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit map(const key_compare& comp);\n    map(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp = key_compare());\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp, const allocator_type& a);\n    map(const map& m);\n    map(map&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit map(const allocator_type& a);\n    map(const map& m, const allocator_type& a);\n    map(map&& m, const allocator_type& a);\n    map(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    map(initializer_list<value_type> il, const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last, const allocator_type& a)\n            : map(first, last, Compare(), a) {}  // C++14\n    map(initializer_list<value_type> il, const allocator_type& a)\n        : map(il, Compare(), a) {}  // C++14\n   ~map();\n\n    map& operator=(const map& m);\n    map& operator=(map&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    map& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // element access:\n    mapped_type& operator[](const key_type& k);\n    mapped_type& operator[](key_type&& k);\n\n          mapped_type& at(const key_type& k);\n    const mapped_type& at(const key_type& k) const;\n\n    // modifiers:\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator, bool> insert(const value_type& v);\n    pair<iterator, bool> insert(      value_type&& v);                                // C++17\n    template <class P>\n        pair<iterator, bool> insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position,       value_type&& v);                   // C++17\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    template <class... Args>\n        pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);          // C++17\n    template <class... Args>\n        pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);               // C++17\n    template <class... Args>\n        iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args); // C++17\n    template <class... Args>\n        iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);      // C++17\n    template <class M>\n        pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);            // C++17\n    template <class M>\n        pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);                 // C++17\n    template <class M>\n        iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);   // C++17\n    template <class M>\n        iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);        // C++17\n\n    iterator  erase(const_iterator position);\n    iterator  erase(iterator position); // C++14\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(map& m)\n        noexcept(allocator_traits<allocator_type>::is_always_equal::value &&\n            is_nothrow_swappable<key_compare>::value); // C++17\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(map<Key, T, Compare, Allocator>& x, map<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass multimap\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type,mapped_type>         value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type,value_type,bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    multimap()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit multimap(const key_compare& comp);\n    multimap(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp,\n                 const allocator_type& a);\n    multimap(const multimap& m);\n    multimap(multimap&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit multimap(const allocator_type& a);\n    multimap(const multimap& m, const allocator_type& a);\n    multimap(multimap&& m, const allocator_type& a);\n    multimap(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    multimap(initializer_list<value_type> il, const key_compare& comp,\n             const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const allocator_type& a)\n            : multimap(first, last, Compare(), a) {} // C++14\n    multimap(initializer_list<value_type> il, const allocator_type& a)\n        : multimap(il, Compare(), a) {} // C++14\n    ~multimap();\n\n    multimap& operator=(const multimap& m);\n    multimap& operator=(multimap&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    multimap& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& v);\n    iterator insert(      value_type&& v);                                            // C++17\n    template <class P>\n        iterator insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position,       value_type&& v);                   // C++17\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    iterator  erase(iterator position); // C++14\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(multimap& m)\n        noexcept(allocator_traits<allocator_type>::is_always_equal::value &&\n            is_nothrow_swappable<key_compare>::value); // C++17\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(multimap<Key, T, Compare, Allocator>& x,\n     multimap<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tree>\n#include <iterator>\n#include <memory>\n#include <utility>\n#include <functional>\n#include <initializer_list>\n#include <type_traits>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _CP, class _Compare,\n          bool = is_empty<_Compare>::value && !__libcpp_is_final<_Compare>::value\n         >\nclass __map_value_compare\n    : private _Compare\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : _Compare() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : _Compare(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x, __y.__cc.first);}\n    void swap(__map_value_compare&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Compare>::value)\n    {\n        using _VSTD::swap;\n        swap(static_cast<const _Compare&>(*this), static_cast<const _Compare&>(__y));\n    }\n\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return static_cast<const _Compare&>(*this) (__x, __y.__cc.first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return static_cast<const _Compare&>(*this) (__x.__cc.first, __y);}\n#endif\n};\n\ntemplate <class _Key, class _CP, class _Compare>\nclass __map_value_compare<_Key, _CP, _Compare, false>\n{\n    _Compare comp;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : comp() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : comp(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return comp;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return comp(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return comp(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return comp(__x, __y.__cc.first);}\n    void swap(__map_value_compare&__y)\n        _NOEXCEPT_(__is_nothrow_swappable<_Compare>::value)\n    {\n        using _VSTD::swap;\n        swap(comp, __y.comp);\n    }\n\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return comp (__x, __y.__cc.first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return comp (__x.__cc.first, __y);}\n#endif\n};\n\ntemplate <class _Key, class _CP, class _Compare, bool __b>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__map_value_compare<_Key, _CP, _Compare, __b>& __x,\n     __map_value_compare<_Key, _CP, _Compare, __b>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Allocator>\nclass __map_node_destructor\n{\n    typedef _Allocator                          allocator_type;\n    typedef allocator_traits<allocator_type>    __alloc_traits;\n\npublic:\n    typedef typename __alloc_traits::pointer    pointer;\n\nprivate:\n    allocator_type& __na_;\n\n    __map_node_destructor& operator=(const __map_node_destructor&);\n\npublic:\n    bool __first_constructed;\n    bool __second_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __map_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __first_constructed(false),\n          __second_constructed(false)\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __map_node_destructor(__tree_node_destructor<allocator_type>&& __x) _NOEXCEPT\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            __x.__value_constructed = false;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__second_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.second));\n        if (__first_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.first));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n};\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class map;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class multimap;\ntemplate <class _TreeIterator> class __map_const_iterator;\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp>\nunion __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n\n    value_type __cc;\n    __nc_value_type __nc;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(const __value_type& __v)\n        {__nc = __v.__cc; return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(__value_type&& __v)\n        {__nc = _VSTD::move(__v.__nc); return *this;}\n\n    template <class _ValueTp,\n              class = typename enable_if<\n                    __is_same_uncvref<_ValueTp, value_type>::value\n                 >::type\n             >\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(_ValueTp&& __v) {\n        __nc = _VSTD::forward<_ValueTp>(__v); return *this;\n    }\n\nprivate:\n    __value_type() _LIBCPP_EQUAL_DELETE;\n    ~__value_type() _LIBCPP_EQUAL_DELETE;\n    __value_type(const __value_type& __v) _LIBCPP_EQUAL_DELETE;\n    __value_type(__value_type&& __v) _LIBCPP_EQUAL_DELETE;\n};\n\n#else\n\ntemplate <class _Key, class _Tp>\nstruct __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n\n    value_type __cc;\n\nprivate:\n   __value_type();\n   __value_type(__value_type const&);\n   __value_type& operator=(__value_type const&);\n   ~__value_type();\n};\n\n#endif\n\ntemplate <class _Tp>\nstruct __extract_key_value_types;\n\ntemplate <class _Key, class _Tp>\nstruct __extract_key_value_types<__value_type<_Key, _Tp> >\n{\n  typedef _Key const __key_type;\n  typedef _Tp        __mapped_type;\n};\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TEMPLATE_VIS __map_iterator\n{\n    typedef typename _TreeIterator::_NodeTypes                   _NodeTypes;\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n\n    _TreeIterator __i_;\n\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef typename _NodeTypes::__map_value_type                value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef value_type&                                          reference;\n    typedef typename _NodeTypes::__map_value_type_pointer        pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator++(int)\n    {\n        __map_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator--(int)\n    {\n        __map_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;\n    template <class> friend class _LIBCPP_TEMPLATE_VIS __map_const_iterator;\n};\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TEMPLATE_VIS __map_const_iterator\n{\n    typedef typename _TreeIterator::_NodeTypes                   _NodeTypes;\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n\n    _TreeIterator __i_;\n\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef typename _NodeTypes::__map_value_type                value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename _NodeTypes::__const_map_value_type_pointer  pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(__map_iterator<\n        typename _TreeIterator::__non_const_iterator> __i) _NOEXCEPT\n        : __i_(__i.__i_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator++(int)\n    {\n        __map_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator--(int)\n    {\n        __map_const_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;\n    template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;\n    template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS __tree_const_iterator;\n};\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TEMPLATE_VIS map\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    class _LIBCPP_TEMPLATE_VIS value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,\n                                                 __value_type>::type __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>   __base;\n    typedef typename __base::__node_traits                 __node_traits;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>             iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    map()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(key_compare())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), typename __base::allocator_type(__a))\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n    map(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : map(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m)\n        : __tree_(__m.__tree_)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(const map& __m)\n        {\n#ifndef _LIBCPP_CXX03_LANG\n            __tree_ = __m.__tree_;\n#else\n            if (this != &__m) {\n                __tree_.clear();\n                __tree_.value_comp() = __m.__tree_.value_comp();\n                __tree_.__copy_assign_alloc(__m.__tree_);\n                insert(__m.begin(), __m.end());\n            }\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    map(map&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), typename __base::allocator_type(__a))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const allocator_type& __a)\n        : map(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_unique(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const allocator_type& __a)\n        : __tree_(typename __base::allocator_type(__a))\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    mapped_type& operator[](const key_type& __k);\n#ifndef _LIBCPP_CXX03_LANG\n    mapped_type& operator[](key_type&& __k);\n#endif\n\n          mapped_type& at(const key_type& __k);\n    const mapped_type& at(const key_type& __k) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return allocator_type(__tree_.__alloc());}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_CXX03_LANG\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> emplace(_Args&& ...__args) {\n        return __tree_.__emplace_unique(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {\n        return __tree_.__emplace_hint_unique(__p.__i_, _VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert(_Pp&& __p)\n            {return __tree_.__insert_unique(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_unique(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n        insert(const value_type& __v) {return __tree_.__insert_unique(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n        insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_unique(__p.__i_, __v);}\n\n#ifndef _LIBCPP_CXX03_LANG\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n    insert(value_type&& __v) {return __tree_.__insert_unique(_VSTD::move(__v));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p,  value_type&& __v)\n    {return __tree_.__insert_unique(__p.__i_, _VSTD::move(__v));}\n#endif\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                insert(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_STD_VER > 14\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> try_emplace(const key_type& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_unique_key_args(__k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(__k),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> try_emplace(key_type&& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_unique_key_args(__k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(_VSTD::move(__k)),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator try_emplace(const_iterator __h, const key_type& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_hint_unique_key_args(__h.__i_, __k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(__k),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator try_emplace(const_iterator __h, key_type&& __k, _Args&&... __args)\n    {\n        return __tree_.__emplace_hint_unique_key_args(__h.__i_, __k,\n            _VSTD::piecewise_construct,\n            _VSTD::forward_as_tuple(_VSTD::move(__k)),\n            _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert_or_assign(const key_type& __k, _Vp&& __v)\n    {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return _VSTD::make_pair(__p, false);\n        }\n        return _VSTD::make_pair(emplace_hint(__p, __k, _VSTD::forward<_Vp>(__v)), true);\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert_or_assign(key_type&& __k, _Vp&& __v)\n    {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return _VSTD::make_pair(__p, false);\n        }\n        return _VSTD::make_pair(emplace_hint(__p, _VSTD::move(__k), _VSTD::forward<_Vp>(__v)), true);\n    }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert_or_assign(const_iterator __h, const key_type& __k, _Vp&& __v)\n     {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return __p;\n        }\n        return emplace_hint(__h, __k, _VSTD::forward<_Vp>(__v));\n     }\n\n    template <class _Vp>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert_or_assign(const_iterator __h, key_type&& __k, _Vp&& __v)\n     {\n        iterator __p = lower_bound(__k);\n        if ( __p != end() && !key_comp()(__k, __p->first))\n        {\n            __p->second = _VSTD::forward<_Vp>(__v);\n            return __p;\n        }\n        return emplace_hint(__h, _VSTD::move(__k), _VSTD::forward<_Vp>(__v));\n     }\n\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(iterator __p)       {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k)\n        {return __tree_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(map& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k) const {return __tree_.__count_unique(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n        {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n        {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n        {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator> equal_range(const key_type& __k)\n        {return __tree_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n        {return __tree_.__equal_range_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_unique(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_unique(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n    typedef typename __base::__node_base_pointer       __node_base_pointer;\n    typedef typename __base::__parent_pointer          __parent_pointer;\n\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n#ifdef _LIBCPP_CXX03_LANG\n    __node_holder __construct_node_with_key(const key_type& __k);\n#endif\n};\n\n\n#ifndef _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmap<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), typename __base::allocator_type(__a))\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_unique(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__nc));\n    }\n}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\n\n#ifdef _LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(const key_type& __k)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), __k);\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return _LIBCPP_EXPLICIT_MOVE(__h);  // explicitly moved for C++03\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __tree_.__find_equal(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node_with_key(__k);\n        __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return __r->__value_.__cc.second;\n}\n\n#else\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)\n{\n    return __tree_.__emplace_unique_key_args(__k,\n        _VSTD::piecewise_construct,\n        _VSTD::forward_as_tuple(__k),\n        _VSTD::forward_as_tuple()).first->__cc.second;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k)\n{\n    return __tree_.__emplace_unique_key_args(__k,\n        _VSTD::piecewise_construct,\n        _VSTD::forward_as_tuple(_VSTD::move(__k)),\n        _VSTD::forward_as_tuple()).first->__cc.second;\n}\n\n#endif  // !_LIBCPP_CXX03_LANG\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k)\n{\n    __parent_pointer __parent;\n    __node_base_pointer& __child = __tree_.__find_equal(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_pointer>(__child)->__value_.__cc.second;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nconst _Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const\n{\n    __parent_pointer __parent;\n    __node_base_pointer __child = __tree_.__find_equal(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_pointer>(__child)->__value_.__cc.second;\n}\n\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(map<_Key, _Tp, _Compare, _Allocator>& __x,\n     map<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TEMPLATE_VIS multimap\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    class _LIBCPP_TEMPLATE_VIS value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY\n        value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,\n                                                 __value_type>::type __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>            __base;\n    typedef typename __base::__node_traits                          __node_traits;\n    typedef allocator_traits<allocator_type>                        __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>      iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(key_compare())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), typename __base::allocator_type(__a))\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : multimap(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m)\n        : __tree_(__m.__tree_.value_comp(),\n          __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(const multimap& __m)\n        {\n#ifndef _LIBCPP_CXX03_LANG\n            __tree_ = __m.__tree_;\n#else\n            if (this != &__m) {\n                __tree_.clear();\n                __tree_.value_comp() = __m.__tree_.value_comp();\n                __tree_.__copy_assign_alloc(__m.__tree_);\n                insert(__m.begin(), __m.end());\n            }\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    multimap(multimap&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), typename __base::allocator_type(__a))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const allocator_type& __a)\n        : multimap(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_multi(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const allocator_type& __a)\n        : __tree_(typename __base::allocator_type(__a))\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return allocator_type(__tree_.__alloc());}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp() const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp() const\n        {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_CXX03_LANG\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator emplace(_Args&& ...__args) {\n        return __tree_.__emplace_multi(_VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {\n        return __tree_.__emplace_hint_multi(__p.__i_, _VSTD::forward<_Args>(__args)...);\n    }\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(_Pp&& __p)\n            {return __tree_.__insert_multi(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_multi(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(value_type&& __v)\n        {return __tree_.__insert_multi(_VSTD::move(__v));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __v)\n        {return __tree_.__insert_multi(__p.__i_, _VSTD::move(__v));}\n\n#endif  // _LIBCPP_CXX03_LANG\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __v) {return __tree_.__insert_multi(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_multi(__p.__i_, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_multi(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(iterator __p)       {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(multimap& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type\n    count(const _K2& __k) const {return __tree_.__count_multi(__k);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n            {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n            {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n            {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator>             equal_range(const key_type& __k)\n            {return __tree_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n            {return __tree_.__equal_range_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_multi(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n};\n\n#ifndef _LIBCPP_CXX03_LANG\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmultimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), typename __base::allocator_type(__a))\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_multi(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__nc));\n    }\n}\n#endif\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n     multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MAP\n","/*\n *  user_strings_unix.cpp - Unix-specific localizable strings\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"sysdeps.h\"\n#include \"user_strings.h\"\n\n\n// Platform-specific string definitions\nuser_string_def platform_strings[] = {\n\t// Common strings that have a platform-specific variant\n\t{STR_VOLUME_IS_MOUNTED_WARN, \"The volume '%s' is mounted under Unix. Basilisk II will try to unmount it.\"},\n\t{STR_EXTFS_CTRL, \"Unix Root\"},\n\t{STR_EXTFS_NAME, \"Unix Directory Tree\"},\n\t{STR_EXTFS_VOLUME_NAME, \"Unix\"},\n\n\t// Purely platform-specific strings\n\t{STR_NO_XSERVER_ERR, \"Cannot connect to X server '%s'.\"},\n\t{STR_NO_XVISUAL_ERR, \"Cannot obtain appropriate X visual.\"},\n\t{STR_UNSUPP_DEPTH_ERR, \"Unsupported color depth of screen.\"},\n\t{STR_NO_FBDEVICE_FILE_ERR, \"Cannot open frame buffer device specification file %s (%s).\"},\n\t{STR_FBDEV_NAME_ERR, \"The %s frame buffer is not supported in %d bit mode.\"},\n\t{STR_FBDEV_MMAP_ERR, \"Cannot mmap() the frame buffer memory (%s).\"},\n\t{STR_VOSF_INIT_ERR, \"Cannot initialize Video on SEGV signals.\"},\n\t{STR_NO_DEV_ZERO_ERR, \"Cannot open /dev/zero (%s).\"},\n\t{STR_LOW_MEM_MMAP_ERR, \"Cannot map Low Memory Globals (%s).\"},\n\t{STR_SIGALTSTACK_ERR, \"Cannot install alternate signal stack (%s).\"},\n\t{STR_SIG_INSTALL_ERR, \"Cannot install %s handler (%s).\"},\n\t{STR_TIMER_CREATE_ERR, \"Cannot create timer (%s).\"},\n\t{STR_TIMER_SETTIME_ERR, \"Cannot start timer (%s).\"},\n\t{STR_TICK_THREAD_ERR, \"Cannot create 60Hz thread (%s).\"},\n\n\t{STR_BLOCKING_NET_SOCKET_WARN, \"Cannot set non-blocking I/O to net socket (%s). Ethernet will not be available.\"},\n\t{STR_NO_SHEEP_NET_DRIVER_WARN, \"Cannot open %s (%s). Ethernet will not be available.\"},\n\t{STR_SHEEP_NET_ATTACH_WARN, \"Cannot attach to Ethernet card (%s). Ethernet will not be available.\"},\n\t{STR_TUN_TAP_CONFIG_WARN, \"Cannot configure TUN/TAP device (%s). Ethernet will not be available.\"},\n\t{STR_SLIRP_NO_DNS_FOUND_WARN, \"Cannot get DNS address. Ethernet will not be available.\"},\n\t{STR_SCSI_DEVICE_OPEN_WARN, \"Cannot open %s (%s). SCSI Manager access to this device will be disabled.\"},\n\t{STR_SCSI_DEVICE_NOT_SCSI_WARN, \"%s doesn't seem to comply to the Generic SCSI API. SCSI Manager access to this device will be disabled.\"},\n\t{STR_NO_AUDIO_DEV_WARN, \"Cannot open %s (%s). Audio output will be disabled.\"},\n\t{STR_NO_AUDIO_WARN, \"No audio device found, audio output will be disabled.\"},\n\t{STR_AUDIO_FORMAT_WARN, \"Audio hardware doesn't seem to support necessary format. Audio output will be disabled.\"},\n\t{STR_KEYCODE_FILE_WARN, \"Cannot open keycode translation file %s (%s).\"},\n\t{STR_KEYCODE_VENDOR_WARN, \"Cannot find vendor '%s' in keycode translation file %s.\"},\n\n\t{STR_PREFS_MENU_FILE_GTK, \"/_File\"},\n\t{STR_PREFS_ITEM_START_GTK, \"/File/_Start Basilisk II\"},\n\t{STR_PREFS_ITEM_ZAP_PRAM_GTK, \"/File/_Zap PRAM File\"},\n\t{STR_PREFS_ITEM_SEPL_GTK, \"/File/sepl\"},\n\t{STR_PREFS_ITEM_QUIT_GTK, \"/File/_Quit Basilisk II\"},\n\t{STR_HELP_MENU_GTK, \"/_Help\"},\n\t{STR_HELP_ITEM_ABOUT_GTK, \"/Help/_About Basilisk II\"},\n\n\t{STR_FBDEV_NAME_CTRL, \"Frame Buffer Name\"},\n\t{STR_FBDEVICE_FILE_CTRL, \"Frame Buffer Spec File\"},\n\t{STR_DSPDEVICE_FILE_CTRL, \"Audio Output Device\"},\n\t{STR_MIXERDEVICE_FILE_CTRL, \"Audio Mixer Device\"},\n\n\t{STR_BROWSE_TITLE, \"Browse file\"},\n\t{STR_BROWSE_CTRL, \"Browse...\"},\n\t{STR_INPUT_PANE_TITLE, \"Keyboard/Mouse\"},\n\t{STR_KEYCODES_CTRL, \"Use Raw Keycodes\"},\n\t{STR_KEYCODE_FILE_CTRL, \"Keycode Translation File\"},\n\t{STR_MOUSEWHEELMODE_CTRL, \"Mouse Wheel Function\"},\n\t{STR_MOUSEWHEELMODE_PAGE_LAB, \"Page Up/Down\"},\n\t{STR_MOUSEWHEELMODE_CURSOR_LAB, \"Cursor Up/Down\"},\n\t{STR_MOUSEWHEELLINES_CTRL, \"Lines To Scroll\"},\n\n\t{STR_IGNORESEGV_CTRL, \"Ignore Illegal Memory Accesses\"},\n\n\t{STR_WINDOW_TITLE_GRABBED, \"Basilisk II (mouse grabbed, press Ctrl-F5 to release)\"},\n\n\t{STR_NO_B2_EXE_FOUND, \"Could not start %s (%s).\"},\n\n\t{-1, NULL}\t// End marker\n};\n\n\n/*\n *  Fetch pointer to string, given the string number\n */\n\nconst char *GetString(int num)\n{\n\t// First search for platform-specific string\n\tint i = 0;\n\twhile (platform_strings[i].num >= 0) {\n\t\tif (platform_strings[i].num == num)\n\t\t\treturn platform_strings[i].str;\n\t\ti++;\n\t}\n\n\t// Not found, search for common string\n\ti = 0;\n\twhile (common_strings[i].num >= 0) {\n\t\tif (common_strings[i].num == num)\n\t\t\treturn common_strings[i].str;\n\t\ti++;\n\t}\n\treturn NULL;\n}\n","/*\n *  xpram_unix.cpp - XPRAM handling, Unix specific stuff\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"sysdeps.h\"\n\n#include <stdlib.h>\n\n#include \"xpram.h\"\n\n\n// XPRAM file name and path\n#if POWERPC_ROM\nconst char XPRAM_FILE_NAME[] = \".sheepshaver_nvram\";\n#else\nconst char XPRAM_FILE_NAME[] = \".basilisk_ii_xpram\";\n#endif\nstatic char xpram_path[1024];\n\n\n/*\n *  Load XPRAM from settings file\n */\n\nvoid LoadXPRAM(const char *vmdir)\n{\n\tif (vmdir) {\n#if POWERPC_ROM\n\t\tsnprintf(xpram_path, sizeof(xpram_path), \"%s/nvram\", vmdir);\n#else\n\t\tsnprintf(xpram_path, sizeof(xpram_path), \"%s/xpram\", vmdir);\n#endif\n\t} else {\n\t\t// Construct XPRAM path\n\t\txpram_path[0] = 0;\n\t\tchar *home = getenv(\"HOME\");\n\t\tif (home != NULL && strlen(home) < 1000) {\n\t\t\tstrncpy(xpram_path, home, 1000);\n\t\t\tstrcat(xpram_path, \"/\");\n\t\t}\n\t\tstrcat(xpram_path, XPRAM_FILE_NAME);\n\t}\n\n\t// Load XPRAM from settings file\n\tint fd;\n\tif ((fd = open(xpram_path, O_RDONLY)) >= 0) {\n\t\tread(fd, XPRAM, XPRAM_SIZE);\n\t\tclose(fd);\n\t}\n}\n\n\n/*\n *  Save XPRAM to settings file\n */\n\nvoid SaveXPRAM(void)\n{\n\tint fd;\n\tif ((fd = open(xpram_path, O_WRONLY | O_CREAT, 0666)) >= 0) {\n\t\twrite(fd, XPRAM, XPRAM_SIZE);\n\t\tclose(fd);\n\t}\n}\n\n\n/*\n *  Delete PRAM file\n */\n\nvoid ZapPRAM(void)\n{\n\t// Construct PRAM path\n\txpram_path[0] = 0;\n\tchar *home = getenv(\"HOME\");\n\tif (home != NULL && strlen(home) < 1000) {\n\t\tstrncpy(xpram_path, home, 1000);\n\t\tstrcat(xpram_path, \"/\");\n\t}\n\tstrcat(xpram_path, XPRAM_FILE_NAME);\n\n\t// Delete file\n\tunlink(xpram_path);\n}\n","/*\n *  vm_alloc.cpp - Wrapper to various virtual memory allocation schemes\n *                 (supports mmap, vm_allocate or fallbacks to malloc)\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n\n#ifdef HAVE_WIN32_VM\n#define WIN32_LEAN_AND_MEAN /* avoid including junk */\n#include <windows.h>\n#endif\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include \"vm_alloc.h\"\n\n#if defined(__APPLE__) && defined(__MACH__)\n#include <sys/utsname.h>\n#endif\n\n#ifdef HAVE_MACH_VM\n#ifndef HAVE_MACH_TASK_SELF\n#ifdef HAVE_TASK_SELF\n#define mach_task_self task_self\n#else\n#error \"No task_self(), you lose.\"\n#endif\n#endif\n#endif\n\n#ifdef HAVE_WIN32_VM\n/* Windows is either ILP32 or LLP64 */\ntypedef UINT_PTR vm_uintptr_t;\n#else\n/* Other systems are sane as they are either ILP32 or LP64 */\ntypedef unsigned long vm_uintptr_t;\n#endif\n\n/* We want MAP_32BIT, if available, for SheepShaver and BasiliskII\n   because the emulated target is 32-bit and this helps to allocate\n   memory so that branches could be resolved more easily (32-bit\n   displacement to code in .text), on AMD64 for example.  */\n#if defined(__hpux)\n#define MAP_32BIT MAP_ADDR32\n#endif\n#ifndef MAP_32BIT\n#define MAP_32BIT 0\n#endif\n#ifndef MAP_ANON\n#define MAP_ANON 0\n#endif\n#ifndef MAP_ANONYMOUS\n#define MAP_ANONYMOUS 0\n#endif\n\n#define MAP_EXTRA_FLAGS (MAP_32BIT)\n\n#ifdef HAVE_MMAP_VM\n#if (defined(__linux__) && defined(__i386__)) || HAVE_LINKER_SCRIPT\n/* Force a reasonnable address below 0x80000000 on x86 so that we\n   don't get addresses above when the program is run on AMD64.\n   NOTE: this is empirically determined on Linux/x86.  */\n#define MAP_BASE\t0x10000000\n#else\n#define MAP_BASE\t0x00000000\n#endif\nstatic char * next_address = (char *)MAP_BASE;\n#ifdef HAVE_MMAP_ANON\n#define map_flags\t(MAP_ANON | MAP_EXTRA_FLAGS)\n#define zero_fd\t\t-1\n#else\n#ifdef HAVE_MMAP_ANONYMOUS\n#define map_flags\t(MAP_ANONYMOUS | MAP_EXTRA_FLAGS)\n#define zero_fd\t\t-1\n#else\n#define map_flags\t(MAP_EXTRA_FLAGS)\nstatic int zero_fd\t= -1;\n#endif\n#endif\n#endif\n\n/* Translate generic VM map flags to host values.  */\n\n#ifdef HAVE_MMAP_VM\nstatic int translate_map_flags(int vm_flags)\n{\n\tint flags = 0;\n\tif (vm_flags & VM_MAP_SHARED)\n\t\tflags |= MAP_SHARED;\n\tif (vm_flags & VM_MAP_PRIVATE)\n\t\tflags |= MAP_PRIVATE;\n\tif (vm_flags & VM_MAP_FIXED)\n\t\tflags |= MAP_FIXED;\n\tif (vm_flags & VM_MAP_32BIT)\n\t\tflags |= MAP_32BIT;\n\treturn flags;\n}\n#endif\n\n/* Align ADDR and SIZE to 64K boundaries.  */\n\n#ifdef HAVE_WIN32_VM\nstatic inline LPVOID align_addr_segment(LPVOID addr)\n{\n\treturn (LPVOID)(((vm_uintptr_t)addr) & -((vm_uintptr_t)65536));\n}\n\nstatic inline DWORD align_size_segment(LPVOID addr, DWORD size)\n{\n\treturn size + ((vm_uintptr_t)addr - (vm_uintptr_t)align_addr_segment(addr));\n}\n#endif\n\n/* Translate generic VM prot flags to host values.  */\n\n#ifdef HAVE_WIN32_VM\nstatic int translate_prot_flags(int prot_flags)\n{\n\tint prot = PAGE_READWRITE;\n\tif (prot_flags == (VM_PAGE_EXECUTE | VM_PAGE_READ | VM_PAGE_WRITE))\n\t\tprot = PAGE_EXECUTE_READWRITE;\n\telse if (prot_flags == (VM_PAGE_EXECUTE | VM_PAGE_READ))\n\t\tprot = PAGE_EXECUTE_READ;\n\telse if (prot_flags == (VM_PAGE_READ | VM_PAGE_WRITE))\n\t\tprot = PAGE_READWRITE;\n\telse if (prot_flags == VM_PAGE_READ)\n\t\tprot = PAGE_READONLY;\n\telse if (prot_flags == 0)\n\t\tprot = PAGE_NOACCESS;\n\treturn prot;\n}\n#endif\n\n/* Translate Mach return codes to POSIX errno values. */\n#ifdef HAVE_MACH_VM\nstatic int vm_error(kern_return_t ret_code)\n{\n\tswitch (ret_code) {\n\t\tcase KERN_SUCCESS:\n\t\t\treturn 0;\n\t\tcase KERN_INVALID_ADDRESS:\n\t\tcase KERN_NO_SPACE:\n\t\t\treturn ENOMEM;\n\t\tcase KERN_PROTECTION_FAILURE:\n\t\t\treturn EACCES;\n\t\tdefault:\n\t\t\treturn EINVAL;\n\t}\n}\n#endif\n\n/* Initialize the VM system. Returns 0 if successful, -1 for errors.  */\n\nint vm_init(void)\n{\n#ifdef HAVE_MMAP_VM\n#ifndef zero_fd\n\tzero_fd = open(\"/dev/zero\", O_RDWR);\n\tif (zero_fd < 0)\n\t\treturn -1;\n#endif\n#endif\n\n// On 10.4 and earlier, reset CrashReporter's task signal handler to\n// avoid having it show up for signals that get handled.\n#if defined(__APPLE__) && defined(__MACH__)\n\tstruct utsname info;\n\n\tif (!uname(&info) && atoi(info.release) <= 8) {\n\t\ttask_set_exception_ports(mach_task_self(),\n\t\t\tEXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,\n\t\t\tMACH_PORT_NULL,\n\t\t\tEXCEPTION_STATE_IDENTITY,\n\t\t\tMACHINE_THREAD_STATE);\n\t}\n#endif\n\n\treturn 0;\n}\n\n/* Deallocate all internal data used to wrap virtual memory allocators.  */\n\nvoid vm_exit(void)\n{\n#ifdef HAVE_MMAP_VM\n#ifndef zero_fd\n\tif (zero_fd != -1) {\n\t\tclose(zero_fd);\n\t\tzero_fd = -1;\n\t}\n#endif\n#endif\n}\n\n/* Allocate zero-filled memory of SIZE bytes. The mapping is private\n   and default protection bits are read / write. The return value\n   is the actual mapping address chosen or VM_MAP_FAILED for errors.  */\n\nvoid * vm_acquire(size_t size, int options)\n{\n\tvoid * addr;\n\t\n\terrno = 0;\n\n\t// VM_MAP_FIXED are to be used with vm_acquire_fixed() only\n\tif (options & VM_MAP_FIXED)\n\t\treturn VM_MAP_FAILED;\n\n#ifndef HAVE_VM_WRITE_WATCH\n\tif (options & VM_MAP_WRITE_WATCH)\n\t\treturn VM_MAP_FAILED;\n#endif\n\n#if defined(HAVE_MACH_VM)\n\t// vm_allocate() returns a zero-filled memory region\n\tkern_return_t ret_code = vm_allocate(mach_task_self(), (vm_address_t *)&addr, size, TRUE);\n\tif (ret_code != KERN_SUCCESS) {\n\t\terrno = vm_error(ret_code);\n\t\treturn VM_MAP_FAILED;\n\t}\n#elif defined(HAVE_MMAP_VM)\n\tint fd = zero_fd;\n\tint the_map_flags = translate_map_flags(options) | map_flags;\n\n\tif ((addr = mmap((caddr_t)next_address, size, VM_PAGE_DEFAULT, the_map_flags, fd, 0)) == (void *)MAP_FAILED)\n\t\treturn VM_MAP_FAILED;\n\t\n\t// Sanity checks for 64-bit platforms\n\tif (sizeof(void *) == 8 && (options & VM_MAP_32BIT) && !((char *)addr <= (char *)0xffffffff))\n\t\treturn VM_MAP_FAILED;\n\n\tnext_address = (char *)addr + size;\n#elif defined(HAVE_WIN32_VM)\n\tint alloc_type = MEM_RESERVE | MEM_COMMIT;\n\tif (options & VM_MAP_WRITE_WATCH)\n\t  alloc_type |= MEM_WRITE_WATCH;\n\n\tif ((addr = VirtualAlloc(NULL, size, alloc_type, PAGE_EXECUTE_READWRITE)) == NULL)\n\t\treturn VM_MAP_FAILED;\n#else\n\tif ((addr = calloc(size, 1)) == 0)\n\t\treturn VM_MAP_FAILED;\n\t\n\t// Omit changes for protections because they are not supported in this mode\n\treturn addr;\n#endif\n\n\t// Explicitely protect the newly mapped region here because on some systems,\n\t// say MacOS X, mmap() doesn't honour the requested protection flags.\n\tif (vm_protect(addr, size, VM_PAGE_DEFAULT) != 0)\n\t\treturn VM_MAP_FAILED;\n\t\n\treturn addr;\n}\n\n/* Allocate zero-filled memory at exactly ADDR (which must be page-aligned).\n   Retuns 0 if successful, -1 on errors.  */\n\nint vm_acquire_fixed(void * addr, size_t size, int options)\n{\n\terrno = 0;\n\t\n\t// Fixed mappings are required to be private\n\tif (options & VM_MAP_SHARED)\n\t\treturn -1;\n\n#ifndef HAVE_VM_WRITE_WATCH\n\tif (options & VM_MAP_WRITE_WATCH)\n\t\treturn -1;\n#endif\n\n#if defined(HAVE_MACH_VM)\n\t// vm_allocate() returns a zero-filled memory region\n\tkern_return_t ret_code = vm_allocate(mach_task_self(), (vm_address_t *)&addr, size, 0);\n\tif (ret_code != KERN_SUCCESS) {\n\t\terrno = vm_error(ret_code);\n\t\treturn -1;\n\t}\n#elif defined(HAVE_MMAP_VM)\n\tint fd = zero_fd;\n\tint the_map_flags = translate_map_flags(options) | map_flags | MAP_FIXED;\n\n\tif (mmap((caddr_t)addr, size, VM_PAGE_DEFAULT, the_map_flags, fd, 0) == (void *)MAP_FAILED)\n\t\treturn -1;\n#elif defined(HAVE_WIN32_VM)\n\t// Windows cannot allocate Low Memory\n\tif (addr == NULL)\n\t\treturn -1;\n\n\tint alloc_type = MEM_RESERVE | MEM_COMMIT;\n\tif (options & VM_MAP_WRITE_WATCH)\n\t  alloc_type |= MEM_WRITE_WATCH;\n\n\t// Allocate a possibly offset region to align on 64K boundaries\n\tLPVOID req_addr = align_addr_segment(addr);\n\tDWORD  req_size = align_size_segment(addr, size);\n\tLPVOID ret_addr = VirtualAlloc(req_addr, req_size, alloc_type, PAGE_EXECUTE_READWRITE);\n\tif (ret_addr != req_addr)\n\t\treturn -1;\n#else\n\t// Unsupported\n\treturn -1;\n#endif\n\n\t// Explicitely protect the newly mapped region here because on some systems,\n\t// say MacOS X, mmap() doesn't honour the requested protection flags.\n\tif (vm_protect(addr, size, VM_PAGE_DEFAULT) != 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Deallocate any mapping for the region starting at ADDR and extending\n   LEN bytes. Returns 0 if successful, -1 on errors.  */\n\nint vm_release(void * addr, size_t size)\n{\n\t// Safety check: don't try to release memory that was not allocated\n\tif (addr == VM_MAP_FAILED)\n\t\treturn 0;\n\n#ifdef HAVE_MACH_VM\n\t// #error HAVE_MACH_VM\n\tif (vm_deallocate(mach_task_self(), (vm_address_t)addr, size) != KERN_SUCCESS)\n\t\treturn -1;\n#else\n#ifdef HAVE_MMAP_VM\n\t// #error HAVE_MMAP_VM\n\tif (munmap((caddr_t)addr, size) != 0)\n\t\treturn -1;\n#else\n#ifdef HAVE_WIN32_VM\n\t// #error HAVE_WIN32_VM\n\tif (VirtualFree(align_addr_segment(addr), 0, MEM_RELEASE) == 0)\n\t\treturn -1;\n#else\n\tfree(addr);\n#endif\n#endif\n#endif\n\t\n\treturn 0;\n}\n\n/* Change the memory protection of the region starting at ADDR and\n   extending LEN bytes to PROT. Returns 0 if successful, -1 for errors.  */\n\nint vm_protect(void * addr, size_t size, int prot)\n{\n#ifdef HAVE_MACH_VM\n\tint ret_code = vm_protect(mach_task_self(), (vm_address_t)addr, size, 0, prot);\n\treturn ret_code == KERN_SUCCESS ? 0 : -1;\n#else\n#ifdef HAVE_MMAP_VM\n\tint ret_code = mprotect((caddr_t)addr, size, prot);\n\treturn ret_code == 0 ? 0 : -1;\n#else\n#ifdef HAVE_WIN32_VM\n\tDWORD old_prot;\n\tint ret_code = VirtualProtect(addr, size, translate_prot_flags(prot), &old_prot);\n\treturn ret_code != 0 ? 0 : -1;\n#else\n\t// Unsupported\n\treturn -1;\n#endif\n#endif\n#endif\n}\n\n/* Return the addresses of the pages that got modified in the\n   specified range [ ADDR, ADDR + SIZE [ since the last reset of the watch\n   bits. Returns 0 if successful, -1 for errors.  */\n\nint vm_get_write_watch(void * addr, size_t size,\n\t\t\t\t\t   void ** pages, unsigned int * n_pages,\n\t\t\t\t\t   int options)\n{\n#ifdef HAVE_VM_WRITE_WATCH\n#ifdef HAVE_WIN32_VM\n\tDWORD flags = 0;\n\tif (options & VM_WRITE_WATCH_RESET)\n\t\tflags |= WRITE_WATCH_FLAG_RESET;\n\n\tULONG page_size;\n\tULONG_PTR count = *n_pages;\n\tint ret_code = GetWriteWatch(flags, addr, size, pages, &count, &page_size);\n\tif (ret_code != 0)\n\t\treturn -1;\n\n\t*n_pages = count;\n\treturn 0;\n#endif\n#endif\n\t// Unsupported\n\treturn -1;\n}\n\n/* Reset the write-tracking state for the specified range [ ADDR, ADDR\n   + SIZE [. Returns 0 if successful, -1 for errors.  */\n\nint vm_reset_write_watch(void * addr, size_t size)\n{\n#ifdef HAVE_VM_WRITE_WATCH\n#ifdef HAVE_WIN32_VM\n\tint ret_code = ResetWriteWatch(addr, size);\n\treturn ret_code == 0 ? 0 : -1;\n#endif\n#endif\n\t// Unsupported\n\treturn -1;\n}\n\n/* Returns the size of a page.  */\n\nint vm_get_page_size(void)\n{\n#ifdef HAVE_WIN32_VM\n\tstatic vm_uintptr_t page_size = 0;\n\tif (page_size == 0) {\n\t\tSYSTEM_INFO si;\n\t\tGetSystemInfo(&si);\n\t\tpage_size = si.dwAllocationGranularity;\n\t}\n\treturn page_size;\n#else\n\treturn getpagesize();\n#endif\n}\n\n#ifdef CONFIGURE_TEST_VM_WRITE_WATCH\nint main(void)\n{\n\tint i, j;\n\n\tvm_init();\n\n\tvm_uintptr_t page_size = vm_get_page_size();\n\t\n\tchar *area;\n\tconst int n_pages = 7;\n\tconst int area_size = n_pages * page_size;\n\tconst int map_options = VM_MAP_DEFAULT | VM_MAP_WRITE_WATCH;\n\tif ((area = (char *)vm_acquire(area_size, map_options)) == VM_MAP_FAILED)\n\t\treturn 1;\n\n\tunsigned int n_modified_pages_expected = 0;\n\tstatic const int touch_page[n_pages] = { 0, 1, 1, 0, 1, 0, 1 };\n\tfor (i = 0; i < n_pages; i++) {\n\t\tif (touch_page[i]) {\n\t\t\tarea[i * page_size] = 1;\n\t\t\t++n_modified_pages_expected;\n\t\t}\n\t}\n\n\tchar *modified_pages[n_pages];\n\tunsigned int n_modified_pages = n_pages;\n\tif (vm_get_write_watch(area, area_size, (void **)modified_pages, &n_modified_pages) < 0)\n\t\treturn 2;\n\tif (n_modified_pages != n_modified_pages_expected)\n\t\treturn 3;\n\tfor (i = 0, j = 0; i < n_pages; i++) {\n\t\tchar v = area[i * page_size];\n\t\tif ((touch_page[i] && !v) || (!touch_page[i] && v))\n\t\t\treturn 4;\n\t\tif (!touch_page[i])\n\t\t\tcontinue;\n\t\tif (modified_pages[j] != (area + i * page_size))\n\t\t\treturn 5;\n\t\t++j;\n\t}\n\n\tvm_release(area, area_size);\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIGURE_TEST_VM_MAP\n#include <stdlib.h>\n#include <signal.h>\n\nstatic void fault_handler(int sig)\n{\n\texit(1);\n}\n\n/* Tests covered here:\n   - TEST_VM_PROT_* program slices actually succeeds when a crash occurs\n   - TEST_VM_MAP_ANON* program slices succeeds when it could be compiled\n*/\nint main(void)\n{\n\tvm_init();\n\n\tsignal(SIGSEGV, fault_handler);\n#ifdef SIGBUS\n\tsignal(SIGBUS,  fault_handler);\n#endif\n\t\n#define page_align(address) ((char *)((vm_uintptr_t)(address) & -page_size))\n\tvm_uintptr_t page_size = vm_get_page_size();\n\t\n\tconst int area_size = 6 * page_size;\n\tvolatile char * area = (volatile char *) vm_acquire(area_size);\n\tvolatile char * fault_address = area + (page_size * 7) / 2;\n\n#if defined(TEST_VM_MMAP_ANON) || defined(TEST_VM_MMAP_ANONYMOUS)\n\tif (area == VM_MAP_FAILED)\n\t\treturn 1;\n\n\tif (vm_release((char *)area, area_size) < 0)\n\t\treturn 1;\n\t\n\treturn 0;\n#endif\n\n#if defined(TEST_VM_PROT_NONE_READ) || defined(TEST_VM_PROT_NONE_WRITE)\n\tif (area == VM_MAP_FAILED)\n\t\treturn 0;\n\t\n\tif (vm_protect(page_align(fault_address), page_size, VM_PAGE_NOACCESS) < 0)\n\t\treturn 0;\n#endif\n\n#if defined(TEST_VM_PROT_RDWR_WRITE)\n\tif (area == VM_MAP_FAILED)\n\t\treturn 1;\n\t\n\tif (vm_protect(page_align(fault_address), page_size, VM_PAGE_READ) < 0)\n\t\treturn 1;\n\t\n\tif (vm_protect(page_align(fault_address), page_size, VM_PAGE_READ | VM_PAGE_WRITE) < 0)\n\t\treturn 1;\n#endif\n\n#if defined(TEST_VM_PROT_READ_WRITE)\n\tif (vm_protect(page_align(fault_address), page_size, VM_PAGE_READ) < 0)\n\t\treturn 0;\n#endif\n\n#if defined(TEST_VM_PROT_NONE_READ)\n\t// this should cause a core dump\n\tchar foo = *fault_address;\n\treturn 0;\n#endif\n\n#if defined(TEST_VM_PROT_NONE_WRITE) || defined(TEST_VM_PROT_READ_WRITE)\n\t// this should cause a core dump\n\t*fault_address = 'z';\n\treturn 0;\n#endif\n\n#if defined(TEST_VM_PROT_RDWR_WRITE)\n\t// this should not cause a core dump\n\t*fault_address = 'z';\n\treturn 0;\n#endif\n}\n#endif\n","/*\n *  video_blit.cpp - Video/graphics emulation, blitters\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"sysdeps.h\"\n#include \"video.h\"\n#include \"video_blit.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n\n// Format of the target visual\nstatic VisualFormat visualFormat;\n\n// This holds the pixels values of the palette colors for 8->16/32-bit expansion\nuint32 ExpandMap[256];\n\n// Mark video_blit.h for specialization\n#define DEFINE_VIDEO_BLITTERS 1\n\n/* -------------------------------------------------------------------------- */\n/* --- Raw Copy / No conversion required                                  --- */\n/* -------------------------------------------------------------------------- */\n\nstatic void Blit_Copy_Raw(uint8 * dest, const uint8 * source, uint32 length)\n{\n\t// This function is likely to be inlined and/or highly optimized\n\tmemcpy(dest, source, length);\n}\n\n/* -------------------------------------------------------------------------- */\n/* --- RGB 555                                                            --- */\n/* -------------------------------------------------------------------------- */\n\n#ifdef WORDS_BIGENDIAN\n# define FB_FUNC_NAME Blit_RGB555_OBO\n#else\n# define FB_FUNC_NAME Blit_RGB555_NBO\n#endif\n\n#define FB_BLIT_1(dst, src) \\\n\t(dst = (((src) >> 8) & 0xff) | (((src) & 0xff) << 8))\n\t\n#define FB_BLIT_2(dst, src) \\\n\t(dst = (((src) >> 8) & 0x00ff00ff) | (((src) & 0x00ff00ff) << 8))\n\n#define FB_BLIT_4(dst, src) \\\n\t(dst =\t(((src) >> 8) & UVAL64(0x00ff00ff00ff00ff)) | \\\n\t\t\t(((src) & UVAL64(0x00ff00ff00ff00ff)) << 8))\n\n#define\tFB_DEPTH 15\n#include \"video_blit.h\"\n\n/* -------------------------------------------------------------------------- */\n/* --- BGR 555                                                            --- */\n/* -------------------------------------------------------------------------- */\n\n#ifdef WORDS_BIGENDIAN\n\n// Native byte order\n\n#define FB_BLIT_1(dst, src) \\\n\t(dst = (((src) >> 10) & 0x001f) | ((src) & 0x03e0) | (((src) << 10) & 0x7c00))\n\n#define FB_BLIT_2(dst, src) \\\n\t(dst = (((src) >> 10) & 0x001f001f) | ((src) & 0x03e003e0) | (((src) << 10) & 0x7c007c00))\n\n#define FB_BLIT_4(dst, src) \\\n\t(dst =\t(((src) >> 10) & UVAL64(0x001f001f001f001f)) | \\\n\t\t\t( (src)        & UVAL64(0x03e003e003e003e0)) | \\\n\t\t\t(((src) << 10) & UVAL64(0x7c007c007c007c00)))\n\n#define FB_DEPTH 15\n#define FB_FUNC_NAME Blit_BGR555_NBO\n#include \"video_blit.h\"\n\n// Opposite byte order (untested)\n\n#define FB_BLIT_1(dst, src) \\\n\t(dst = (((src) >> 2) & 0x1f00) | (((src) >> 8) & 3) | (((src) << 8) & 0xe000) | (((src) << 2) & 0x7c))\n\n#define FB_BLIT_2(dst, src) \\\n\t(dst = (((src) >> 2) & 0x1f001f00) | (((src) >> 8) & 0x30003) | (((src) << 8) & 0xe000e000) | (((src) << 2) & 0x7c007c))\n\n#define FB_BLIT_4(dst, src) \\\n\t(dst =\t(((src) >> 2) & UVAL64(0x1f001f001f001f00)) | \\\n\t\t\t(((src) >> 8) & UVAL64(0x0003000300030003)) | \\\n\t\t\t(((src) << 8) & UVAL64(0xe000e000e000e000)) | \\\n\t\t\t(((src) << 2) & UVAL64(0x007c007c007c007c)))\n\n#define FB_DEPTH 15\n#define FB_FUNC_NAME Blit_BGR555_OBO\n#include \"video_blit.h\"\n\n#else\n\n// Native byte order (untested)\n\n#define FB_BLIT_1(dst, src) \\\n\t(dst = (((src) >> 2) & 0x1f) | (((src) >> 8) & 0xe0) | (((src) << 8) & 0x0300) | (((src) << 2) & 0x7c00))\n\n#define FB_BLIT_2(dst, src) \\\n\t(dst = (((src) >> 2) & 0x1f001f) | (((src) >> 8) & 0xe000e0) | (((src) << 8) & 0x03000300) | (((src) << 2) & 0x7c007c00))\n\n#define FB_BLIT_4(dst, src) \\\n\t(dst =\t(((src) >> 2) & UVAL64(0x001f001f001f001f)) | \\\n\t\t\t(((src) >> 8) & UVAL64(0x00e000e000e000e0)) | \\\n\t\t\t(((src) << 8) & UVAL64(0x0300030003000300)) | \\\n\t\t\t(((src) << 2) & UVAL64(0x7c007c007c007c00)))\n\n#define FB_DEPTH 15\n#define FB_FUNC_NAME Blit_BGR555_NBO\n#include \"video_blit.h\"\n\n// Opposite byte order (untested)\n\n#define FB_BLIT_1(dst, src) \\\n\t(dst = (((src) << 6) & 0x1f00) | ((src) & 0xe003) | (((src) >> 6) & 0x7c))\n\n#define FB_BLIT_2(dst, src) \\\n\t(dst = (((src) << 6) & 0x1f001f00) | ((src) & 0xe003e003) | (((src) >> 6) & 0x7c007c))\n\n#define FB_BLIT_4(dst, src) \\\n\t(dst =\t(((src) << 6) & UVAL64(0x1f001f001f001f00)) | \\\n\t\t\t( (src)       & UVAL64(0xe003e003e003e003)) | \\\n\t\t\t(((src) >> 6) & UVAL64(0x007c007c007c007c)))\n\n#define FB_DEPTH 15\n#define FB_FUNC_NAME Blit_BGR555_OBO\n#include \"video_blit.h\"\n\n#endif\n\n/* -------------------------------------------------------------------------- */\n/* --- RGB 565                                                            --- */\n/* -------------------------------------------------------------------------- */\n\n#ifdef WORDS_BIGENDIAN\n\n// Native byte order\n\n#define FB_BLIT_1(dst, src) \\\n\t(dst = (((src) & 0x1f) | (((src) << 1) & 0xffc0)))\n\n#define FB_BLIT_2(dst, src) \\\n\t(dst = (((src) & 0x001f001f) | (((src) << 1) & 0xffc0ffc0)))\n\n#define FB_BLIT_4(dst, src) \\\n\t(dst =\t(((src)       & UVAL64(0x001f001f001f001f)) | \\\n\t\t\t(((src) << 1) & UVAL64(0xffc0ffc0ffc0ffc0))))\n\n#define FB_DEPTH 16\n#define FB_FUNC_NAME Blit_RGB565_NBO\n#include \"video_blit.h\"\n\n// Opposite byte order\n\n#define FB_BLIT_1(dst, src) \\\n\t(dst = ((((src) >> 7) & 0xff) | (((src) << 9) & 0xc000) | (((src) << 8) & 0x1f00)))\n\n#define FB_BLIT_2(dst, src) \\\n\t(dst = ((((src) >> 7) & 0x00ff00ff) | (((src) << 9) & 0xc000c000) | (((src) << 8) & 0x1f001f00)))\n\n#define FB_BLIT_4(dst, src) \\\n\t(dst =\t(((src) >> 7) & UVAL64(0x00ff00ff00ff00ff)) | \\\n\t\t\t(((src) << 9) & UVAL64(0xc000c000c000c000)) | \\\n\t\t\t(((src) << 8) & UVAL64(0x1f001f001f001f00)))\n\n#define FB_DEPTH 16\n#define FB_FUNC_NAME Blit_RGB565_OBO\n#include \"video_blit.h\"\n\n#else\n\n// Native byte order\n\n#define FB_BLIT_1(dst, src) \\\n\t(dst = (((src) >> 8) & 0x001f) | (((src) << 9) & 0xfe00) | (((src) >> 7) & 0x01c0))\n\t\n#define FB_BLIT_2(dst, src) \\\n\t(dst = (((src) >> 8) & 0x001f001f) | (((src) << 9) & 0xfe00fe00) | (((src) >> 7) & 0x01c001c0))\n\n#define FB_BLIT_4(dst, src) \\\n\t(dst =\t(((src) >> 8) & UVAL64(0x001f001f001f001f)) | \\\n\t\t\t(((src) << 9) & UVAL64(0xfe00fe00fe00fe00)) | \\\n\t\t\t(((src) >> 7) & UVAL64(0x01c001c001c001c0)))\n\n#define FB_DEPTH 16\n#define FB_FUNC_NAME Blit_RGB565_NBO\n#include \"video_blit.h\"\n\n// Opposite byte order (untested)\n\n#define FB_BLIT_1(dst, src) \\\n\t(dst = (((src) & 0x1f00) | (((src) << 1) & 0xe0fe) | (((src) >> 15) & 1)))\n\n#define FB_BLIT_2(dst, src) \\\n\t(dst = (((src) & 0x1f001f00) | (((src) << 1) & 0xe0fee0fe) | (((src) >> 15) & 0x10001)))\n\n#define FB_BLIT_4(dst, src) \\\n\t(dst =\t(((src)        & UVAL64(0x1f001f001f001f00)) | \\\n\t\t\t(((src) <<  1) & UVAL64(0xe0fee0fee0fee0fe)) | \\\n\t\t\t(((src) >> 15) & UVAL64(0x0001000100010001))))\n\n#define FB_DEPTH 16\n#define FB_FUNC_NAME Blit_RGB565_OBO\n#include \"video_blit.h\"\n\n#endif\n\n/* -------------------------------------------------------------------------- */\n/* --- RGB 888                                                            --- */\n/* -------------------------------------------------------------------------- */\n\n#ifdef WORDS_BIGENDIAN\n# define FB_FUNC_NAME Blit_RGB888_OBO\n#else\n# define FB_FUNC_NAME Blit_RGB888_NBO\n#endif\n\n#define FB_BLIT_2(dst, src) \\\n\t(dst = (((src) >> 24) & 0xff) | (((src) >> 8) & 0xff00) | (((src) & 0xff00) << 8) | (((src) & 0xff) << 24))\n\n#define FB_BLIT_4(dst, src) \\\n\t(dst =\t(((src) >> 24) & UVAL64(0x000000ff000000ff)) | \\\n\t\t\t(((src) >>  8) & UVAL64(0x0000ff000000ff00)) | \\\n\t\t\t(((src) & UVAL64(0x0000ff000000ff00)) <<  8) | \\\n\t\t\t(((src) & UVAL64(0x000000ff000000ff)) << 24))\n\n#define FB_DEPTH 24\n#include \"video_blit.h\"\n\n/* -------------------------------------------------------------------------- */\n/* --- BGR 888                                                            --- */\n/* -------------------------------------------------------------------------- */\n\n// Native byte order [BE] (untested)\n\n#ifdef WORDS_BIGENDIAN\n\n#define FB_BLIT_2(dst, src) \\\n\t(dst = (((src) >> 16) & 0xff) | ((src) & 0xff00) | (((src) & 0xff) << 16))\n\n#define FB_BLIT_4(dst, src) \\\n\t(dst =\t(((src) >> 16) & UVAL64(0x000000ff000000ff)) | \\\n\t\t\t( (src)        & UVAL64(0x0000ff000000ff00)) | \\\n\t\t\t(((src) & UVAL64(0x000000ff000000ff)) << 16))\n\n#define FB_FUNC_NAME Blit_BGR888_NBO\n#define FB_DEPTH 24\n#include \"video_blit.h\"\n\n#else\n\n// Opposite byte order [LE] (untested)\n\n#define FB_BLIT_2(dst, src) \\\n\t(dst = (((src) >> 16) & 0xff) | ((src) & 0xff0000) | (((src) & 0xff) << 16))\n\n#define FB_BLIT_4(dst, src) \\\n\t(dst =\t(((src) >> 16) & UVAL64(0x000000ff000000ff)) | \\\n\t\t\t( (src)        & UVAL64(0x00ff000000ff0000)) | \\\n\t\t\t(((src) & UVAL64(0x000000ff000000ff)) << 16))\n\n#define FB_FUNC_NAME Blit_BGR888_OBO\n#define FB_DEPTH 24\n#include \"video_blit.h\"\n\n#endif\n\n// Opposite byte order [BE] (untested) / Native byte order [LE] (untested)\n\n#ifdef WORDS_BIGENDIAN\n# define FB_FUNC_NAME Blit_BGR888_OBO\n#else\n# define FB_FUNC_NAME Blit_BGR888_NBO\n#endif\n\n#define FB_BLIT_2(dst, src) \\\n\t(dst = ((src) & 0xff00ff) | (((src) & 0xff00) << 16))\n\n#define FB_BLIT_4(dst, src) \\\n\t(dst = ((src) & UVAL64(0x00ff00ff00ff00ff)) | (((src) & UVAL64(0x0000ff000000ff00)) << 16))\n\n#define FB_DEPTH 24\n#include \"video_blit.h\"\n\n/* -------------------------------------------------------------------------- */\n/* --- 1/2/4-bit indexed to 8-bit mode conversion                         --- */\n/* -------------------------------------------------------------------------- */\n\nstatic void Blit_Expand_1_To_8(uint8 * dest, const uint8 * p, uint32 length)\n{\n\tuint8 *q = (uint8 *)dest;\n\tfor (uint32 i=0; i<length; i++) {\n\t\tuint8 c = *p++;\n\t\t*q++ = c >> 7;\n\t\t*q++ = (c >> 6) & 1;\n\t\t*q++ = (c >> 5) & 1;\n\t\t*q++ = (c >> 4) & 1;\n\t\t*q++ = (c >> 3) & 1;\n\t\t*q++ = (c >> 2) & 1;\n\t\t*q++ = (c >> 1) & 1;\n\t\t*q++ = c & 1;\n\t}\n}\n\nstatic void Blit_Expand_2_To_8(uint8 * dest, const uint8 * p, uint32 length)\n{\n\tuint8 *q = (uint8 *)dest;\n\tfor (uint32 i=0; i<length; i++) {\n\t\tuint8 c = *p++;\n\t\t*q++ = c >> 6;\n\t\t*q++ = (c >> 4) & 3;\n\t\t*q++ = (c >> 2) & 3;\n\t\t*q++ = c & 3;\n\t}\n}\n\nstatic void Blit_Expand_4_To_8(uint8 * dest, const uint8 * p, uint32 length)\n{\n\tuint8 *q = (uint8 *)dest;\n\tfor (uint32 i=0; i<length; i++) {\n\t\tuint8 c = *p++;\n\t\t*q++ = c >> 4;\n\t\t*q++ = c & 0x0f;\n\t}\n}\n\n/* -------------------------------------------------------------------------- */\n/* --- 1/2/4/8-bit indexed to 16-bit mode color expansion                 --- */\n/* -------------------------------------------------------------------------- */\n\nstatic void Blit_Expand_1_To_16(uint8 * dest, const uint8 * p, uint32 length)\n{\n\tuint16 *q = (uint16 *)dest;\n\tfor (uint32 i=0; i<length; i++) {\n\t\tuint8 c = *p++;\n\t\t*q++ = -(c >> 7);\n\t\t*q++ = -((c >> 6) & 1);\n\t\t*q++ = -((c >> 5) & 1);\n\t\t*q++ = -((c >> 4) & 1);\n\t\t*q++ = -((c >> 3) & 1);\n\t\t*q++ = -((c >> 2) & 1);\n\t\t*q++ = -((c >> 1) & 1);\n\t\t*q++ = -(c & 1);\n\t}\n}\n\nstatic void Blit_Expand_2_To_16(uint8 * dest, const uint8 * p, uint32 length)\n{\n\tuint16 *q = (uint16 *)dest;\n\tfor (uint32 i=0; i<length; i++) {\n\t\tuint8 c = *p++;\n\t\t*q++ = ExpandMap[c >> 6];\n\t\t*q++ = ExpandMap[c >> 4];\n\t\t*q++ = ExpandMap[c >> 2];\n\t\t*q++ = ExpandMap[c];\n\t}\n}\n\nstatic void Blit_Expand_4_To_16(uint8 * dest, const uint8 * p, uint32 length)\n{\n\tuint16 *q = (uint16 *)dest;\n\tfor (uint32 i=0; i<length; i++) {\n\t\tuint8 c = *p++;\n\t\t*q++ = ExpandMap[c >> 4];\n\t\t*q++ = ExpandMap[c];\n\t}\n}\n\nstatic void Blit_Expand_8_To_16(uint8 * dest, const uint8 * p, uint32 length)\n{\n\tuint16 *q = (uint16 *)dest;\n\tfor (uint32 i=0; i<length; i++)\n\t\t*q++ = ExpandMap[*p++];\n}\n\n/* -------------------------------------------------------------------------- */\n/* --- 1/2/4/8-bit indexed to 32-bit mode color expansion                 --- */\n/* -------------------------------------------------------------------------- */\n\nstatic void Blit_Expand_1_To_32(uint8 * dest, const uint8 * p, uint32 length)\n{\n\tuint32 *q = (uint32 *)dest;\n\tfor (uint32 i=0; i<length; i++) {\n\t\tuint8 c = *p++;\n\t\t*q++ = -(c >> 7);\n\t\t*q++ = -((c >> 6) & 1);\n\t\t*q++ = -((c >> 5) & 1);\n\t\t*q++ = -((c >> 4) & 1);\n\t\t*q++ = -((c >> 3) & 1);\n\t\t*q++ = -((c >> 2) & 1);\n\t\t*q++ = -((c >> 1) & 1);\n\t\t*q++ = -(c & 1);\n\t}\n}\n\nstatic void Blit_Expand_2_To_32(uint8 * dest, const uint8 * p, uint32 length)\n{\n\tuint32 *q = (uint32 *)dest;\n\tfor (uint32 i=0; i<length; i++) {\n\t\tuint8 c = *p++;\n\t\t*q++ = ExpandMap[c >> 6];\n\t\t*q++ = ExpandMap[c >> 4];\n\t\t*q++ = ExpandMap[c >> 2];\n\t\t*q++ = ExpandMap[c];\n\t}\n}\n\nstatic void Blit_Expand_4_To_32(uint8 * dest, const uint8 * p, uint32 length)\n{\n\tuint32 *q = (uint32 *)dest;\n\tfor (uint32 i=0; i<length; i++) {\n\t\tuint8 c = *p++;\n\t\t*q++ = ExpandMap[c >> 4];\n\t\t*q++ = ExpandMap[c];\n\t}\n}\n\nstatic void Blit_Expand_8_To_32(uint8 * dest, const uint8 * p, uint32 length)\n{\n\tuint32 *q = (uint32 *)dest;\n\tfor (uint32 i=0; i<length; i++)\n\t\t*q++ = ExpandMap[*p++];\n}\n\n/* -------------------------------------------------------------------------- */\n/* --- Blitters to the host frame buffer, or XImage buffer                --- */\n/* -------------------------------------------------------------------------- */\n\n// Function used to update the hosst frame buffer (DGA), or an XImage buffer (WIN)\n// --> Shall be initialized only through the Screen_blitter_init() function\ntypedef void (*Screen_blit_func)(uint8 * dest, const uint8 * source, uint32 length);\nScreen_blit_func Screen_blit = 0;\n\n// Structure used to match the adequate framebuffer update function\nstruct Screen_blit_func_info {\n\tint\t\t\t\t\tdepth;\t\t\t// Screen depth\n\tuint32\t\t\t\tRmask;\t\t\t// Red mask\n\tuint32\t\t\t\tGmask;\t\t\t// Green mask\n\tuint32\t\t\t\tBmask;\t\t\t// Blue mask\n\tScreen_blit_func\thandler_nbo;\t// Update function (native byte order)\n\tScreen_blit_func\thandler_obo;\t// Update function (opposite byte order)\n};\n\n// Table of visual formats supported and their respective handler\nstatic Screen_blit_func_info Screen_blitters[] = {\n#ifdef WORDS_BIGENDIAN\n\t{  1, 0x000000, 0x000000, 0x000000, Blit_Copy_Raw\t, Blit_Copy_Raw\t\t},\t// NT\n\t{  8, 0x000000, 0x000000, 0x000000, Blit_Copy_Raw\t, Blit_Copy_Raw\t\t},\t// OK (NBO)\n\t{ 15, 0x007c00, 0x0003e0, 0x00001f, Blit_Copy_Raw\t, Blit_RGB555_OBO\t},\t// OK (OBO)\n\t{ 15, 0x00001f, 0x0003e0, 0x007c00, Blit_BGR555_NBO\t, Blit_BGR555_OBO\t},\t// NT\n\t{ 16, 0x007c00, 0x0003e0, 0x00001f, Blit_Copy_Raw\t, Blit_RGB555_OBO\t},\t// OK (OBO)\n\t{ 16, 0x00f800, 0x0007e0, 0x00001f, Blit_RGB565_NBO\t, Blit_RGB565_OBO\t},\t// OK (OBO)\n\t{ 24, 0xff0000, 0x00ff00, 0x0000ff, Blit_Copy_Raw\t, Blit_RGB888_OBO\t},\t// OK (OBO)\n\t{ 24, 0x0000ff, 0x00ff00, 0xff0000, Blit_BGR888_NBO\t, Blit_BGR888_OBO\t},\t// NT\n\t{ 32, 0xff0000, 0x00ff00, 0x0000ff, Blit_Copy_Raw\t, Blit_RGB888_OBO\t},\t// OK\n\t{ 32, 0x0000ff, 0x00ff00, 0xff0000, Blit_BGR888_NBO\t, Blit_BGR888_OBO\t},\t// OK\n#else\n\t{  1, 0x000000, 0x000000, 0x000000, Blit_Copy_Raw\t, Blit_Copy_Raw\t\t},\t// NT\n\t{  8, 0x000000, 0x000000, 0x000000, Blit_Copy_Raw\t, Blit_Copy_Raw\t\t},\t// OK (NBO)\n\t{ 15, 0x007c00, 0x0003e0, 0x00001f, Blit_RGB555_NBO\t, Blit_Copy_Raw\t\t},\t// OK (NBO)\n\t{ 15, 0x00001f, 0x0003e0, 0x007c00, Blit_BGR555_NBO\t, Blit_BGR555_OBO\t},\t// NT\n\t{ 16, 0x007c00, 0x0003e0, 0x00001f, Blit_RGB555_NBO\t, Blit_Copy_Raw\t\t},\t// OK (NBO)\n\t{ 16, 0x00f800, 0x0007e0, 0x00001f, Blit_RGB565_NBO\t, Blit_RGB565_OBO\t},\t// OK (NBO)\n\t{ 24, 0xff0000, 0x00ff00, 0x0000ff, Blit_RGB888_NBO\t, Blit_Copy_Raw\t\t},\t// OK (NBO)\n\t{ 24, 0x0000ff, 0x00ff00, 0xff0000, Blit_BGR888_NBO\t, Blit_BGR888_OBO\t},\t// NT\n\t{ 32, 0xff0000, 0x00ff00, 0x0000ff, Blit_RGB888_NBO\t, Blit_Copy_Raw\t\t},\t// OK (NBO)\n\t{ 32, 0x0000ff, 0x00ff00, 0xff0000, Blit_BGR888_NBO\t, Blit_BGR888_OBO\t},\t// NT\n#endif\n\t{ 32, 0xff00, 0xff0000, 0xff000000, Blit_Copy_Raw   , Blit_Copy_Raw     }   // OK\n};\n\n// Initialize the framebuffer update function\n// Returns FALSE, if the function was to be reduced to a simple memcpy()\n// --> In that case, VOSF is not necessary\nbool Screen_blitter_init(VisualFormat const & visual_format, bool native_byte_order, int mac_depth)\n{\nprintf(\"Screen_blitter_init\\n\");\t\n#if USE_SDL_VIDEO\n\tconst bool use_sdl_video = true;\n#else\n\tconst bool use_sdl_video = false;\n#endif\n#if REAL_ADDRESSING || DIRECT_ADDRESSING\n\tif (mac_depth == 1 && !use_sdl_video && !visual_format.fullscreen) {\n\n\t\t// Windowed 1-bit mode uses a 1-bit X image, so there's no need for special blitting routines\n\t\tScreen_blit = Blit_Copy_Raw;\n\n\t} else {\n\n\t\t// Compute RGB shift values\n\t\tvisualFormat = visual_format;\n\t\tvisualFormat.Rshift = 0;\n\t\tfor (uint32 Rmask = visualFormat.Rmask; Rmask && ((Rmask & 1) != 1); Rmask >>= 1)\n\t\t\t++visualFormat.Rshift;\n\t\tvisualFormat.Gshift = 0;\n\t\tfor (uint32 Gmask = visualFormat.Gmask; Gmask && ((Gmask & 1) != 1); Gmask >>= 1)\n\t\t\t++visualFormat.Gshift;\n\t\tvisualFormat.Bshift = 0;\n\t\tfor (uint32 Bmask = visualFormat.Bmask; Bmask && ((Bmask & 1) != 1); Bmask >>= 1)\n\t\t\t++visualFormat.Bshift;\n\n\tprintf(\"### Screen_blitter_init\\n\");\n\tprintf(\"\\tR/G/B mask values  : 0x%06x, 0x%06x, 0x%06x (depth = %d) (mac_depth = %d)\\n\",\n\t\tvisualFormat.Rmask, visualFormat.Gmask, visualFormat.Bmask, visualFormat.depth, mac_depth);\n\tprintf(\"\\tR/G/B shift values : %d/%d/%d\\n\",\n\t\tvisualFormat.Rshift, visualFormat.Gshift, visualFormat.Bshift);\n\n\t\t// 1/2/4/8-bit mode on 8/16/32-bit screen?\n\t\tScreen_blit = NULL;\n\t\tswitch (visualFormat.depth) {\n\t\tcase 8:\n\t\t\tswitch (mac_depth) {\n\t\t\tcase 1: Screen_blit = Blit_Expand_1_To_8; break;\n\t\t\tcase 2: Screen_blit = Blit_Expand_2_To_8; break;\n\t\t\tcase 4: Screen_blit = Blit_Expand_4_To_8; break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 15:\n\t\tcase 16:\n\t\t\tswitch (mac_depth) {\n\t\t\tcase 1: Screen_blit = Blit_Expand_1_To_16; break;\n\t\t\tcase 2: Screen_blit = Blit_Expand_2_To_16; break;\n\t\t\tcase 4: Screen_blit = Blit_Expand_4_To_16; break;\n\t\t\tcase 8: Screen_blit = Blit_Expand_8_To_16; break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 24:\n\t\tcase 32:\n\t\t\tswitch (mac_depth) {\n\t\t\tcase 1: Screen_blit = Blit_Expand_1_To_32; break;\n\t\t\tcase 2: Screen_blit = Blit_Expand_2_To_32; break;\n\t\t\tcase 4: Screen_blit = Blit_Expand_4_To_32; break;\n\t\t\tcase 8: Screen_blit = Blit_Expand_8_To_32; break;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbool blitter_found = (Screen_blit != NULL);\n\t\n\t\t// Search for an adequate blit function\n\t\tconst int blitters_count = sizeof(Screen_blitters)/sizeof(Screen_blitters[0]);\n\t\tfor (int i = 0; !blitter_found && (i < blitters_count); i++) {\n\t\t\tif\t(\t(visualFormat.depth == Screen_blitters[i].depth)\n\t\t\t\t&&\t(visualFormat.Rmask == Screen_blitters[i].Rmask)\n\t\t\t\t&&\t(visualFormat.Gmask == Screen_blitters[i].Gmask)\n\t\t\t\t&&\t(visualFormat.Bmask == Screen_blitters[i].Bmask)\n\t\t\t\t)\n\t\t\t{\n\t\t\t\tblitter_found = true;\n\t\t\t\tScreen_blit = native_byte_order\n\t\t\t\t\t\t\t? Screen_blitters[i].handler_nbo\n\t\t\t\t\t\t\t: Screen_blitters[i].handler_obo\n\t\t\t\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\n\t\t// No appropriate blitter found, dump RGB mask values and abort()\n\t\tif (!blitter_found) {\n\t\t\tfprintf(stderr, \"### No appropriate blitter found\\n\");\n\t\t\tfprintf(stderr, \"\\tR/G/B mask values  : 0x%06x, 0x%06x, 0x%06x (depth = %d)\\n\",\n\t\t\t\tvisualFormat.Rmask, visualFormat.Gmask, visualFormat.Bmask, visualFormat.depth);\n\t\t\tfprintf(stderr, \"\\tR/G/B shift values : %d/%d/%d\\n\",\n\t\t\t\tvisualFormat.Rshift, visualFormat.Gshift, visualFormat.Bshift);\n\t\t\tabort();\n\t\t}\n\t}\n#else\n\t// The UAE memory handlers will blit correctly\n\t// --> no need for specialised blitters here\n\tScreen_blit = Blit_Copy_Raw;\n#endif\n\n\tprintf(\"depth=%d mac_depth=%d\\n\", visual_format.depth, mac_depth);\n\tif (visual_format.depth == 32 && mac_depth == 8) {\n\t\tprintf(\"switching to Blit_Expand_8_To_32\\n\");\n\t\tScreen_blit = Blit_Expand_8_To_32;\n\t}\n\t\n\t// If the blitter simply reduces to a copy, we don't need VOSF in DGA mode\n\t// --> In that case, we return FALSE\n\treturn (Screen_blit != Blit_Copy_Raw);\n}\n","/*\n *  macos_util.cpp - MacOS definitions/utility functions\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"sysdeps.h\"\n#include \"cpu_emulation.h\"\n#include \"adb.h\"\n#include \"main.h\"\n#include \"sony.h\"\n#include \"disk.h\"\n#include \"cdrom.h\"\n#include \"macos_util.h\"\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n/*\n *  Enqueue QElem to list\n */\n\nvoid EnqueueMac(uint32 elem, uint32 list)\n{\n\tWriteMacInt32(elem + qLink, 0);\n\tif (!ReadMacInt32(list + qTail)) {\n\t\tWriteMacInt32(list + qHead, elem);\n\t\tWriteMacInt32(list + qTail, elem);\n\t} else {\n\t\tWriteMacInt32(ReadMacInt32(list + qTail) + qLink, elem);\n\t\tWriteMacInt32(list + qTail, elem);\n\t}\n}\n\n\n/*\n *  Find first free drive number, starting at num\n */\n\nstatic bool is_drive_number_free(int num)\n{\n\tuint32 e = ReadMacInt32(0x308 + qHead);\n\twhile (e) {\n\t\tuint32 d = e - dsQLink;\n\t\tif ((int)ReadMacInt16(d + dsQDrive) == num)\n\t\t\treturn false;\n\t\te = ReadMacInt32(e + qLink);\n\t}\n\treturn true;\n}\n\nint FindFreeDriveNumber(int num)\n{\n\twhile (!is_drive_number_free(num))\n\t\tnum++;\n\treturn num;\n}\n\n\n/*\n *  Mount volume with given file handle (call this function when you are unable to\n *  do automatic media change detection and the user has to press a special key\n *  or something to mount a volume; this function will check if there's really a\n *  volume in the drive with SysIsDiskInserted(); volumes which are present on startup\n *  are automatically mounted)\n */\n\nvoid MountVolume(void *fh)\n{\n\tSonyMountVolume(fh) || DiskMountVolume(fh) || CDROMMountVolume(fh);\n}\n\n\n/*\n *  Calculate disk image file layout given file size and first 256 data bytes\n */\n\nvoid FileDiskLayout(loff_t size, uint8 *data, loff_t &start_byte, loff_t &real_size)\n{\n\tif (size == 419284 || size == 838484) {\n\t\t// 400K/800K DiskCopy image, 84 byte header\n\t\tstart_byte = 84;\n\t\treal_size = (size - 84) & ~0x1ff;\n\t} else {\n\t\t// 0..511 byte header\n\t\tstart_byte = size & 0x1ff;\n\t\treal_size = size - start_byte;\n\t}\n}\n\n\nuint32 DebugUtil(uint32 Selector)\n{\n\tswitch (Selector) {\n\t\tcase duDebuggerGetMax:\n\t\t\treturn 3;\n\t\tcase duDebuggerEnter:\n\t\t\treturn 0;\n\t\tcase duDebuggerExit:\n\t\t\treturn 0;\n\t\tcase duDebuggerPoll:\n\t\t\tADBInterrupt();\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn (uint32) paramErr;\n\t}\n}\n\n\n/*\n *  Convert time_t value to MacOS time (seconds since 1.1.1904)\n */\n\nuint32 TimeToMacTime(time_t t)\n{\n\t// This code is taken from glibc 2.2\n\n\t// Convert to number of seconds elapsed since 1-Jan-1904\n\tstruct tm *local = localtime(&t);\n\tconst int TM_EPOCH_YEAR = 1900;\n\tconst int MAC_EPOCH_YEAR = 1904;\n\tint a4 = ((local->tm_year + TM_EPOCH_YEAR) >> 2) - !(local->tm_year & 3);\n\tint b4 = (MAC_EPOCH_YEAR >> 2) - !(MAC_EPOCH_YEAR & 3);\n\tint a100 = a4 / 25 - (a4 % 25 < 0);\n\tint b100 = b4 / 25 - (b4 % 25 < 0);\n\tint a400 = a100 >> 2;\n\tint b400 = b100 >> 2;\n\tint intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n\tuint32 days = local->tm_yday + 365 * (local->tm_year - 4) + intervening_leap_days;\n\treturn local->tm_sec + 60 * (local->tm_min + 60 * (local->tm_hour + 24 * days));\n}\n","/*\n *  xpram.cpp - XPRAM handling\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/*\n *  SEE ALSO\n *    Inside Macintosh: Operating System Utilities, chapter 7 \"Parameter RAM Utilities\"\n */\n\n#include <string.h>\n\n#include \"sysdeps.h\"\n#include \"xpram.h\"\n\n\n// Extended parameter RAM\nuint8 XPRAM[XPRAM_SIZE];\n\n\n/*\n *  Initialize XPRAM\n */\n\nvoid XPRAMInit(const char *vmdir)\n{\n\t// Clear XPRAM\n\tmemset(XPRAM, 0, XPRAM_SIZE);\n\n\t// Load XPRAM from settings file\n\tLoadXPRAM(vmdir);\n}\n\n\n/*\n *  Deinitialize XPRAM\n */\n\nvoid XPRAMExit(void)\n{\n\t// Save XPRAM to settings file\n\tSaveXPRAM();\n}\n","/*\n *  macos_util.h - MacOS definitions/utility functions\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef MACOS_UTIL_H\n#define MACOS_UTIL_H\n\n#include \"cpu_emulation.h\"\n\n\n/*\n *  Queues\n */\n\nenum {\t// Queue types\n\tdummyType\t= 0,\n\tvType\t\t= 1,\n\tioQType\t\t= 2,\n\tdrvQType\t= 3,\n\tevType\t\t= 4,\n\tfsQType\t\t= 5,\n\tsIQType\t\t= 6,\n\tdtQType\t\t= 7,\n\tnmType\t\t= 8\n};\n\nenum {\t// QElem struct\n\tqLink = 0,\n\tqType = 4,\n\tqData = 6\n};\n\nenum {\t// QHdr struct\n\tqFlags = 0,\n\tqHead = 2,\n\tqTail = 6\n};\n\n\n/*\n *  Definitions for Device Manager\n */\n\n// Error codes\nenum {\n\tnoErr\t\t\t= 0,\n\tcontrolErr\t\t= -17,\n\tstatusErr\t\t= -18,\n\treadErr\t\t\t= -19,\n\twritErr\t\t\t= -20,\n\tbadUnitErr\t\t= -21,\n\tunitEmptyErr\t= -22,\n\topenErr\t\t\t= -23,\n\tclosErr\t\t\t= -24,\n\tabortErr\t\t= -27,\n\tnotOpenErr\t\t= -28,\n\tdskFulErr\t\t= -34,\n\tnsvErr\t\t\t= -35,\n\tioErr\t\t\t= -36,\n\tbdNamErr\t\t= -37,\n\tfnOpnErr\t\t= -38,\n\teofErr\t\t\t= -39,\n\tposErr\t\t\t= -40,\n\ttmfoErr\t\t\t= -42,\n\tfnfErr\t\t\t= -43,\n\twPrErr\t\t\t= -44,\n\tfLckdErr\t\t= -45,\n\tfBsyErr\t\t\t= -47,\n\tdupFNErr\t\t= -48,\n\tparamErr\t\t= -50,\n\trfNumErr\t\t= -51,\n\tpermErr\t\t\t= -54,\n\tnsDrvErr\t\t= -56,\n\textFSErr\t\t= -58,\n\tnoDriveErr\t\t= -64,\n\toffLinErr\t\t= -65,\n\tnoNybErr\t\t= -66,\n\tnoAdrMkErr\t\t= -67,\n\tdataVerErr\t\t= -68,\n\tbadCksmErr\t\t= -69,\n\tbadBtSlpErr\t\t= -70,\n\tnoDtaMkErr\t\t= -71,\n\tbadDCksum\t\t= -72,\n\tbadDBtSlp\t\t= -73,\n\twrUnderrun\t\t= -74,\n\tcantStepErr\t\t= -75,\n\ttk0BadErr\t\t= -76,\n\tinitIWMErr\t\t= -77,\n\ttwoSideErr\t\t= -78,\n\tspdAdjErr\t\t= -79,\n\tseekErr\t\t\t= -80,\n\tsectNFErr\t\t= -81,\n\tfmt1Err\t\t\t= -82,\n\tfmt2Err\t\t\t= -83,\n\tverErr\t\t\t= -84,\n\tmemFullErr\t\t= -108,\n\tdirNFErr\t\t= -120\n};\n\n// Misc constants\nenum {\n\tgoodbye\t\t\t= -1,\n\n\tioInProgress\t= 1,\n\taRdCmd\t\t\t= 2,\n\taWrCmd\t\t\t= 3,\n\tasyncTrpBit\t\t= 10,\n\tnoQueueBit\t\t= 9,\n\n\tdReadEnable\t\t= 0,\n\tdWritEnable\t\t= 1,\n\tdCtlEnable\t\t= 2,\n\tdStatEnable\t\t= 3,\n\tdNeedGoodBye\t= 4,\n\tdNeedTime\t\t= 5,\n\tdNeedLock\t\t= 6,\n\n\tdOpened\t\t\t= 5,\n\tdRAMBased\t\t= 6,\n\tdrvrActive\t\t= 7,\n\n\trdVerify\t\t= 64,\n\n\tfsCurPerm\t\t= 0,\n\tfsRdPerm\t\t= 1,\n\tfsWrPerm\t\t= 2,\n\tfsRdWrPerm\t\t= 3,\n\tfsRdWrShPerm\t= 4,\n\n\tfsAtMark\t\t= 0,\n\tfsFromStart\t\t= 1,\n\tfsFromLEOF\t\t= 2,\n\tfsFromMark\t\t= 3,\n\n\tsony\t\t\t= 0,\n\thard20\t\t\t= 1\n};\n\nenum {\t// Large volume constants\n\tkWidePosOffsetBit\t= 8,\n\tkMaximumBlocksIn4GB\t= 0x007fffff\n};\n\nenum {\t// IOParam struct\n\tioTrap = 6,\n\tioCmdAddr = 8,\n\tioCompletion = 12,\n\tioResult = 16,\n\tioNamePtr = 18,\n\tioVRefNum = 22,\n\tioRefNum = 24,\n\tioVersNum = 26,\n\tioPermssn = 27,\n\tioMisc = 28,\n\tioBuffer = 32,\n\tioReqCount = 36,\n\tioActCount = 40,\n\tioPosMode = 44,\n\tioPosOffset = 46,\n\tioWPosOffset = 46,\t// Wide positioning offset when ioPosMode has kWidePosOffsetBit set\n\tSIZEOF_IOParam = 50\n};\n\nenum {\t// CntrlParam struct\n\tcsCode = 26,\n\tcsParam = 28\n};\n\nenum {\t// DrvSts struct\n\tdsTrack = 0,\n\tdsWriteProt = 2,\n\tdsDiskInPlace = 3,\n\tdsInstalled = 4,\n\tdsSides = 5,\n\tdsQLink = 6,\n\tdsQType = 10,\n\tdsQDrive = 12,\n\tdsQRefNum = 14,\n\tdsQFSID = 16,\n\tdsTwoSideFmt = 18,\n\tdsNewIntf = 19,\n\tdsDiskErrs = 20,\n\tdsMFMDrive = 22,\n\tdsMFMDisk = 23,\n\tdsTwoMegFmt = 24\n};\n\nenum {\t// DrvSts2 struct\n\tdsDriveSize = 18,\n\tdsDriveS1 = 20,\n\tdsDriveType = 22,\n\tdsDriveManf = 24,\n\tdsDriveChar = 26,\n\tdsDriveMisc = 28,\n\tSIZEOF_DrvSts = 30\n};\n\nenum {\t// DCtlEntry struct\n\tdCtlDriver = 0,\n\tdCtlFlags = 4,\n\tdCtlQHdr = 6,\n\tdCtlPosition = 16,\n\tdCtlStorage = 20,\n\tdCtlRefNum = 24,\n\tdCtlCurTicks = 26,\n\tdCtlWindow = 30,\n\tdCtlDelay = 34,\n\tdCtlEMask = 36,\n\tdCtlMenu = 38,\n\tdCtlSlot = 40,\n\tdCtlSlotId = 41,\n\tdCtlDevBase = 42,\n\tdCtlOwner = 46,\n\tdCtlExtDev = 50,\n\tdCtlFillByte = 51,\n\tdCtlNodeID = 52\n};\n\n\n/*\n *  Definitions for Deferred Task Manager\n */\n\nenum {\t// DeferredTask struct\n\tdtFlags = 6,\n\tdtAddr = 8,\n\tdtParam = 12,\n\tdtReserved = 16\n};\n\n\n// Definitions for DebugUtil() Selector\nenum {\n\tduDebuggerGetMax = 0,\n\tduDebuggerEnter = 1,\n\tduDebuggerExit = 2,\n\tduDebuggerPoll = 3,\n\tduGetPageState = 4,\n\tduPageFaultFatal = 5,\n\tduDebuggerLockMemory = 6,\n\tduDebuggerUnlockMemory = 7,\n\tduEnterSupervisorMode = 8\n};\n\n// Functions\nextern void EnqueueMac(uint32 elem, uint32 list);\t// Enqueue QElem in list\nextern int FindFreeDriveNumber(int num);\t\t\t// Find first free drive number, starting at \"num\"\nextern void MountVolume(void *fh);\t\t\t\t\t// Mount volume with given file handle (see sys.h)\nextern void FileDiskLayout(loff_t size, uint8 *data, loff_t &start_byte, loff_t &real_size);\t// Calculate disk image file layout given file size and first 256 data bytes\nextern uint32 DebugUtil(uint32 Selector);\t\t\t// DebugUtil() Replacement\nextern uint32 TimeToMacTime(time_t t);\t\t\t\t// Convert time_t value to MacOS time\n\n// Construct four-character-code\n#define FOURCC(a,b,c,d) (((uint32)(a) << 24) | ((uint32)(b) << 16) | ((uint32)(c) << 8) | (uint32)(d))\n\n// Emulator identification codes (4 and 2 characters)\nconst uint32 EMULATOR_ID_4 = 0x62617369;\t\t\t// 'basi'\nconst uint16 EMULATOR_ID_2 = 0x6261;\t\t\t\t// 'ba'\n\n// Test if basic MacOS initializations (of the ROM) are done\nstatic inline bool HasMacStarted(void)\n{\n\treturn ReadMacInt32(0xcfc) == FOURCC('W','L','S','C');\t// Mac warm start flag\n}\n\n#endif\n","/*\n *  clip_dummy.cpp - Clipboard handling, dummy implementation\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"sysdeps.h\"\n\n#include \"clip.h\"\n#include \"macos_util.h\"\n\n#define DEBUG 0\n#include \"debug.h\"\n\n\n/*\n *  Initialization\n */\n\nvoid ClipInit(void)\n{\n}\n\n\n/*\n *  Deinitialization\n */\n\nvoid ClipExit(void)\n{\n}\n\n\n/*\n *  Mac application reads clipboard\n */\n\nvoid GetScrap(void **handle, uint32 type, int32 offset)\n{\n\tD(bug(\"GetScrap handle %p, type %08x, offset %d\\n\", handle, type, offset));\n}\n\n/*\n * ZeroScrap() is called before a Mac application writes to the clipboard; clears out the previous contents\n */\n\nvoid ZeroScrap()\n{\n\tD(bug(\"ZeroScrap\\n\"));\n}\n\n/*\n *  Mac application wrote to clipboard\n */\n\nvoid PutScrap(uint32 type, void *scrap, int32 length)\n{\n\tD(bug(\"PutScrap type %08lx, data %08lx, length %ld\\n\", type, scrap, length));\n\tif (length <= 0)\n\t\treturn;\n\n\tswitch (type) {\n\t\tcase FOURCC('T','E','X','T'):\n\t\t\tD(bug(\" clipping TEXT\\n\"));\n\t\t\tbreak;\n\t}\n}\n","/*\n *  prefs_editor_dummy.cpp - Preferences editor, dummy implementation\n *\n *  Basilisk II (C) 1997-2008 Christian Bauer\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"sysdeps.h\"\n#include \"prefs.h\"\n#include \"prefs_editor.h\"\n#include \"user_strings.h\"\n\n\n/*\n *  Show preferences editor\n *  Returns true when user clicked on \"Start\", false otherwise\n */\n\nbool PrefsEditor(void)\n{\n\treturn true;\n}\n"]}